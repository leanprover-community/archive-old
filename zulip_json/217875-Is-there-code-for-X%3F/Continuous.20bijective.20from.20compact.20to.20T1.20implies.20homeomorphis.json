[
    {
        "content": "<p>I guess that we have somewhere in mathlib the fact that a continuous bijection from a compact space to a separated space is an homeomorphism, but I am not able to find it... does someone know where is it?</p>",
        "id": 229652836,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1615381300
    },
    {
        "content": "<p>You have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous.closed_embedding\">docs#continuous.closed_embedding</a></p>",
        "id": 229653273,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1615381460
    },
    {
        "content": "<p>Thank's! It seems a little strange to me that we don't have the literal statement, but may I am missing some subtleties about this part of the library.</p>",
        "id": 229655009,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1615382110
    },
    {
        "content": "<p>I think there was a PR recently with a constructor for <code>homeo</code> that did just that. But maybe I misremember.</p>",
        "id": 229655992,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615382459
    },
    {
        "content": "<p>I just wanted this and was about to ask here but Zulip pointed me to this thread when I was composing the title. I have the same question except I'm only smart enough to prove it for t2 spaces. Do we really not have either of these?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.homeomorph</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≃</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f.symm</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">continuous_iff_is_closed.mpr</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">C</span> <span class=\"n\">hC</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hC2</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hC3</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hC4</span> <span class=\"o\">:</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">library_search</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">hC4</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≃</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≃ₜ</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">continuous_to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">continuous_inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">f</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>What I like about the proof of <code>foo</code> is that it's essentially the proof I'd write on the board.</p>",
        "id": 261719300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637103167
    },
    {
        "content": "<p>It's apparently not actually true for T1 spaces.</p>",
        "id": 261719784,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637103418
    },
    {
        "content": "<p>If both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>∪</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\cup\\{\\infty\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∞</span><span class=\"mclose\">}</span></span></span></span> as their points where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is the one-point compactification of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> has the cofinite topology, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is compact, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is T1, the identity function is a continuous bijection, but it's not a homeomorphism.</p>",
        "id": 261721496,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1637104359
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/CompHaus.is_iso_of_bijective\">docs#CompHaus.is_iso_of_bijective</a> should be a thing (I think)</p>",
        "id": 261722347,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637104903
    },
    {
        "content": "<p>Oh perfect, that will do for me. Adam I'm still wrestling with that binary product thing ;-)</p>",
        "id": 261722463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637104972
    },
    {
        "content": "<p>I think we have a wrapper for Profinite too... Let's check <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Profinite.is_iso_of_bijective\">docs#Profinite.is_iso_of_bijective</a></p>",
        "id": 261722535,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637105018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261722347\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/CompHaus.is_iso_of_bijective\">docs#CompHaus.is_iso_of_bijective</a> should be a thing (I think)</p>\n</blockquote>\n<p>I think it's a bad idea to add mathematical content to the category theory part of mathlib. It should only wrap mathematical content. If the concrete lemma is missing I think you should add it first and then wrap it.</p>",
        "id": 261754364,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637137414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261721496\">said</a>:</p>\n<blockquote>\n<p>If both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi><mo>∪</mo><mo stretchy=\"false\">{</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\cup\\{\\infty\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">∞</span><span class=\"mclose\">}</span></span></span></span> as their points where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is the one-point compactification of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> has the cofinite topology, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is compact, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is T1, the identity function is a continuous bijection, but it's not a homeomorphism.</p>\n</blockquote>\n<p>Don't hesitate to add this example right after proving the lemma. I think we should have more of those in mathlib.</p>",
        "id": 261754432,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637137446
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.category.Compactum</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">Compactum_to_CompHaus.is_equivalence</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">Compactum.forget</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">of_type_monad</span> <span class=\"n\">ultrafilter</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">forget_reflects_iso</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.reflects_isomorphisms_comp</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">⥤</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">reflects_isomorphisms</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">resetI</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">is_iso_of_reflects_iso</span> <span class=\"n\">f</span> <span class=\"n\">F</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_iso_of_reflects_iso</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">Compactum_to_CompHaus.inv</span> <span class=\"o\">:=</span>\n<span class=\"n\">category_theory.of_full_and_faithful</span> <span class=\"n\">Compactum_to_CompHaus.inv</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">reflects_isomorphisms</span> <span class=\"o\">(</span><span class=\"n\">Compactum_to_CompHaus.inv</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">category_theory.reflects_isomorphisms_comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.reflects_isomorphisms_of_iso</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≅</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">reflects_isomorphisms</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">constructor</span><span class=\"o\">,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">h1</span><span class=\"o\">,</span><span class=\"n\">h2</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"o\">(</span><span class=\"n\">G.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">η.inv.app</span> <span class=\"n\">B</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">≫</span> <span class=\"n\">η.hom.app</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">reassoc_of</span> <span class=\"n\">h1</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">η.hom.naturality</span><span class=\"o\">,</span> <span class=\"n\">reassoc_of</span> <span class=\"n\">h2</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_iso_of_reflects_iso</span> <span class=\"n\">f</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">reflects_isomorphisms</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">CompHaus</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">forget</span> <span class=\"n\">CompHaus</span> <span class=\"bp\">≅</span> <span class=\"n\">Compactum_to_CompHaus.inv</span> <span class=\"bp\">⋙</span> <span class=\"n\">Compactum.forget</span> <span class=\"o\">:=</span>\n  <span class=\"n\">iso_whisker_right</span> <span class=\"n\">Compactum_to_CompHaus.as_equivalence.counit_iso.symm</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n<span class=\"n\">category_theory.reflects_isomorphisms_of_iso</span> <span class=\"n\">E</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">CompHaus.is_iso_of_bijective'</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">CompHaus</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_iso</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">is_iso_iff_bijective</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">is_iso</span> <span class=\"o\">((</span><span class=\"n\">forget</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"n\">resetI</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">is_iso_of_reflects_iso</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 261798222,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1637162240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/261754432\">said</a>:</p>\n<blockquote>\n<p>Don't hesitate to add this example right after proving the lemma. I think we should have more of those in mathlib.</p>\n</blockquote>\n<p>I wasn't sure whether what <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> wrote made it into mathlib (at least I couldn't find the theorem statement), so I created <a href=\"https://github.com/leanprover-community/mathlib/pull/11072\">#11072</a> just in case.</p>\n<p>It also has a counterexample for the T1 generalization, written as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">homeo_of_equiv_compact_to_t2.t1_counterexample</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">t1_space</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"bp\">¬</span> <span class=\"n\">continuous</span> <span class=\"n\">f.symm</span>\n</code></pre></div>\n<p>though I probably should refactor the proof -- I basically reimplemented the one-point compactification, and I wasn't sure whether the cofinite topology already existed in some way so I implemented that for <code>nat</code> with the discrete topology, too.</p>",
        "id": 266155044,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640592851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/11076\">#11076</a></p>",
        "id": 266176601,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640615435
    },
    {
        "content": "<p>Sorry about all those missing pieces.</p>",
        "id": 266176610,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640615446
    },
    {
        "content": "<p>I haven't included your counter-example, this is <em>your</em> reward.</p>",
        "id": 266176652,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640615482
    },
    {
        "content": "<p>After that PR you'll be able to modify yours to use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">homeo_of_equiv_compact_to_t2.t1_counterexample</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iα</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Iβ</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"n\">compact_space</span> <span class=\"n\">α</span> <span class=\"bp\">∧</span> <span class=\"n\">t1_space</span> <span class=\"n\">β</span> <span class=\"bp\">∧</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">≃</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">continuous</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">continuous</span> <span class=\"n\">f.symm</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">topα</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nhds_adjoint</span> <span class=\"mi\">0</span> <span class=\"n\">filter.cofinite</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">topβ</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">topological_space.cofinite</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">ℕ</span> <span class=\"o\">,</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">topα</span><span class=\"o\">,</span> <span class=\"n\">topβ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">t1_space_cofinite</span><span class=\"o\">,</span> <span class=\"n\">equiv.refl</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_compact_iff_ultrafilter_le_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">↑</span><span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">_</span> <span class=\"n\">topα</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">_</span> <span class=\"n\">topα</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">h0U</span><span class=\"o\">,</span> <span class=\"n\">hU_fin</span><span class=\"o\">,</span> <span class=\"n\">hUf</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span><span class=\"bp\">ᶜ.</span><span class=\"n\">finite</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">∉</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_adjoint_nhds</span><span class=\"o\">,</span> <span class=\"n\">filter.le_def</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n        <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n        <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">and_assoc</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hf</span> <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">ultrafilter.compl_mem_iff_not_mem</span> <span class=\"n\">at</span> <span class=\"n\">hUf</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">hn'</span><span class=\"o\">,</span> <span class=\"n\">hn</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ultrafilter.eq_principal_of_finite_mem</span> <span class=\"n\">hU_fin</span> <span class=\"n\">hUf</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">s'</span> <span class=\"n\">hns'</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mem_of_mem_nhds</span> <span class=\"n\">_</span> <span class=\"n\">topα</span> <span class=\"n\">n</span> <span class=\"n\">_</span> <span class=\"n\">hns'</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">continuous_iff_coinduced_le</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">topα</span> <span class=\"bp\">≤</span> <span class=\"n\">topβ</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">gc_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nhds_cofinite</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">topβ</span> <span class=\"bp\">≤</span> <span class=\"n\">topα</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">continuous_iff_coinduced_le</span><span class=\"o\">,</span> <span class=\"n\">coinduced_id</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">le_nhds_adjoint_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span>  <span class=\"o\">(</span><span class=\"n\">finite_singleton</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">infinite_compl</span> <span class=\"o\">(</span><span class=\"n\">h.2</span> <span class=\"mi\">1</span> <span class=\"n\">one_ne_zero</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton</span> <span class=\"mi\">1</span><span class=\"o\">⟩)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 266176688,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640615518
    },
    {
        "content": "<p>Note this proof isn't much shorter if you take into account that the topology definitions have been removed, but it minimizes messing around with sets.</p>",
        "id": 266176910,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640615712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20bijective.20from.20compact.20to.20T1.20implies.20homeomorphis/near/266176610\">said</a>:</p>\n<blockquote>\n<p>Sorry about all those missing pieces.</p>\n</blockquote>\n<p>No need to apologize! I was happy doing this as an exercise, and it's nice that it helped drive more library development. (Thanks for implementing <code>eq_principal_of_finite_mem</code>, too.)</p>",
        "id": 266178412,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640616976
    },
    {
        "content": "<p>Indeed counter-examples also have this library development role.</p>",
        "id": 266178609,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640617197
    },
    {
        "content": "<p>The cofinite topology was a really unexpected hole.</p>",
        "id": 266178702,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640617251
    },
    {
        "content": "<p>Is there a construction like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_space.nhds_adjoint\">docs#topological_space.nhds_adjoint</a> that could specialize to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alexandroff.topological_space\">docs#alexandroff.topological_space</a>?</p>",
        "id": 266178986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640617512
    },
    {
        "content": "<p>I guess we could cook up a definition giving both cases, but I'm not sure we would gain much.</p>",
        "id": 266180535,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640618925
    }
]
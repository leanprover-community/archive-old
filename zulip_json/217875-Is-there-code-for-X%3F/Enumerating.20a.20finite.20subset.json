[
    {
        "content": "<p>Do we have a convenient way enumerating the elements of a finite subset?</p>",
        "id": 250227414,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629565663
    },
    {
        "content": "<p>For example, do we have anything like <code>finset.to_fun</code> below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.fincard</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_to_fun_eq</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">t.to_fun</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Variant of `range_to_fun_eq` that stays in computable `finset` land:</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">image_to_fun_univ_eq</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">image</span> <span class=\"n\">t.to_fun</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>",
        "id": 250227464,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629565697
    },
    {
        "content": "<p>Or maybe we should ignore <code>finset</code> and just work with finite <code>set</code>s. Do we have anything like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.fincard</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">set.finite</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s.finite</span><span class=\"o\">)</span>\n<span class=\"kn\">include</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">card</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">nat.card</span> <span class=\"n\">s</span> <span class=\"c1\">-- How does this not exist already!?</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">h.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_to_fun_eq</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">h.to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">set.finite</span>\n</code></pre></div>",
        "id": 250227550,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629565848
    },
    {
        "content": "<p>you can presumably get it by toying with <code>fintype.equiv_fin</code>, but that's not ideal</p>",
        "id": 250228692,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1629567506
    },
    {
        "content": "<p>I started an implementation of <code>to_fun</code> using a <code>to_list</code> function, but I think <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>'s suggestion of <code>fintype.equiv_fun</code> might be less work (depending on how all the coercions look).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.fincard</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_list</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">t.1.to_list</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_to_list</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t.to_list</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">to_list</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">multiset.coe_to_list</span><span class=\"o\">],</span>\n     <span class=\"n\">exact</span> <span class=\"n\">iff.rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_list_length</span> <span class=\"o\">:</span> <span class=\"n\">t.to_list.length</span> <span class=\"bp\">=</span> <span class=\"n\">t.card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">to_list</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.coe_card</span><span class=\"o\">,</span> <span class=\"n\">multiset.coe_to_list</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">t.to_list.nth_le</span> <span class=\"n\">i</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">to_list_length</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">i.property</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>",
        "id": 250229221,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629568219
    },
    {
        "content": "<p>We do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sort\">docs#finset.sort</a></p>",
        "id": 250230405,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629569980
    },
    {
        "content": "<p>You can sort with any random relation, for example</p>",
        "id": 250230466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629570035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250228692\">said</a>:</p>\n<blockquote>\n<p>you can presumably get it by toying with <code>fintype.equiv_fin</code>, but that's not ideal</p>\n</blockquote>\n<p>Interesting, I suppose  that makes this possible:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_fun</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">t</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 250230645,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629570250
    },
    {
        "content": "<p>I'm a little surprised that <code>finset.to_list</code> doesn't already exist.  <code>finset.sort</code> is <code>finset.to_list</code> the long way (\"I'm going to put my arbitrary list into an arbitrary order\" rather than \"I'm happy with the arbitrary list as-is.\")</p>",
        "id": 250230675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629570335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250229221\">said</a>:</p>\n<blockquote>\n<p><em>Edit: updated this code block</em></p>\n</blockquote>\n<p>Oh wow, thanks for this! Superb. I'm being pulled away for dinner but I'm really grateful.</p>",
        "id": 250230709,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629570364
    },
    {
        "content": "<p>finset.to_list may as well just be finset.sort with the equality relation</p>",
        "id": 250230720,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629570369
    },
    {
        "content": "<p>How do you mean? Doesn't <code>finset.sort</code> need a total order?</p>",
        "id": 250230731,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629570403
    },
    {
        "content": "<p>Oh right I missed that assumption</p>",
        "id": 250230746,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629570433
    },
    {
        "content": "<p>Well that's silly. We should also have a finest.sort that takes any arbitrary relation</p>",
        "id": 250230809,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629570551
    },
    {
        "content": "<p>Maybe it would be noncomputable but <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 250230810,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1629570551
    },
    {
        "content": "<p><code>finset.to_list</code>: <a href=\"https://github.com/leanprover-community/mathlib/issues/8797\">#8797</a></p>",
        "id": 250231298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629571364
    },
    {
        "content": "<p>Using that PR, <code>finset.to_fun</code> could look like this</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">t.to_list.nth_le</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">i_property</span><span class=\"o\">]</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_fun_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">t.to_fun</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hj</span><span class=\"o\">⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">length_to_list</span> <span class=\"n\">at</span> <span class=\"n\">hi</span> <span class=\"n\">hj</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">to_fun</span><span class=\"o\">,</span> <span class=\"n\">fin.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">list.nth_le_nth</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">list.nth_le_nth</span> <span class=\"n\">hj</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">list.nth_injective</span> <span class=\"n\">hi</span> <span class=\"o\">(</span><span class=\"n\">nodup_to_list</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_to_fun_univ_eq</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">image</span> <span class=\"n\">t.to_fun</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">to_fun</span><span class=\"o\">,</span> <span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">list.nth_le</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">mem_to_list</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">list.nth_le_mem</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">mem_to_list</span><span class=\"o\">,</span> <span class=\"n\">list.mem_iff_nth_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">length_to_list</span> <span class=\"n\">at</span> <span class=\"n\">hi</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩,</span> <span class=\"n\">finset.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_to_fun_eq</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">t.to_fun</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">image_to_fun_univ_eq</span> <span class=\"n\">t</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>\n</div></div>",
        "id": 250232097,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629572568
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.order_iso_of_fin\">docs#finset.order_iso_of_fin</a>?</p>",
        "id": 250294046,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629667960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250294046\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.order_iso_of_fin\">docs#finset.order_iso_of_fin</a>?</p>\n</blockquote>\n<p>This would be what I want except that it requires <code>[linear_order α]</code> (presumably to make things computable).</p>",
        "id": 250325950,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629708966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250230645\">said</a>:</p>\n<blockquote>\n<p>Interesting, I suppose  that makes this possible:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_fun</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">t</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">n</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I might need this later today so I will lazily record what I think might be the most convenient definition here. Instead of <code>fintype.equiv_fin</code> used above, I now realise it is better to use <code>fintype.equiv_fin_of_card_eq</code> and thus obtain:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin_of_card_eq</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">t</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm.to_fun</span>\n</code></pre></div>",
        "id": 250326147,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629709085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250325950\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Enumerating.20a.20finite.20subset/near/250294046\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.order_iso_of_fin\">docs#finset.order_iso_of_fin</a>?</p>\n</blockquote>\n<p>This would be what I want except that it requires <code>[linear_order α]</code> (presumably to make things computable).</p>\n</blockquote>\n<p>Do we not have the well ordering principle?</p>",
        "id": 250327550,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1629710166
    },
    {
        "content": "<p>I believe we do so I guess this would also work, at the cost of some <code>@</code> characters to provide the instance!</p>",
        "id": 250327734,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629710309
    },
    {
        "content": "<p>We have an open PR that puts a linear order on any fintype I believe</p>",
        "id": 250334636,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1629715474
    },
    {
        "content": "<p>Interesting! Looks like it is <a href=\"https://github.com/leanprover-community/mathlib/issues/7123\">#7123</a> I'm juggling a few things but I'll look at it more closely if / when I need this. Thanks for the note.</p>",
        "id": 250334849,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1629715645
    },
    {
        "content": "<p>For the sake of anyone looking at this thread in the future, I might as well say that I cooked up the following approach to what I was asking about here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Finite subsets carry an enumeration. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">enumerate</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">coe</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin_of_card_eq</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">t</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"sd\">/-- We can get the index of an element of a finite subset with respect to its enumeration. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">denumerate</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"o\">:=</span>\n<span class=\"n\">fintype.equiv_fin_of_card_eq</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">enumerate_mem</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t.enumerate</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">enumerate</span><span class=\"o\">,</span> <span class=\"n\">coe_mem</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">denumerate_enumerate_eq</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">t.denumerate</span> <span class=\"o\">⟨</span><span class=\"n\">t.enumerate</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">t.enumerate_mem</span> <span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">enumerate</span><span class=\"o\">,</span> <span class=\"n\">denumerate</span><span class=\"o\">,</span> <span class=\"n\">mk_coe</span><span class=\"o\">,</span> <span class=\"n\">equiv.apply_symm_apply</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">enumerate_denumerate_eq</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t.enumerate</span> <span class=\"o\">(</span><span class=\"n\">t.denumerate</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">enumerate</span><span class=\"o\">,</span> <span class=\"n\">denumerate</span><span class=\"o\">,</span> <span class=\"n\">equiv.symm_apply_apply</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">range_enumerate</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">t.enumerate</span> <span class=\"bp\">=</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">enumerate</span><span class=\"o\">,</span> <span class=\"n\">coe_mem</span><span class=\"o\">,</span> <span class=\"n\">mem_coe</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">use</span> <span class=\"n\">t.denumerate</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_coe.mp</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">image_enumerate_univ_eq</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">image</span> <span class=\"n\">t.enumerate</span> <span class=\"n\">univ</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">enumerate_mem</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_image</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">],</span>\n    <span class=\"n\">use</span> <span class=\"n\">t.denumerate</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_coe.mp</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">t</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A pair of nested finite subsets `s ⊆ t` yields an embedding of their emumerating types. -/</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">fin_card_embed_of_subset</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">s.card</span> <span class=\"bp\">↪</span> <span class=\"n\">fin</span> <span class=\"n\">t.card</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">t.denumerate</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">set.inclusion</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">∘</span>\n            <span class=\"o\">(</span><span class=\"n\">fintype.equiv_fin_of_card_eq</span> <span class=\"o\">(</span><span class=\"n\">fintype.card_coe</span> <span class=\"n\">s</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">inj'</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">denumerate</span><span class=\"o\">,</span> <span class=\"n\">equiv.apply_eq_iff_eq</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">equiv.apply_eq_iff_eq</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">set.inclusion_injective</span> <span class=\"n\">h</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">fin_card_embed_of_subset_enumerate_comp</span> <span class=\"o\">:</span>\n  <span class=\"n\">t.enumerate</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">fin_card_embed_of_subset</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">s.enumerate</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">fin_card_embed_of_subset</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finset</span>\n</code></pre></div>",
        "id": 251225847,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630328732
    },
    {
        "content": "<p>However I eventually decided that <code>t.enumerate</code> was actually just a less useful version of <code>(coe : t → α)</code>.</p>",
        "id": 251225957,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630328777
    },
    {
        "content": "<p>In fact, your <code>enumerate</code> is an embedding into <code>α</code>, so you can have a lemma about <code>finset.map</code>.  </p>\n<p>Separately, it will get much clunkier when your <code>t</code> is a non-simple finset, like the union/diff/inter of other finsets.</p>",
        "id": 251226224,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630328913
    },
    {
        "content": "<p>Well there are times when one wants an embedding into <code>α</code>. For example, if one wants to speak of linear independence of a <code>finset α</code>.</p>",
        "id": 251226486,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1630329042
    }
]
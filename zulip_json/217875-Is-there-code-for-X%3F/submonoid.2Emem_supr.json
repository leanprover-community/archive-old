[
    {
        "content": "<p>For <code>mem_supr</code> for submonoids, subgroups and submodules we tend to have <code>mem_supr_of_directed</code> (if in the supr of a directed collection then it's in one of the collection), and <code>mem_supr_of_mem</code> (if in one of them, then in the supr). Do we have any of the following (I probably only need one):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.finprod</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"c1\">-- finprod variant</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">submonoid.mem_supr</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">submonoid</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"bp\">∏ᶠ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- finset variant</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">submonoid.mem_supr'</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"bp\">Π</span> <span class=\"n\">j</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- finsupp variant which I only know how to make for add_monoids because maybe we don't have `→₁`?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_submonoid.mem_supr</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">s.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>[There are also versions for <code>subgroup</code> and <code>submodule</code>]. It would not surprise me if we had ways of moving from any of these three lemmas to any other (modulo issues with the multiplicative version with finsupp). I would imagine it would not be hard to prove any or all of these using some kind of induction principle if we knew that the supr was the closure of the set.Union, because we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure_induction\">docs#submonoid.closure_induction</a> . Do we already have anything else which would make one of these short?</p>",
        "id": 234672788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618492683
    },
    {
        "content": "<p>Does <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_submonoid.closure_Union\">docs#add_submonoid.closure_Union</a> help?</p>",
        "id": 234674153,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618493209
    },
    {
        "content": "<p>It's definitely a step in the right direction. From then on it's just some induction I guess. Thanks!</p>",
        "id": 234677433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618494294
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.mem_supr_iff_exists_dfinsupp\">docs#submodule.mem_supr_iff_exists_dfinsupp</a> (once CI rebuilds the docs)</p>",
        "id": 245872791,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1626203439
    }
]
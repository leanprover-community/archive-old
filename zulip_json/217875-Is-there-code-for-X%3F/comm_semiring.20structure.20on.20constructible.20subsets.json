[
    {
        "content": "<p>Dear All,</p>\n<p>I am wondering whether</p>\n<ol>\n<li>constructible subsets of a topological space are in Lean (I could not find them);</li>\n<li>if they are, is there is a <code>comm_semiring</code> structure on them?</li>\n</ol>\n<p>In case you are wondering what I mean by constructible subsets, they are the subsets generated by open sets by iterations of<br>\na) taking unions,<br>\nb) taking intersections,<br>\nc) taking complements.</p>",
        "id": 218440324,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838020
    },
    {
        "content": "<p>The constructible topology should be easy to define using an inductive proposition. In fact, I remember seeing the construction at some point, but I can't remember where right now.</p>",
        "id": 218440726,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838161
    },
    {
        "content": "<p>I think Alex did it at LFTCM</p>",
        "id": 218440825,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606838185
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lftcm2020/blob/master/src/exercises_sources/wednesday/topological_spaces.lean\">https://github.com/leanprover-community/lftcm2020/blob/master/src/exercises_sources/wednesday/topological_spaces.lean</a></p>",
        "id": 218441041,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> your answer makes me think that I should have stressed that constructible sets are closed under <em>finitely many</em> of the operations written above.  Is the constructible topology this, or does it allow, for instance, infinite intersections of open sets?</p>",
        "id": 218441042,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838278
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/lftcm2020/blob/c07fa2bd7968e5d1faf32d59745d14d702e5548c/src/exercises_sources/wednesday/topological_spaces.lean#L117\">https://github.com/leanprover-community/lftcm2020/blob/c07fa2bd7968e5d1faf32d59745d14d702e5548c/src/exercises_sources/wednesday/topological_spaces.lean#L117</a></p>",
        "id": 218441126,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <br>\nThank you for the pointer!  I will take a look at the link!</p>",
        "id": 218441162,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838312
    },
    {
        "content": "<p>Take a look at the second one with the precise line...</p>",
        "id": 218441261,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838345
    },
    {
        "content": "<p>But I don't think the ring structure is there.</p>",
        "id": 218441292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/218441261\">said</a>:</p>\n<blockquote>\n<p>Take a look at the second one with the precise line...</p>\n</blockquote>\n<p>Indeed!  This is exactly the definition I had in mind, thanks!</p>",
        "id": 218441500,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838413
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  just in case <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 218441692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838478
    },
    {
        "content": "<p>So, it turns out that I unknowingly did quite a few of those steps and went on to prove the ring structure.  However, in quite a clumsy way.  Would anyone be interested in seeing what I did and help me get it into better shape?</p>",
        "id": 218442210,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838674
    },
    {
        "content": "<p>(Not only clumsy, but really getting my hands dirty and not using much of automation...)</p>",
        "id": 218442285,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838709
    },
    {
        "content": "<p>Sure!</p>",
        "id": 218442403,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838760
    },
    {
        "content": "<p>Great: should I link a gist?  Or do you prefer me to paste it here (I have ~250 lines of code)</p>",
        "id": 218442634,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606838848
    },
    {
        "content": "<p>gist might be better</p>",
        "id": 218442689,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606838865
    },
    {
        "content": "<p><a href=\"https://gist.github.com/adomani/9e2d64e34ccd627eb00cf1d13691a8de\">Here</a> it is!</p>",
        "id": 218443255,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606839073
    },
    {
        "content": "<p>I only did it for the exercise session, so all I wrote is what's there (i.e almost nothing). I think Antoine Chambert-Loir also said I should assume locally noetherian or something too to match the literature.</p>",
        "id": 218443328,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1606839104
    },
    {
        "content": "<p>I have never really used <code>instances</code>, I tried using them, but could not get them to work...</p>\n<p>Also, I had a hard time getting the <code>const X</code> terms to print nicely, and they do not...</p>",
        "id": 218443602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606839151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I have a meeting in a few minutes, so I can't take a very close look right now, but here is one quick suggestion.<br>\nI think the class <code>const</code> would make more sense in the following form:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">constr</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_constr</span> <span class=\"o\">:</span> <span class=\"n\">is_constructible</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218445948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606840042
    },
    {
        "content": "<p>The type of all constructible subsets can then be made using, e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled\">docs#category_theory.bundled</a> (or something like that)</p>",
        "id": 218446072,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606840091
    },
    {
        "content": "<p>Ok, I will look into this!  I also think that I prefer to replace the <code>∧</code> by <code>→</code>, so I may do a few such cosmetic changes!  However, I may also not have a lot of time right now, since it is 5.30pm here, right now</p>",
        "id": 218446458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606840269
    },
    {
        "content": "<p>In any case, already thank you very much for the suggestions!</p>",
        "id": 218446481,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606840280
    },
    {
        "content": "<p>On second thought, I'm not sure whether <code>constr</code> as above should be a class, only because <code>is_open</code> is not a class.</p>",
        "id": 218448388,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606841024
    },
    {
        "content": "<p>To be honest, <code>class</code>, <code>structure</code>, <code>inductive</code> look all very similar to me...</p>",
        "id": 218449247,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606841312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> We had a session at LFTCM about structures and classes. By now, you might be able to get more out of it.</p>",
        "id": 218451889,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606842420
    },
    {
        "content": "<p>Ah, thanks <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> : I will watch it!</p>",
        "id": 218451931,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606842445
    },
    {
        "content": "<p>If you have questions, I'm happy to explain more (if you want, we can do a short video call at some point)</p>",
        "id": 218451949,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606842456
    },
    {
        "content": "<p>Thanks for the offer!  I will give it a go on my own, but I may ask some lingering questions, once I am through with the video and tried it a little bit on my own!</p>",
        "id": 218452092,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606842512
    },
    {
        "content": "<p><span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span></p>",
        "id": 218452122,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606842526
    },
    {
        "content": "<p>Is the semiring structure you’re talking about essentially the Boolean algebra structure, or else one we could define from any Boolean algebra?</p>",
        "id": 218453862,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1606843293
    },
    {
        "content": "<p>It is indeed the Boolean algebra: unions and intersections of sets, happen to map constructible sets to themselves.</p>",
        "id": 218454331,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606843515
    },
    {
        "content": "<p>Does mathlib have the boolean algebra structure on <code>set X</code> for any <code>X</code>?</p>",
        "id": 218454576,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606843639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/218449247\">said</a>:</p>\n<blockquote>\n<p>To be honest, <code>class</code>, <code>structure</code>, <code>inductive</code> look all very similar to me...</p>\n</blockquote>\n<p>There is also the Lean 4 documentation that was written a couple of days ago, which I found concise, clear, well-written, to the point.<br>\n<a href=\"https://github.com/leanprover/lean4/blob/master/doc/typeclass.md\">https://github.com/leanprover/lean4/blob/master/doc/typeclass.md</a></p>\n<p>Of course the syntax differs a little bit from Lean 3, but I don't think that will be a big problem.</p>",
        "id": 218454660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606843682
    },
    {
        "content": "<p>Great: I will take a look!  I actually prefer to have something to read through, before watching a video and trying it out on my example!</p>",
        "id": 218454855,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606843775
    },
    {
        "content": "<p><code>rg \"comm_ring \\(set\"</code> doesn't give me any hits, so I think it's not there</p>",
        "id": 218454907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606843800
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/218454576\">said</a>:</p>\n<blockquote>\n<p>Does mathlib have the boolean algebra structure on <code>set X</code> for any <code>X</code>?</p>\n</blockquote>\n<p>I guess  it does. So maybe we should define constructible sets as the boolean subalgebra of <code>set X</code> generated by opens?</p>",
        "id": 218454958,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606843808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/218454576\">said</a>:</p>\n<blockquote>\n<p>Does mathlib have the boolean algebra structure on <code>set X</code> for any <code>X</code>?</p>\n</blockquote>\n<p>This reminds me the Friday challenge with <code>37={37}</code>...</p>",
        "id": 218454973,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606843815
    },
    {
        "content": "<p>I am in the process of learning this stuff too, watching the videos. I spent something like 15 minutes trying to figure out what was the difference between the structure  <code>is_even_cube_above_100</code> and the proposition with the two <code>∧</code>... and of course he explains this 3 minutes later, so be sure to watch the whole video before starting to think that you do not understand something!</p>",
        "id": 218455052,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1606843850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/218454907\">said</a>:</p>\n<blockquote>\n<p><code>rg \"comm_ring \\(set\"</code> doesn't give me any hits, so I think it's not there</p>\n</blockquote>\n<p>I may be wrong, but <code>comm_ring</code> might assume the existence of opposites for <code>add</code>, so would not work with the Boolean algebra, I think</p>",
        "id": 218455113,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606843879
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.boolean_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">boolean_algebra</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>\n<p>That works for me <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 218455237,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606843925
    },
    {
        "content": "<p>I guess the <code>boolean_algebra</code> to <code>comm_semiring</code> instance is missing?</p>",
        "id": 218455639,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1606844114
    },
    {
        "content": "<p>AFAIK mathlib doesn't have a definition of Boolean subalgebra, though</p>",
        "id": 218455662,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606844128
    },
    {
        "content": "<p><a href=\"https://github.com/rwbarton/lean-omin/blob/master/src/for_mathlib/boolean_subalgebra.lean\">https://github.com/rwbarton/lean-omin/blob/master/src/for_mathlib/boolean_subalgebra.lean</a></p>",
        "id": 218455847,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606844196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> if you want to learn about structures, then I cannot recommend highly enough making a PR for boolean subalgebras. Several Imperial students have got a lot out of bundling various subobjects (submonoids, subgroups and subrings were all bundled by Imperial beginners-at-the-time).</p>",
        "id": 218455939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606844250
    },
    {
        "content": "<p>I will give it a try, although in this case, it seems that Reid already has done quite a bit of work on this!</p>",
        "id": 218456184,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606844361
    },
    {
        "content": "<p>Dear All,</p>\n<p>I found some time to work on this and my progress so far is in the gist below.  If anyone would like to chime in to give suggestions and improvements on how to work with the file below, I would be _really_ grateful!</p>\n<p>My final goal is to define a boolean_algebra/comm_semiring structure generated by the open subsets of a topological space.  In particular, I am not so interested in having the singletons of X to be part of the boolean algebra.  Eventually, this would help with <code>constructible</code> subsets of a topological space.</p>\n<p>Thanks!</p>\n<hr>\n<p>Gist:<br>\n<a href=\"https://gist.github.com/adomani/a1228c1f9726a999c8460ebf445d8871\">https://gist.github.com/adomani/a1228c1f9726a999c8460ebf445d8871</a></p>",
        "id": 222562893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610535082
    },
    {
        "content": "<p>Could you rename the gist to have a <code>.lean</code> extension so that it syntax-highlights?</p>",
        "id": 222563102,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610535227
    },
    {
        "content": "<p>I just did: thanks for the suggestion!</p>",
        "id": 222563291,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610535329
    },
    {
        "content": "<p>I am trying to make the arguments clearer and the linter wanted a <code>inhabited</code> instance.  I provided one, but I do not understand why it works: can someone give me a pointer as to why the code below compiles and pleases the linter?</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.lattice</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">fil</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">uc_closure</span> <span class=\"o\">(</span><span class=\"n\">fil</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">uc_empty</span> <span class=\"o\">:</span> <span class=\"n\">uc_closure</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"n\">uc_fil</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">},</span> <span class=\"n\">fil</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">uc_closure</span> <span class=\"n\">f</span>\n<span class=\"bp\">|</span> <span class=\"n\">uc_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">},</span> <span class=\"n\">uc_closure</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">uc_closure</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">uc_closure</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">∪</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">uc_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"n\">uc_closure</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">uc_closure</span> <span class=\"n\">C</span><span class=\"bp\">ᶜ</span>\n\n<span class=\"sd\">/--- `uc_type` is the SubType of `set X` consisting of the subsets</span>\n<span class=\"sd\">spelled out by `uc_closure fil`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">uc_type</span> <span class=\"o\">(</span><span class=\"n\">fil</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">uc_closure</span> <span class=\"n\">fil</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n\n<span class=\"c1\">--  I thought that, for all `R`and all choices of `fil : set X → Prop`,  I would have had to given an example of `uc_type fil`</span>\n<span class=\"c1\">-- but it seems that I did not.  Moreover, Lean is happy only with checking the axiom uc.empty?</span>\n<span class=\"kd\">instance</span> <span class=\"n\">uc_type.inhabited</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">uc_type</span> <span class=\"n\">fil</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">uc_closure.uc_empty</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 222688364,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610611464
    },
    {
        "content": "<p>The inhabited linter just wants to see an explicit example of a term of your type. If you've made a family of types it just wants to see a term of one of them. Is that your question?</p>",
        "id": 222688962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610611993
    },
    {
        "content": "<p>Your inhabited instance ignored the provided <code>fil</code>, so it says, no matter what <code>fil</code> I get, there's always the closure over the empty set.</p>",
        "id": 222688987,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1610612018
    },
    {
        "content": "<p>Especially because <code>uc_closure.uc_empty</code> doesn't actually use a <code>fil</code> argument.</p>",
        "id": 222689058,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1610612051
    },
    {
        "content": "<p>Ah, I see!  It is the first time that I work with <code>inhabited</code>, so my doubt was really basic.  So, <code>inhabited</code> just wants to know that there is one value of all the parameters of the construction that produces a non-empty type, correct?  What I have provided is the example on the empty type, if I understood correctly.</p>\n<p>Thanks!</p>",
        "id": 222689174,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612151
    },
    {
        "content": "<p>Kevin and Yakov, I think that indeed what confused me was that I had to specify <code>fil</code> to the instance, but then I proved something that did not work with an arbitrary <code>fil</code>.  Now it is clearer!</p>",
        "id": 222689289,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612236
    },
    {
        "content": "<p>Yes it's really easy to please. You could probably even make it happy by telling it an explicit fil on nat and writing down an explicit term of uc_type for that fil</p>",
        "id": 222689296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612241
    },
    {
        "content": "<p>You actually want to prove that the type is inhabited for <em>all</em> settings of the parameters, in this case <code>fil</code></p>",
        "id": 222689324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612269
    },
    {
        "content": "<p>in your case this is easy because you have a constructor that says as much</p>",
        "id": 222689382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612293
    },
    {
        "content": "<p>Mario, I thought that this was the case, but I think that the proof only uses an \"empty\" <code>fil</code>.  I think that I am still missing something...</p>",
        "id": 222689409,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612330
    },
    {
        "content": "<p>No, the proof shows that the empty set is in the closure of any <code>fil</code></p>",
        "id": 222689428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/comm_semiring.20structure.20on.20constructible.20subsets/near/222689174\">said</a>:</p>\n<blockquote>\n<p>one value of all the parameters of the construction that produces a non-empty type</p>\n</blockquote>\n<p>Rather, no matter the value of the parameters, one can always produce a term of the type.</p>",
        "id": 222689444,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1610612365
    },
    {
        "content": "<p>Ah, but what if the remaining axioms were contradictory?  Why did I not have to check that, then?</p>",
        "id": 222689463,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612383
    },
    {
        "content": "<p>because these aren't axioms, they are constructors</p>",
        "id": 222689477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612398
    },
    {
        "content": "<p>it's an inductive type, so any constructor will do</p>",
        "id": 222689525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612407
    },
    {
        "content": "<p>if it was a structure then you would have to set all the fields to be something coherent, which might be harder</p>",
        "id": 222689555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612435
    },
    {
        "content": "<p>Ok, so, regardless of what <code>X</code> and <code>fil</code> are, the empty set is always a term of the resulting type.  Now this makes much more sense!  Thanks and sorry for the silly questions!</p>",
        "id": 222689590,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612463
    },
    {
        "content": "<p>for example proving that <code>group A</code> is inhabited is not at all trivial</p>",
        "id": 222689604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612470
    },
    {
        "content": "<p>(actually it's only true if <code>A</code> is inhabited)</p>",
        "id": 222689655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612511
    },
    {
        "content": "<p>This seems to be clearing up a more fundamental confusion of mine on the distinction between inductive types and structures/classes.</p>",
        "id": 222689716,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612537
    },
    {
        "content": "<p>a structure is sugar for an inductive type with one constructor and a bunch of arguments to that constructor</p>",
        "id": 222689746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612562
    },
    {
        "content": "<p>So this means that it is possible to eliminate all structures, if you have inductive types?</p>",
        "id": 222689858,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612648
    },
    {
        "content": "<p>My experience with the inhabited linter is that it's happy even if you construct a term of a specialisation of your type family. Is this not the case?</p>",
        "id": 222689871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612665
    },
    {
        "content": "<p>Not just that, they are actually inductive types under the hood</p>",
        "id": 222689877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612677
    },
    {
        "content": "<p>(not that I would want to, but <code>structure</code> is just one special kind of inductive type?)</p>",
        "id": 222689879,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612680
    },
    {
        "content": "<p>There is a <code>rec_on</code> and <code>no_confusion</code> and all the other things you find on inductive types</p>",
        "id": 222689905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612711
    },
    {
        "content": "<p>Ok, whereas a class is something like defining a mathematical object by generators and relations?</p>",
        "id": 222689909,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612717
    },
    {
        "content": "<p>and I think if you ask lean if it's an inductive type it will say yes</p>",
        "id": 222689920,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612726
    },
    {
        "content": "<p>A class is just a structure</p>",
        "id": 222689928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612735
    },
    {
        "content": "<p>The only extra thing is that it's tagged with an attribute</p>",
        "id": 222689944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612753
    },
    {
        "content": "<p>A class is a structure with an annotation on it, <code>class</code> = <code>@[class] structure</code></p>",
        "id": 222689950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612757
    },
    {
        "content": "<p>So the type class system knows about it</p>",
        "id": 222689998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612768
    },
    {
        "content": "<p>the other part of that being <code>instance</code> = <code>@[instance] def</code></p>",
        "id": 222690027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612790
    },
    {
        "content": "<p>It's like a simp lemna is just a lemma tagged with the simp attribute</p>",
        "id": 222690041,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612798
    },
    {
        "content": "<p>Mathematically a class and a structure are the same</p>",
        "id": 222690062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612826
    },
    {
        "content": "<p>Ok, I probably have to go back and read again classes/structures/inductive types and re-read Kevin's post on no-confusion!</p>",
        "id": 222690086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612855
    },
    {
        "content": "<p>Attributes just change the way some tactics or internals use the definition</p>",
        "id": 222690105,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612870
    },
    {
        "content": "<p>Eg the type class inference square bracket machine will look for <code>class</code> tags</p>",
        "id": 222690160,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612894
    },
    {
        "content": "<p>And the simplifier will look for <code>simp</code> tags</p>",
        "id": 222690177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610612914
    },
    {
        "content": "<p>Ah, so the things that are in square brackets are structures labelled with a <code>class</code> tag, right?</p>",
        "id": 222690199,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610612947
    },
    {
        "content": "<p>yes, <code>[group A]</code> only does something because <code>group</code> is marked as <code>@[class]</code></p>",
        "id": 222690227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610612987
    },
    {
        "content": "<p>if you did <code>[even n]</code> it wouldn't work</p>",
        "id": 222690295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610613016
    },
    {
        "content": "<p>Thanks, this is now entering my mind: I believe that it bounced on it several times in the past...</p>",
        "id": 222690341,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610613074
    },
    {
        "content": "<p>the <code>inhabited</code>-linter is there to force us to do some basic checks that we are not making stupid definitions. So when you write an instance to make it happy, it's best to try to make the example as \"canonical\" as possible. In other words, even if you can give an example for just <code>X = nat</code>, we encourage you to make it for every <code>X</code>, just like you did.</p>",
        "id": 222690725,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610613404
    },
    {
        "content": "<p>... in line with the aspiration that everything is mathlib should be as general as possible, including the specific examples!</p>",
        "id": 222690839,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610613502
    },
    {
        "content": "<p>So, while we are talking about this, does this mean that maybe I should make <code>uc_closure</code> a <code>structure</code>?  Or even a <code>class</code>?</p>",
        "id": 222691279,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610613884
    },
    {
        "content": "<p>A structure is nothing more than an inductive type with one constructor. There's no such thing as a structure in some sense, it's just a certain kind of inductive type with some syntax sugar. Your inductive type has four constructors.</p>",
        "id": 222691842,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610614296
    },
    {
        "content": "<p>Ah, I see!  Thanks!</p>",
        "id": 222692013,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610614417
    },
    {
        "content": "<p>Dear All,</p>\n<p>to get some familiarity with these notions, I showed how you can construct a boolean subalgebra of a boolean algebra.  The gist is linked below.  If you have any comments, they are more than welcome, as usual!</p>\n<p>I will create a PR with this later on, if people think that it might be useful.</p>\n<p>Thanks!</p>\n<p><a href=\"https://gist.github.com/adomani/2c60da5448abb9ef27769162eb3038a0\">https://gist.github.com/adomani/2c60da5448abb9ef27769162eb3038a0</a></p>",
        "id": 222732126,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610637889
    },
    {
        "content": "<p>It surprises me how different the approach you use there is to how things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subalgebra\">docs#subalgebra</a> are defined, in that you build an inductive predicate instead of stating properties of a set</p>",
        "id": 222732730,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610638160
    },
    {
        "content": "<p>Yes I agree. Did you look at how it's done for subgroups of groups?</p>",
        "id": 222733195,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610638339
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">boolean_subalgebra</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">boolean_algebra</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bot_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sup_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">compl_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>would normally be the start</p>",
        "id": 222733283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610638382
    },
    {
        "content": "<p>You want to make the type of subalgebras, and construct the Galois insertion from subsets to subalgebras. This gives you a complete lattice structure on subalgebras. I would strongly recommend looking at how it is done for submonoids, subgroups, subrings etc.</p>",
        "id": 222733918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610638602
    },
    {
        "content": "<p>I have not looked at anything, other than the manual for seeing the syntax of inductive types...  I will take a look at subgroups/sub-other things!</p>",
        "id": 222734203,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610638719
    },
    {
        "content": "<p>I think your <code>is_bool_subalgebra fil x</code> would usually be spelt <code>x \\in boolean_subalgebra.closure fil</code></p>",
        "id": 222734530,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610638839
    },
    {
        "content": "<p>As a general rule, I have embraced the \"talking about types instead of sets\" idea, which is why I did not think of using an \"underlying set\".  However, as I do not have any experience of how these definitions play out in the long run, I do not insist on maintaining it like this!</p>\n<p>I was pleased to see that, when I start with the open subsets of a topological space, I do get the usual constructible sets!</p>",
        "id": 222734557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610638855
    },
    {
        "content": "<p>Well, <code>B → Prop</code> is the same as <code>set B</code>, so your <code>is_bool_subalgebra fil</code> is simply a computation of that underlying set!</p>",
        "id": 222734645,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610638894
    },
    {
        "content": "<p>Sure, but I do not need to talk about elements...</p>",
        "id": 222734701,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610638917
    },
    {
        "content": "<p>Arguably <code>is_bool_subalgebra fil a</code> is talking about elements because it's defeq to <code>a ∈ is_bool_subalgebra fil</code></p>",
        "id": 222734846,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610638955
    },
    {
        "content": "<p>\"Types instead of sets\" is more about using <code>(b : B)</code> instead of <code>(a : A) (ha : a ∈ b)</code> - using <code>(a : A) (ha : p a)</code> isn't morally any different to the <code>set</code> spelling (although both are fine when its convenient!)</p>",
        "id": 222735311,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610639113
    },
    {
        "content": "<p>Why \"fil\"?</p>",
        "id": 222755938,
        "sender_full_name": "Reid Barton",
        "timestamp": 1610646995
    },
    {
        "content": "<p>Because I was thinking of using the elements of a filter at some point...  Not a very good reason!</p>",
        "id": 222781634,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1610657283
    }
]
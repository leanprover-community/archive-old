[
    {
        "content": "<p>Say I have defined a structure named <code>blah</code> which has fields <code>F1</code> ... <code>Fn</code> in its definition. When proving a certain theorem about <code>blah</code>, I have in my context some stuff <code>X Y Z: blah</code> which are going to be used in the statement and the proof of the theorem. In my tactic-style proof, Lean can display in context/goal <code>X.F1</code>, <code>Y.F1</code> etc which is great. But, if I make <code>blah</code> into a type-class, which is desirable in some situations, then instead of <code>X.F1</code> Lean displays <code>blah.F1</code> for both <code>X.F1</code>, <code>Y.F1</code>, which is less useful when proving theorems with lots of instances. Is there a way to formalize my structure <code>blah</code> with a type-class but also have the useful projections <code>X.F1</code>, <code>Y.F1</code>?</p>",
        "id": 314715991,
        "sender_full_name": "Sina",
        "timestamp": 1670517435
    },
    {
        "content": "<p>Yes, replace <code>(the_field_I_want_a_projection_of : its_type)</code> by <code>(the_field_I_want_a_projection_of [] : its_type)</code> in the structure declaration.</p>",
        "id": 314716412,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670517542
    },
    {
        "content": "<p>Not sure I am doing it right. Here's a MWE: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">functor</span> <span class=\"o\">(</span><span class=\"bp\">𝓒</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category_str.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"bp\">𝓒</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">𝓓</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category_str.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"bp\">𝓓</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"bp\">𝓒</span> <span class=\"bp\">→</span> <span class=\"bp\">𝓓</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"bp\">𝓒</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">resp_id'</span>   <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"bp\">𝓒</span><span class=\"o\">),</span> <span class=\"n\">mor</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">resp_comp'</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"bp\">𝓒</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">),</span> <span class=\"n\">mor</span> <span class=\"o\">(</span><span class=\"n\">f</span>  <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">≫</span>  <span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>Now, in defining composition of functors, Lean displays <code>mor 𝓔 (mor 𝓓 (𝟙 X)) = 𝟙 (obj (obj X))</code>  (when i put my cursor on the first <code>simp</code> in the definition below) whereas i would like it to display <code>G.mor (F.mor (𝟙 X)) = 𝟙 (G.obj (F.obj X))</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"bp\">𝓒</span> <span class=\"bp\">𝓓</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"bp\">𝓓</span> <span class=\"bp\">𝓔</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"bp\">𝓒</span> <span class=\"bp\">𝓔</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">obj</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">G.obj</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"c1\">-- G.obj ∘ F.obj,</span>\n  <span class=\"n\">mor</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">G.mor</span> <span class=\"o\">(</span><span class=\"n\">F.mor</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"n\">resp_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">functor.resp_id</span> <span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">resp_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intros</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">functor.resp_comp</span><span class=\"o\">],},</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 314720304,
        "sender_full_name": "Sina",
        "timestamp": 1670518638
    },
    {
        "content": "<p>That doesn't answer your question, but you most definitely don't want <code>functor</code> to be a class, as it means you will be able to use only one functor between any two categories!</p>",
        "id": 314721680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670519010
    },
    {
        "content": "<p>Absolutely, I just used the functor example as MWE, since your trick with <code>[ ]</code> would work for other examples i had. Thanks for your answer though, i never quite understood the purpose of <code>[ ]</code>  in type classes before.</p>",
        "id": 314726827,
        "sender_full_name": "Sina",
        "timestamp": 1670520531
    },
    {
        "content": "<p>Have you tried defining your structure as a structure, but then adding <code>attribute [class]</code> to it afterwards?</p>",
        "id": 314727441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670520672
    },
    {
        "content": "<p>The <code>[]</code> trick answers why it shows up as <code>blah.F1</code> rather than <code>X.F1</code>, but your second message makes it seem that you expected <code>X.F1</code> rather than <code>blah.F1 X</code>. This is a different question, and relates to \"pretty-printing\" (aka pp).</p>",
        "id": 314727535,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670520706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span>  I see. I'd prefer <code>X.F1</code>, but would also be happy with <code>blah.F1 X</code>. With <code>functor</code> example, I do not even get the latter; I only get  <code>blah.F1</code>. So, adding <code>[]</code> to <code>obj</code> and <code>mor</code> field of the functor type class , Lean would display</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mor</span> <span class=\"bp\">𝓔</span> <span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"bp\">𝓓</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"bp\">𝓔</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"bp\">𝓓</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>instead of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">mor</span> <span class=\"o\">(</span><span class=\"n\">mor</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>without adding <code>[]</code>.  </p>\n<p>Does <code>pp</code> help with displaying either <code>F.mor</code> or <code>mor F</code> for a functor <code>(F : functor 𝓒 𝓓)</code> ? Again this is in the context of wrongly declaring <code>functor</code> as a type-class.</p>",
        "id": 314730075,
        "sender_full_name": "Sina",
        "timestamp": 1670521477
    }
]
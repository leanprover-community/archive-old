[
    {
        "content": "<p>Hello, are there people working on the spectral theorem for finite dimensional Hilbert spaces (or anything of greater generality)?</p>",
        "id": 204140690,
        "sender_full_name": "Kevin Shu",
        "timestamp": 1594932515
    },
    {
        "content": "<p>we just finished Cayley Hamilton, so defining eigenstuff is definitely in striking distance</p>",
        "id": 204142839,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245078\">@Apurva Nakade</span> was looking to start on a project like this</p>",
        "id": 204142872,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933516
    },
    {
        "content": "<p>Anne Baanen's recent linear algebra video is great, have you watched it yet?</p>",
        "id": 204142909,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933538
    },
    {
        "content": "<p><a href=\"https://www.youtube.com/watch?v=EnZvGCU_jpc&amp;feature=youtu.be\">https://www.youtube.com/watch?v=EnZvGCU_jpc&amp;feature=youtu.be</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"EnZvGCU_jpc\" href=\"https://www.youtube.com/watch?v=EnZvGCU_jpc&amp;feature=youtu.be\"><img src=\"https://i.ytimg.com/vi/EnZvGCU_jpc/default.jpg\"></a></div>",
        "id": 204142946,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933561
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Status.20of.20Spectral.20Theorem.3F/near/204142839\">said</a>:</p>\n<blockquote>\n<p>we just finished Cayley Hamilton, so defining eigenstuff is definitely in striking distance</p>\n</blockquote>\n<p>I really don't understand why everybody keeps repeating that. Why would you need CH to defining eigenstuff?</p>",
        "id": 204143070,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594933606
    },
    {
        "content": "<p>This is totally insane.</p>",
        "id": 204143121,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594933633
    },
    {
        "content": "<p>in my head, the number of eigenvalues with multiplicity is equal to the degree of the characteristic polynomial</p>",
        "id": 204143159,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933666
    },
    {
        "content": "<p>but maybe there's a much more efficient path</p>",
        "id": 204143172,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933677
    },
    {
        "content": "<p>Even if you don't do \"linear algebra done right\", you can define eigenstuff and prove a lot about them with Cayley-Hamilton.</p>",
        "id": 204143222,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594933685
    },
    {
        "content": "<p>i agree you don't need all this for the definition of eignstuff</p>",
        "id": 204143257,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933707
    },
    {
        "content": "<p>The degree of the characteristic polynomial is the size of the matrix.</p>",
        "id": 204143271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594933714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243947\">@Miguel Raz Guzmán Macedo</span> was also interested in eigenvalues</p>",
        "id": 204143402,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1594933790
    },
    {
        "content": "<p>i should maybe pick up a book and read an efficient development of the theory before commenting further about the best past forward</p>",
        "id": 204143410,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594933794
    },
    {
        "content": "<p>We need a #bourbaki, for Patrick's use only.</p>",
        "id": 204143490,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1594933820
    },
    {
        "content": "<p>Hey! I am very interested in trying to prove the spectral theorem, for normal operators maybe?<br>\nAm still browsing the library and trying to figure out what is known about hilbert spaces...</p>",
        "id": 204144508,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1594934289
    },
    {
        "content": "<p>Looks like inner product spaces are defined under normed spaces but quadratic forms are defined under linear algebra. Hmm... Where would Hilbert spaces go?</p>",
        "id": 204145157,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1594934670
    },
    {
        "content": "<p>One observation is that the existence of eigenvalues for real symmetric matrices can be done using 'only' calculus, and observing that the corresponding quadratic form is minimized on the unit sphere, since it is compact. This is a relatively ugly proof, but I think it's just a computation once you know that the sphere is compact. Do we have that fact?</p>",
        "id": 204145366,
        "sender_full_name": "Kevin Shu",
        "timestamp": 1594934800
    },
    {
        "content": "<p>Heather, I don't think the exposition style in \"Linear algebra done right\" is so close to Bourbaki's style...</p>",
        "id": 204145808,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594935032
    },
    {
        "content": "<p>But the definition of eigenstuff is independent of determinant and Cayley-Hamilton in any case, even in determinant-centric expositions.</p>",
        "id": 204145894,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594935075
    },
    {
        "content": "<p>Kevin, we know finite dimensional spheres are compact.</p>",
        "id": 204145943,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594935112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296764\">@Kevin Shu</span> I feel like proving spectral theorem the \"standard way\" will force us to build the theory of finite dim Hilbert spaces which will be useful on its own.</p>",
        "id": 204147329,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1594935915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245078\">@Apurva Nakade</span> That is true, you probably want this standard proof in the end. That said, the proof I described might also be used to show the variational characterization of eigenvalues, which is useful in other places, and it might be thought of as a stopgap. I will give a shot at that version, though since I am new, how far I'll get is questionable :)</p>",
        "id": 204150037,
        "sender_full_name": "Kevin Shu",
        "timestamp": 1594937618
    },
    {
        "content": "<p>kevin, if you post a link to a github project, i'll happy follow</p>",
        "id": 204150252,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1594937738
    },
    {
        "content": "<p>I tried defining eigenstuff a month ago (to be fair, I'm not experienced now, and I was REALLY new then). I found that defining what an eigenvalue/eigenvector is works just fine, but if you want to do anything that involves finsets in the finite-dimensional case, or prove any existence results, Cayley-Hamilton seemed by far the easiest place to start</p>",
        "id": 204157281,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1594943513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, I only had in mind the existence of eigenvalues for finite dimensional matrices over C, when I've been advertising Cayley-Hamilton.  (Pretty much as <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> says.)</p>",
        "id": 204163600,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594950255
    },
    {
        "content": "<p>I think it would be great if we just do Banach algebra / C*-algebras / functional calculus, and then derive finite dimensional stuff from that (it would fit with how the rest of mathlib goes ...).</p>",
        "id": 204163635,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594950329
    },
    {
        "content": "<p>I'm not actually sure that that route helps at all for the \"finite-dimensional-but-not-necessarily-normal\" part of the theory. I guess I've only ever thought about the route to that via CH...</p>",
        "id": 204163698,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1594950405
    },
    {
        "content": "<p>I think that existence of eigenvalues for finite dimensional matrices over C is precisely where the path advocated by \"Linear algebra done right\" is better without any possible debate.</p>",
        "id": 204179167,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1594972197
    },
    {
        "content": "<p>As a start, would it make sense to prove that a normal matrix with complex entries can be written as <code>UDU*</code> where <code>U</code> is unitary and <code>D</code> is diagonal?</p>",
        "id": 204250630,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1595015443
    },
    {
        "content": "<p>And then one day when f.d. complex inner product spaces exist we can produce a more direct proof by proving the existence of an eigenbasis?</p>",
        "id": 204251268,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1595015857
    },
    {
        "content": "<p>mathematically, don't <code>U</code> and the eigenbasis have the same data? if you think know how to prove the first form, you should do it.</p>",
        "id": 204253783,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1595017196
    },
    {
        "content": "<p>Yes, theoretically it is the same information. But proving the existence of an eigenbasis for normal operators requires one to setup the theory of complex inner product spaces whereas I believe all the theory needed for proving the theorem for matrices already exists in mathlib.</p>",
        "id": 204255074,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1595017726
    },
    {
        "content": "<p>got it, so to move between the two forms of the theorem you need... a *-algebra isomorphism between <code>matrix n n R</code> and the linear endomorphisms of <code>(n \\to R)</code>? I think we already have this as a linear isomorphism and maybe even an algebra isomorphism</p>",
        "id": 204255355,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1595017842
    },
    {
        "content": "<p>I think the strategy of \"first prove any form of the theorem, then see what API you need to convert to other forms\" is a good one</p>",
        "id": 204255439,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1595017893
    },
    {
        "content": "<p>once you've proven the first theorem, you reduce the problem from a maths + software engineering challenge to only a software engineering challenge :)</p>",
        "id": 204255535,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1595017929
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296764\">@Kevin Shu</span> I had started working on the Spectral Theorem a year ago. I followed this document: <a href=\"https://www.maa.org/sites/default/files/pdf/awards/Axler-Ford-1996.pdf\">https://www.maa.org/sites/default/files/pdf/awards/Axler-Ford-1996.pdf</a><br>\nI guess this is the same approach as in \"Linear algebra done right\".</p>\n<p>I formalized Theorem 2.1, Proposition 2.2, Lemma 3.1, and Proposition 3.4. I'll try to update the code to the latest version of mathlib and upload it somewhere.</p>\n<p>Have you started working on this? Which approach are you taking?</p>",
        "id": 206824740,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597330437
    },
    {
        "content": "<p>So this is what I currently have, now updated to the latest version of mathlib: <a href=\"https://github.com/abentkamp/spectral\">https://github.com/abentkamp/spectral</a></p>",
        "id": 206931182,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597413144
    },
    {
        "content": "<p>Oh wow, this is great. I have been trying to get to the spectral theorem in a more direct way:</p>\n<ol>\n<li>Show that an eigenvector + eigenvalue exists using Cayley-Hamilton</li>\n<li>Construct a unitary matrix whose first column is this eigenvector</li>\n<li>Reduce the problem to a lower dimensional matrix and induct.</li>\n</ol>",
        "id": 206959427,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597428534
    },
    {
        "content": "<p>Just posted my code here: <a href=\"https://github.com/apurvnakade/spectral-theorem\">https://github.com/apurvnakade/spectral-theorem</a></p>",
        "id": 206959449,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597428543
    },
    {
        "content": "<p>I will add a README.md and several comments to the code now that there seems to be multiple approaches to proving this</p>",
        "id": 206959498,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597428588
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span>  since you already have done so much work on eigenvalues and eigenvectors, I will focus on theorems about unitary and normal matrices</p>",
        "id": 206959993,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597428910
    },
    {
        "content": "<p>I see that you already have <code>lemma generalized_eigenvector_span</code> :D</p>",
        "id": 206960958,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597429466
    },
    {
        "content": "<p>the spectral theorem should be a direct corollary of this</p>",
        "id": 206960969,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597429475
    },
    {
        "content": "<p>Can you push this to mathlib?</p>",
        "id": 206961074,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597429532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129120\">Alexander Bentkamp</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Status.20of.20Spectral.20Theorem.3F/near/206931182\">said</a>:</p>\n<blockquote>\n<p>So this is what I currently have, now updated to the latest version of mathlib: <a href=\"https://github.com/abentkamp/spectral\">https://github.com/abentkamp/spectral</a></p>\n</blockquote>\n<p>Alex, did you see that algebraically closed fields and existence of algebraic closures are now in mathlib?</p>",
        "id": 206979000,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597437467
    },
    {
        "content": "<p>Why isn't all this in mathlib?</p>",
        "id": 206979382,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597437683
    },
    {
        "content": "<blockquote>\n<p>Apurva Nakade: the spectral theorem should be a direct corollary of this</p>\n</blockquote>\n<p>I think we first need a complex inner product, right?</p>",
        "id": 207014431,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597485126
    },
    {
        "content": "<blockquote>\n<p>Patrick Massot: Why isn't all this in mathlib?</p>\n</blockquote>\n<p>Yeah, I know I should have merged this earlier, but I have been a bit worried about finishing my main PhD project in time. Now it looks like it's easily doable and I'll have some time to merge it.</p>",
        "id": 207014791,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597485735
    },
    {
        "content": "<blockquote>\n<p>I think we first need a complex inner product, right?</p>\n</blockquote>\n<p>Oh, well, in your approach, you'll use the dot product instead, which I just discovered in your files. Then the spectral theorem shouldn't be far away indeed.</p>",
        "id": 207015751,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597487467
    },
    {
        "content": "<p>Using your theorem you need two more steps:</p>\n<ol>\n<li>Gram-Schmidt orthogonalization </li>\n<li>Proving that an upper triangular normal matrix is diagonal<br>\nThe second should be easy, the first one will need some work though. In any case, your theorems are great! I was daunted by having to prove the existence of an eigenvbasis and was trying a workaround using induction but now we don't need to do that anymore.</li>\n</ol>",
        "id": 207025034,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597503237
    },
    {
        "content": "<p>Actually, you don't even need Gram-Schmidt orthogonalization if you are only interested in the linear operator version of spectral theorem. All you need to show is that every generalized eigenvector of a normal operator is a genuine eigenvector. I don't remember the proof of the top of my head but it is the linear operator version of every upper triangular normal matrix is diagonal.</p>",
        "id": 207025288,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597503635
    },
    {
        "content": "<p>I, <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> , and <span class=\"user-mention\" data-user-id=\"296764\">@Kevin Shu</span>  have been trying to brainstorm how to move toward the spectral theorem given that complex inner products seem <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product\">controversial</a>. </p>\n<p>We were thinking of doing this using complex <em>dot</em> products (that mimic the current dot product) and then prove the spectral theorem for normal matrices using <span class=\"user-mention\" data-user-id=\"129120\">@Alexander Bentkamp</span> 's work. We want to write the code in such a way that one day when complex inner products exist the code can be easily upgraded with no extra effort. Does this sound reasonable? Or is it better to wait for complex inner products to exist on mathlib?</p>",
        "id": 207074404,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597589304
    },
    {
        "content": "<p>My original plan was to prove the spectral theorem without choosing a basis (i.e., only linear maps, no matrices). I'd still find it elegant if we could do it that way. The dot product can only be defined with a basis, right?</p>",
        "id": 207074604,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597589731
    },
    {
        "content": "<p>Mathematically, what you say is uncontroversially the best way to do it. But this requires the existence of a complex inner product, which might take a long time to make it to mathlib.</p>",
        "id": 207074814,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597590060
    },
    {
        "content": "<p>Although, maybe this has changed recently. It would be really awesome if we could have some complex inner product on mathlib. That would just open up doors to so many more results.</p>",
        "id": 207074911,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597590184
    },
    {
        "content": "<p>I think we could at least try to push for it by creating a copy of <code>real_inner_product</code> and adapting it to complex numbers. Then create a pull request and try to get it merged. Do you think that would be rejected?</p>",
        "id": 207075228,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597590660
    },
    {
        "content": "<p>It could still be generalized later if that's what people want...</p>",
        "id": 207075239,
        "sender_full_name": "Alexander Bentkamp",
        "timestamp": 1597590684
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> <span class=\"user-mention\" data-user-id=\"284606\">@Chris M</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 207075256,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1597590718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129120\">Alexander Bentkamp</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Status.20of.20Spectral.20Theorem.3F/near/207075228\">said</a>:</p>\n<blockquote>\n<p>I think we could at least try to push for it by creating a copy of <code>real_inner_product</code> and adapting it to complex numbers. Then create a pull request and try to get it merged. Do you think that would be rejected?</p>\n</blockquote>\n<p>This has already been done: <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/200795959\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/200795959</a></p>",
        "id": 207075330,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597590827
    },
    {
        "content": "<p>but it was not PRed to mathlib. maybe with your work now there is enough motivation to have this is in the library</p>",
        "id": 207075379,
        "sender_full_name": "Apurva Nakade",
        "timestamp": 1597590873
    },
    {
        "content": "<p>so let's add <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> to the tag party :)</p>",
        "id": 207075472,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1597591022
    },
    {
        "content": "<p>Personally, I wish there were some way to unify the real and Hermitian inner product (maybe along the lines I was brainstorming <a href=\"#narrow/stream/144837-PR-reviews/topic/.233658.20extend.20Hahn-Banach.20from.20.E2.84.9D.20to.20.E2.84.82\">here</a>).  But it seems nobody knows a good way to do it, so maybe it is better to have parallel real and Hermitian files.</p>",
        "id": 207075688,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1597591433
    },
    {
        "content": "<p>How exactly does <code>to_additive</code> work?  Would it be possible to do something like that in this setting, to reduce duplication?</p>",
        "id": 207075754,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1597591516
    },
    {
        "content": "<p>I think it's not too hard to code something like <code>to_additive</code> and I'd like to see more meta-programming in this style, but I'm not sure the specification would be so easy to write. Actually we may need to first write everything by hand with as much duplication as possible before knowing exactly what we want the tactic to do.</p>",
        "id": 207077018,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597593604
    },
    {
        "content": "<p>the machine learning folks say that what they need is lots of labeled examples. This is also true for \"good old-fashioned AI\", i.e. metaprogramming. If we write the library in such a way that it's easy to see how to use automation to make the presentation more compact / maintainable, then we'll get more people teaching themselves how to metaprogram.<br>\nMaybe a second example of \"things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/to_additive\">docs#to_additive</a>\" is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simps_attr\">docs#simps_attr</a>, which I just learned has very detailed docstrings.<br>\nI guess in addition to heaping praise on <code>to_additive</code>, we should also encourage theory-specific provers like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mfld_set_tac.\">docs#mfld_set_tac.</a></p>",
        "id": 207082676,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597601823
    },
    {
        "content": "<p>more on topic...<br>\nI agree that the specification is not easy to write. I tried (on the <code>mathlib:complex_dot_product</code> branch) imitating the proof of one real inner product lemma for the complex numbers, and found that we were missing a lemma like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">conj_sum</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"err\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>  <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 207083159,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597602700
    },
    {
        "content": "<p>I'm not sure how one would make sure they've gotten all of the side lemmas like this without effectively doing the whole \"manual translation\" one declaration at a time</p>",
        "id": 207083581,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597603446
    },
    {
        "content": "<p>This should follow immediately from the fact that complex.conj is an additive group hom. Presumably <code>complex.conj</code> is the \"bare function\"; the ring homomorphism will probably have nicer properties.</p>",
        "id": 207085457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597605540
    },
    {
        "content": "<p>sorry, I didn't mean to imply that the sorry was hard to fill. Just that it seems to be missing, and makes a good simp lemma. Unless there's a way to teach <code>simp</code> about the version for general additive homs?</p>",
        "id": 207091561,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597614381
    },
    {
        "content": "<p>Doesn't <code>simp</code> already know the result for general additive homs? I don't know if this is impossible in your situation but I'm wondering if you can use the ring hom instead of the bare map all the way through. I don't know if this is more sensible than just training the simplifier on all the ring isom lemmas for complex.conj.</p>",
        "id": 207096102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597622329
    },
    {
        "content": "<p>I see. Right now, data.matrix.basic models a vector as a bare function type <code>n \\to V</code>. I think you want to see a type <code>vector n</code> so that  </p>\n<ul>\n<li><code>vector n</code> has a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\"> \\mathbb C </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>-module instance</li>\n<li><code>vector.map</code>takes additive homs to additive homs</li>\n<li><code>vector.conj</code> is defined as <code>vector.map complex.conj</code></li>\n</ul>",
        "id": 207097530,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597624843
    },
    {
        "content": "<p>maybe modelling off of data.matrix.basic doesn't make sense. Is it written with bare function types for computational reasons?</p>",
        "id": 207097732,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597625222
    },
    {
        "content": "<p>Ah, I see Frederic bases it on real_inner_product.lean.</p>",
        "id": 207098121,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597625989
    },
    {
        "content": "<p>Ah, I'm glad that this is coming up again -- I would also very much like to see complex inner products in mathlib, a lot of what I am interested in formalizing depends on this! I'm not convinced that duplicating the real inner product code (like I did a while back) is the best approach however, it would be much nicer to have a unified approach to both cases. I'm starting to think that the better way to do this would be to create this \"ℝ or ℂ\" typeclass that was mentioned in that other thread. I was thinking of something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">is_R_or_C</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">ℝ</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">re</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">im</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">conj</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and then giving that class the same API as the complex numbers, adding whatever it takes to the class definition along the way to make it happen. The result probably won't be very pretty, but then afterwards when using it, it should behave fairly nicely, with <code>re</code>, <code>im</code>, <code>conj</code>, etc, being defeq to the right things in both cases.</p>\n<p>Does that sound like a reasonable plan?</p>",
        "id": 207145955,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597672216
    },
    {
        "content": "<p>I fear this will make the real case much less pleasant to work with.</p>",
        "id": 207146055,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597672277
    },
    {
        "content": "<p>why not just say \"a finite extension of R\"</p>",
        "id": 207146097,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597672290
    },
    {
        "content": "<p>Unless you have meta-programming generating the right statements in the real and complex case from statements in this real_or_complex case.</p>",
        "id": 207146146,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597672319
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  yeah I said that last time and it derailed the thread</p>",
        "id": 207146203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597672335
    },
    {
        "content": "<p>I was hoping that for the real case, you would end up with a bunch of <code>re</code> and <code>conj</code>, etc, being the identity and that it wouldn't be too much of an inconvenience but this might be a bit naive...</p>",
        "id": 207146436,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597672459
    },
    {
        "content": "<p>You can only hope for definitional equality here, not syntactic one. But again meta-programming could help here. You would have something like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">real_or_complex</span><span class=\"o\">]</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">inner_symm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">inner</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">inner</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n\n\n<p>that would generate two lemmas <code>real_inner_symm (x y : α) : inner x y = inner y x := </code> and <code>cplx_inner_symm (x y : α) : inner x y = conj (inner y x) := </code>. The proof would be the same, and the statement would simply remove <code>conj</code> and <code>re</code>, and do something smarter about <code>im</code>.</p>",
        "id": 207147080,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597672805
    },
    {
        "content": "<p>Yes, that would be much nicer to use at the end. I'm guessing it wouldn't be too much harder to program than <code>to_additive</code> but then again I have zero experience with metaprogramming.</p>",
        "id": 207147463,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597672994
    },
    {
        "content": "<p>I think the meta-programming part isn't the hardest part. If you want to see that happening, the hard work is to first do it by hand for a number of lemmas which illustrate as many situations as possible.</p>",
        "id": 207147806,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597673192
    },
    {
        "content": "<p>Actually the code of <code>to_additive</code> even contain crucial bits that are ready to serve elsewhere, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tactic.transform_decl_with_prefix_dict\">docs#tactic.transform_decl_with_prefix_dict</a></p>",
        "id": 207148234,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597673406
    },
    {
        "content": "<p>Actually I guess in practice that would be very similar to what I did by coding a complex version of <code>real_inner_product.lean</code>...</p>",
        "id": 207149144,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597673874
    },
    {
        "content": "<p>I don't remember the status of sesquilinear forms actually. We do have something, right?</p>",
        "id": 207149395,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597674007
    },
    {
        "content": "<p>It's there, yes, in <code>linear_algebra/sesquilinear_form.lean</code>. It involves a parameter <code>(I : R ≃+* Rᵒᵖ)</code> that plays the role of the complex conjugate -- maybe there's a way to use it to make this parameter go away somehow in the real and complex cases but I don't see how to do it.</p>",
        "id": 207149865,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597674295
    },
    {
        "content": "<p>Maybe this <code>out_param</code> business would help here -- is this documented somewhere? I tried to follow the refactoring of affine spaces but I didn't understand anything.</p>",
        "id": 207150238,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597674477
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> In your proposal, does that still require the <code>is_R_or_C</code> typeclass? What is the type of <code>inner_symm</code>?</p>",
        "id": 207159234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597678874
    },
    {
        "content": "<p>Yes, I was still thinking about using this type class. But it's not a very serious proposal until we actually see some code.</p>",
        "id": 207165233,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597681760
    },
    {
        "content": "<p>I feel like the best way forward is to get something merged now which deals with the very basics of the complex, maximizing the code similarity between the real and complex cases as per one of Patrick's suggestions. Maybe this involves taking a file called <code>real_inner_product_space.lean</code>, changing it to a folder <code>inner_product_space</code> with two files <code>real.lean</code> and <code>complex.lean</code>.  A reviewer might choose to literally read the diff of the two files with each other as part of the review.</p>",
        "id": 207202690,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597702206
    },
    {
        "content": "<p>Doing it this way creates the sort of well-defined and obviously-valuable metaprogramming problem which will cause people to invest effort to learn metaprogramming. The problem comes with a lower bound on how many lines of code you get to remove from mathlib, which sounds like a pretty fun metric to optimize for.</p>",
        "id": 207203022,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1597702477
    },
    {
        "content": "<p>This could be done pretty quickly, but the danger here is to drag our feet on the metaprogramming once this is done and get in too deep with the two separate cases. For instance, once we have complex inner products, it will be very tempting to get started on Hilbert spaces, where there is a lot of \"ℝ or ℂ\" stuff going on as well. Getting it right the first time could save us a lot of work done the line...</p>",
        "id": 207209598,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597707696
    },
    {
        "content": "<p>I've got a probably daft idea for the <code>is_R_or_C</code> typeclass, from reading up on Artin-Schreier: <br>\n<code>variables {K : Type*} [field K] [algebra ℝ K] [finite_dimensional ℝ K]</code> would define your <code>K</code> to be probably R or C enough, but then you'd still need a variable for the automorphism that'd either be the identity for R or conjugation for C</p>",
        "id": 207211447,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597709508
    },
    {
        "content": "<p>Right -- the problem with this approach is that you'll surely end up needing that the norm from K down to the reals sends z to z*sigma(z) if K isn't R, i.e. that it's Galois with group of order at most 2. I do not know this area. In number theory (when dealing with infinite places of number fields) we are really happy with the squared norm |a+ib|=a^2+b^2 because this makes a bunch of stuff work out quite nicely. But in analysis I would imagine that you want to take the square root a fair amount of the time. Whilst it is true that there is a more general theory where you assume that the extension has degree 2, I'm finding it hard to unify the degree 1 and 2 cases. In number theory it's quite common to split into two different calculations for the real and the complex case.</p>",
        "id": 207212145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597710249
    },
    {
        "content": "<p>Also, I think Patrick's main point was that having this automorphism lying around all the time would get too annoying in the long run, even if it ends up being defeq to the identity or conjugation depending on the case.</p>",
        "id": 207218394,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597718405
    },
    {
        "content": "<p>One possibility would be to have a general interface with the automorphism and then a specialized API for when the automorphism is the identity, though I don't really know whether there are enough other examples to make this worthwhile</p>",
        "id": 207218611,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597718735
    },
    {
        "content": "<p>Yes, I think a specialized API is what we want in the end, and I guess the main question is whether we should write it by hand or if it's worth having a <code>to_additive</code>-style mechanism to generate it automatically.</p>",
        "id": 207218775,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597718991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Status.20of.20Spectral.20Theorem.3F/near/207209598\">said</a>:</p>\n<blockquote>\n<p>This could be done pretty quickly, but the danger here is to drag our feet on the metaprogramming once this is done and get in too deep with the two separate cases. For instance, once we have complex inner products, it will be very tempting to get started on Hilbert spaces, where there is a lot of \"ℝ or ℂ\" stuff going on as well. Getting it right the first time could save us a lot of work done the line...</p>\n</blockquote>\n<p>I'm sure we can try the meta-programming before doing Hilbert spaces.</p>",
        "id": 207241370,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597744397
    },
    {
        "content": "<p>I agree! Do you know of a reference for metaprogramming? I wouldn't mind giving it a shot, but I'm a total beginner on that front...</p>",
        "id": 207260077,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597757956
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/learn.html#metaprogramming-and-tactic-writing\">https://leanprover-community.github.io/learn.html#metaprogramming-and-tactic-writing</a> contains a link to a very nice introductory tutorial (written by Patrick in fact).</p>",
        "id": 207265241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597760581
    },
    {
        "content": "<p>Nice -- thanks!</p>",
        "id": 207265718,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597760799
    },
    {
        "content": "<p>The tutorial videos from LFTCM2020 by Rob Lewis are great too: <a href=\"https://www.youtube.com/watch?v=o6oUjcE6Nz4&amp;list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2\">https://www.youtube.com/watch?v=o6oUjcE6Nz4&amp;list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"o6oUjcE6Nz4\" href=\"https://www.youtube.com/watch?v=o6oUjcE6Nz4&amp;list=PLlF-CfQhukNnq2kDCw2P_vI5AfXN7egP2\"><img src=\"https://i.ytimg.com/vi/o6oUjcE6Nz4/default.jpg\"></a></div>",
        "id": 207275536,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597765107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> Good point. Here's a PR that adds them to <code>learn.md</code>: <a href=\"https://github.com/leanprover-community/leanprover-community.github.io/pull/115\">https://github.com/leanprover-community/leanprover-community.github.io/pull/115</a></p>",
        "id": 207280998,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597767639
    },
    {
        "content": "<p>I've given this some more thought, and I think it's probably better to write at least the statements of the specialized lemmas by hand, especially for the real case.  What we want is substantially fancier than <code>to_additive</code>: for instance, we don't just want to replace <code>im</code>'s by zeroes, we want to get rid of them completely. This means that if the lemmas are autogenerated, there will be a lot of guesswork involved in figuring out what statement the metaprogram actually produced, which sounds much more painful than having to write them all by hand. However, it might be useful to write a tactic that would turn the proofs of these specialized statements into one-liners, for example by hunting down subexpressions involving <code>im</code>, <code>re</code>, etc, and calling the simplifier on them with a cleverly chosen set of lemmas (i.e. <code>mul_zero</code> and friends).</p>",
        "id": 207364745,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597804790
    },
    {
        "content": "<p>This might not need any actually metaprogramming, just an appropriate simp-set.</p>",
        "id": 207366094,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597806526
    },
    {
        "content": "<p>Even better!</p>",
        "id": 207366342,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1597806951
    },
    {
        "content": "<p>That's why I wrote \"and do something smarter about <code>im</code>\".</p>",
        "id": 207379891,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597824022
    },
    {
        "content": "<p>I've made some progress on the new typeclass, and I now have a first draft in PR <a href=\"https://github.com/leanprover-community/mathlib/issues/3934\">#3934</a>, that I have marked as work in progress for now. Basically I've defined the typeclass and added enough axioms to be able to reproduce most of the API in <code>complex.lean</code>. Towards the end of the file most of the original proofs just went through unchanged, which seems to bode well.</p>\n<p>I'd be very happy to have some feedback on this! In particular, if someone knows a good way to prove this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">thirty_seven</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">37</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of_real</span> <span class=\"mi\">37</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 207902263,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1598306223
    }
]
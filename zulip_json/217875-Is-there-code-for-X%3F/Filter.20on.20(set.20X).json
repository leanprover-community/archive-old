[
    {
        "content": "<p>I have a function defined on <code>set (X)</code> (or rather, on a filter <code>F</code> of neighborhoods on <code>X</code>), and want to take its limit when taking smaller and smaller neighborhoods. I think the filter along which I want to take its limit is something like </p>\n<p><span class=\"tex-error\">$$\\{T : set (set X) | T \\subset F \\and \\exists U \\in F, \\forall V \\in T, T \\subset U\\}.$$</span></p>\n<p>The motivation is as follows: I am formalizing the notion(s) of topological entropy. Classically, you take some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\epsilon &gt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, define a quantity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo stretchy=\"false\">(</mo><mi>ϵ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h(\\epsilon)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ϵ</span><span class=\"mclose\">)</span></span></span></span>, and take the limit <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\epsilon \\to 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">ϵ</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. I want to get a non-metric version of topological entropy; I thus take some uniformity set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, define a quantity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">h(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>, and now I want to take its limit when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>→</mo><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">U \\to \\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Δ</mi></mrow><annotation encoding=\"application/x-tex\">\\Delta</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord\">Δ</span></span></span></span> is the diagonal.</p>\n<p>Is it implemented in some way? I have found <code>order.filter.small_sets</code>, but it is much to large (it includes all subsets of a given <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>∈</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">U \\in F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7224em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, not only those which are in the initial filter).</p>",
        "id": 289436216,
        "sender_full_name": "Damien Thomine",
        "timestamp": 1657705757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513919\">@Damien Thomine</span>  I don't think what you wrote makes sense:<br>\n<span class=\"tex-error\">$$\\{T : set (set X) | T \\subset F \\and \\exists U \\in F, \\forall V \\in T, T \\subset U\\}.$$</span><br>\nFirst it's not obvious it defines a filter (I think it usually doen't). Second, it's weird that  T \\subset U doesn't depend on V. Third, no matter what you replace T \\subset U with, the condition is vacuously true when T is empty, so the empty set is in the filter and the filter must be trivial.</p>\n<p>I suppose you want to formalize what Wikipedia calls the <a href=\"https://en.wikipedia.org/wiki/Topological_entropy#Definition_of_Bowen_and_Dinaburg\">definition of Bowen and Dinaburg</a>. I think what you want is the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.at_top_bot</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">filter.at_bot</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">F.sets</span><span class=\"o\">)</span> <span class=\"c1\">-- defeq to `(filter.at_bot : filter {T // T ∈ F})`</span>\n</code></pre></div>\n<p>Could you simply use it? And I guess you intend to take <code>F</code> to be some <a href=\"https://leanprover-community.github.io/mathlib_docs/find/uniform_space.core.uniformity\">docs#uniform_space.core.uniformity</a>, right?</p>\n<p>I also thought a little about the more general definition that doesn't require a uniform structure, only a topology. It's a supremum over all open covers, and can be calculated as a limit over finer and finer open covers. To formalize the latter definition we need to order the open covers by refinement, which doesn't seem to exist in mathlib, but once we have that, I think we can simply use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_top\">docs#filter.at_top</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.at_bot\">docs#filter.at_bot</a>. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finpartition.has_le\">docs#finpartition.has_le</a> is the refinement relation for finite partitions, but covers are more general than partitions (which requires disjointness), not to mention the finiteness restriction. We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.grothendieck_topology.cover\">docs#category_theory.grothendieck_topology.cover</a> for Grothendieck topology (which is essentially ordered by refinement and used to construct <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.grothendieck_topology.sheafify\">docs#category_theory.grothendieck_topology.sheafify</a>) but not a more straightforward version for topological spaces. We also want the meet of finitely many open covers, which is given by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finpartition.has_inf\">docs#finpartition.has_inf</a> for finpartitions.</p>",
        "id": 289547838,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657769704
    },
    {
        "content": "<p>@Junyan Xu Thank you very much for your answer. You are right, my attempt at a definition is nonsensical. I am not used to working with filters, so I may not always make sense; my excuses.</p>\n<p>Your proposition (<code>filter.at_bot</code> on <code>(uniformity X).sets</code>) looks good. If I understand well, it is a filter on <code>{U : set(X x X) | U \\in uniformity X}</code>. In order to avoid annoying coercions, I would have liked a filter on <code>set (X x X)</code> (I think the image of the former under the inclusion <code>(uniformity X) -&gt; set (X x X)</code> ), but maybe this is enough. I'll try this tomorrow and confirm if it works.</p>\n<p>I choose the Bowen-Dinaburg version because it is convenient for applications, and I had in mind to actually compute the topologial entropy of a subshift of finite type.</p>\n<p>The uniform structure is not a problem as long as one works with compact spaces, because then the uniform structure is canonical. However, I wanted to define the topological entropy for invariant compact subsets of larger spaces, and these larger spaces have no reason to be compact, so their uniform structure is not determined by their topology. Of course the end result will depend only on the topology of the space rather than its uniform structure, but I have not yet found a good fix for that.</p>",
        "id": 289646703,
        "sender_full_name": "Damien Thomine",
        "timestamp": 1657831229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"513919\">@Damien Thomine</span> </p>\n<blockquote>\n<p>I choose the Bowen-Dinaburg version because it is convenient for applications, and I had in mind to actually compute the topologial entropy of a subshift of finite type.</p>\n</blockquote>\n<p>Your project sounds fun! </p>\n<blockquote>\n<p>However, I wanted to define the topological entropy for invariant compact subsets of larger spaces, and these larger spaces have no reason to be compact, so their uniform structure is not determined by their topology. </p>\n</blockquote>\n<p>I don't quite see what the problem is. Can't you just view these compact subsets as compact topological spaces, and use the topological entropy on these compact spaces, which has unique uniform structure? Or maybe you want to connect them somehow to the topological entropy on the larger spaces?</p>\n<p>Now, some update on the original question: after some more thoughts, I think I figured out the right definition for the filter on <code>set X</code> : it's simply <code>{T : set (set X)) | ∃ U ∈ F, ∀ V ⊆ U, V ∈ T}</code>, which I call <code>filter_of_directed</code>. This filter is larger than <code>filter.map coe filter.at_bot</code> (which I abbreviate as <code>map_at_bot</code>), so once you show your function has limit on <code>filter_of_directed</code>, then it also has limit on <code>map_at_bot</code>. </p>\n<p>In the code below I did it in maximal generality, generalizing <code>set X</code> to an arbitrary preorder and the filter on <code>X</code> to an arbitrary nonempty downward-directed subset.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.at_top_bot</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.pfilter</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">filter.pfilter</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">order.pfilter</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">F.sets</span><span class=\"o\">,</span>\n    <span class=\"n\">lower'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">F.sets_of_superset</span> <span class=\"n\">ha</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">nonempty'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">F.univ_sets</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">directed'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">order_dual.to_dual</span> <span class=\"o\">(</span><span class=\"n\">a.of_dual</span> <span class=\"bp\">∩</span> <span class=\"n\">b.of_dual</span><span class=\"o\">),</span>\n      <span class=\"n\">F.inter_sets</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">set.inter_subset_left</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">set.inter_subset_right</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.generate_singleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">filter.generate</span> <span class=\"o\">{</span><span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">filter.principal</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">t</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">filter.generate_sets.superset</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">filter.generate_sets.basic</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">filter.sets_iff_generate</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"n\">subset_rfl</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">F.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">directed_on</span> <span class=\"o\">(</span><span class=\"bp\">≥</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"c1\">-- hn and hd together are weaker than pfilter (two of three conditions)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">filter_of_directed</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"bp\">∈</span> <span class=\"n\">T</span><span class=\"o\">},</span>\n  <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">hn.some</span><span class=\"o\">,</span> <span class=\"n\">hn.some_mem</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">trivial</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">⟩</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"n\">hl</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">)⟩,</span>\n  <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">⟨</span><span class=\"n\">U₁</span><span class=\"o\">,</span> <span class=\"n\">hU₁</span><span class=\"o\">,</span> <span class=\"n\">hs₁</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">U₂</span><span class=\"o\">,</span> <span class=\"n\">hU₂</span><span class=\"o\">,</span> <span class=\"n\">hs₂</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">hl₁</span><span class=\"o\">,</span> <span class=\"n\">hl₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hd</span> <span class=\"n\">U₁</span> <span class=\"n\">hU₁</span> <span class=\"n\">U₂</span> <span class=\"n\">hU₂</span> <span class=\"k\">in</span>\n    <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">hV</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hs₁</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">hV.trans</span> <span class=\"n\">hl₁</span><span class=\"o\">),</span> <span class=\"n\">hs₂</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">hV.trans</span> <span class=\"n\">hl₂</span><span class=\"o\">)⟩⟩</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_filter_of_directed</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">T</span> <span class=\"bp\">∈</span> <span class=\"n\">filter_of_directed</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">set.Iic</span> <span class=\"n\">U</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter_of_directed_eq</span> <span class=\"o\">:</span>\n  <span class=\"n\">filter_of_directed</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">filter.principal</span> <span class=\"o\">(</span><span class=\"n\">set.Iic</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">filter.generate_singleton</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">filter.generate_Union</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">filter.sets_iff_generate</span><span class=\"o\">,</span> <span class=\"n\">rintro</span> <span class=\"n\">T</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_Union₂.1</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">mem_filter_of_directed</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span> <span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">he.superset</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">T</span> <span class=\"n\">hT</span><span class=\"o\">,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">hl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">mem_filter_of_directed</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span> <span class=\"n\">T</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">filter.generate_sets.superset</span> <span class=\"o\">(</span><span class=\"n\">filter.generate_sets.basic</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.mem_Union₂.2</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">directed_on_univ'</span> <span class=\"o\">:</span> <span class=\"n\">directed_on</span> <span class=\"o\">(</span><span class=\"bp\">≥</span><span class=\"o\">)</span> <span class=\"n\">F</span> <span class=\"bp\">↔</span> <span class=\"n\">directed_on</span> <span class=\"o\">(</span><span class=\"bp\">≥</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">directed_on_univ_iff</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hd</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">hd</span><span class=\"o\">⟩</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hd</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter_of_directed_eq_at_bot</span> <span class=\"o\">:</span>\n  <span class=\"n\">filter_of_directed</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ_nonempty</span> <span class=\"n\">_</span> <span class=\"n\">hn.to_subtype</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">directed_on_univ'.1</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"n\">filter.at_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter_of_directed_eq</span><span class=\"o\">,</span> <span class=\"n\">filter.at_bot</span><span class=\"o\">,</span> <span class=\"n\">infi_univ</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">map_at_bot</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">filter.map</span> <span class=\"n\">coe</span> <span class=\"o\">(</span><span class=\"n\">filter.at_bot</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kn\">include</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_map_at_bot</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">T</span> <span class=\"bp\">∈</span> <span class=\"n\">map_at_bot</span> <span class=\"n\">F</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"bp\">∈</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">set.Iic</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">F</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">map_at_bot</span><span class=\"o\">],</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">filter_of_directed_eq_at_bot</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">mem_filter_of_directed</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"o\">⟨</span><span class=\"n\">hVU</span><span class=\"o\">,</span> <span class=\"n\">hVF</span><span class=\"o\">⟩,</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hVF</span><span class=\"o\">⟩</span> <span class=\"n\">hVU</span><span class=\"o\">⟩,</span>\n    <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">⟩,</span> <span class=\"n\">trivial</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">hVF</span><span class=\"o\">⟩</span> <span class=\"n\">hVU</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">hVU</span><span class=\"o\">,</span> <span class=\"n\">hVF</span><span class=\"o\">⟩⟩⟩,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_at_bot_eq</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">map_at_bot</span> <span class=\"n\">F</span> <span class=\"bp\">=</span> <span class=\"n\">filter_of_directed</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span> <span class=\"bp\">⊓</span> <span class=\"n\">filter.principal</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter.mem_inf_principal</span><span class=\"o\">,</span> <span class=\"n\">mem_map_at_bot</span> <span class=\"n\">hn</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">mem_filter_of_directed</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">exists₂_congr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">forall_congr</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Let me tag <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> to see if any of these are already in mathlib.</p>",
        "id": 289690942,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657866581
    },
    {
        "content": "<p>Oh wait, I think <code>filter_of_directed</code> doesn't actually work, and we should stick to <code>map_at_bot</code>, which I proved is equal to <code>{T | ∃ U ∈ F, set.Iic U ∩ F ⊆ T}</code>, i.e. <code>{T : set (set X)) | ∃ U ∈ F, ∀ V ⊆ U, V ∈ F → V ∈ T}</code>.</p>",
        "id": 289692897,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1657868706
    }
]
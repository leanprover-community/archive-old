[
    {
        "content": "<p>I have the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">pointwise</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">set_of</span> <span class=\"n\">even</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I have tried writing <code>rw set.mem_smul_set.1 at h</code> but it doesn't work for some reason... any ideas?</p>",
        "id": 305295932,
        "sender_full_name": "Ben",
        "timestamp": 1666338023
    },
    {
        "content": "<p>That doesn't seem to have the necessary imports - can you share a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 305298538,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1666339212
    },
    {
        "content": "<p>ah didn't realise what it needed, have updated message</p>",
        "id": 305299745,
        "sender_full_name": "Ben",
        "timestamp": 1666339726
    },
    {
        "content": "<p>And are you sure that means what you think it does?</p>\n<blockquote>\n<p>Pointwise monoids (<code>set</code>, <code>finset</code>, <code>filter</code>) have derived pointwise actions of the form<br>\n<code>has_smul α β → has_smul α (set β)</code>. When <code>α</code> is <code>ℕ</code> or <code>ℤ</code>, this action conflicts with the<br>\nnat or int action coming from <code>set β</code> being a <code>monoid</code> or <code>div_inv_monoid</code>. For example,<br>\n<code>2 • {a, b}</code> can both be <code>{2 • a, 2 • b}</code> (pointwise action, pointwise repeated addition,<br>\n<code>set.has_smul_set</code>) and <code>{a + a, a + b, b + a, b + b}</code> (nat or int action, repeated pointwise<br>\naddition, <code>set.has_nsmul</code>).</p>\n<p>Because the pointwise action can easily be spelled out in such cases, we give higher priority to the<br>\nnat and int actions.</p>\n</blockquote>",
        "id": 305299808,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1666339751
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> suggests, as currently written your lemma is false:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.slim_check</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.parity</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">pointwise</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">even</span> <span class=\"n\">x</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">two_smul</span><span class=\"o\">,</span> <span class=\"n\">set.mem_add</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of</span><span class=\"o\">,</span> <span class=\"n\">even</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">slim_check</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 305319799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666347457
    },
    {
        "content": "<p>(note I swapped your <code>even</code> for the builtin <code>even</code> since lean knows how to use slim_check on the latter)</p>",
        "id": 305319841,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666347481
    },
    {
        "content": "<p>Here's a true version of your statement:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.slim_check</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">pointwise</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">even</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">n</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">has_smul</span> <span class=\"n\">ℕ</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set.has_smul_set</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"mi\">2</span> <span class=\"bp\">•</span> <span class=\"n\">set_of</span> <span class=\"n\">even</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"mi\">4</span> <span class=\"bp\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">set.mem_smul_set</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_left_comm</span><span class=\"o\">],</span>\n  <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 305320490,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1666347735
    }
]
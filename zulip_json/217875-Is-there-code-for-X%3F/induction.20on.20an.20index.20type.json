[
    {
        "content": "<p>I am trying to show <code>[is_domain (mv_power_series I R)]</code>, generalizing from <code>[is_domain (power_series R)]</code>. I am hoping to \"induct\" on the index type, proving the <code>R[X]</code> case first, using the proof we have already. Do we have code that helps facilitate this? I was thinking of something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.power_series.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mv_power_series</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"sd\">/-- The contravariant map between multivariate formal power series</span>\n<span class=\"sd\">induced by a map on the indeterminates. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">map_indeterminate</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">τ</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">τ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x.map_domain</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">indeterminate_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_empty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">subsingleton</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">E</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_sum</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">σₗ</span> <span class=\"n\">σ</span><span class=\"bp\">ᵣ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σₗ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span><span class=\"bp\">ᵣ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fg</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"o\">(</span><span class=\"n\">σₗ</span> <span class=\"bp\">⊕</span> <span class=\"n\">σ</span><span class=\"bp\">ᵣ</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">fg</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h_iso</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">τ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">≃</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">τ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n    <span class=\"n\">P</span> <span class=\"n\">σ</span> <span class=\"o\">(</span><span class=\"n\">f.map_indeterminate</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">mv_power_series</span>\n</code></pre></div>",
        "id": 269460754,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643222549
    },
    {
        "content": "<p>You already showed this fact for hahn_series right? So it seems a bit of a shame to have to give a separate proof here, I couldn't find the equivalence between hahn series on <code>\\sigma \\to \\N</code> and <code>mv_power_series \\sigma</code> (hopefully I'm not mathematically wrong and it doesnt exist xD) but there is the single variable case already <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hahn_series.to_power_series\">docs#hahn_series.to_power_series</a>. Do you think it'll be easier to just transfer this fact from a ring equivalence to hahn_series?</p>",
        "id": 269463528,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643223663
    },
    {
        "content": "<p>Maybe -- I did want it in <code>ring_theory.power_series.basic</code> so I could generalize <code>inv</code> from field to <code>division_ring</code> though.</p>",
        "id": 269463743,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643223737
    },
    {
        "content": "<p>You could always split the file? Mathematically if a fact about power series is a special case of one about hahn series I'd say there is a dependency there and we shouldn't reprove things</p>",
        "id": 269463993,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643223824
    },
    {
        "content": "<p>Alex, can you clarify something for me please? Do you mean we should prove it via the <code>hahn_series sigma X</code> and a compatible <code>\\sigma to nat</code>? (First showing that those are ring isomorphic?)</p>",
        "id": 269491858,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643235669
    },
    {
        "content": "<p>And in general refactor to make <code>power_series/basic</code> import <code>hahn_series</code>?</p>",
        "id": 269491882,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643235692
    },
    {
        "content": "<p>I was thinking of the following def, sans sorries + API</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">to_mv_power_series</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hahn_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃+*</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.coeff</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"gr\">sorry</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mv_power_series.coeff_mul</span><span class=\"o\">,</span> <span class=\"n\">power_series.coeff_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_coeff</span><span class=\"o\">,</span> <span class=\"n\">is_pwo_support</span><span class=\"o\">],</span>\n    <span class=\"n\">classical</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">mul_coeff</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"n\">sum_filter_ne_zero.symm.trans</span>\n      <span class=\"o\">((</span><span class=\"n\">sum_congr</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">sum_filter_ne_zero</span><span class=\"o\">),</span>\n    <span class=\"n\">ext</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.mem_antidiagonal</span><span class=\"o\">,</span> <span class=\"n\">and.congr_left_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_add_antidiagonal</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span>\n      <span class=\"n\">and_iff_left_iff_imp</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">mem_support</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">contrapose</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">decidable.or_iff_not_and_not</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h1</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 269499736,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643240281
    },
    {
        "content": "<p>Refactoring power_series/basic completely to depend on hahn_series would be quite a job right now (but might be worth it eventually),  however its almost 2000 lines so it definitely needs a haircut or two. (One obvious thing is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/power_series\">docs#power_series</a> is only defined on line 800 so could be split off but thats slightly orthogonal).<br>\nDomain for <code>power_series</code> is on line ~1300 of that file, so maybe stuff after that is more commutative algebra than just basic facts about power series, that could be a good point to split perhaps and have that part import hahn_series</p>",
        "id": 269500207,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643240576
    },
    {
        "content": "<p>Is this even true though? What if <code>\\sigma</code> is <code>complex</code>? It's not ordered, but one can still have a completely valid <code>mv_power_series complex R</code></p>",
        "id": 269500976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643241190
    },
    {
        "content": "<p>Maybe you need <code>fintype sigma</code> yeah? That certainly was the case for the inductive proof you proposed too I guess</p>",
        "id": 269502144,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643241811
    },
    {
        "content": "<p>If my sigma was <code>nat</code> or even <code>nat \\o+ nat</code> I think my proof would still work?</p>",
        "id": 269502281,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643241891
    },
    {
        "content": "<p>The induction you asked about above is summing subsingleton sigmas only so I don't think you can get nat from that</p>",
        "id": 269502442,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643241968
    },
    {
        "content": "<p>Or is it really only true for <code>fintype</code> in general?</p>",
        "id": 269502457,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643241983
    },
    {
        "content": "<p>I thought the summing singletons would be enough for any <code>encodable</code> type</p>",
        "id": 269502527,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1643242025
    },
    {
        "content": "<p>I don't think thats possible, your induction principle can prove things about arbitrarily large fintypes but not infinite types. I think the statement that mv_power_series are a domain when R is is true in complete generality, but I cant think of a good way to approach proving it</p>",
        "id": 269504060,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643243008
    },
    {
        "content": "<p>It seems to me that if you have countably many variables <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">X_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, ... then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>+</mo><msub><mi>X</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo></mrow><annotation encoding=\"application/x-tex\">X_1 + X_2 + \\cdots</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.313em;\"></span><span class=\"minner\">⋯</span></span></span></span> is not a Hahn series. (I checked the referenced paper by van der Hoeven and it seems to agree with this.) On the other hand it is an <code>mv_power_series</code>. I'm not sure whether this is a good thing or a bad thing--apparently SGA3 has an opinion about this which I'm trying to look up</p>",
        "id": 269504476,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643243280
    },
    {
        "content": "<p>Yeah my sorry above is unprovable (as they often are <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>) except in the fintype sigma case</p>",
        "id": 269504761,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643243456
    },
    {
        "content": "<p>I didn't find whatever I was supposed to be looking for in SGA3, but Wikipedia agrees with mathlib's definition of the power series ring at least.</p>",
        "id": 269510223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643244203
    },
    {
        "content": "<p>How about this argument to reduce to the case of finitely many variables. Suppose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>b</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">ab = 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">ab</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">a \\ne 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo mathvariant=\"normal\">≠</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">b \\ne 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">[</mo><mi>S</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[[S]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]]</span></span></span></span>. Pick a nonzero monomial of each of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>. Together they contain only finitely many variables. Send the rest of the variables to 0. Then we get nonzero elements of a power series ring in finitely many variables, which multiply to zero</p>",
        "id": 269510342,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643244287
    },
    {
        "content": "<p>I just got back to this and finally proved the fintype version. Some lemmas need breaking out but I'll try and PR it today</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">to_mv_power_series</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hahn_series</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃+*</span> <span class=\"n\">mv_power_series</span> <span class=\"n\">σ</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.coeff</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.partially_well_ordered_on.mono</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">change</span> <span class=\"n\">set.is_pwo</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">),</span> <span class=\"c1\">-- mono for is_pwo?</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.is_pwo_iff_exists_monotone_subseq</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">monotone</span><span class=\"o\">,</span> <span class=\"n\">finsupp.le_def</span><span class=\"o\">],</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span> <span class=\"bp\">⊆</span> <span class=\"n\">set.univ</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">↪</span><span class=\"n\">o</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span>\n      <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">this</span> <span class=\"n\">univ</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply'</span> <span class=\"n\">finset.induction</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">existsi</span> <span class=\"n\">rel_embedding.refl</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">hx</span> <span class=\"n\">ih</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">is_well_order.wf.is_wf</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">is_pwo.exists_monotone_subseq</span>\n        <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"n\">mo</span> <span class=\"o\">:</span> <span class=\"n\">σ</span> <span class=\"bp\">→₀</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">mo</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">g'</span><span class=\"o\">,</span> <span class=\"n\">hg'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.subset_univ</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">g'.trans</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_insert</span><span class=\"o\">,</span> <span class=\"n\">forall_eq_or_imp</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">,</span> <span class=\"n\">rel_embedding.coe_trans</span><span class=\"o\">],</span>\n      <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hg</span> <span class=\"o\">(</span><span class=\"n\">order_hom_class.mono</span> <span class=\"n\">g'</span> <span class=\"n\">hab</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hg'</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mv_power_series.coeff_mul</span><span class=\"o\">,</span> <span class=\"n\">power_series.coeff_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_coeff</span><span class=\"o\">,</span> <span class=\"n\">is_pwo_support</span><span class=\"o\">],</span>\n    <span class=\"n\">classical</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">*</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coeff</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">mul_coeff</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"n\">sum_filter_ne_zero.symm.trans</span>\n      <span class=\"o\">((</span><span class=\"n\">sum_congr</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">sum_filter_ne_zero</span><span class=\"o\">),</span>\n    <span class=\"n\">ext</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat.mem_antidiagonal</span><span class=\"o\">,</span> <span class=\"n\">and.congr_left_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_add_antidiagonal</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span>\n      <span class=\"n\">and_iff_left_iff_imp</span><span class=\"o\">,</span> <span class=\"n\">mem_filter</span><span class=\"o\">,</span> <span class=\"n\">mem_support</span><span class=\"o\">],</span>\n    <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"n\">contrapose</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">decidable.or_iff_not_and_not</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h1</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 270598067,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1643914051
    }
]
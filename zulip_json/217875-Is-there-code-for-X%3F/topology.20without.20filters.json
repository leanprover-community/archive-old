[
    {
        "content": "<p>I'm doing topology with the proofs I was taught, for pedagogical reasons. </p>\n<p>The conclusion of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/compact_iff_finite_subcover\">docs#compact_iff_finite_subcover</a> is <code>(∃ (t : finset ι), s ⊆ ⋃ (i : ι) (H : i ∈ t), U i)</code>, which often turns into <code>⊢ x ∈ ⋃ (i : ι) (H : i ∈ t), U i</code>. But my poor students cannot now <code>rw mem_bUnion_iff</code> because this is not a <code>bUnion</code> because <code>t</code> is a finset not a set :-(</p>\n<p>Would the topologists welcome a PR proving</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">compact_iff_finite_subcover'</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_compact</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n    <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">t.finite</span> <span class=\"bp\">∧</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">compact_iff_finite_subcover</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hs</span> <span class=\"n\">ι</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hsU</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hs</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hsU</span> <span class=\"k\">with</span> <span class=\"n\">F</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[(</span><span class=\"bp\">↑</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">finset.finite_to_set</span> <span class=\"n\">F</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hF</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">hs</span> <span class=\"n\">ι</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hsU</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hs</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hsU</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">hFfin</span><span class=\"o\">,</span> <span class=\"n\">hF</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">hFfin.to_finset</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">hF</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>? Sticking to sets makes the union stuff much easier for beginners (especially ones who have not been taught about <code>finset</code>s...)</p>\n<p>While I'm here, how come <code>set.mem_union</code>, <code>set.mem_Union</code> and <code>set.mem_sUnion</code> are all <code>iff</code>s, but <code>set.mem_bUnion</code> isn't, and it's <code>set.mem_bUnion_iff</code>?</p>",
        "id": 225766536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1612909117
    },
    {
        "content": "<p>Can you rewrite by <code>set.mem_Union</code> twice?</p>",
        "id": 225770010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1612911284
    },
    {
        "content": "<p>I don't care whether we have a version of <code>is_compact.elim*</code> with <code>set.finite</code> or not. I mean, I'd merge a PR with this lemma but I don't think that this is important. BTW, it seems that we don't have <code>{s : set α // finite s} ≃o finset α</code>. If someone will PR this equivalence (either an <code>equiv</code>, or an <code>order_iso</code>), then please add more corollaries like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.exists_finite_iff_finset\">docs#set.exists_finite_iff_finset</a>. I can think of <code>∃</code>, <code>∀</code>, <code>supr</code>, <code>infi</code>.</p>",
        "id": 228354749,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1614661887
    }
]
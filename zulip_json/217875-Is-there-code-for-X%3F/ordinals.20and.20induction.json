[
    {
        "content": "<p>I would like to make an induction over ordinals less than a given ordinal <code>o</code> (say, <code>o = cardinal.ord (aleph 1 : cardinal.{u})</code>). I can do an induction over all ordinals in <code>ordinal.{u}</code>, but this brings me to universe <code>u+1</code>, which is problematic for me. Instead of this, it would be more convenient to have a representative of <code>o</code> as a type in <code>Type u</code>, with a well-order, but I can't find an API around this. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> , do you have thoughts about a nice way to do this with current mathlib?</p>",
        "id": 273653022,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646146721
    },
    {
        "content": "<p>If <code>o : ordinal</code>, you can use <code>o.out.α</code> for a representative (using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient_out\">docs#quotient_out</a>), and there are a bunch of lemmas about this, like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.type_out\">docs#ordinal.type_out</a>.</p>",
        "id": 273654384,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646147218
    },
    {
        "content": "<p>Yes, but as far as I can tell there is no order relation instantiated by default on <code>o.out.α</code>. Maybe it's just a matter of registering them, but since they're not there I was wondering if I was missing another way.</p>",
        "id": 273655056,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646147465
    },
    {
        "content": "<p>Oh, I see. Yeah, most of the ordinal library works with an explicitly given order <code>r</code>, instead of <code>&lt;</code>.</p>",
        "id": 273655856,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646147833
    },
    {
        "content": "<p>Maybe it's just a matter of registering a few instances such as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_lt</span> <span class=\"o\">(</span><span class=\"n\">o.out.α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">o.out.r</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"n\">o.out.α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">has_lt.lt</span><span class=\"o\">,</span> <span class=\"n\">o.out.wo.wf</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>(probably building a linear order).</p>",
        "id": 273656392,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646148063
    },
    {
        "content": "<p>What do you want to do with it that you cannot use <code>r</code> directly?</p>",
        "id": 273656917,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1646148236
    },
    {
        "content": "<p>Maybe it's an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem. I want to show that the cardinality of the sigma-algebra generated by something is controlled in terms of the cardinality of the something. The standard proof is to construct the sets in thz sigma-algebra by transfinite induction, show that it stabilizes at omega_1, and obtain inductively the cardinality controls. The inductive construction would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_lt</span> <span class=\"o\">(</span><span class=\"n\">o.out.α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">o.out.r</span><span class=\"o\">⟩</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_well_founded</span> <span class=\"n\">o.out.α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">has_lt.lt</span><span class=\"o\">,</span> <span class=\"n\">o.out.wo.wf</span><span class=\"o\">⟩</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">wf</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}):</span> <span class=\"bp\">@</span><span class=\"n\">well_founded</span> <span class=\"n\">o.out.α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">o.out.wo.wf</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">ordinal.out_induction</span> <span class=\"o\">{</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">o.out.α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">o.out.α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">o.out.wo.wf.induction</span> <span class=\"n\">i</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">induction_generate_from</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">cardinal.ord</span> <span class=\"o\">(</span><span class=\"n\">aleph</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}))</span><span class=\"bp\">.</span><span class=\"n\">out.α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"bp\">//</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"n\">induction_generate_from</span> <span class=\"n\">j.1</span><span class=\"o\">)</span>\n      <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"bp\">//</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"n\">induction_generate_from</span> <span class=\"n\">j.1</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)))</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">j.2</span><span class=\"o\">]}</span>\n</code></pre></div>\n<p>This seems to work fine, but maybe there's a more idiomatic way.</p>",
        "id": 273658256,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646148704
    },
    {
        "content": "<p>What I did for the small object argument is work as long as possible with a <code>well_order_top</code>, defined <a href=\"https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/order/well_order_top.lean#L13\">here</a> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">well_order_top</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">complete_linear_order</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">wf_lt</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">((</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but then eventually you have to get your hands on one somehow, which I did <a href=\"https://github.com/rwbarton/lean-model-categories/blob/top-dev/src/wfs_top.lean#L30\">here</a> in basically the same way you have written above.</p>",
        "id": 273659945,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646149352
    },
    {
        "content": "<p>For your cardinality argument of course there is no point in having the flexibility to choose a well-ordered type other than <code>o.out</code> in the cardinality estimate.</p>",
        "id": 273660211,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646149454
    },
    {
        "content": "<p>There's a bunch of API that allows you to go back and forth between ordinals and a representative with the order type of a specific ordinal</p>",
        "id": 273683189,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646157540
    },
    {
        "content": "<p><code>typein</code> and <code>enum</code> will help you here</p>",
        "id": 273683243,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646157558
    },
    {
        "content": "<p>I'm personally opposed to making <code>&lt;</code> a synonym for <code>o.out.r</code> since that would muddle this distinction, I believe.</p>",
        "id": 273683672,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646157652
    },
    {
        "content": "<p>Oh and also, <code>o.out.wo</code> will give you the proof that <code>o.out.r</code> is a well order in <code>o.out.\\a</code></p>",
        "id": 273684939,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646158135
    },
    {
        "content": "<p>Yeah, having two different names for the same relation is not ideal.  But I'd rather avoid the <code>o.out.r</code> then, and use <code>&lt;</code> instead everywhere.</p>",
        "id": 273802937,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1646226445
    },
    {
        "content": "<p>I have tried to go following your advice of not making <code>&lt;</code> a synonym for <code>o.out.r</code>. I was afraid it would be very heavy to use, but in fact with a few notations it is completely reasonable. You can have a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/12422\">#12422</a> to check that I am using the library in the way it was intended.</p>",
        "id": 273932616,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646292044
    },
    {
        "content": "<p>Actually, I've thought about this for a bit, and particularly after seeing your code, I can definitely see the merit in the <code>&lt;</code> relation being a thing</p>",
        "id": 273986264,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646320288
    },
    {
        "content": "<p>I may have forgotten than <code>&lt;</code> was quite overloaded as is</p>",
        "id": 273986342,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646320315
    },
    {
        "content": "<p>(by design)</p>",
        "id": 273986428,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646320339
    },
    {
        "content": "<p>Since it seems like other people here agree with the usefulness of this, I'll start to work on this in a few hours</p>",
        "id": 274019047,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646333007
    },
    {
        "content": "<p>In my first transfinite induction in lean I wrote some lemmas like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lt_of_lt_of_le_unbundled</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_strict_total_order'</span> <span class=\"n\">α</span> <span class=\"n\">r</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span><span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>Is there an easier way? Otherwise I'd also plead for <code>&lt;</code> instead of <code>r</code></p>",
        "id": 274138681,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1646405298
    },
    {
        "content": "<p>I'm not sure what you mean. Are you trying to avoid <code>≤</code> and <code>&lt;</code>? If not, then you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_le.le.lt_of_not_le\">docs#has_le.le.lt_of_not_le</a>.</p>",
        "id": 274138958,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1646405411
    },
    {
        "content": "<p>My point is precisely that: I don't know if it possible to access the lemma you cited without making the <code>&lt;</code> = <code>r</code> synonym</p>",
        "id": 274139118,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1646405495
    },
    {
        "content": "<p>And do you actually need to avoid using <code>≤</code> and <code>&lt;</code>?</p>",
        "id": 274139302,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1646405569
    },
    {
        "content": "<p><code>is_strict_order</code> is barely ever used.</p>",
        "id": 274139332,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1646405585
    },
    {
        "content": "<p>No, but in the status quo, as discussed above, there is only <code>o.out.r</code></p>",
        "id": 274139526,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1646405646
    },
    {
        "content": "<p>I was only supporting the proposal of introducing this <code>has_lt</code></p>",
        "id": 274139708,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1646405727
    },
    {
        "content": "<p>Then you're in luck! Check out <a href=\"https://github.com/leanprover-community/mathlib/pull/12468\">#12468</a>.</p>",
        "id": 274291755,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1646553082
    },
    {
        "content": "<p>I'm trying to generalize this definition<br>\n<span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/273658256\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">induction_generate_from</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">cardinal.ord</span> <span class=\"o\">(</span><span class=\"n\">aleph</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}))</span><span class=\"bp\">.</span><span class=\"n\">out.α</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"bp\">//</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"n\">induction_generate_from</span> <span class=\"n\">j.1</span><span class=\"o\">)</span>\n      <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"bp\">//</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">},</span> <span class=\"n\">induction_generate_from</span> <span class=\"n\">j.1</span><span class=\"o\">)),</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)))</span>\n<span class=\"n\">using_well_founded</span> <span class=\"o\">{</span><span class=\"n\">dec_tac</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"o\">[</span><span class=\"n\">exact</span> <span class=\"n\">j.2</span><span class=\"o\">]}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>in order to define the <a href=\"https://en.wikipedia.org/wiki/Borel_hierarchy#Boldface_Borel_hierarchy\">Borel hierarchy</a>. I have noted that the union now ranges over the interval <code>Iio i</code> (which is exactly the same set as above). But I felt that it looked prettier to write the union above like <code>⋃ j (hij: j &lt; i), induction_generate_from j</code>. It seems that the proofs go through with this alternative formulation.</p>\n<p>Is there any benefit of using the intervals here?</p>",
        "id": 310499372,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668631857
    },
    {
        "content": "<p>By the way, my first attempt to formalize the definition of $\\Sigma^0_i$ and $\\Pi^0_i$ goes by defining the <em>pair</em> of both families, and then obtaining each pointset by using <code>fst</code> and <code>snd</code>. Is this the simplest approach?<br>\nAt least I couldn't find references to definitions by nested (“double”) recursion over an ordinal (or its <code>.out</code>, as in the previous discussion).</p>",
        "id": 310500302,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668632225
    },
    {
        "content": "<p>LaTeX: use double dollars $$ not single dollars (don't ask me why). Definitions: yes I would definitely define the pair. An attempt to do some kind of mutual inductive definition will just get translated internally into the pair definition, and mutual inductives are generally avoided in Lean 3.</p>",
        "id": 310503644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1668633646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327749\">@Pedro Sánchez Terraf</span> I'd recommend that you use an inductive definition like how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_space.generate_measurable/src\">src#measurable_space.generate_measurable</a> is done:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.ordinal</span>\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kn\">open</span> <span class=\"n\">cardinal</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">generate_from</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">basic</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">generate_from</span> <span class=\"n\">o</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"n\">generate_from</span> <span class=\"n\">o</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"n\">compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">o'</span> <span class=\"bp\">&lt;</span> <span class=\"n\">o</span><span class=\"o\">),</span> <span class=\"n\">generate_from</span> <span class=\"n\">o'</span> <span class=\"n\">u</span> <span class=\"bp\">→</span> <span class=\"n\">generate_from</span> <span class=\"n\">o</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span>\n<span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">o'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">o'</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">generate_from</span> <span class=\"o\">(</span><span class=\"n\">o'</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">generate_from</span> <span class=\"n\">o</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"c\">/-</span><span class=\"cm\"> The following version doesn't work:</span>\n<span class=\"cm\">| union : ∀ o (f : ℕ → set α), (∀ n, ∃ o' &lt; o, generate_from o' (f n)) → generate_from o (⋃ i, f i)</span>\n<span class=\"cm\">inductive type being declared can only be nested inside the parameters of other inductive types -/</span>\n</code></pre></div>",
        "id": 310513474,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668637866
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Thanks. My particular definition, as <code>generate_measurable_rec</code>, gets stuck at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, but then again I'm curious if there is any particular benefit of the approach taken in <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/measure_theory/card_measurable_space.lean\">card_measurable_space</a>.</p>",
        "id": 310525964,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668644606
    },
    {
        "content": "<p>But most importantly, I do not know how to write standard ordinal recursions that use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, successor, and limit cases.</p>",
        "id": 310526170,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668644757
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.limit_rec_on\">docs#ordinal.limit_rec_on</a></p>",
        "id": 310526253,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668644798
    },
    {
        "content": "<p>I'll experiment a bit and bring some prototype back. Thanks a lot</p>",
        "id": 310526413,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668644914
    },
    {
        "content": "<p>I think we should avoid ordinal.out.α when possible. It seems <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> uses it because he wants to have something in <code>Type u</code> rather than <code>ordinal.{u}</code> which is in <code>Type (u+1)</code>. But I don't quite see why he needs that in the proof. It seems the only crucial fact is that a N-indexed sequence in omega_1 has an upper bound in omega_1, or in other words, omega is not cofinal with omega_1. I don't see how the universe is crucial here. (Update: another crucial fact is that the unions are taken over an initial segment of omega_1, but those also all have cardinality bounded by aleph_0.) </p>\n<p>Notice that my definition doesn't use well-foundedness of the ordinals, and I think that will be used when you prove (by induction) that it works as expected (e.g. that <code>generate_from s o</code> consists of exactly those sets obtained from <code>generate_from s o'</code> for <code>o' &lt; o</code>).</p>",
        "id": 310526790,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668645104
    },
    {
        "content": "<p>My definition above is just because I could work out the proof with it :-). If you find another more idiomatic way in terms of an inductive definition, this would probably be better. The reason I used <code>(aleph 1 : cardinal.{u})).out.α</code> is because I wanted a well-order of size aleph_1, i.e., I didn't want to do the induction over all ordinals just because we know we can stop at aleph_1 and this will already give all measurable sets. And also for universe reasons: at the end of the day if everything is in universe <code>u</code> you want bounds in terms of cardinals in the same universe, not the next one (although it would probably be possible to downlift things from a higher universe).</p>",
        "id": 310561315,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1668672580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310561315\">said</a>:</p>\n<blockquote>\n<p>at the end of the day if everything is in universe <code>u</code> you want bounds in terms of cardinals in the same universe, not the next one (although it would probably be possible to downlift things from a higher universe).</p>\n</blockquote>\n<p>Indeed, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of the very first universe should suffice foundationally speaking (but I took the trouble to try that and check that it fails with the proofs as they stand). Thanks!</p>",
        "id": 310594689,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1668686245
    },
    {
        "content": "<p>Indeed I think even though you can show <code>countable {o' // o &lt; o}</code> you would still get a <code>cardinal.{u+1}</code> by default; you can do computation in universe <code>u+1</code> but need to downlift it using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.lift_le\">docs#cardinal.lift_le</a> in the end. However, we certainly want the Borel hierarchy be indexed by ordinals (≤ omega_1) rather than <code>omega_1.out.α</code>; once we have the Borel hierarchy and prove that it stabilizes, we may go back to refactor and hopefully golf the cardinality proof.</p>",
        "id": 310698299,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668718783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310526790\">said</a>:</p>\n<blockquote>\n<p>I think we should avoid ordinal.out.α when possible. </p>\n</blockquote>\n<p>You mean in public-facing API? I can see your point if so, but otherwise hard disagree. The fact that each <code>ordinal.{u}</code> corresponds to a well-ordered type in <code>Type u</code> is a crucial fact. Most notably, we can take indexed suprema of <code>ordinal.{u}</code> when the indexing type is in universe <code>u</code>, but not when it's any larger. By bumping up the universes, it means that we have to move back and forth between the <code>Iio x ≅o x.out.α</code> order isomorphism, which is not ideal and really defeats the purpose.</p>\n<p>Maybe part of why it seems so unnatural is due to the odd notation. This could be easily fixed by introducing something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ordinal.to_type</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"n\">o.out.α</span>\n</code></pre></div>\n<p>We can then add a doc comment explaining how this represents a canonical type with the given order type.</p>",
        "id": 323317081,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1674583045
    },
    {
        "content": "<p>Regarding the public API, I'm reminded that we already have a way around this issue. Instead of using the ordinal supremum, one can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.bsup\">docs#ordinal.bsup</a>. If we want to do even more general stuff, like index a family of sets by ordinals, we can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.family_of_bfamily\">docs#ordinal.family_of_bfamily</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.bfamily_of_family\">docs#ordinal.bfamily_of_family</a> to easily convert between the <code>out.α</code> indexing and the natural indexing.</p>\n<p>I'm not a huge fan of this because it introduces a lot of redundancy into the API (where many theorems have to be stated in terms of either supremum), but that's the best we currently got. Besides, we already get by with this sort of redundancy elsewhere (see all the kinds of set unions in mathlib).</p>",
        "id": 323317924,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1674583255
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 323318258,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1674583347
    },
    {
        "content": "<p>Thinking about it further. Maybe both introducing <code>ordinal.to_type</code> and making better use of the <code>ordinal.bsup</code> API are good ideas.</p>",
        "id": 323319786,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1674583773
    },
    {
        "content": "<p>(Sorry to anyone reading in real time for all the edits, I guess I'm only now really solidifying my ideas here)</p>",
        "id": 323322468,
        "sender_full_name": "Violeta Hernández",
        "timestamp": 1674584459
    },
    {
        "content": "<p>I have no objection to using <code>x.out.α</code> in proofs if it makes things shorter; your golf in <a href=\"https://github.com/leanprover-community/mathlib/pull/17972\">#17972</a> looks great to me. However, in this case we want to define a function with all ordinals as its domain; it would be unnatural to define the hierarchy on <code>ω₁.out.α</code> since you would need to transfer by <code>Iio ω₁ ≅o ω₁.out.α</code> if you want to refer to e.g. the 1st level, or the ωth level in the hierarchy. In particular, we want <code>⋃ j &lt; i</code> in the statement rather than <code>⋃ j : i.out.α</code>. Even if you can get away with <code>ω₁.out.α</code> here because the Borel hierarchy stabilizes at ω₁, it wouldn't be possible to do so when defining but IMO that's unnatural; what if we want to define <a href=\"https://en.wikipedia.org/wiki/Derived_set_(mathematics)#Cantor%E2%80%93Bendixson_rank\">derived sets</a> (which stablizes eventually but at arbitrarily large ordinal), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.aleph\">docs#cardinal.aleph</a>, or the von Neumann hierarchy (which doesn't stabilize).</p>",
        "id": 323335799,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1674588205
    }
]
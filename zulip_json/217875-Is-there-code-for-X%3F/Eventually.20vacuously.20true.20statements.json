[
    {
        "content": "<p>Is there nice ways to lift <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">¬</mi><mi>p</mi><mi>x</mi><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>p</mi><mi>x</mi><mo>→</mo><mi>q</mi><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\forall x, \\lnot p x) \\implies (\\forall x, p x \\to q x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">¬</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> for any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi></mrow><annotation encoding=\"application/x-tex\">p, q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span></span></span></span> propositions for eventually filters, MWE:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.specific_limits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eventually_false_of_not</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think I can do it by brute-forcing stuff, mostly by proving that <code>{ x | p x } \\notin l</code> as <code>{ x | not(p(x)) } \\in l</code> (otherwise, intersection would be empty, and the empty set would be in the filter), </p>\n<p>Therefore, <code>{ x | p x → q x } = univ</code>, which should complete the proof. But I'm looking for more idiomatic ways to perform this proof rather than spamming definitions.</p>",
        "id": 249878017,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1629305311
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.eventually.mono\">docs#filter.eventually.mono</a> and then you just have to give the pointwise proof</p>",
        "id": 249880231,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1629306224
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Eventually.20vacuously.20true.20statements/near/249880231\">said</a>:</p>\n<blockquote>\n<p>You can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.eventually.mono\">docs#filter.eventually.mono</a> and then you just have to give the pointwise proof</p>\n</blockquote>\n<p>You're definitely <a href=\"https://steins-gate.fandom.com/wiki/Itaru_Hashida\">super hacka</a> :-)</p>",
        "id": 249880502,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1629306330
    },
    {
        "content": "<p>For completeness:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">eventually_false_of_not</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hnp</span><span class=\"o\">:</span> <span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"bp\">∀ᶠ</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">eventually.mono</span> <span class=\"n\">hnp</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hnpx</span> <span class=\"n\">hpx</span><span class=\"o\">,</span> <span class=\"n\">absurd</span> <span class=\"n\">hpx</span> <span class=\"n\">hnpx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 249881445,
        "sender_full_name": "Ryan Lahfa",
        "timestamp": 1629306712
    }
]
[
    {
        "content": "<p>Is there something along the lines of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span>  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>? (One could, of course, do this more generally, with <code>fin n.succ</code> and <code>ℕ</code> replaced by arbitrary types with suitable (pre)order structures.)</p>",
        "id": 298770188,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663161921
    },
    {
        "content": "<p>Can you recycle <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.of_fn\">docs#list.of_fn</a> and combine it with one of the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.merge\">docs#list.merge</a> like functions?</p>",
        "id": 298770733,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1663162107
    },
    {
        "content": "<p>Ah, do you actually want the permutation, or sorting it would be enough?</p>",
        "id": 298770909,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1663162170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> Yes, there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tuple.sort\">docs#tuple.sort</a> and the associated lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tuple.monotone_sort\">docs#tuple.monotone_sort</a></p>",
        "id": 298777239,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663164209
    },
    {
        "content": "<p>If you search \"perm monotone\" in the chat you find a couple of relevant threads, including <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Sorting.20by.20function.20value/near/291074607\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Sorting.20by.20function.20value/near/291074607</a></p>",
        "id": 298777267,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663164216
    },
    {
        "content": "<p>But that required an injection, so it doesn't immediately apply here, in fact the proof I gave there also works for <code>strict_mono</code></p>",
        "id": 298777745,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663164356
    },
    {
        "content": "<p>Oh and you are permuting the domain! So that is also different</p>",
        "id": 298779296,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663164855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> Thanks, that should do what I want.</p>",
        "id": 298780336,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663165189
    },
    {
        "content": "<p>Wow, I don't know how I managed to miss Heather's message completely, sorry!</p>",
        "id": 298780661,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663165286
    },
    {
        "content": "<p>Now the follow-up question: Do we have some kind of \"bubble sort principle\"?. I.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 298781324,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663165503
    },
    {
        "content": "<p>Related to a proof attempt: I wold have assumed that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">is_well_founded</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>works, but it doesn't. How do I easily obtain that instance? (It should follow from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.lex.is_well_founded\">docs#prod.lex.is_well_founded</a> by induction, but this looks a bit complicated to carry out.)</p>",
        "id": 298827942,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663180589
    },
    {
        "content": "<p>Another question:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">preorder.lift</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>complains <code>failed to synthesize type class instance for preorder (lex (fin n.succ → ℕ))</code>, even though</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span>\n</code></pre></div>\n<p>works. What am I missing here?</p>",
        "id": 298828738,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663180837
    },
    {
        "content": "<p>I don't know the root cause, but by turning on</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.type_context.is_def_eq_detail</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>and staring at the output I figure its some issue with universes. Then it turns out the following (specifying universe levels to be 0 0) fixes it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">preorder.lift.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 298833836,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663182558
    },
    {
        "content": "<p>OK, thanks.</p>",
        "id": 298834073,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663182639
    },
    {
        "content": "<p>Here is an idea for the proof of the \"bubble sort principle\".<br>\nIf  <code>i &lt; j</code> and <code>g j &lt; g i</code>. then <code>g ∘ equiv.swap i j</code> is lexicorgaphically strictly smaller than <code>g</code>. If <code>f</code> is not yet increasing, we can move to a lexicographically smaller <code>f ∘ σ</code> in this way. This cannot go on forever, since the lexicorgraphic order is a well-order, and when it stops, the last <code>f ∘ σ</code> must be increasing.<br>\nBut I'm having difficulties in translating this to Lean. I'd like to state the principle behind this somewhat like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">well_order_bot</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">well_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊥</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">⊥</span>\n</code></pre></div>\n<p>but there is no bundled <code>well_order</code> structure, and trying something like <code>[has_lt α] [is_well_order α (&lt;)]</code> then runs into the problem that <code>has_bot α</code> cannot be deduced (which should follow from the well-ordering and the existence of <code>a</code>). Any ideas? (Of course, one needs the well-ordering on <code>lex (fin n.succ → ℕ)</code> first to apply this...)</p>",
        "id": 298835261,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663183058
    },
    {
        "content": "<p>OK, here is a version of <code>well_order_bot</code> that seems to work.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">well_order_bot</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"o\">((</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">bot</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">well_founded.induction</span> <span class=\"n\">hwf</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">ih'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hbot</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">bot</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hbot</span> <span class=\"bp\">▸</span> <span class=\"n\">hP</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy₁</span><span class=\"o\">,</span> <span class=\"n\">hy₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">x</span> <span class=\"n\">hbot</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ih'</span> <span class=\"n\">y</span> <span class=\"n\">hy₁</span> <span class=\"n\">hy₂</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 298841363,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663185356
    },
    {
        "content": "<p>Hopefully someone like <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> can come and tell us how to do this properly, but here is a proof of well foundedness for lex</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.sign</span>\n<span class=\"bp\">.</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">logic</span> <span class=\"o\">{</span><span class=\"n\">Plt0</span> <span class=\"n\">Peq0</span> <span class=\"n\">Peq</span> <span class=\"n\">Peqe</span> <span class=\"n\">Plt</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hhh</span> <span class=\"o\">:</span> <span class=\"n\">Peq</span> <span class=\"bp\">↔</span> <span class=\"n\">Peqe</span> <span class=\"bp\">∧</span> <span class=\"n\">Peq0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">Plt0</span> <span class=\"bp\">∨</span> <span class=\"n\">Peq0</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">Peqe</span> <span class=\"bp\">∨</span> <span class=\"n\">Plt</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">Peq</span> <span class=\"bp\">∨</span> <span class=\"n\">Plt0</span> <span class=\"bp\">∨</span> <span class=\"n\">Peq0</span> <span class=\"bp\">∧</span> <span class=\"n\">Plt</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"bp\">!</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prod.lex.le_iff'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a.1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b.1</span> <span class=\"bp\">∨</span> <span class=\"n\">a.1</span> <span class=\"bp\">=</span> <span class=\"n\">b.1</span> <span class=\"bp\">∧</span> <span class=\"n\">a.2</span> <span class=\"bp\">≤</span> <span class=\"n\">b.2</span> <span class=\"o\">:=</span> <span class=\"n\">prod.lex_def</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pi.lex.lt_iff</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n<span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pi.lex.le_iff</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n<span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lex_succ_order_equiv_prod</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">≃</span><span class=\"n\">o</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×ₗ</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_rel_iff'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">equiv.pi_fin_succ_apply</span><span class=\"o\">,</span> <span class=\"n\">equiv.to_fun_as_coe</span><span class=\"o\">,</span> <span class=\"n\">equiv.coe_fn_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">prod.lex.le_iff'</span><span class=\"o\">,</span> <span class=\"n\">pi.lex.le_iff</span><span class=\"o\">,</span> <span class=\"n\">pi.lex.le_iff</span><span class=\"o\">,</span> <span class=\"n\">fin.exists_fin_succ</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin.forall_fin_succ</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">,</span> <span class=\"n\">fin.not_lt_zero</span><span class=\"o\">,</span> <span class=\"n\">is_empty.forall_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">implies_true_iff</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">fin.succ_pos</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">,</span> <span class=\"n\">fin.succ_lt_succ_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">exists_and_distrib_left</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">logic</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">and_comm</span><span class=\"o\">,</span> <span class=\"n\">function.funext_iff</span><span class=\"o\">,</span> <span class=\"n\">function.funext_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">fin.forall_fin_succ</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">equiv.pi_fin_succ</span> <span class=\"n\">n</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">is_well_founded</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">unique</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">pi.unique_of_is_empty</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">unique.subsingleton</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">well_founded.intro</span><span class=\"o\">,</span> <span class=\"n\">intro</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">revert</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">change</span> <span class=\"bp\">¬</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">not_lt</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">eq.le</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">subsingleton.elim</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">order_embedding.well_founded</span> <span class=\"o\">(</span><span class=\"n\">lex_succ_order_equiv_prod</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_order_embedding</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">prod.lex.is_well_founded.wf</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">is_well_order.to_is_well_founded</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_assumption</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 298852578,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663189933
    },
    {
        "content": "<p>Thanks! I'll look at it tomorrow.<br>\nThis should be a good addition to mathlib (with <code>ℕ</code> in the codomain replaced by an arbitrary well-founded order).</p>",
        "id": 298854653,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663190770
    },
    {
        "content": "<p>That should be generalisable to two well orders (and dependent functions). Indeed this is basically ordinal multiplication.</p>",
        "id": 298854982,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663190942
    },
    {
        "content": "<p>I've made one generalization as an edit, I'll PR it at somepoint to this week, unless it turns out there is an easier way</p>",
        "id": 298855013,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663190958
    },
    {
        "content": "<p>Indeed the dependent case should be easy</p>",
        "id": 298855038,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663190972
    },
    {
        "content": "<p>But making the domain not fin n scares me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 298855048,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663190985
    },
    {
        "content": "<p>Actually <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.pi_fin_succ\">docs#equiv.pi_fin_succ</a> is only for non-dependent functions it seems, so I'll leave it like this for now</p>",
        "id": 298855678,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1663191284
    },
    {
        "content": "<p>But <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.pi_fin_succ_above_equiv\">docs#equiv.pi_fin_succ_above_equiv</a> isn't...</p>",
        "id": 298857940,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1663192385
    },
    {
        "content": "<p>With the help of <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>'s code from above, I have now managed to reduce the proof of <code>bubble_sort</code> to the following lemma.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">tuple.unique_monotone</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hfσ</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>I find this surprisingly hard to prove.</p>",
        "id": 299043974,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663272544
    },
    {
        "content": "<p>One attempt is to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.eq_of_perm_of_sorted\">docs#list.eq_of_perm_of_sorted</a>. This would work if one had proofs of (for <code>f : fin n → ℕ</code> and <code>σ : equiv.perm (fin n)</code>) <code>list.of_fn (f ∘ σ) ~ list.of_fn f</code> and <code>monotone f → (list.of_fn f).sorted (≤)</code>. But these don't look straightforward either (in particular the first).</p>",
        "id": 299044301,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663272703
    },
    {
        "content": "<p>Ideas?</p>",
        "id": 299044518,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663272786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> Is this true, or do you maybe need strict monotonicity?</p>",
        "id": 299045396,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663273168
    },
    {
        "content": "<p>This is true. If you permute a weakly increasing sequence so that the result is again weakly increasing, then both are the same.</p>",
        "id": 299045549,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663273237
    },
    {
        "content": "<p>(I don't claim that <code>σ</code> must be the identity.)</p>",
        "id": 299045584,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663273257
    },
    {
        "content": "<p>I think this is true, and the reason you don't strict monotonicity is because it's written <code>f o s = f</code> as opposed to <code>s = id</code></p>",
        "id": 299045586,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663273260
    },
    {
        "content": "<p>an induction argument would be quite easy if you can prove that wlog s 0 = 0, which is a bit annoying</p>",
        "id": 299045649,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663273301
    },
    {
        "content": "<p>You can fairly easily show that <code>f (s 0) = f 0</code>. It is not clear to me that this helps a lot.</p>",
        "id": 299045790,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663273363
    },
    {
        "content": "<p>Aside: I was trying to define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">function.count</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">set.preimage</span> <span class=\"n\">f</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">to_finset.card</span>\n</code></pre></div>\n<p>but got the complaint <code>failed to synthesize type class instance for fintype ↥(f ⁻¹' {x})</code> (and adding <code>[decidable_pred (λ a, f a = x)]</code> to the arguments does not help...). How to do that in a way Lean understands?<br>\n(The idea being that <code>f ∘ σ</code> and <code>f</code> take a given value the same number of times...)</p>",
        "id": 299046382,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663273643
    },
    {
        "content": "<p><code>decidable_pred (∈ f ⁻¹' {x})</code></p>",
        "id": 299046610,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663273742
    },
    {
        "content": "<p>Is this not defeq?</p>",
        "id": 299046678,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663273785
    },
    {
        "content": "<p>Typeclass inference doesn't know about defeq. Luckily, otherwise type synonyms wouldn't work!</p>",
        "id": 299046897,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663273884
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299045790\">said</a>:</p>\n<blockquote>\n<p>You can fairly easily show that <code>f (s 0) = f 0</code>. It is not clear to me that this helps a lot.</p>\n</blockquote>\n<p>my idea is that if we can assume assume the _stronger_ <code>s 0 = 0</code> in the theorem statement, it lets us induct easier using a function of the form <code>λ x, (σ x.succ).pred sorry</code></p>",
        "id": 299048941,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663274797
    },
    {
        "content": "<p>this doesn't work though, sadly</p>",
        "id": 299048962,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663274812
    },
    {
        "content": "<p>because we then end up requiring that that function maps zero to zero</p>",
        "id": 299049017,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663274840
    },
    {
        "content": "<p>and so this exact method only proves that s = id, which isn't always true</p>",
        "id": 299049051,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663274858
    },
    {
        "content": "<p>I'm missing a specification lemma for <code>list.sorted</code>, i.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.sorted_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.sorted</span> <span class=\"n\">r</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">l.length</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">l.nth_le</span> <span class=\"n\">i.1</span> <span class=\"n\">i.2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l.nth_le</span> <span class=\"n\">j.1</span> <span class=\"n\">j.2</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Versions of the <code>→</code> direction are there (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.sorted.rel_nth_le_of_le\">docs#list.sorted.rel_nth_le_of_le</a>), but the converse seems to be missing.<br>\nHow do you prove that a list is sorted? (This came up while attempting the second missing ingredient above.)</p>",
        "id": 299049967,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663275286
    },
    {
        "content": "<p>sorted is defeq to <code>pairwise</code>, so maybe look there</p>",
        "id": 299050524,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663275556
    },
    {
        "content": "<p>For the first, something like the following would be helpful.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.perm_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.length</span> <span class=\"bp\">=</span> <span class=\"n\">l'.length</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">~</span> <span class=\"n\">l'</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">l.length</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">l.length</span><span class=\"o\">,</span> <span class=\"n\">l.nth_le</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">l'.nth_le</span> <span class=\"n\">i</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 299050665,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663275619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299050524\">said</a>:</p>\n<blockquote>\n<p>sorted is defeq to <code>pairwise</code>, so maybe look there</p>\n</blockquote>\n<p>Possibly <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.pairwise_iff\">docs#list.pairwise_iff</a>, but it looks a bit unwieldy.</p>",
        "id": 299051218,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663275902
    },
    {
        "content": "<p>I think I nearly have the first, I'm not sure how we don't have this yet:</p>\n<p><code>lemma of_fn_eq_map : list.of_fn f = list.map f (list.fin_range n) :=</code></p>",
        "id": 299052139,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663276296
    },
    {
        "content": "<p>(for the record, I  proved it already, don't bother reproving it)</p>",
        "id": 299052159,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663276306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299052139\">said</a>:</p>\n<blockquote>\n<p>I think I nearly have the first</p>\n</blockquote>\n<p>In my counting, the first is <code>list.of_fn (f ∘ σ) ~ list.of_fn f</code>, which one should be able to reduce to <code>list.perm_iff</code> above. Is that what you mean, or are you talking about <code>list.sorted_iff</code>?</p>",
        "id": 299054269,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663277144
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.abel_ruffini</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">perm.map_congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l₁.map</span> <span class=\"n\">f</span> <span class=\"bp\">~</span> <span class=\"n\">l₂.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">perm.swap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list.perm.trans</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁₂</span> <span class=\"n\">h₂₃</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h₁₂.trans</span> <span class=\"n\">h₂₃</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">list.of_fn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"n\">list.of_fn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">of_fn_eq_map</span><span class=\"o\">,</span> <span class=\"n\">of_fn_eq_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">map_map</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">perm.map_congr</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">perm_ext</span> <span class=\"o\">((</span><span class=\"n\">nodup_fin_range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">σ.injective</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">nodup_fin_range</span> <span class=\"n\">n</span><span class=\"o\">],</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_map</span><span class=\"o\">,</span> <span class=\"n\">mem_fin_range</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">iff_true</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">σ.surjective</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>\n<p>(ignore the imports, I'm lazy)</p>",
        "id": 299055108,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663277492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> thanks!<br>\nI've come up with a (fairly direct) pen-and-paper proof of <code>tuple.unique_monotone</code>, which I'll try to formalize. Let's see which approach gives the shorter proof <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 299116820,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663318113
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.abel_ruffini</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">perm.map_congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l₁.map</span> <span class=\"n\">f</span> <span class=\"bp\">~</span> <span class=\"n\">l₂.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">perm.swap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">list.perm.trans</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁₂</span> <span class=\"n\">h₂₃</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h₁₂.trans</span> <span class=\"n\">h₂₃</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">_root_.equiv.perm.of_fn_comp_perm</span> <span class=\"o\">:</span> <span class=\"n\">list.of_fn</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">~</span> <span class=\"n\">list.of_fn</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">of_fn_eq_map</span><span class=\"o\">,</span> <span class=\"n\">of_fn_eq_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">map_map</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">perm.map_congr</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">perm_ext</span> <span class=\"o\">((</span><span class=\"n\">nodup_fin_range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">σ.injective</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">nodup_fin_range</span> <span class=\"n\">n</span><span class=\"o\">],</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_map</span><span class=\"o\">,</span> <span class=\"n\">mem_fin_range</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">iff_true</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">σ.surjective</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">_root_.monotone.of_fn_sorted</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">list.of_fn</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sorted</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sorted</span><span class=\"o\">,</span> <span class=\"n\">pairwise_iff_nth_le</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hj</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nth_le_of_fn'</span><span class=\"o\">,</span> <span class=\"n\">nth_le_of_fn'</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hij.le</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">tuple.unique_monotone</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hfσ</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">of_fn_injective</span> <span class=\"bp\">$</span> <span class=\"n\">eq_of_perm_of_sorted</span> <span class=\"o\">(</span><span class=\"n\">σ.of_fn_comp_perm</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">hfσ.of_fn_sorted</span> <span class=\"n\">hf.of_fn_sorted</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>",
        "id": 299124142,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663320954
    },
    {
        "content": "<p>here is a full proof modulo golfing imports</p>",
        "id": 299124217,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663320966
    },
    {
        "content": "<p>I'd say the <code>perm</code> and the <code>monotone</code> one should definitely be theorems regardless, so in some ways this is a \"8 line proof\"</p>",
        "id": 299124381,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663321036
    },
    {
        "content": "<p>(bonus golfing question: it'd be really nice to make <code>perm.map_congr</code> using the equation compiler; does anyone know how to golf it to that? I tried and couldn't get it to work)</p>",
        "id": 299124773,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663321185
    },
    {
        "content": "<p>Nice! I doubt I can get my proof down to comparable length (it is not even finished and already quite a bit longer, though certainly golfable to some extent).</p>",
        "id": 299134721,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663325264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> Would you like to PR the four lemmas?</p>",
        "id": 299134789,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663325285
    },
    {
        "content": "<p>I'm happy for you to PR them, but if you don't want to I'll PR them later today</p>",
        "id": 299134955,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663325385
    },
    {
        "content": "<p>Here is my proof of the \"bubble sort principle\", based on the above (including the <code>well_founded</code> instance for the lexicographic order provided by <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>). Some golfing is certainly possible...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">tuple.unique_sort</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">τ</span> <span class=\"o\">:=</span> <span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">σ'</span> <span class=\"o\">:=</span> <span class=\"n\">τ</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">σ</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">τ</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">σ'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function.comp_app</span><span class=\"o\">,</span> <span class=\"n\">equiv.perm.coe_mul</span><span class=\"o\">,</span> <span class=\"n\">equiv.perm.apply_inv_self</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">tuple.unique_monotone</span> <span class=\"o\">(</span><span class=\"n\">tuple.monotone_sort</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">h'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">antitone_pair_of_not_sorted</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">monotone</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">eq_or_lt_of_le</span> <span class=\"n\">hij</span> <span class=\"k\">with</span> <span class=\"n\">heq</span> <span class=\"n\">hlt</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">heq</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hf</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hlt</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">tuple.unique_sort</span> <span class=\"n\">hm</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lex_desc</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">to_lex</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">has_lt.lt</span><span class=\"o\">,</span> <span class=\"n\">pi.lex</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">hik</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">equiv.swap_apply_of_ne_of_ne</span> <span class=\"o\">(</span><span class=\"n\">ne_of_lt</span> <span class=\"n\">hik</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ne_of_lt</span> <span class=\"bp\">$</span> <span class=\"n\">hik.trans</span> <span class=\"n\">h₁</span><span class=\"o\">)],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">equiv.swap_apply_left</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">well_founded_bot</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">bot</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">P</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">well_founded.induction</span> <span class=\"n\">hwf</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">ih'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">hbot</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">bot</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hbot</span> <span class=\"bp\">▸</span> <span class=\"n\">hP</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy₁</span><span class=\"o\">,</span> <span class=\"n\">hy₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ih</span> <span class=\"n\">x</span> <span class=\"n\">hbot</span> <span class=\"n\">hP</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ih'</span> <span class=\"n\">y</span> <span class=\"n\">hy₁</span> <span class=\"n\">hy₂</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bubble_sort</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">g</span> <span class=\"n\">j</span> <span class=\"bp\">&lt;</span> <span class=\"n\">g</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">equiv.swap</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">Of</span> <span class=\"o\">:=</span> <span class=\"n\">set.range</span> <span class=\"n\">φ</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">φ'</span> <span class=\"o\">:=</span> <span class=\"n\">set.cod_restrict</span> <span class=\"n\">φ</span> <span class=\"n\">Of</span> <span class=\"n\">set.mem_range_self</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">φ</span> <span class=\"n\">σ</span> <span class=\"o\">:=</span> <span class=\"n\">set.coe_cod_restrict_apply</span> <span class=\"n\">φ</span> <span class=\"n\">Of</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">Of_to_lex</span> <span class=\"o\">:</span> <span class=\"n\">Of</span> <span class=\"bp\">→</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">Of_to_map</span> <span class=\"o\">:</span> <span class=\"n\">Of</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">of_lex</span> <span class=\"bp\">∘</span> <span class=\"n\">Of_to_lex</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">inv_image</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">has_lt.lt</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">Of_to_lex</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">wf'</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">inv_image.wf</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">lex_well_founded</span> <span class=\"n\">n.succ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">wf</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">POf</span> <span class=\"o\">:</span> <span class=\"n\">Of</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">Of_to_map</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">equiv.perm</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span><span class=\"o\">),</span>  <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">POf</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"n\">σ</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">POf</span><span class=\"o\">,</span> <span class=\"n\">φ'</span><span class=\"o\">,</span> <span class=\"n\">Of_to_map</span><span class=\"o\">,</span> <span class=\"n\">Of_to_lex</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf₁</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">@</span><span class=\"n\">well_founded_bot</span> <span class=\"n\">Of</span> <span class=\"n\">r</span> <span class=\"n\">wf'</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">POf</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">hg₁</span> <span class=\"n\">hg₂</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">POf</span><span class=\"o\">,</span> <span class=\"n\">Of_to_map</span><span class=\"o\">,</span> <span class=\"n\">Of_to_lex</span><span class=\"o\">,</span> <span class=\"n\">φ'</span><span class=\"o\">,</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">set.coe_cod_restrict_apply</span><span class=\"o\">,</span> <span class=\"n\">of_lex_to_lex</span><span class=\"o\">,</span> <span class=\"n\">equiv.perm.coe_one</span><span class=\"o\">,</span> <span class=\"n\">function.comp.right_id</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">σ</span><span class=\"o\">,</span> <span class=\"n\">hσ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_range.mp</span> <span class=\"o\">(</span><span class=\"n\">subtype.mem</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"n\">hg₁'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"bp\">≠</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hφ</span><span class=\"o\">],</span>\n      <span class=\"n\">by_contra'</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hg₁</span> <span class=\"o\">(</span><span class=\"n\">subtype.coe_injective</span> <span class=\"n\">hf</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hσ</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg₁'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hσ'</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">tuple.sort</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">to_lex_inj</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hg₁'</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hg₁'</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">hij₁</span><span class=\"o\">,</span> <span class=\"n\">hij₂</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">antitone_pair_of_not_sorted</span> <span class=\"n\">hσ'</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hσ''</span><span class=\"o\">:</span> <span class=\"n\">POf</span> <span class=\"o\">(</span><span class=\"n\">φ'</span> <span class=\"n\">σ</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">hg₂</span><span class=\"o\">,</span>\n      <span class=\"n\">apply_fun</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">Of</span> <span class=\"bp\">→</span> <span class=\"n\">lex</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n.succ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">))</span> <span class=\"n\">using</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span>\n      <span class=\"n\">rwa</span> <span class=\"n\">hφ</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">hh</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij₁</span> <span class=\"n\">hij₂</span> <span class=\"o\">((</span><span class=\"n\">hf₁</span> <span class=\"n\">σ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">hσ''</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">φ'</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">equiv.swap</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">lex_desc</span> <span class=\"n\">hij₁</span> <span class=\"n\">hij₂</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">inv_image</span><span class=\"o\">,</span> <span class=\"n\">φ'</span><span class=\"o\">,</span> <span class=\"n\">Of_to_lex</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hσ</span><span class=\"o\">,</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">set.coe_cod_restrict_apply</span><span class=\"o\">,</span> <span class=\"n\">equiv.perm.coe_mul</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">hf₁</span><span class=\"o\">,</span> <span class=\"n\">equiv.perm.coe_mul</span><span class=\"o\">],</span>\n      <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">function.comp.assoc</span><span class=\"o\">],</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 299136057,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663325825
    },
    {
        "content": "<p>Wooah! This turned out to be more complex than I was expecting.</p>",
        "id": 299136246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663325887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did you see this thread?</p>",
        "id": 299136306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1663325916
    },
    {
        "content": "<p>I may not have hit on the simplest proof possible <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 299136317,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663325920
    },
    {
        "content": "<p>But I was also expecting it to be simpler, to be honest.</p>",
        "id": 299136353,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663325941
    },
    {
        "content": "<p>yeah that seems weirdly hard</p>",
        "id": 299136408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663325958
    },
    {
        "content": "<p>although I guess it's a weird statement too. If you just want a sorted version of the function you could just do that, this induction principle is doing something else</p>",
        "id": 299136632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1663326031
    },
    {
        "content": "<p>The first <code>have</code> can be proved by <code>ext, simp</code>.</p>",
        "id": 299136719,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1663326095
    },
    {
        "content": "<p>The induction principle is what I was after, so perhaps the name of the topic was slightly misleading. Sorry about the <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>...</p>",
        "id": 299136822,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663326126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299136719\">said</a>:</p>\n<blockquote>\n<p>The first <code>have</code> can be proved by <code>ext, simp</code>.</p>\n</blockquote>\n<p>I did have a nagging feeling that there should be a simpler way of doing this, I have edited the proof.</p>",
        "id": 299137019,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663326229
    },
    {
        "content": "<p>I have generalized <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>'s code and my code so that it works with suitable ordered types <code>α</code> in place of <code>ℕ</code> (edited in the long message above).</p>",
        "id": 299146104,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663329919
    },
    {
        "content": "<p>It would make sense to PR this together with <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>'s well-foundedness instance for <code>lex (fin n → α)</code>. Any suggestions regarding in which files these should go? A better name for <code>bubble_sort</code>?</p>",
        "id": 299146397,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663330021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.22sort.22.20a.20function/near/299124773\">said</a>:</p>\n<blockquote>\n<p>(bonus golfing question: it'd be really nice to make <code>perm.map_congr</code> using the equation compiler; does anyone know how to golf it to that? I tried and couldn't get it to work)</p>\n</blockquote>\n<p>Same - I got as far as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.abel_ruffini</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">perm.map_congr</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l₁</span> <span class=\"bp\">~</span> <span class=\"n\">l₂</span><span class=\"o\">),</span> <span class=\"n\">l₁.map</span> <span class=\"n\">f</span> <span class=\"bp\">~</span> <span class=\"n\">l₂.map</span> <span class=\"n\">f</span>\n<span class=\"bp\">|</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">list.perm.nil</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">list.perm.cons</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">perm.map_congr</span> <span class=\"n\">hx</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">list.perm.swap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">perm.swap</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"n\">l₁</span> <span class=\"n\">l₂</span> <span class=\"o\">(</span><span class=\"n\">list.perm.trans</span> <span class=\"n\">h₁₂</span> <span class=\"n\">h₂₃</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">perm.map_congr</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h₁₂.trans</span> <span class=\"n\">h₂₃</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but lean fails to prove well-founded recursion in the trans case</p>",
        "id": 299147784,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1663330512
    },
    {
        "content": "<p>It looks like we are also missing a well-foundedness instance for the product order on function types with finite domain and well-founded codomain(s). It would be good to add that together with the instance for the lex order.</p>",
        "id": 299237757,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663360549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> <br>\nI've successfully <a href=\"https://gist.github.com/alreadydone/f043f5432faead3872c037a5bc670765\">generalized the well-foundedness result to `finsupp</a>; the signature of the result is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">finsupp.lex'</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">),</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">y</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"bp\">⇑</span><span class=\"n\">x</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">y</span> <span class=\"n\">b</span>\n<span class=\"n\">well_founded_lex'</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"n\">N</span><span class=\"o\">],</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">⦄,</span> <span class=\"bp\">¬</span><span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">well_founded</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">well_founded</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">lex'</span> <span class=\"n\">r</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The condition <code>∀ ⦃n : N⦄, ¬s n 0</code> is necessary: otherwise if α is infinite then every coordinate in <code>0 : α →₀ N</code> can be decreased, yielding an infinite decreasing sequence; similarly if the function is infinitely supported then each coordinate in the support could potentially be decreased, so finite support is crucial. It should be easy to generalize to <code>dfinsupp</code>.</p>\n<p>I actually started thinking about the problem a few days earlier because I also needed it for the fundamental theorem of symmetric polynomials. The proof closely follows the proof of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/well_founded.cut_expand/src\">src#well_founded.cut_expand</a> (which is essentially the special case N = ℕ), but it took me some days to figure out the correct generalization of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/relation.cut_expand_fibration\">docs#relation.cut_expand_fibration</a>; in the presence of a monoid structure (as is the case for ℕ) you can just use addition to combine two finsupp functions, but in general you need to consider all possible ways of merging them, parametrized by a function <code>α → bool</code> specifying which coordinates to take from one function and which to take from the other.</p>",
        "id": 299256970,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1663372150
    },
    {
        "content": "<p>I've updated <a href=\"https://gist.github.com/alreadydone/f043f5432faead3872c037a5bc670765\">the gist</a> to include a derivation of <code>pi.well_founded_lex</code> from the finsupp version when the domain is finite with a linear_order. The signature is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">pi.well_founded_lex'</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_3</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_4</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">],</span>\n    <span class=\"n\">well_founded</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">well_founded</span> <span class=\"o\">(</span><span class=\"n\">pi.lex</span> <span class=\"n\">has_lt.lt</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I plan to generalize to dfinsupp and derive the finsupp version and then the original multiset version from it, and PR it in 1-2 days.</p>",
        "id": 299271273,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1663388861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> Can you include the version for the product order (which does not need an order on <code>α</code>, just finiteness, but it should follow from the lex version by imposing any linear order, since it is a subrelation)? In any case, thanks for doing this!</p>",
        "id": 299289703,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663404597
    },
    {
        "content": "<p>I have PRed the induction principle</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">well_founded.induction_bot</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hwf</span> <span class=\"o\">:</span> <span class=\"n\">well_founded</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">bot</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"n\">bot</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">C</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">bot</span>\n</code></pre></div>\n<p>see <a href=\"https://github.com/leanprover-community/mathlib/pull/16536\">#16536</a>. I have put it in <code>order.well_founded</code> (the other well-founded induction principles are in core). Please have a look!</p>",
        "id": 299295814,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663408070
    },
    {
        "content": "<p>I have now come up with a proof of <code>bubble_sort</code> that does not require the well-foundedness of the lex order (by using instead that an irreflexive relation on a finite set is always well-founded). (But the well-foundedness of lex is still a good thing to have, and I will need the well-foundedness of the product order for something else, too!)<br>\nThis relies on a number of other lemmas on tuples and also on <code>well_founded.induction_bot</code>, which is in <a href=\"https://github.com/leanprover-community/mathlib/pull/16536\">#16536</a>.<br>\nHow should I proceed:</p>\n<ul>\n<li>Wait until <a href=\"https://github.com/leanprover-community/mathlib/pull/16536\">#16536</a> gets merged and then open another PR?</li>\n<li>Extend <a href=\"https://github.com/leanprover-community/mathlib/pull/16536\">#16536</a> to include the additional material?<br>\nThanks for comments!</li>\n</ul>",
        "id": 299419173,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663499216
    },
    {
        "content": "<p>you can always make a dependent PR so people see what you're building up to, but sometimes they're annoying to follow up on. it's your choice</p>",
        "id": 299420861,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1663500209
    },
    {
        "content": "<p>Then I prefer to have everything in one place. I'll update <a href=\"https://github.com/leanprover-community/mathlib/pull/16536\">#16536</a> accordingly.</p>",
        "id": 299433603,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1663507033
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> The well-foundedness of the lexicographic/product order on (d)finsupp/pi/function is finally ready at <a href=\"https://github.com/leanprover-community/mathlib/pull/16772\">#16772</a>. Takes much longer than I expected to streamline everything, and I probably need to break it down to several PRs. <a href=\"https://github.com/leanprover-community/mathlib/pull/16720\">#16720</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/16740\">#16740</a> both overlap with this branch and should be easy to review; the diff will become smaller when they're merged. I also ported the files <em>finsupp.ne_locus</em> and <em>finsupp.lex</em> to <code>dfinsupp</code>, and those could be one PR.</p>",
        "id": 301990430,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1664763400
    }
]
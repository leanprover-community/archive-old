[
    {
        "content": "<p>I am not very familiar with the polynomial API. Is there code for the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.polynomial.monic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_monomial_sum_monomial</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"n\">p.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coeff_sum</span><span class=\"o\">,</span> <span class=\"n\">coeff_monomial</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">finset_sum_coeff</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff</span><span class=\"o\">,</span>\n             <span class=\"n\">finset.sum_ite_eq'</span><span class=\"o\">,</span> <span class=\"n\">ite_eq_right_iff</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_forall</span><span class=\"o\">,</span> <span class=\"n\">sum_def</span><span class=\"o\">],</span>\n  <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hg</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">not_not</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.unop.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"n\">r</span><span class=\"o\">)),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">p.sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">monomial</span> <span class=\"n\">n</span> <span class=\"n\">r.unop</span><span class=\"o\">)),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sum_monomial_sum_monomial</span><span class=\"o\">,</span> <span class=\"n\">opposite.unop_zero</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">,</span> <span class=\"n\">sum_monomial_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sum_monomial_sum_monomial</span><span class=\"o\">,</span> <span class=\"n\">opposite.op_zero</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">sum_monomial_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sum_add_index</span><span class=\"o\">],</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"n\">using</span> <span class=\"n\">opposite.op_induction</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">q</span> <span class=\"n\">using</span> <span class=\"n\">opposite.op_induction</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248239488,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628005549
    },
    {
        "content": "<p>Is it any easier to prove this for <code>add_monoid_algebra</code> first?</p>",
        "id": 248245251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628008147
    },
    {
        "content": "<p>The strategy here will be to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.map_mul_iff\">docs#add_monoid_hom.map_mul_iff</a> and <code>ext</code> I think</p>",
        "id": 248251491,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628011212
    },
    {
        "content": "<p>In particular, this ext lemma helps:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Add_monoid homs from the opposite type are equal if they are equal when composed with the regular type.</span>\n\n<span class=\"sd\">This allows further ext lemmas to chain. -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_hom.op_ext</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_zero_class</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_zero_class</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">op_add_equiv</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span> <span class=\"bp\">=</span>\n       <span class=\"n\">g.comp</span> <span class=\"o\">(</span><span class=\"n\">op_add_equiv</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_monoid_hom.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.congr_fun</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">x.unop</span>\n</code></pre></div>",
        "id": 248251567,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628011258
    },
    {
        "content": "<p>Full solution for <code>add_monoid_algebra</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finsupp</span> <span class=\"n\">opposite</span>\n\n<span class=\"c1\">-- simps doesn't do well here, but we could add some lemmas about `support` and `coe_fn` that are true by rfl</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add_monoid_algebra.op_add_equiv</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">≃+</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"n\">opposite.op_add_equiv.symm.trans</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">p.support</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.trans</span> <span class=\"o\">(</span><span class=\"n\">op_ne_zero_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">p.support</span><span class=\"o\">,</span> <span class=\"n\">unop</span> <span class=\"bp\">∘</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">mem_support_iff.trans</span> <span class=\"o\">(</span><span class=\"n\">unop_ne_zero_iff</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">finsupp.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">finsupp.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">finsupp.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_algebra.op_add_equiv_single</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">):</span>\n  <span class=\"n\">add_monoid_algebra.op_add_equiv</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"n\">r</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">single</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_algebra.op_add_equiv</span><span class=\"o\">,</span> <span class=\"n\">single_apply</span><span class=\"o\">,</span> <span class=\"n\">apply_ite</span> <span class=\"n\">op</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_monoid_hom.op_ext</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_zero_class</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_zero_class</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">op_add_equiv</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span> <span class=\"bp\">=</span>\n       <span class=\"n\">g.comp</span> <span class=\"o\">(</span><span class=\"n\">op_add_equiv</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃+</span> <span class=\"n\">A</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_monoid_hom.ext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.congr_fun</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">x.unop</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">add_monoid_algebra.op_ring_equiv</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"n\">I</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_equiv.to_fun_eq_coe</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">add_equiv.coe_to_add_monoid_hom</span><span class=\"o\">],</span>\n    <span class=\"n\">revert</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">add_monoid_hom.map_mul_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">op_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_monoid_algebra.single_mul_single</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_algebra.op_add_equiv_single</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span><span class=\"n\">op_mul</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">add_monoid_algebra.op_add_equiv</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248253010,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012011
    },
    {
        "content": "<p>Will you PR this?</p>",
        "id": 248253342,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628012163
    },
    {
        "content": "<p>Probably not - are you happy to do so?</p>",
        "id": 248253799,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012383
    },
    {
        "content": "<p>I'll try to understand how this works and how to specialize it to polynomial.</p>",
        "id": 248253908,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628012422
    },
    {
        "content": "<p>I'm also curious how hard it is to take that definition and apply it to polynomial; in the past they're defeq, but there's now a structure constructor to get slightly in the way. At any rate, it would be  nice to have the def there for both (as then you get it for <code>mv_polynomial</code> too)</p>",
        "id": 248254047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012506
    },
    {
        "content": "<p>For <code>monoid_algebra</code> you can do a similar trick but additionally map <code>I</code> through <code>op</code>, to avoid needing commutativity. We don't have an <code>additive_op</code> which is why we can't do that for <code>add_monoid_algebra</code> , but it's not relevant to polynomials where <code>I</code> is <code>nat</code> anyway.</p>",
        "id": 248254280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012617
    },
    {
        "content": "<p>If I understand correctly, one should be able to fill the holes here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">ring_equiv.trans</span> <span class=\"n\">_</span>\n<span class=\"o\">(</span><span class=\"n\">add_monoid_algebra.op_ring_equiv</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">add_monoid_algebra</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">))</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 248254862,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628012896
    },
    {
        "content": "<p>Ah, good point!</p>",
        "id": 248254971,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012953
    },
    {
        "content": "<p>I think theres <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.to_finsupp_iso_alg\">docs#polynomial.to_finsupp_iso_alg</a></p>",
        "id": 248254992,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628012971
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.to_finsupp_iso_alg\">docs#polynomial.to_finsupp_iso_alg</a></p>",
        "id": 248255052,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628012999
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.to_finsupp_iso\">docs#polynomial.to_finsupp_iso</a> is enough here</p>",
        "id": 248255114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628013009
    },
    {
        "content": "<p>I guess it should be an <code>alg_equiv</code> not just a ring_equiv</p>",
        "id": 248255122,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628013014
    },
    {
        "content": "<p><code>add_monoid_hom.op_ext</code> probably ought to be repeated for <code>linear_map.op_ext</code>, if that makes sense there. Maybe right actions screw with it.</p>",
        "id": 248255188,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628013047
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8537\">#8537</a></p>",
        "id": 248272745,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628020973
    },
    {
        "content": "<p>alg_equivs require commutativity iiuc</p>",
        "id": 248272777,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628020984
    }
]
[
    {
        "content": "<p>Hi all, I am trying to prove the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dfinsupp</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mul_zero_class.to_has_zero</span> <span class=\"n\">finsupp.has_zero</span>\n  <span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">finsupp.add_monoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sigma_finsupp_to_dfinsupp</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dfinsupp.mk</span> <span class=\"o\">(</span><span class=\"n\">finsupp.split_support</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finsupp.split</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(this is a linear equivalence, but let's start with this). The proof of <code>map_add'</code> seems quite painful: I can do it (I think) by several <code>by_cases</code>, looking at <code>f.split_support</code>, <code>g.split_support</code> and <code>(f + g).split_support</code>. Do someone see a better way of doing this? Maybe avoiding <code>dfinsupp.mk</code> or something.</p>",
        "id": 241143524,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622638256
    },
    {
        "content": "<p>Note that the line <code>local attribute [-instance] mul_zero_class.to_has_zero finsupp.has_zero\n  finsupp.add_zero_class finsupp.add_monoid</code> is necessary, otherwise Lean is unable to find the <code>R</code>-module instance on <code>(Π₀ i, (η i →₀ N))</code>.</p>",
        "id": 241143613,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622638312
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dfinsupp</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">not_iff_of_iff_not</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"bp\">¬</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">P</span> <span class=\"bp\">↔</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tauto</span><span class=\"bp\">!</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">not_mem_split_support_iff_zero</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">αs</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">αs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">i</span> <span class=\"bp\">∉</span> <span class=\"n\">split_support</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">split</span> <span class=\"n\">l</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">not_iff_of_iff_not</span> <span class=\"bp\">$</span> <span class=\"n\">mem_split_support_iff_nonzero</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finsupp</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">dfinsupp.mk_split_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">η</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">dfinsupp.mk</span> <span class=\"o\">(</span><span class=\"n\">finsupp.split_support</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finsupp.split</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">=</span>\n  <span class=\"n\">f</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">dfinsupp.mk_apply</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">not_mem_split_support_iff_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finsupp.split_apply</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- this should be fixed, not worked around...</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mul_zero_class.to_has_zero</span> <span class=\"n\">finsupp.has_zero</span>\n  <span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">finsupp.add_monoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sigma_finsupp_to_dfinsupp</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dfinsupp.mk</span> <span class=\"o\">(</span><span class=\"n\">finsupp.split_support</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finsupp.split</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">dfinsupp.mk_apply</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">dfinsupp.mk_apply</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 241148974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622640815
    },
    {
        "content": "<p>I just had the idea of something like <code>dfinsupp.mk_split_apply</code>, but you are too fast!</p>\n<p>I agree that the problem with <code>local attribute [-instance]...</code> should be fixed, but I think it's a little to complicated for me...</p>",
        "id": 241150064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622641263
    },
    {
        "content": "<p>I think you can do better by avoiding <code>dfinsupp.mk</code>, which introduces an annoying if</p>",
        "id": 241150697,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622641556
    },
    {
        "content": "<p>My idea was to prove immediately after the definition</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n<span class=\"n\">finsupp.split</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">sigma_finsupp_to_dfinsupp</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>so for all the proof I can move to  <code>(Π i, (η i →₀ N))</code>, where the claim are more or less obvious.</p>",
        "id": 241151498,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622641889
    },
    {
        "content": "<p>I was looking for a direct way to construct an element of <code>(Π₀ i, (η i →₀ N))</code> from an element of <code>(Π i, (η i →₀ N))</code> and a proof that the support is finite, but this seems to be missing.</p>",
        "id": 241151683,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622641942
    },
    {
        "content": "<p>Here's the <code>mk</code>-free version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dfinsupp</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"c1\">-- this lemmas should definitely exist</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">dfinsupp.coe_mk</span> <span class=\"o\">[</span><span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"bp\">⟦</span><span class=\"n\">dfinsupp.pre.mk</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">hf</span><span class=\"bp\">⟧</span> <span class=\"o\">:</span> <span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finsupp</span>\n\n<span class=\"c1\">-- this should be fixed, not worked around...</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mul_zero_class.to_has_zero</span> <span class=\"n\">finsupp.has_zero</span>\n  <span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">finsupp.add_monoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sigma_finsupp_to_dfinsupp</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">⟦</span><span class=\"o\">⟨</span><span class=\"n\">finsupp.split</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finsupp.split_support</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">finset.mem_def</span><span class=\"o\">,</span> <span class=\"n\">mem_split_support_iff_nonzero</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">decidable.em</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"kd\">end</span><span class=\"o\">⟩</span><span class=\"bp\">⟧</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finsupp.split_apply</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finsupp.split_apply</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 241151702,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622641951
    },
    {
        "content": "<p>This one has the nice property that <code>finsupp.split f = sigma_finsupp_to_dfinsupp f</code> is true by rfl</p>",
        "id": 241151758,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622641980
    },
    {
        "content": "<p>Ah, it's <code>dfinsupp.pre.mk</code>!</p>",
        "id": 241152018,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622642110
    },
    {
        "content": "<p>I am trying to investigate why <code>local attribute [-instance] finsupp.has_zero</code> is needed. The workaround has been suggested by <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>  here<br>\n<a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/240928594\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/finite.20free.20modules/near/240928594</a></p>\n<p>Here is a minimal example showing that something is wrong, but <code>lemma test</code> is indeed true by <code>rfl</code> (I am not sure it is relevant). I don't have a clue about how to correct this, but if you have any indication I can work on it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.dfinsupp</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">add_zero_class</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">add_zero_class.to_has_zero</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">ι</span> <span class=\"n\">N</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">@</span><span class=\"n\">finsupp.has_zero</span> <span class=\"n\">ι</span> <span class=\"n\">N</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">add_zero_class.to_has_zero</span> <span class=\"n\">N</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"c1\">--this fail</span>\n<span class=\"c1\">--noncomputable lemma foo1 [h : add_zero_class N] : has_add (Π₀ i, (η i →₀ N)) := by apply_instance</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">finsupp.has_zero</span>\n\n<span class=\"c1\">--this works</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">lemma</span> <span class=\"n\">foo2</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">add_zero_class</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 241170315,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622649629
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7806\">#7806</a> contains <code>dfinsupp.coe_mk</code>, renamed to <code>dfinsupp.coe_pre_mk</code></p>",
        "id": 241172306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622650521
    }
]
[
    {
        "content": "<p>Dear All,</p>\n<p>let <code>S</code> be an  <code>R</code>-algebra and <code>M</code> an <code>S</code>-module.  Suppose that <code>gs : set S</code> is a set of generators of <code>S</code>as an <code>R</code>-module and <code>gm : set M</code> is a set of generators of <code>M</code> as an <code>S</code>-module.  Is it already in Lean the statement that the products <code>s • m</code>, for <code>s ∈ gs</code> and <code>m ∈ gm</code>generate <code>M</code> as an <code>R</code>-module?</p>\n<p>Thank you!</p>",
        "id": 229107944,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615046123
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 229107962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615046147
    },
    {
        "content": "<p>Fixed!</p>",
        "id": 229108027,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615046178
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">span_smul</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">span</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"n\">S</span> <span class=\"n\">t</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 229108197,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1615046353
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/b04aeb5e19faa21c2ae76158fc8454bb236f5f4f/src/algebra/algebra/tower.lean#L266\">https://github.com/leanprover-community/mathlib/blob/b04aeb5e19faa21c2ae76158fc8454bb236f5f4f/src/algebra/algebra/tower.lean#L266</a></p>",
        "id": 229108200,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1615046355
    },
    {
        "content": "<p>Great, thanks Kenny!</p>",
        "id": 229108211,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615046371
    },
    {
        "content": "<p>Is your statement something like <code>[algebra R S] [module S M] (hs : subalgebra.adjoin gs = \\top) (hm : submodule.span S gm =\\top) : submodule.span R {...} = \\top</code>?</p>",
        "id": 229108313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615046413
    },
    {
        "content": "<p>Eric, yes, with some <code>is_scalar_tower</code> scattered around as well.</p>",
        "id": 229108351,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615046447
    },
    {
        "content": "<p>I will try to see if what Kenny sent works, but it looks like it is exactly what I need!</p>",
        "id": 229108407,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615046490
    },
    {
        "content": "<p>Unrelatedly, the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.smul_mem_span_smul'\">docs#submodule.smul_mem_span_smul'</a> next to Kenny's lemma looks like a special case of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.smul_mem\">docs#submodule.smul_mem</a>?</p>",
        "id": 229108554,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615046624
    },
    {
        "content": "<p>Continuing in this thread, I like the \\smul notation for multiplying <code>set ??</code>, but it seems that I cannot smultiply <code>finset ??</code> by <code>finset ??</code>. </p>\n<p>Since I am a little worried of <code>finset</code>, before embarking in proving that the smultiplication of finsets is a finset, I wanted to make sure that this is really not in mathlib yet.</p>\n<p>So...  are finsets smultiplicable in mathlib?</p>",
        "id": 229118831,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615055666
    },
    {
        "content": "<p>(For those who are curious about why I care about this, I am trying to prove that in the \"generator tower\" mentioned at the beginning of the thread, if I start with finite generating sets for the two parts, then I get a finite generating set over the whole tower.)</p>",
        "id": 229118926,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615055750
    },
    {
        "content": "<p>Why not just use sets with a <code>finite</code> hypothesis? I think this makes things easier.</p>",
        "id": 229120434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615057143
    },
    {
        "content": "<p>Ok, I will try!</p>",
        "id": 229124215,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615060566
    },
    {
        "content": "<p>Kevin, your suggestion reduces my problem to the lemma below.  If you have any suggestions of what I can try to remove the sorry, I will be happy to hear it!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.tower</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229124961,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615061197
    },
    {
        "content": "<p>The library will know that the product of G and v (a subset of S x M) is finite, and that the image of a finite set is finite.</p>",
        "id": 229125168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615061373
    },
    {
        "content": "<p>So, I should first prove that <code>(G • v)</code> is a fintype?  Sorry about the silly questions, but I am not really able to make much progress on this.</p>",
        "id": 229125759,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615061900
    },
    {
        "content": "<p>I managed to construct a function from the cartesian product to the smul-product, but even assuming a fintype instance on the product, Lean would not allow me to prove fintype from a surjection:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">⟩⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">fintype.of_surjective</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"c1\">--- here is the error:</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_4</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n<span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">,</span>\n<span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n       <span class=\"n\">_a.cases_on</span>\n         <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n            <span class=\"n\">subtype.cases_on</span> <span class=\"n\">fst</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">fst_val</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fst_property</span> <span class=\"o\">:</span> <span class=\"n\">fst_val</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n                 <span class=\"n\">subtype.cases_on</span> <span class=\"n\">snd</span>\n                   <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">snd_val</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd_property</span> <span class=\"o\">:</span> <span class=\"n\">snd_val</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n                      <span class=\"n\">id_rhs</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">fst_val</span> <span class=\"bp\">•</span> <span class=\"n\">snd_val</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩))))</span>\n      <span class=\"n\">_x</span><span class=\"o\">,</span>\n<span class=\"n\">_inst</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229126903,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615062856
    },
    {
        "content": "<p>Does <code>letI</code> work better than haveI?</p>",
        "id": 229127644,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615063518
    },
    {
        "content": "<p>Eric, I got it down to just the product instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">⟩⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"o\">{</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">fintype.of_surjective</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">j_val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">gG</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mv</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">subtype.mk_eq_mk.mpr</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"n\">fG</span> <span class=\"n\">fv</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229127706,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615063565
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.fintype\">docs#prod.fintype</a>?</p>",
        "id": 229127905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615063719
    },
    {
        "content": "<p>I think that the issue is that when I write <code>G</code>, it is no longer a set, but a weird type and Lean does not seem to know that G.fintype means that this weird type is also a fintype...</p>",
        "id": 229128074,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615063839
    },
    {
        "content": "<p>so when I apply prod.fintype, Lean tells me that there is no fintype instance on <code>G</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_4</span> <span class=\"o\">:</span> <span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n<span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">,</span>\n<span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n       <span class=\"n\">_a.cases_on</span>\n         <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">fst</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"n\">v</span><span class=\"o\">),</span>\n            <span class=\"n\">subtype.cases_on</span> <span class=\"n\">fst</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">fst_val</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fst_property</span> <span class=\"o\">:</span> <span class=\"n\">fst_val</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span><span class=\"o\">),</span>\n                 <span class=\"n\">subtype.cases_on</span> <span class=\"n\">snd</span>\n                   <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">snd_val</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">snd_property</span> <span class=\"o\">:</span> <span class=\"n\">snd_val</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span><span class=\"o\">),</span>\n                      <span class=\"n\">id_rhs</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">⟨</span><span class=\"n\">fst_val</span> <span class=\"bp\">•</span> <span class=\"n\">snd_val</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩))))</span>\n      <span class=\"n\">_x</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"n\">G</span>\n</code></pre></div>",
        "id": 229128107,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615063883
    },
    {
        "content": "<p>Well add two new haveIs for those instances then!</p>",
        "id": 229128207,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615063942
    },
    {
        "content": "<p>Indeed!  This is where I am now:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">⟩⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prod.fintype</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">fintype.of_surjective</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">j_val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">gG</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mv</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">subtype.mk_eq_mk.mpr</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"n\">fG</span> <span class=\"n\">fv</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229128219,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615063963
    },
    {
        "content": "<p>library_search: <code>haveI : fintype G := set.finite.fintype fG</code>!</p>",
        "id": 229128240,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615063986
    },
    {
        "content": "<p>This works!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">⟩⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">vM</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩⟩⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">set.finite.fintype</span> <span class=\"n\">fG</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">set.finite.fintype</span> <span class=\"n\">fv</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">prod.fintype</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">fintype.of_surjective</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">j_val</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">gG</span><span class=\"o\">,</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">gG</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mv</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">subtype.mk_eq_mk.mpr</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"n\">fG</span> <span class=\"n\">fv</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229128281,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615064017
    },
    {
        "content": "<p>It feels unnecessarily complicated, but I am happy to have it now!</p>",
        "id": 229128292,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615064034
    },
    {
        "content": "<p>The whole point is to avoid finset and fintype completely</p>",
        "id": 229128725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615064401
    },
    {
        "content": "<p>You do everything with sets and then show that everything is finite.</p>",
        "id": 229128826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615064437
    },
    {
        "content": "<p>I tried to use sets, but when I write <code>G × v</code>, Lean converts this to something that is not a set.  Is there a way of getting the cartesian product without making it into a strange type?</p>",
        "id": 229129143,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615064743
    },
    {
        "content": "<p><code>set.finite.fintype fg</code> is <code>fg.fintype</code> I think</p>",
        "id": 229129395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615064951
    },
    {
        "content": "<p>And you should be able to get away without the third haveI</p>",
        "id": 229129415,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615064973
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.prod\">docs#set.prod</a>?</p>",
        "id": 229129680,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615065227
    },
    {
        "content": "<p>Well, I give up for today.</p>\n<p>I also realized that my \"proof\" above does not actually work!</p>\n<p>Hopefully it will all seem simpler when I get back to this!</p>",
        "id": 229131267,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615066733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.tower</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finite.smul_of_finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">fG</span> <span class=\"o\">:</span> <span class=\"n\">G.finite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">fv</span> <span class=\"o\">:</span> <span class=\"n\">v.finite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">•</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"n\">fG.image2</span> <span class=\"o\">(</span><span class=\"bp\">•</span><span class=\"o\">)</span> <span class=\"n\">fv</span>\n</code></pre></div>\n<p>Sorry I didn't get to this earlier -- I was having family time. The <code>set.finite</code> API should be, IMNSHO, the go-to way for mathematicians to deal with finiteness. <code>finset</code> and <code>fintype</code> are these type-valued finiteness things which experts seem to be able to use and can't see what the fuss is all about when us regular people whinge about instance problems because they understand all the details of what's going on. The advantage of <code>finset</code> over <code>finite</code> is that it's computable, but computability is worth absolutely nothing to me, and I find Prop-valued finiteness much easier to use.</p>",
        "id": 229140547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615075816
    },
    {
        "content": "<p>Kevin, thank you so much for the proof and also for the information about <code>finset</code> vs <code>finite</code>.  I did not realize that one of them was easier to work with and was using <code>finset</code> simply because that was what I had seen in mathlib.</p>\n<p>Even though I had problems working with <code>finite</code>, it did appear easier to navigate than <code>finset</code>.</p>\n<p>I certainly tried <code>library_search</code> on the lemma above.  Why did it fail?  Is it because of the fact that one of the inputs is a function?</p>",
        "id": 229160695,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615097067
    },
    {
        "content": "<p>I don't know. I just looked at the definition of G bub v, saw it used set.image2, so knew that the answer was going to be set.finite.image2 . I agree that <code>library_search</code> could have found this.</p>",
        "id": 229167545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615104251
    },
    {
        "content": "<p>I tried looking at the definition of the \\smul, but what I clicked took me to <code>has_scalar</code>, which was probably not what you found.</p>",
        "id": 229168386,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615105049
    },
    {
        "content": "<p>But this is the pattern in general, eg in my sketch above I went via <a href=\"http://set.prod\">set.prod</a> and the proof that a product of two finite sets is finite is <a href=\"http://set.finite.prod\">set.finite.prod</a> . The \"weird type\" you're talking about above is just the coercion to Type. This is what happens when you bundle subobjects. Because things like <code>set X</code> and <code>subgroup G</code> ( if G is a group) are types, this means that things like <code>H : subgroup G</code> are terms, which is not how we mathematicians usually think about them -- we would usually think of a subgroup as being a group itself. This is why we have the notation g \\in H, to remind us that the type of g is still G and the relationship between g and H is something else. This is fine sometimes, but if you actually want to think about H as a type itself rather than a term (eg if you really want to define a function with source H and cannot or will not think about it as the restriction of a function defined on G, or you want to talk about a subgroup of H and cannot or will not think of it as a subgroup of G contained in H) then you need to have a way to promote H to a type. This is done via <code>has_coe_to_sort</code> and as I've implied it's often something I try to avoid because it looks a bit inelegant, but it's not hard to understand: the promotion of the subset <code>{x | p x}</code> is the subtype <code>{x // p x}</code> and a term of this type is just a pair consisting of x : G and a proof that <code>x \\in H</code> so you can do <code>cases</code> on it and use pointy bracket notation etc.</p>",
        "id": 229168438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615105089
    },
    {
        "content": "<p>I just assumed that it was set up in such a way that once you set up <code>smul</code> for types, then it automatically picks up what to do with subsets of those types.</p>",
        "id": 229168451,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615105113
    },
    {
        "content": "<p>Re definition: you need to use the infoview correctly. You looked at the definition of the notation in general. If you inspect the bub in G bub v you can see it's something like set.has_scalar (I think -- not at lean right now) and this is where you can see it's <code>image2</code>.</p>",
        "id": 229168546,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615105225
    },
    {
        "content": "<p>Thanks, Kevin!  The stuff on coercions is very helpful!  It is something that I am starting to understand, but I still struggle with.  For instance, I would like to avoid these coercions, but sometimes I feel that Lean corners me into using them and I am rarely able to exit the resulting mess.  However, it is not always clear to me what it is that I did wrong that took me to such an undesirable place!</p>",
        "id": 229168811,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615105455
    },
    {
        "content": "<p>I indeed Ctrl-clicked the bullet in the code side, and did not think of clicking on the infoview and then specializing to the correct bullet to go to the correct definition!  <em>Now</em> I found it!  Thanks again!</p>",
        "id": 229168884,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615105536
    },
    {
        "content": "<p>You treated a term as a type, that's what makes <code>has_coe_to_sort</code> kick in. We're taught that everything is a term and some terms are types but this is a bad way of thinking about things. If you think of everything as precisely one of a term, a type and a universe then you get a much better model of how type theory is used in mathematics in general.</p>",
        "id": 229168986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615105651
    },
    {
        "content": "<p>well, some terms <em>are</em> types: <code>nat</code> is a type and also a term of type <code>Type</code></p>",
        "id": 229169042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615105694
    },
    {
        "content": "<p>of course when we talk about terms used as types we usually mean terms whose type is not <code>Type</code> or <code>Prop</code> but something like <code>finset A</code>, in which case you need a coercion</p>",
        "id": 229169099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615105779
    },
    {
        "content": "<p>&lt;/pedantic&gt;</p>",
        "id": 229169101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615105786
    },
    {
        "content": "<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this and I would accept a model of type theory where there were two different colons, one of the form term : type and one of the form type :: universe.</p>",
        "id": 229169339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615105997
    },
    {
        "content": "<p>Ok, while I knew this, I am glad that Kevin also finds it a little bit of a coincidence that <code>nat</code> is a term!</p>\n<p>I view this as the type-theory analogue of the fact that you <em>can</em> wonder about whether ℕ is an <em>element</em> of π in set-theory, but you really shouldn't!</p>",
        "id": 229169497,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615106154
    },
    {
        "content": "<p>I remember as a beginner trying to draw a map of Lean's type theory and starting with Prop : Type which is in some sense the most harmful of all the \"random\" term : type relations. It took me a long time to realise that Prop and Type were the same kind of thing and that this relation between them was of no use. We have a system where we can ask if nat = Prop and for me this is embarrassing, it's a junk question. I have constantly emphasised this universe/type/term viewpoint in my teaching and I think it makes it clearer to mathematicians</p>",
        "id": 229169564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615106194
    },
    {
        "content": "<p>I certainly find it closer to my intuition to separate Props from non-Props.  In fact, I sometimes have troubles applying inductions (Edit: in Lean!) and I think that the issue is often related to the fact that there is a blur between whether you are doing it on Prop or Type (or something like that).</p>\n<p>Yet, I find it interesting that this distinction is not so strong and you can talk about Props on a similar footing as \"usual mathematical objects\".  I guess that this is something that is no news to logicians, but I find charming these concepts!</p>",
        "id": 229169835,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615106493
    },
    {
        "content": "<p><code>Prop : Type</code> and <code>nat : Type</code> make sense in the context of <code>list Prop</code> and <code>list nat</code>, respectively a list of statements and a list of integers</p>",
        "id": 229170500,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615107089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/generators.20smul.20generators.20generate/near/229169339\">said</a>:</p>\n<blockquote>\n<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this and I would accept a model of type theory where there were two different colons, one of the form term : type and one of the form type :: universe.</p>\n</blockquote>\n<p>This kind of type theory exists; it's actually quite common outside DTT circles. For example Haskell's type theory distinguishes between \"terms\", \"types\" and \"kinds\"; so for example <code>1 : int</code> and <code>int : *</code> where <code>*</code> is the kind of all types (what we would call <code>Type</code>). This is useful when talking about \"higher kinded types\" like <code>list : * -&gt; *</code>, where <code>* -&gt; *</code> is another \"kind\". (Of course this is no biggie for a DTT user, but if you are used to dealing with just types then these \"types of types\" are a little mind blowing.)</p>",
        "id": 229171026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615107625
    },
    {
        "content": "<p>I guess the DTT crowd saw this and said \"well you're duplicating all the work now with a typehood relation that looks just like the other one. What if you need kinds of kinds? So let's make an infinite hierarchy of kinds of kinds of kinds and call them universes\"</p>",
        "id": 229171198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615107777
    },
    {
        "content": "<p>This solves the problem of having many kinds of typehood judgment, at the cost of universe hierarchy management. Lean uses a little nat-like algebra of levels, while Coq uses a partial order of globally coherent universe constraints, and I think they are both lotsa complicated when we only really care about somewhere between 0 and 1 universes</p>",
        "id": 229171337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615107953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I would be surprised if there were any lists of Props occurring anywhere in mathlib other than in meta code. I can fully believe that this is an important concept in tactic-writing but this is an abstraction layer i never go into in my teaching.</p>",
        "id": 229172917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615109465
    },
    {
        "content": "<p>Perhaps <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tfae\">docs#tfae</a> uses it?</p>",
        "id": 229173086,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615109643
    },
    {
        "content": "<p>Or whatever the full name is...</p>",
        "id": 229173203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615109720
    },
    {
        "content": "<p>I think that's a secret def that doc-gen doesn't want to tell me about?</p>",
        "id": 229173304,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615109817
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.tfae\">docs#list.tfae</a> ?</p>",
        "id": 229173307,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615109820
    },
    {
        "content": "<p>Ironic how <code>list</code> was in the name!  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 229173333,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615109849
    },
    {
        "content": "<p>I did not know about <code>tfae</code>.</p>",
        "id": 229173401,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1615109889
    },
    {
        "content": "<p>tfae is the only example I know</p>",
        "id": 229173755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615110269
    },
    {
        "content": "<p>In fact <code>list Prop</code> is useless in meta code because <code>Prop</code> has no computational content</p>",
        "id": 229173760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615110294
    },
    {
        "content": "<p>it may as well be <code>list unit</code></p>",
        "id": 229173762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615110299
    },
    {
        "content": "<p>I think a much more important use of types as terms is in things like <code>ring A</code> where the application of <code>A</code> to <code>ring</code> is the same as the application of <code>f</code> to <code>x</code> in any function application <code>f x</code></p>",
        "id": 229173870,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615110383
    },
    {
        "content": "<p>It's possible to get by with this being two different kinds of application but it's at best a notational headache</p>",
        "id": 229173988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615110498
    },
    {
        "content": "<p>In the current definition of simple graphs in mathlib, edges are given by <code>V -&gt; V -&gt; Prop</code>, so a list of statements whether an edge is in the graph would also be <code>list Prop</code></p>",
        "id": 229187625,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615123693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/generators.20smul.20generators.20generate/near/229169339\">said</a>:</p>\n<blockquote>\n<p>The fact that nat is a term is for me deemed harmful. I don't see any use of this</p>\n</blockquote>\n<p>How would you then phrase statements like \"the naturals are countable\", \"the reals are uncountable\"?</p>",
        "id": 229187762,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615123847
    },
    {
        "content": "<p>Surely it would be <code>list (sym2 V)</code>?</p>",
        "id": 229187767,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615123852
    },
    {
        "content": "<p>You're right, I mean a list of <code>edge \\in graph</code></p>",
        "id": 229187815,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615123915
    },
    {
        "content": "<p>I think one of the smarter things that is in Lean syntax is differentiating cartesian products from the type level to the term level: <code>term : (⬝,⬝) vs type (⬝ × ⬝)</code>, unlike Haskell which uses <code>(,)</code> for both.</p>",
        "id": 229187938,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615124035
    },
    {
        "content": "<p>Well, in haskell you don't need to since types and terms are different</p>",
        "id": 229194133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615129599
    },
    {
        "content": "<p>You wouldn't really be able to unify them in lean because they have different (incompatible) types</p>",
        "id": 229194165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615129641
    },
    {
        "content": "<p>I once played around with unifying lambda and pi, which is just about doable (you just treat lambda as pi when it is used as a type)</p>",
        "id": 229194243,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1615129709
    }
]
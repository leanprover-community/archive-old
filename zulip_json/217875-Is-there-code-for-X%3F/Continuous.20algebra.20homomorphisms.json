[
    {
        "content": "<p>Ugh, I want to talk about continuous algebra homomorphisms.</p>\n<p>I can't bear the thought of building yet another bundled structure, with pages of API about equivalences and subobjects and so on.</p>",
        "id": 230670103,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615978054
    },
    {
        "content": "<p>Can I just define the category <code>TopAlgebra</code> and work there? :-)</p>",
        "id": 230670200,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1615978096
    },
    {
        "content": "<p>who knows... if it works, that would be great.</p>",
        "id": 230670681,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615978353
    },
    {
        "content": "<p>We really need the structure bundle builder gadget that people talked about at LT2021</p>",
        "id": 230670702,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615978372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Continuous.20algebra.20homomorphisms/near/230670200\">said</a>:</p>\n<blockquote>\n<p>Can I just define the category <code>TopAlgebra</code> and work there? :-)</p>\n</blockquote>\n<p>Scott, is it remotely viable to use this approach everywhere, and build the non-category API as a thin later on top of the category API?</p>",
        "id": 230673393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615979829
    },
    {
        "content": "<p>The thing you immediately lose is the ability to talk about homomorphisms between objects at different universe levels.</p>",
        "id": 230854031,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616070583
    },
    {
        "content": "<p>This is pretty annoying.</p>",
        "id": 230854064,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616070601
    },
    {
        "content": "<p>Are there situations where that makes statements weaker, or is it just super annoying but not strictly limiting (in that you need <code>ulift</code> everywhere)?</p>",
        "id": 230858112,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616072415
    },
    {
        "content": "<p>Scott says \"this is pretty annoying\" wrt this universe polymorphic stuff, however I spent 25 years of my life doing research mathematics without the ability to talk about homomorphisms between objects at different universe levels and this didn't bother me in the slightest.</p>",
        "id": 230858548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616072581
    },
    {
        "content": "<p>Sticking to homs between objects of the same type is far less of an extreme restriction than my usual \"why not just let everything be Type or Prop\" rant which usually comes out at this point. This lets people be universe-polymorphic but not multi-polymorphic. Do we really need maps between groups of type u and type v in any application, or do we just do them because we can?</p>",
        "id": 230858840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616072706
    },
    {
        "content": "<p>There's no way to generalize over both Type and Prop without also generalizing over all universes though, right?</p>",
        "id": 230859367,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616072910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, yes, but that's still orthogonal to Kevin's point.</p>",
        "id": 230862214,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616074017
    },
    {
        "content": "<p>I agree, I think, Kevin. Perhaps what I meant is that \"it is pretty annoying that people bring this up as an objection\". :-)</p>",
        "id": 230862297,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616074052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you've also spent 25 years of your life believing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mi>g</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>g</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[1/fg] = R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span>...</p>",
        "id": 230862550,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616074159
    },
    {
        "content": "<p>Ah, I misread \"type or prop\" as \"some wildcard that covers both\" not \"just pick one each time\"</p>",
        "id": 230862581,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616074174
    },
    {
        "content": "<p>Yes I agree that it's annoying that there's no wildcard which covers both, however mathematicians are very good at distinguishing between them (for example I was carefully taught that the recursor from nat to Type was called \"construction by recursion\" and the recursor to Prop was called \"proof by induction\"). In my teaching tools there are Type and Prop everywhere and it's very rare that I want to explicitly unify these things. Mathematicians even have an arrow <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>→</mo></mrow><annotation encoding=\"application/x-tex\">\\to</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">→</span></span></span></span> for Type and a different arrow <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext></mrow><annotation encoding=\"application/x-tex\">\\implies</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.549em;vertical-align:-0.024em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span></span></span> for Prop.</p>",
        "id": 230863084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616074368
    },
    {
        "content": "<p>Perhaps a good example of where unifying the two is useful is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.Union\">docs#set.Union</a>`, which enables the bounded union notation; but I agree even those cases are rare</p>",
        "id": 230864044,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616074726
    },
    {
        "content": "<p>Usually at this point of discussion <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> comes to the room and tells us about some exotic cases in parts of math I don't understand where it's important to have different universes. I still wonder if it's easier to use category theory almost everywhere and use <code>ulift</code> whenever we really need different universes.</p>",
        "id": 230936038,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616100924
    },
    {
        "content": "<p>One downside of using category theory homs everywhere is that we loose tricks like \"<code>monoid_hom</code> both for monoid and group homs\"</p>",
        "id": 230936196,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616100994
    },
    {
        "content": "<p>I'm sympathetic to this point of view, but it doesn't really work to have everything in <code>Type u</code> (i.e. polymorphic but with only one universe) because lots of things are in <code>Type</code></p>",
        "id": 230936202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616100997
    },
    {
        "content": "<p>I mean you can get by with <code>ulift</code> but it's really inconvenient</p>",
        "id": 230936266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616101032
    },
    {
        "content": "<p>Indeed, we can't stick to \"everything in <code>Type u</code>\" without <code>nat.{u}</code> and <code>real.{u}</code>.</p>",
        "id": 230936315,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616101052
    },
    {
        "content": "<p>Good point.</p>",
        "id": 230936324,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616101057
    },
    {
        "content": "<p>(and we probably don't want to have lots of different <code>nat</code>s around.</p>",
        "id": 230936433,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1616101091
    },
    {
        "content": "<p>The theory of cardinals does essentially this</p>",
        "id": 230936485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616101110
    },
    {
        "content": "<p><code>omega.{u}</code> is defined as <code>mk (ulift nat)</code></p>",
        "id": 230936509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616101124
    },
    {
        "content": "<p>It's also annoying to have universe parameters that aren't inferred because you usually can't omit them, i.e. you will actually be writing <code>nat.{u}</code> most of the time</p>",
        "id": 230936621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616101195
    },
    {
        "content": "<p>I recall early in the category theory development I suggested pinning the second universe argument of <code>category</code> (for the homs) to either <code>v=u</code> or <code>v=u+1</code>, but Scott argued that we want to prove things generic over both, so now we have two universe params. And once you start doing that it's really unnatural to restrict the parametricity in some specific areas because you wind up revising it eventually anyway (like the recent example with <code>limit</code>)</p>",
        "id": 230937106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616101363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>, has this ever been done? Do you still need it? If so, I can produce it in an hour or so.</p>",
        "id": 272853350,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645557490
    },
    {
        "content": "<p>I assume you're talking about continuous algebra homomorphism?</p>",
        "id": 272853671,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557655
    },
    {
        "content": "<p>If so, no, to my knowledge we don't have these.</p>",
        "id": 272853707,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557669
    },
    {
        "content": "<p>The thing to look at is the end of the proof of the Stone-Weierstrass theorem.</p>",
        "id": 272853757,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557702
    },
    {
        "content": "<p>In mathlib or in real life?</p>",
        "id": 272853936,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645557764
    },
    {
        "content": "<p>We have to jump through an awkward hoop to talk about a function that is both continuous and an algebra map.</p>",
        "id": 272853990,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557787
    },
    {
        "content": "<p>(the implementation in mathlib)</p>",
        "id": 272854023,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557799
    },
    {
        "content": "<p>I think the test for a proposed implementation of continuous algebra homomorphisms should be: \"does it make that argument cleaner\".</p>",
        "id": 272854153,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645557848
    },
    {
        "content": "<p>Bhavik is already out there telling me to work on my example sheets instead of writing boilerplate <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 272854309,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1645557942
    }
]
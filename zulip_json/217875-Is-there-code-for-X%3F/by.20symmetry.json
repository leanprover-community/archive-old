[
    {
        "content": "<p>I have a proof that I'd like to be able to write in a shape like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.opens</span>\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">hST</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">),</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">symmetry''</span><span class=\"o\">,</span> <span class=\"c1\">-- hypothetical tactic</span>\n  <span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- some longish proof</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>That is, I have a goal of the form <code>p S ↔ p T</code>, and all my hypotheses are symmetrical on swapping S and T. I'd like to reduce the goal to just proving one direction <code>p S → p T</code>, \"because obviously it's all symmetric.\"</p>\n<p>Is there a tactic that can do this for me?</p>",
        "id": 234081177,
        "sender_full_name": "Greg Price",
        "timestamp": 1618179919
    },
    {
        "content": "<p>wlog can do this for inequalities. In your case, you have S \\le T and T \\le S, if you do apply le_antisymm instead of ext x</p>",
        "id": 234081407,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618180203
    },
    {
        "content": "<p>Hmm interesting! I'll try that</p>",
        "id": 234081542,
        "sender_full_name": "Greg Price",
        "timestamp": 1618180331
    },
    {
        "content": "<p>Here's what I get from one attempt at using <code>wlog</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">hST</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">),</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"n\">wlog</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">using</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  3 goals</span>\n<span class=\"cm\">  case cases</span>\n<span class=\"cm\">  α β : Type,</span>\n<span class=\"cm\">  f : set α → β,</span>\n<span class=\"cm\">  S T : set α,</span>\n<span class=\"cm\">  hST : f S = f T</span>\n<span class=\"cm\">  ⊢ T ≤ S ∨ S ≤ T</span>\n\n<span class=\"cm\">  case main</span>\n<span class=\"cm\">  α β : Type,</span>\n<span class=\"cm\">  f : set α → β,</span>\n<span class=\"cm\">  S T : set α,</span>\n<span class=\"cm\">  case : T ≤ S,</span>\n<span class=\"cm\">  hST : f S = f T</span>\n<span class=\"cm\">  ⊢ S ≤ T</span>\n\n<span class=\"cm\">  α β : Type,</span>\n<span class=\"cm\">  f : set α → β,</span>\n<span class=\"cm\">  S T : set α,</span>\n<span class=\"cm\">  hST : f S = f T</span>\n<span class=\"cm\">  ⊢ T ≤ S</span>\n<span class=\"cm\">  -/</span>\n</code></pre></div>",
        "id": 234081684,
        "sender_full_name": "Greg Price",
        "timestamp": 1618180455
    },
    {
        "content": "<p>I'm clearly doing something wrong there because the first goal isn't even true a priori (not without basically proving the original goal)</p>",
        "id": 234081715,
        "sender_full_name": "Greg Price",
        "timestamp": 1618180524
    },
    {
        "content": "<p>I guess another version of the question is, if I just <code>apply le_antisymm</code> instead of the <code>ext x</code>, then I have these two goals:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>αβ: Type\nf: set α → β\nST: set α\nhST: f S = f T\n⊢ S ≤ T\n\nαβ: Type\nf: set α → β\nST: set α\nhST: f S = f T\n⊢ T ≤ S\n</code></pre></div>\n<p>And the thing I want to do is provide a proof of one of them, and somehow use that to discharge the other. Which will be by somehow using the fact that if you swap the variable names and apply symmetry to <code>hST</code>, that turns the one goal into the other one.</p>\n<p>But I'm not seeing the match between that and what <code>wlog</code> does -- it seems to want to split the goal into more goals, not coalesce symmetrical goals.</p>",
        "id": 234081971,
        "sender_full_name": "Greg Price",
        "timestamp": 1618180828
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">hST</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">),</span>\n  <span class=\"n\">wlog</span> <span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">using</span> <span class=\"n\">T</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- pick one of the directions of `T ≤ S` or `S ≤ T` to prove here</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- now knowing that `T ≤ S`, use that to prove `T = S` using your \"longish proof\"</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234082805,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618181836
    },
    {
        "content": "<p>Hmm -- but how does that avoid repeating the main proof twice?</p>",
        "id": 234082865,
        "sender_full_name": "Greg Price",
        "timestamp": 1618181896
    },
    {
        "content": "<p>Once for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mo>≤</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\"> T \\leq S </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and once for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>≤</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\"> S \\leq T </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span></p>",
        "id": 234082908,
        "sender_full_name": "Greg Price",
        "timestamp": 1618181952
    },
    {
        "content": "<p>maybe it'll be easier to understand if you have the actual mathematical setup</p>",
        "id": 234082976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1618182009
    },
    {
        "content": "<p>Sure, one moment</p>",
        "id": 234083009,
        "sender_full_name": "Greg Price",
        "timestamp": 1618182025
    },
    {
        "content": "<p>The details of the proof are rather messy at present, but here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.instances.real</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.opens</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n<span class=\"kn\">open</span> <span class=\"n\">metric</span>\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">cardinal</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">cardinal</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mk_opens_R_aux</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>\n<span class=\"c1\">-- (Any dense set would do just as well in place of ℚ.)</span>\n<span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">p.2</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"n\">mk_le_of_injective</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"k\">assume</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">mem_nhds_sets</span> <span class=\"n\">S.property</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">mem_nhds_iff.mp</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">ε</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">hεpos</span><span class=\"o\">,</span> <span class=\"n\">hball</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">exists_pos_rat_lt</span> <span class=\"o\">(</span><span class=\"n\">half_pos</span> <span class=\"n\">hεpos</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">εQ</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h0εQ</span><span class=\"o\">,</span> <span class=\"n\">hεQ</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">ball</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">εQ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">ball_mem_nhds</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">rat.cast_pos.mpr</span> <span class=\"n\">h0εQ</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">exists.elim</span> <span class=\"o\">(</span><span class=\"n\">dense_embedding_of_rat.dense.inter_nhds_nonempty</span> <span class=\"n\">this</span><span class=\"o\">),</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">yR</span> <span class=\"o\">⟨⟨</span><span class=\"n\">yQ</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span> <span class=\"n\">hyballx</span><span class=\"o\">⟩,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">yR</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">εQ</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">set.mem_def.mp</span> <span class=\"n\">hyballx</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">yQ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">εQ</span> <span class=\"bp\">⊆</span> <span class=\"n\">ball</span> <span class=\"n\">x</span> <span class=\"n\">ε</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">ball_subset</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">linarith</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">yQ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">εQ</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">set.subset.trans</span> <span class=\"n\">this</span> <span class=\"n\">hball</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">yQ</span><span class=\"o\">,</span> <span class=\"n\">εQ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">set.mem_def.mpr</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">yQ</span><span class=\"o\">,</span> <span class=\"n\">εQ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hST</span> <span class=\"bp\">▸</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">yQ</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">εQ</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">set.mem_def.mp</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hyballT</span> <span class=\"o\">:</span> <span class=\"n\">ball</span> <span class=\"n\">yR</span> <span class=\"n\">εQ</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">hy</span> <span class=\"bp\">▸</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.mem_of_subset_of_mem</span> <span class=\"n\">hyballT</span> <span class=\"o\">(</span><span class=\"n\">mem_ball_comm.mp</span> <span class=\"n\">hyballx</span><span class=\"o\">),</span>\n  <span class=\"o\">},</span>\n\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- \"by symmetry\"</span>\n<span class=\"o\">})</span>\n</code></pre></div>",
        "id": 234083188,
        "sender_full_name": "Greg Price",
        "timestamp": 1618182188
    },
    {
        "content": "<p>(I think all the details in that block after <code>split</code> don't matter, except to see why I don't want to just say it twice with S and T swapped)</p>",
        "id": 234083350,
        "sender_full_name": "Greg Price",
        "timestamp": 1618182307
    },
    {
        "content": "<p>Another trick would be to prove the implication for general variables (X, Y) first, and then apply it twice: once on (S, T) and once on (T, S).</p>\n<div class=\"codehilite\" data-code-language=\"import\"><pre><span></span><code>open function\n\nexample (α β : Type) (f : set α → β) : injective f :=\nbegin\n  assume S T (hST : f S = f T),\n  have aux_lemma : ∀ X Y : whatever_S_and_T_are, any_condition_on_S_and_T → S ⊆ T := sorry,\n  have : S = T := subset.antisymm (aux_lemma S T conditions_on_S conditions_on_T) (aux_lemma T S conditions_on_T conditions_on_S),\nend```\nIt would be great if a tactic could figure out how to change the goal on its own, but I slightly doubt it's feasible.\n</code></pre></div>",
        "id": 234287517,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1618302532
    },
    {
        "content": "<p>Thanks! Yeah, that's the best existing solution I've found.</p>",
        "id": 234446381,
        "sender_full_name": "Greg Price",
        "timestamp": 1618380790
    },
    {
        "content": "<p>For my example above, it might look like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mk_opens_R_aux</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>\n<span class=\"c1\">-- (Any dense set would do just as well in place of ℚ.)</span>\n<span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">p</span> <span class=\"bp\">|</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">p.2</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"n\">mk_le_of_injective</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"n\">injective</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">from</span>\n<span class=\"k\">suffices</span> <span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">⊆</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"k\">from</span> <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span> <span class=\"n\">opens.ext</span> <span class=\"bp\">$</span> <span class=\"n\">set.subset.antisymm</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">T</span> <span class=\"n\">S</span> <span class=\"n\">hST.symm</span><span class=\"o\">),</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">assume</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">x</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">mem_nhds_sets</span> <span class=\"n\">S.property</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- … same long detailed proof as before …</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">})</span>\n</code></pre></div>",
        "id": 234446969,
        "sender_full_name": "Greg Price",
        "timestamp": 1618381247
    },
    {
        "content": "<p>I don't find that totally satisfying, because it feels like a fair bit of fuss for what in a paper/blackboard proof would be done almost without comment, and it feels like something that <em>should</em> in principle be totally possible for a computer to see.</p>\n<p>But I guess there isn't currently code around that can do it. Maybe I'll see if if I can figure out how to make a tactic that does. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 234447412,
        "sender_full_name": "Greg Price",
        "timestamp": 1618381610
    },
    {
        "content": "<p>Yeah, <code>wlog</code> doesn't handle \"by symmetry\" proofs of this form. It can case split on <code>S &lt;= T \\/ T &lt;= S</code> but that doesn't make sense here because <code>opens real</code> is not totally ordered.</p>",
        "id": 234447704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618381864
    },
    {
        "content": "<p>Yeah, that makes sense</p>",
        "id": 234447723,
        "sender_full_name": "Greg Price",
        "timestamp": 1618381880
    },
    {
        "content": "<p>FWIW I would set up your proof like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mk_opens_R_aux</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>\n  <span class=\"c1\">-- (Any dense set would do just as well in place of ℚ.)</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span> <span class=\"bp\">|</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">p.2</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mk_le_of_injective</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">antisymm</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST.symm</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span> <span class=\"n\">x</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">↑</span><span class=\"n\">S</span> <span class=\"bp\">∈</span> <span class=\"bp\">𝓝</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">mem_nhds_sets</span> <span class=\"n\">S.property</span> <span class=\"n\">hxS</span><span class=\"o\">,</span>\n  <span class=\"bp\">...</span> <span class=\"c1\">-- as before</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 234448308,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618382220
    },
    {
        "content": "<p>Thanks. Ah, yeah, the <code>{S T}</code> trick simplifies that next line. And using \\le instead of \\sub means skipping the <code>opens.ext</code> translation.</p>",
        "id": 234448551,
        "sender_full_name": "Greg Price",
        "timestamp": 1618382359
    },
    {
        "content": "<p>Presumably the commented fact \"An open set in ℝ is uniquely determined by the [any dense set] balls included in it.\" is itself a mathlib worthy lemma, separated from any cardinality facts.</p>",
        "id": 234448584,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618382386
    },
    {
        "content": "<p>I'd be happy to PR it! I will certainly clean up the proof first (most of all in the parts that come after the part this question is about.)</p>",
        "id": 234448683,
        "sender_full_name": "Greg Price",
        "timestamp": 1618382437
    },
    {
        "content": "<p>the statement can also be stated in terms of <code>2^omega</code></p>",
        "id": 234448741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618382496
    },
    {
        "content": "<p>I was writing it up as the main part of another fun fact about the open sets in ℝ:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The open sets in ℝ have the same cardinality as ℝ. -/</span>\n<span class=\"c1\">-- Probably the right level of generality for this is a separable... uniform space?</span>\n<span class=\"c1\">-- At least any separable metric space.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mk_opens_R</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">#</span><span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>which I think likely also belongs in mathlib. Though it's possible the main work needed for that is already present -- I looked in places specific to ℝ but haven't tried to find it in the places where the main lemma at the right level of generality would live.</p>",
        "id": 234448849,
        "sender_full_name": "Greg Price",
        "timestamp": 1618382562
    },
    {
        "content": "<p>(And as the comment says, I haven't even worked out yet at a mathematical level what level of generality that is.)</p>",
        "id": 234448923,
        "sender_full_name": "Greg Price",
        "timestamp": 1618382633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/by.20symmetry/near/234448308\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mk_le_of_injective</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">antisymm</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST.symm</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah, and the reason you're using <code>@mk_le_of_injective</code> there is to specify <code>f</code>, which is the same effect my version above was getting with <code>show injective f,</code>.</p>\n<p>I do like <code>show</code> when it makes things clearer, but here it really isn't adding anything beyond specifying <code>f</code>.</p>",
        "id": 234452446,
        "sender_full_name": "Greg Price",
        "timestamp": 1618384747
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397997\">@Greg Price</span> Here's a golf of the remainder of your proof, without fundamentally changing the proof approach:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mk_opens_R_aux</span> <span class=\"o\">:</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">#</span><span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- An open set in ℝ is uniquely determined by the rational balls included in it.</span>\n  <span class=\"c1\">-- (Any dense set would do just as well in place of ℚ.)</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">ℝ</span><span class=\"o\">),</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">×</span> <span class=\"n\">ℚ</span> <span class=\"bp\">|</span> <span class=\"n\">ball</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"n\">p.2</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"bp\">≤</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">mk_le_of_injective</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">antisymm</span> <span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">hST.symm</span><span class=\"o\">))</span> <span class=\"o\">},</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"n\">hST</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">hxS</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"k\">show</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">ε</span><span class=\"o\">,</span> <span class=\"n\">hεpos</span><span class=\"o\">,</span> <span class=\"n\">hball</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_nhds_iff.1</span> <span class=\"o\">(</span><span class=\"n\">mem_nhds_sets</span> <span class=\"n\">S.2</span> <span class=\"n\">hxS</span><span class=\"o\">),</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">εQ</span><span class=\"o\">,</span> <span class=\"n\">h0εQ</span><span class=\"o\">,</span> <span class=\"n\">hεQ</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">exists_pos_rat_lt</span> <span class=\"o\">(</span><span class=\"n\">half_pos</span> <span class=\"n\">hεpos</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">ball_mem_nhds</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">rat.cast_pos.2</span> <span class=\"n\">h0εQ</span><span class=\"o\">),</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">yR</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">yQ</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">hyballx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">dense_embedding_of_rat.dense.inter_nhds_nonempty</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">set.subset.trans</span> <span class=\"o\">(</span><span class=\"n\">ball_half_subset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ball_subset_ball</span> <span class=\"n\">hεQ.le</span> <span class=\"n\">hyballx</span><span class=\"o\">))</span> <span class=\"n\">hball</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">yQ</span><span class=\"o\">,</span> <span class=\"n\">εQ</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">set.subset.trans</span> <span class=\"o\">(</span><span class=\"n\">ball_subset_ball</span> <span class=\"n\">hεQ.le</span><span class=\"o\">)</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">hST</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">mem_ball_comm.mp</span> <span class=\"n\">hyballx</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It's possible that you can do more by generalizing to dense embeddings or something</p>",
        "id": 234462279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618389650
    }
]
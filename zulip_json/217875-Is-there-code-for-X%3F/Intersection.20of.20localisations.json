[
    {
        "content": "<p>Do we have (or is it easy to prove given what we have) that the ring of integers of a number field is the intersection of all its local valuation rings? I think somewhere in the proof we need something like an integral domain is an intersection of its localisations at all primes?</p>",
        "id": 302776082,
        "sender_full_name": "David Ang",
        "timestamp": 1665113756
    },
    {
        "content": "<p>I'm quite sure we do not have this yet. But we seem to have most of the ingredients.</p>",
        "id": 302785988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665123030
    },
    {
        "content": "<p>I think that using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_def\">docs#is_dedekind_domain.height_one_spectrum.int_valuation_def</a> this should be very easy.  Given <code>r/s</code> in the field of fractions <code>K</code>, you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation_of_mk'\">docs#is_dedekind_domain.height_one_spectrum.valuation_of_mk'</a> to compute all its valuations and deduce that the <code>s</code> is a unit.</p>",
        "id": 302792243,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665126638
    },
    {
        "content": "<p>s isn't a well-defined thing so I'm not sure it's as easy as that (there's no notion of \"lowest terms\" in general). Given an element k in the field of fractions of an integral domain you can construct the ideal of denominators of that element, which is all the elements r of the ring such that r*k is in the ring. It's not principal in general.</p>",
        "id": 302792724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665126884
    },
    {
        "content": "<p>But there is a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_div_eq_div\">docs#is_dedekind_domain.height_one_spectrum.int_valuation_div_eq_div</a> so I think any choice would work.</p>",
        "id": 302793045,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665127046
    },
    {
        "content": "<p>(ops, link broken, I'll fix: it says it is indep. of the choices of <code>s</code> and <code>r</code>)</p>",
        "id": 302793077,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665127074
    },
    {
        "content": "<p>Oh no, I see the problem. I agree with <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> .</p>",
        "id": 302795277,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1665128241
    },
    {
        "content": "<p>The general assertion is that the integral closure of a domain in a field is the intersection of all valuation rings of the field field with a centre on your given domain.</p>",
        "id": 302853111,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665149743
    },
    {
        "content": "<p>You can probably find a proof in Zariski-Samuel</p>",
        "id": 302853480,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665149870
    },
    {
        "content": "<p>I don’t think mathlib even knows that valuation rings are normal!</p>",
        "id": 302855784,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665150496
    },
    {
        "content": "<p>That should be a quick PR.</p>",
        "id": 302855857,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665150524
    },
    {
        "content": "<p>There is another <a href=\"https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a\">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.colon\">docs#submodule.colon</a>). But I suspect what <span class=\"user-mention\" data-user-id=\"464700\">@David Ang</span> actually want is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.dedekind_domain.adic_valuation</span>\n<span class=\"kn\">open</span> <span class=\"n\">is_dedekind_domain</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_dedekind_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">height_one_spectrum.valuation_le_one'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v.valuation</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- could also use is_localization.is_integer in statement --</span>\n</code></pre></div>\n<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation\">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href=\"http://associate.mk\">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self\">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>\nIn fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">localization_subalgebra_eq_integer</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≤</span> <span class=\"n\">non_zero_divisors</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">localization.subalgebra.of_field</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">v.as_ideal</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">integer</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 302879610,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665156997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610\">said</a>:</p>\n<blockquote>\n<p>There is another <a href=\"https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a\">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.colon\">docs#submodule.colon</a>). But I suspect what <span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> actually want is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.dedekind_domain.adic_valuation</span>\n<span class=\"kn\">open</span> <span class=\"n\">is_dedekind_domain</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_dedekind_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">height_one_spectrum.valuation_le_one'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v.valuation</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- could also use is_localization.is_integer in statement --</span>\n</code></pre></div>\n<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation\">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href=\"http://associate.mk\">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self\">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>\nIn fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">localization_subalgebra_eq_integer</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≤</span> <span class=\"n\">non_zero_divisors</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">localization.subalgebra.of_field</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">v.as_ideal</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">integer</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I currently only have a proof of the statement you linked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">maximal_spectrum.localization_infi_eq_bot</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">I.is_maximal</span><span class=\"o\">},</span> <span class=\"n\">localization.subalgebra.of_field</span> <span class=\"n\">K</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ideal.prime_compl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v.property.is_prime</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">le_non_zero_divisors_of_no_zero_divisors</span> <span class=\"bp\">$</span>\n      <span class=\"n\">not_not_intro</span> <span class=\"n\">v.val.zero_mem</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>I also have the <code>prime_spectrum</code> and <code>height_one_spectrum</code> versions that follow pretty much immediately.</p>",
        "id": 302880257,
        "sender_full_name": "David Ang",
        "timestamp": 1665157180
    },
    {
        "content": "<p>But yes, I also think that what I want is what you wrote after this.</p>",
        "id": 302880703,
        "sender_full_name": "David Ang",
        "timestamp": 1665157312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302855857\">said</a>:</p>\n<blockquote>\n<p>That should be a quick PR.</p>\n</blockquote>\n<p>scratch that, we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/valuation_ring.is_bezout\">docs#valuation_ring.is_bezout</a></p>",
        "id": 302909232,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665166322
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_bezout.is_integrally_closed\">docs#is_bezout.is_integrally_closed</a></p>",
        "id": 302909294,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665166335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610\">said</a>:</p>\n<blockquote>\n<p>There is another <a href=\"https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a\">general statement</a> </p>\n</blockquote>\n<p>Right -- this is the ideal of denominators proof that I was hinting at earlier.</p>",
        "id": 302943561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665181722
    },
    {
        "content": "<p>Just completed a proof of <code>mem_integers_of_valuation_le_one</code>!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.dedekind_domain.S_integer</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">is_dedekind_domain</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">unique_factorization_monoid</span> <span class=\"n\">height_one_spectrum</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_dedekind_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">height_one_spectrum.mem_integers_of_valuation_le_one</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v.valuation</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">is_localization.mk'_surjective</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hx</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">x</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">is_localization.mk'_zero</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subring.zero_mem</span> <span class=\"o\">},</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">ideal.span</span> <span class=\"o\">{</span><span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"bp\">∣</span> <span class=\"o\">(</span><span class=\"n\">ideal.span</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.span_singleton_le_span_singleton.1</span> <span class=\"o\">(</span><span class=\"n\">ideal.le_of_dvd</span> <span class=\"n\">this</span><span class=\"o\">),</span>\n    <span class=\"n\">use</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_localization.eq_mk'_iff_mul_eq</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">associates.mk_le_mk_iff_dvd_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">associates.factors_le</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy'</span> <span class=\"o\">:=</span> <span class=\"n\">non_zero_divisors.ne_zero</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">ine</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">},</span> <span class=\"n\">mt</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ideal.span_singleton_eq_bot</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">associates.factors_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ine</span> <span class=\"n\">hx</span><span class=\"o\">),</span> <span class=\"n\">associates.factors_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ine</span> <span class=\"n\">hy'</span><span class=\"o\">)],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">with_top.coe_le_coe</span><span class=\"o\">,</span> <span class=\"n\">multiset.le_iff_count</span><span class=\"o\">],</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">⟩,</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">associates.mk_surjective</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hv'</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">associates.irreducible_mk</span><span class=\"o\">,</span> <span class=\"n\">irreducible_iff_prime</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ideal.is_prime_of_prime</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">hv.ne_zero</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">valuation_of_mk'</span><span class=\"o\">,</span> <span class=\"n\">int_valuation</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">valuation.to_fun_eq_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int_valuation_def_if_neg</span> <span class=\"n\">_</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">int_valuation_def_if_neg</span> <span class=\"n\">_</span> <span class=\"n\">hy'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">with_zero.coe_div</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">with_zero.coe_one</span><span class=\"o\">,</span> <span class=\"n\">with_zero.coe_le_coe</span><span class=\"o\">,</span>\n      <span class=\"bp\">←</span> <span class=\"n\">of_add_sub</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">of_add_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">le_of_sub_nonpos</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">neg_le_neg_iff</span><span class=\"o\">,</span> <span class=\"n\">int.coe_nat_le</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">associates.factors_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ine</span> <span class=\"n\">hx</span><span class=\"o\">),</span> <span class=\"n\">associates.factors_mk</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ine</span> <span class=\"n\">hy'</span><span class=\"o\">),</span> <span class=\"n\">option.coe_def</span> <span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">associates.count_some</span> <span class=\"n\">hv'</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">is_dedekind_domain</span>\n</code></pre></div>",
        "id": 302954312,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665190578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302880257\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302879610\">said</a>:</p>\n<blockquote>\n<p>There is another <a href=\"https://math.stackexchange.com/questions/630752/an-integral-domain-a-is-exactly-the-intersection-of-the-localisations-of-a-a\">general statement</a> and the first answer seems pretty easy to formalize (we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.colon\">docs#submodule.colon</a>). But I suspect what <span class=\"user-mention silent\" data-user-id=\"464700\">David Ang</span> actually want is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.dedekind_domain.adic_valuation</span>\n<span class=\"kn\">open</span> <span class=\"n\">is_dedekind_domain</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_dedekind_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">height_one_spectrum.valuation_le_one'</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">v.valuation</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"c1\">-- could also use is_localization.is_integer in statement --</span>\n</code></pre></div>\n<p>My outline for proving this is to show if we write x = r/s, then the multiset of normalized factors of the ideal (s) is less than or equal to the multiset of normalized factors of (r) using the condition <code>h</code>. (The definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.valuation\">docs#is_dedekind_domain.height_one_spectrum.valuation</a> uses counts of factors of <a href=\"http://associate.mk\">associate.mk</a>, so there will need some glue.) Then you may write the latter multiset as the former multiset plus some other multiset, multiply up the multisets and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod_normalized_factors_eq_self\">docs#prod_normalized_factors_eq_self</a> to get that (r)=(s)I for some ideal I, so r is s times some element in the ideal; then x=r/s equals that element.<br>\nIn fact I wrote down a more general statement a while ago but haven't got around to prove it:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">localization_subalgebra_eq_integer</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">≤</span> <span class=\"n\">non_zero_divisors</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">localization.subalgebra.of_field</span> <span class=\"n\">K</span> <span class=\"n\">M</span> <span class=\"n\">hM</span> <span class=\"bp\">=</span>\n  <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">height_one_spectrum</span> <span class=\"n\">R</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">v.as_ideal</span><span class=\"o\">}</span><span class=\"bp\">.</span><span class=\"n\">integer</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I currently only have a proof of the statement you linked:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">maximal_spectrum.localization_infi_eq_bot</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span> <span class=\"bp\">//</span> <span class=\"n\">I.is_maximal</span><span class=\"o\">},</span> <span class=\"n\">localization.subalgebra.of_field</span> <span class=\"n\">K</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ideal.prime_compl</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">v.property.is_prime</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"n\">le_non_zero_divisors_of_no_zero_divisors</span> <span class=\"bp\">$</span>\n      <span class=\"n\">not_not_intro</span> <span class=\"n\">v.val.zero_mem</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>I also have the <code>prime_spectrum</code> and <code>height_one_spectrum</code> versions that follow pretty much immediately.</p>\n</blockquote>\n<p>Here is the preliminary PR for this: <a href=\"https://github.com/leanprover-community/mathlib/pull/16860\">https://github.com/leanprover-community/mathlib/pull/16860</a></p>",
        "id": 302963996,
        "sender_full_name": "David Ang",
        "timestamp": 1665201501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I don't think the result on localisations (the one I just proved :/) will be all that useful for the result I actually want (the one you have!), so perhaps they should be separate PRs?</p>",
        "id": 302964400,
        "sender_full_name": "David Ang",
        "timestamp": 1665201915
    },
    {
        "content": "<p>Actually, was there a discussion before on whether <code>maximal_spectrum</code> is a good thing to have, instead of just using <code>prime_spectrum</code> or <code>height_one_spectrum</code>?</p>",
        "id": 302964620,
        "sender_full_name": "David Ang",
        "timestamp": 1665202215
    },
    {
        "content": "<p>Yeah I think they should be separate PRs. In order to use your work, we need that for every maximal ideal p, localization at p gives exactly the {p}ᶜ-integers; the ⊆  direction seems nontrivial and likely requires a proof like mine above. I think I'd better extract some lemmas and add some related results like <code>localization_subalgebra_eq_integer</code> before PR'ing my proof above.</p>",
        "id": 302964962,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665202776
    },
    {
        "content": "<p>I think it would make things easier if we redefine <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation_def\">docs#is_dedekind_domain.height_one_spectrum.int_valuation_def</a> in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.normalized_factors\">docs#unique_factorization_monoid.normalized_factors</a> instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/associates.factors\">docs#associates.factors</a>. Since we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal.normalization_monoid\">docs#ideal.normalization_monoid</a> there is no need to pass to normalized_factors. In fact, I propose to generalize <a href=\"https://leanprover-community.github.io/mathlib_docs/find/associates.factors\">docs#associates.factors</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/associates.factors'\">docs#associates.factors'</a> to arbitrary <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normalization_monoid\">docs#normalization_monoid</a>, and since <a href=\"https://leanprover-community.github.io/mathlib_docs/find/associates\">docs#associates</a> always form a normalization_monoid (which is already known to Lean via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normalization_monoid_of_unique_units\">docs#normalization_monoid_of_unique_units</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/associates.unique_units\">docs#associates.unique_units</a>), they can always be specialized to the associates monoid. associates.factors  is easier to work with than normalized_factors because the former is a multiset of irreducible elements, so when you apply e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.le_iff_count\">docs#multiset.le_iff_count</a> you don't have to deal with the counts of reducible elements which are zero. If anyone would like to take up this that would be great.</p>\n<p>BTW, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_dedekind_domain.height_one_spectrum.int_valuation\">docs#is_dedekind_domain.height_one_spectrum.int_valuation</a> is missing a <code>@[simps]</code> attribute or a lemma to simplify it to int_valuation_def.</p>",
        "id": 303052448,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665254848
    },
    {
        "content": "<p>Regarding <code>maximal_spectrum</code>, I think it's harmless to add it as a definition, and it could potentially be used elsewhere, e.g. in <a href=\"https://math.stanford.edu/~conrad/papers/aws.pdf\">these notes on non-archimedean geometry</a> it's denoted MaxSpec or M(A) and used throughout. <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> is working on some C*-algebra stuff and there are likely some parallels with the non-archimedean Banach algebras (complete <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_algebra\">docs#normed_algebra</a>) studied in the notes.</p>\n<p>I don't know whether we want to put the Zariski topology on it now, as it may not be predominantly the topology we want on the set as is the case for prime_spectrum. It's interesting to note that in the context of <a href=\"https://github.com/leanprover-community/mathlib/pull/16719\">#16719</a>, although the Zariski topology (whose closed sets are generated by zero loci of functions) is ostensibly coarser than the weak topology on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/weak_dual.character_space\">docs#weak_dual.character_space</a>, they are actually the same, because any compact t2_space is completely regular (cf. <a href=\"https://math.stackexchange.com/questions/1947834/when-is-every-closed-set-singleton-the-zero-set-of-complex-valued-functions\">link 1</a>, <a href=\"https://mathoverflow.net/a/198595/3332\">link 2</a>).</p>",
        "id": 303064326,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665263870
    },
    {
        "content": "<p>In case my input matters at all: I have no issue with adding <code>maximal_spectrum</code>. We won't use it directly for the C⋆-algebra work I'm currently doing because we will also be concerned (eventually) with the non-unital case, so the character space is the way to go. However, I will probably add an equiv for convenience. You're welcome to put the Zariski topology on it. Some authors just use the maximal ideal space and the Zariski topology directly instead of (or in addition to) the character space.</p>",
        "id": 303065106,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665264549
    },
    {
        "content": "<p>In fact <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Intersection.20of.20localisations/near/302954312\"><code>mem_integers_of_valuation_le_one</code></a> is the second defining property of a <a href=\"https://en.wikipedia.org/wiki/Krull_ring#Formal_definition\">Krull ring</a>, which are higher dimensional generalization of Dedekind domains.</p>",
        "id": 310744963,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668744328
    }
]
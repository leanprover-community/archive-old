[
    {
        "content": "<p>I would like the following infinite pigeonhole principle:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cofinality</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">β</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.omega</span> <span class=\"bp\">≤</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">set.infinite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The only infinite pigeonhole principle I see in <code>set_theory.cofinality</code> (e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.infinite_pigeonhole/src\">src#ordinal.infinite_pigeonhole</a>) is ... more complicated! Is there an easy way to get this from that?</p>",
        "id": 241337236,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622680986
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cofinality</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">cardinal</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">mk</span> <span class=\"n\">β</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mk</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">omega</span> <span class=\"bp\">≤</span> <span class=\"n\">mk</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">mk</span> <span class=\"n\">β</span> <span class=\"bp\">&lt;</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">succ_le</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ordinal.infinite_pigeonhole_card</span> <span class=\"n\">f</span>\n    <span class=\"o\">((</span><span class=\"n\">mk</span> <span class=\"n\">β</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">succ_le.mpr</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">w'.trans</span> <span class=\"o\">(</span><span class=\"n\">lt_succ_self</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">)</span>\n    <span class=\"o\">((</span><span class=\"n\">lt_succ_self</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans_le</span> <span class=\"o\">(</span><span class=\"n\">succ_is_regular</span> <span class=\"n\">w'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">ge</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">β</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w'</span> <span class=\"o\">:</span> <span class=\"n\">cardinal.omega</span> <span class=\"bp\">≤</span> <span class=\"n\">cardinal.mk</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">set.infinite</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">set.infinite_coe_iff</span><span class=\"o\">,</span> <span class=\"n\">cardinal.infinite_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">cases</span> <span class=\"n\">foo</span> <span class=\"n\">w</span> <span class=\"n\">w'</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">w'.trans</span> <span class=\"n\">hb.le</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The first lemma should probably be in mathlib.</p>",
        "id": 241338958,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1622682868
    },
    {
        "content": "<p>The idea is to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordinal.infinite_pigeonhole_card\">docs#ordinal.infinite_pigeonhole_card</a> (which is more general) and then take for <code>θ</code> any regular cardinal between <code>#β</code> and <code>#α</code>.  In this case we can take <code>(#β).succ</code>.</p>",
        "id": 241339279,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1622683315
    },
    {
        "content": "<p>Thanks @Floris, I understand now! These are useful.</p>",
        "id": 241350208,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622698525
    }
]
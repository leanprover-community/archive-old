[
    {
        "content": "<p>Do we have something like the following already? <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> , you were asking about pointwise function inequality, so you might know...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.convex.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">linear_map</span> <span class=\"n\">submodule</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">pointwise_min</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">pointwise.min</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">min</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">pointwise.max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">pointwise.abs</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"n\">pointwise.max</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">pointwise.min_eq_left</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.min</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">min_eq_left</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pointwise.min_eq_right</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.min</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">min_eq_right</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pointwise.max_eq_left</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.max</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">max_eq_left</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">pointwise.max_eq_right</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.max</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">max_eq_right</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pointwise_min</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">convex</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">ordered_add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">linear_ordered_add_comm_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">ℝ</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n   <span class=\"o\">[</span><span class=\"n\">ordered_module</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ordered_module</span> <span class=\"n\">ℝ</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n   <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">convex_on.pointwise_max</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">convex_on</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">convex_on</span> <span class=\"n\">s</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">convex_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">pointwise.max</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n   <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hf.left</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">convex_on_iff_div</span> <span class=\"n\">at</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n   <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">max_le_iff</span><span class=\"o\">,</span> <span class=\"n\">pointwise.max</span><span class=\"o\">],</span>\n   <span class=\"n\">split</span><span class=\"o\">,</span>\n   <span class=\"o\">{</span> <span class=\"k\">calc</span>\n      <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:</span>\n         <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hf.right</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span> <span class=\"o\">(</span><span class=\"n\">zero_lt_one.trans_le</span> <span class=\"n\">hab.ge</span><span class=\"o\">)</span>\n      <span class=\"bp\">...</span>               <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n         <span class=\"n\">add_le_add</span>\n            <span class=\"o\">(</span><span class=\"n\">smul_le_smul_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">smul_le_smul_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n   <span class=\"o\">{</span> <span class=\"k\">calc</span>\n      <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">g</span> <span class=\"n\">y</span> <span class=\"o\">:</span>\n         <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hab</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hg.right</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span> <span class=\"o\">(</span><span class=\"n\">zero_lt_one.trans_le</span> <span class=\"n\">hab.ge</span><span class=\"o\">)</span>\n      <span class=\"bp\">...</span>               <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">•</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n         <span class=\"n\">add_le_add</span>\n            <span class=\"o\">(</span><span class=\"n\">smul_le_smul_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">le_max_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">ha</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">smul_le_smul_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">le_max_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">concave_on.pointwise_min</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">concave_on</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">concave_on</span> <span class=\"n\">s</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n   <span class=\"n\">concave_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">pointwise.min</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">convex_on.pointwise_max</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">convex</span>\n</code></pre></div>",
        "id": 251584117,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630512089
    },
    {
        "content": "<p>I am sorry, I really don't know. I was indeed looking for pointwise inequality, but the <code>pi.le_def</code> lemma was enough for me and I haven't dug any deeper.</p>",
        "id": 251584991,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1630512429
    },
    {
        "content": "<p>Do you think my <code>pointwise.min</code> should be called <code>pi.min</code>?</p>",
        "id": 251585069,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630512460
    },
    {
        "content": "<p>Well, I don't know. I would say that <code>pi.min</code> should express the existence of a universal <code>min</code> assuming all Types have a <code>min</code>; but I think that there might be other definitions of <code>min</code>, no?</p>",
        "id": 251585546,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1630512639
    },
    {
        "content": "<p>Yes, I agree, good point. That's maybe indicates it should be called <code>pointwise</code>.</p>",
        "id": 251585678,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630512702
    },
    {
        "content": "<p>I would rather argue that I'd call it <code>pointwise_min</code> rather than with a <code>dot</code> since it seems to me that no <code>dot</code>-notation is involved.</p>",
        "id": 251585704,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1630512711
    },
    {
        "content": "<p>Also makes sense. Maybe we will have a pointwise namespace at somepoint?</p>",
        "id": 251585805,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630512738
    },
    {
        "content": "<p>This seems a good idea.</p>",
        "id": 251585846,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1630512753
    },
    {
        "content": "<p>We already have <code>pointwise.min</code>, it's <code>has_inf.inf</code> / <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_inf\">docs#pi.has_inf</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- added on to your example above</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.min</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⊓</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pointwise.max</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">⊔</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 251587427,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630513314
    },
    {
        "content": "<p>Going off topic a bit, if there were J-like \"verb trains\" (which wouldn't make any sense for Lean to have), then <code>λ x, min (f x) (g x)</code> could be written as <code>f min g</code>, which I suppose is essentially what the <code>has_inf.inf</code> instance is doing by using an operator version of <code>min</code>.  \"Verb trains\" are all just short-hand ways of doing common sorts of combinators, and I'm slightly surprised that this particular combinator doesn't already exist in <code>function.lean</code>.  Neither <code>on_fun</code> nor <code>combine</code> do quite the right thing (<code>combine</code> is the \"dyadic fork\" in J-speak, but there's no \"monadic fork\").</p>\n<p>I'm not suggesting adding the missing combinators though.  Plain-old lambdas usually seem to be the clearer and more accessible choice, if there's not already a specialized meaningful notation.</p>",
        "id": 251603936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630519805
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8958\">#8958</a></p>",
        "id": 251621465,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630527021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/pointwise.20min.20and.20max/near/251603936\">said</a>:</p>\n<blockquote>\n<p>I'm slightly surprised that this particular combinator doesn't already exist in <code>function.lean</code>.</p>\n</blockquote>\n<p>They do already exist, kind of, in unassembled format:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.suggest</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic.function.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">combinator</span>\n\n<span class=\"c1\">-- If you like SKI-ing:</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">min</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">g</span>\n\n<span class=\"c1\">-- Or alternatively, if you like Haskell:</span>\n<span class=\"sd\">/-- I didn't manage to put an instance on `(→) α`, so introduce a synonym. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">reader'</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">reader'.applicative</span> <span class=\"o\">:</span> <span class=\"n\">applicative</span> <span class=\"o\">(</span><span class=\"n\">reader'</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">combinator.K</span><span class=\"o\">,</span>\n  <span class=\"n\">seq</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">combinator.S</span> <span class=\"o\">}</span>\n\n<span class=\"k\">#reduce</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"bp\">&lt;$&gt;</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">reader'</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 251685377,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1630573136
    },
    {
        "content": "<p>I guess <code>K</code> could be used to turn 2-argument <code>combine</code> into a 1-argument <code>combine</code>.   I might have run into an elaborator bug, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">pointwise_min</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n<span class=\"kn\">open</span> <span class=\"n\">combinator</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">pointwise.min</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">f</span> <span class=\"bp\">-</span><span class=\"o\">[</span><span class=\"n\">min</span><span class=\"o\">]</span><span class=\"bp\">-</span> <span class=\"n\">K</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">punit.star</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">kernel failed to type check declaration 'pointwise.min' this is usually due to a buggy tactic or a bug in the builtin elaborator</span>\n<span class=\"cm\">elaborated type:</span>\n<span class=\"cm\">  Π {E : Type u} {β : Type v} [_inst_1 : linear_order β], (E → β) → (E → β) → E → β</span>\n<span class=\"cm\">elaborated value:</span>\n<span class=\"cm\">  λ {E : Type u} {β : Type v} [_inst_1 : linear_order β] (f g : E → β), (K f -[min]- K g) punit.star</span>\n<span class=\"cm\">nested exception message:</span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  @K (E → β)</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  E → β</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Type (max u v)</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Type u_1</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">pointwise_min</span>\n</code></pre></div>",
        "id": 251750740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1630602881
    }
]
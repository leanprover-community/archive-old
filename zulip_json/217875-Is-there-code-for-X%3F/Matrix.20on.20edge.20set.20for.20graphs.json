[
    {
        "content": "<p>Hello!<br>\nI am trying to define the incidence matrix of a graph, but currently fail to do so using the edge set of the graph. Is there any code for that i.e. where the edge set of the graph is used as a fintype for the matrix?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Some attempts, unsuccessful</span>\n<span class=\"c1\">--variables (E : finset (sym2 V))</span>\n<span class=\"c1\">--def E := G.edge_set.to_finset</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">incidence_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"n\">ℤ</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_finset</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>What I am currently struggling is creating E such that E is a fintype, and also E is the edge set of V so that I can define the incidence matrix of G properly.</p>",
        "id": 228939597,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1614944695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303889\">@Alena Gusakov</span> <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> will probably know. But I think the adjacency matrix is already defined somewhere.</p>",
        "id": 228940154,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614945005
    },
    {
        "content": "<p>Yes, but the adjancency matrix is defined on the set of vertices V, what I am looking for is a matrix defined on the edge set, if that makes sense.</p>",
        "id": 228940221,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1614945041
    },
    {
        "content": "<p>Ooh, sorry. I don't know much about graphs</p>",
        "id": 228940295,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614945083
    },
    {
        "content": "<p>Can you use <code>{e // e \\in G.edge_set}</code>?</p>",
        "id": 228940416,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614945146
    },
    {
        "content": "<p>That should give you a type, and hopefully Lean figures out automatically that it is finite if <code>V</code> is finite.</p>",
        "id": 228940452,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614945172
    },
    {
        "content": "<p>So, although we have from the simple_graph file that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">edge_set</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sym2.from_rel</span> <span class=\"n\">G.sym</span>\n</code></pre></div>\n<p>When I define my set E as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span><span class=\"o\">}</span> <span class=\"c1\">-- btw what does // mean? is it like the mathematical notation {x | x \\in \\N, x &lt; 3} or something like that?</span>\n</code></pre></div>\n<p>I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span><span class=\"o\">}</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n</code></pre></div>",
        "id": 228941035,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1614945471
    },
    {
        "content": "<p><code>matrix</code> expects a type <code>n</code> with an instance <code>fintype n</code>. you are trying to feed it a <code>set</code>.</p>",
        "id": 228942280,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614946055
    },
    {
        "content": "<p><code>{x // condition on x}</code> creates a <code>Type*</code> which you can then use for <code>matrix</code>.</p>",
        "id": 228942355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614946086
    },
    {
        "content": "<p>But it still needs the <code>fintype</code> instance.</p>",
        "id": 228942373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614946095
    },
    {
        "content": "<p>Oh, now I see. Ok, so after the fixes, the thing that is left is this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_finset</span><span class=\"o\">}</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"n\">ℤ</span>\n</code></pre></div>\n<p>which gives the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">E</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">E</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n    <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can you please explain what the error means? I often come across error messages like this, but can't see what they precisely mean.</p>",
        "id": 228943081,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1614946488
    },
    {
        "content": "<p>Lean definitely can't find <code>fintype E</code> there, as you hid it behind a def</p>",
        "id": 228943404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614946654
    },
    {
        "content": "<p>I wonder if you might be able to just have <code>[fintype G.edge_set]</code> for this?</p>",
        "id": 228965846,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1614955994
    },
    {
        "content": "<p>I know fintype/finset stuff is really annoying</p>",
        "id": 228965900,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1614956016
    },
    {
        "content": "<p>Can't seem to make it work with that idea, this is how I managed to do it for now, I know it's ugly, but I will improve it when I myself improve at Lean probably <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"bp\">//</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">edges_fintype'</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype</span> <span class=\"n\">G.E</span> <span class=\"o\">:=</span> <span class=\"n\">subtype.fintype</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">has_mem</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">V</span> <span class=\"n\">G.E</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">e.val</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.E</span> <span class=\"n\">ℤ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>Oh, and I don't seem to find any library containing directed graphs, since I might need them to define the directed incidence matrix. Is there some work in progress towards that? (this is just for learning purposes towards my project, don't want to copy anybody <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 228968362,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1614956858
    },
    {
        "content": "<p>I'd suggest not defining <code>E</code> and instead use Lean's auto-coercion feature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℤ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e.val</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>(By the way, there's also <code>e.val ∈ G.incidence_set i</code> for indicating that an edge and a vertex are incident.  It means exactly the same thing as <code>i ∈ e.val</code> but potentially has more useful lemmas about it.)</p>",
        "id": 228991329,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1614965050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"366674\">Gabriel Moise</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/228968362\">said</a>:</p>\n<blockquote>\n<p>Oh, and I don't seem to find any library containing directed graphs, since I might need them to define the directed incidence matrix. Is there some work in progress towards that? (this is just for learning purposes towards my project, don't want to copy anybody <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>\n</blockquote>\n<p>There's nothing about directed graphs yet.  For directed incidence matrices, I've thought it would be nice if there were a type of directed simple graphs, a function to <code>simple_graph</code> that forgets orientations, and a function to prove/calculate things about simple graphs by giving a proof/calculation for directed graphs and a proof that changing the orientation of an edge doesn't change the result.  This could be how you'd use directed incidence matrices for a simple graph.  (One example: calculate the graph Laplacian from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><msup><mi>I</mi><mi>T</mi></msup></mrow><annotation encoding=\"application/x-tex\">II^T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span></span></span></span></span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> a directed incidence matrix of a directed version of a given simple graph.)</p>",
        "id": 228992531,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1614965508
    },
    {
        "content": "<p>By the time you are talking about an incidence matrix, it will get increasingly cumbersome to think of edges as certain pairs of vertices. Instead, you can model a graph as an incidence structure on a  vertex type <code>V</code> and an edge type <code>E</code> together with some some incidence information (such as <code>inc : V \\to E \\to \\nat</code> or <code>head : E \\to V</code>,  <code>tail : E \\to V</code>), the flavour of which could capture simple graphs, multigraphs, digraphs, hypergraphs, etc etc.  Defining an incidence matrix is easy if you set things up this way. For directed graphs, I personally like <code>inc : V \\to E \\to int</code> which takes values <code>1</code> and <code>-1</code>.</p>\n<p>In some areas of graph theory, such as when you're thinking about induced subgraphs and complements, an edge really 'is' a pair of vertices. However, in other cases, you really want to think of edges as their own entities that are not syntactically bound to vertices. If you want an incidence matrix, this strongly suggests to me that you're in the latter situation.</p>",
        "id": 229056067,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614997424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/228991329\">said</a>:</p>\n<blockquote>\n<p>I'd suggest not defining <code>E</code> and instead use Lean's auto-coercion feature:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℤ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e.val</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>(By the way, there's also <code>e.val ∈ G.incidence_set i</code> for indicating that an edge and a vertex are incident.  It means exactly the same thing as <code>i ∈ e.val</code> but potentially has more useful lemmas about it.)</p>\n</blockquote>\n<p>Following this approach, I get into some trouble with type coercions, for example, here I want to prove something quite simple :</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">inc_matrix</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_ite</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>which is very similar to what is already done in the simple_graph module, however I stumble upon the following thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">fintype.card</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.edge_set</span><span class=\"o\">)),</span> <span class=\"bp\">↑</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n</code></pre></div>\n<p>which is what is left to be proven, but I can't seem to get it done, as I am not very experienced with coercions. My fear is that I will encounter this a lot and it would make code look messy.</p>",
        "id": 229188091,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615124130
    },
    {
        "content": "<p>Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>",
        "id": 229188343,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615124380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/229056067\">said</a>:</p>\n<blockquote>\n<p>By the time you are talking about an incidence matrix, it will get increasingly cumbersome to think of edges as certain pairs of vertices. Instead, you can model a graph as an incidence structure on a  vertex type <code>V</code> and an edge type <code>E</code> together with some some incidence information (such as <code>inc : V \\to E \\to \\nat</code> or <code>head : E \\to V</code>,  <code>tail : E \\to V</code>), the flavour of which could capture simple graphs, multigraphs, digraphs, hypergraphs, etc etc.  Defining an incidence matrix is easy if you set things up this way. For directed graphs, I personally like <code>inc : V \\to E \\to int</code> which takes values <code>1</code> and <code>-1</code>.</p>\n<p>In some areas of graph theory, such as when you're thinking about induced subgraphs and complements, an edge really 'is' a pair of vertices. However, in other cases, you really want to think of edges as their own entities that are not syntactically bound to vertices. If you want an incidence matrix, this strongly suggests to me that you're in the latter situation.</p>\n</blockquote>\n<p>With this approach, I see that I can do something like </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">incidence</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, if I want to define a simple_graph as a special case for the more general graph (I am not sure it is necessary for me to do that though, just felt it might be needed), I thought this would work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">incidence</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">sym2.is_diag</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>However, this looks much more \"unfriendly\" than the usual structure of a simple_graph from the library and it doesn't look like I can do much with it right away.</p>",
        "id": 229188350,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615124398
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Matrix.20on.20edge.20set.20for.20graphs/near/229188343\">said</a>:</p>\n<blockquote>\n<p>Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span> <span class=\"n\">matrix</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span> <span class=\"n\">matrix</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">e.val</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">inc_matrix</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_ite</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229189037,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615125019
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e.val</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_def</span> <span class=\"o\">:</span> <span class=\"n\">G.inc_matrix</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">e.val</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_edge_set_of_incidence</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.mem_of_mem_inter_left</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">inc_matrix_def</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_ite</span><span class=\"o\">,</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_id</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_const</span><span class=\"o\">,</span> <span class=\"n\">nsmul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_const_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">subtype.val_eq_coe</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">G.incidence_finset</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">fintype.card_coe</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_finset</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n  <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">finset.card_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">e</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">incidence_finset</span><span class=\"o\">,</span> <span class=\"n\">incidence_set</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"n\">he1</span> <span class=\"n\">he2</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">ext</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">e</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mem_incidence_finset</span> <span class=\"n\">at</span> <span class=\"n\">he</span><span class=\"o\">,</span>\n      <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">mem_edge_set_of_incidence</span> <span class=\"n\">he</span><span class=\"o\">],</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">incidence_set</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he.right</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229191322,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615126960
    },
    {
        "content": "<p>That's solving your current problem. I had to provide two tiny pieces of API.</p>",
        "id": 229191341,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615126984
    },
    {
        "content": "<p>In general, I think there are likely better ways to phrase it such that you don't have to juggle between fintype, finsets, and various coercions.</p>",
        "id": 229191367,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615127022
    },
    {
        "content": "<p>Here's another version, pick your poison.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_def</span> <span class=\"o\">:</span> <span class=\"n\">G.inc_matrix</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_edge_set_of_incidence</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.mem_of_mem_inter_left</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">inc_matrix_def</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.sum_boole</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_id</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.card_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">mem_edge_set_of_incidence</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">he1</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"n\">he2</span><span class=\"o\">⟩</span> <span class=\"n\">he1'</span> <span class=\"n\">he2'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">he'</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229192200,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615127724
    },
    {
        "content": "<p>Woah, thank you very much! I will try to use a different approach, cause this is actually a lot of work for such a result, so I guess I need a change.</p>",
        "id": 229192462,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615127973
    },
    {
        "content": "<p>If you check the <code>simp</code>s, you'll see absolutely no content about graphs</p>",
        "id": 229192737,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615128239
    },
    {
        "content": "<p>So that just means some finset/fintype API is missing</p>",
        "id": 229192790,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615128251
    },
    {
        "content": "<p>One minute</p>",
        "id": 229192799,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615128255
    },
    {
        "content": "<p>Like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fintype.card_coe_filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype.card</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">finset.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">finset.univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.card_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_filter</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">he1</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"n\">he2</span><span class=\"o\">⟩</span> <span class=\"n\">he1'</span> <span class=\"n\">he2'</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hr</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">],</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_filter</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he'</span><span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">exists_prop_of_true</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_def</span> <span class=\"o\">:</span> <span class=\"n\">G.inc_matrix</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_edge_set_of_incidence</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"n\">set.mem_of_mem_inter_left</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">incidence_subset_edge_set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">v</span> <span class=\"bp\">⊆</span> <span class=\"n\">G.edge_set</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.mem_of_mem_inter_left</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inc_matrix_def</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">],</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">fintype.card_coe_filter</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_subset_edge_set</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229192981,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615128457
    },
    {
        "content": "<p>Now you can see that your statement is very simple, and is just the result of the simple implication that any <code>incidence_set</code> is definitionally a subset of the <code>edge_set</code>.</p>",
        "id": 229193066,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615128532
    },
    {
        "content": "<p>Oh, I see what you mean. So, I should either get used to working with finsets and fintypes to continue with this model, or choose a different model.</p>",
        "id": 229193612,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615129093
    },
    {
        "content": "<p>I see this as just part of the formalization. You have to identify which pieces of what you're working on are the \"mathematical content\" and which is the \"fomalization plumbing\". Separating out the two is the skill I've had to gain to be able to do the formalizations I am interested in</p>",
        "id": 229193766,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615129239
    },
    {
        "content": "<p>In addition, graphs might be some of the more frustrating things in formalization because of the constant jumps between objects, subobjects, choice, finite vs infinite, many different \"induction principles\"</p>",
        "id": 229193937,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615129402
    },
    {
        "content": "<p>And working with concrete objects too.</p>",
        "id": 229193942,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615129424
    },
    {
        "content": "<p>Well, I guess I will become good at them with experience and I will see what tools I need to formalize what I want. I will see what I can do to progress with what you proved for me! Thank you again! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 229194139,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615129613
    },
    {
        "content": "<p>By the way, <code>incidence_subset_edge_set</code> already exists as <code>simple_graph.incidence_set_subset</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">fintype.card_coe_filter</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">t</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype.card</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">finset.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">t</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">finset.univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.card_congr</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_filter</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e1</span><span class=\"o\">,</span> <span class=\"n\">he1</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"n\">he2</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hr</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">he</span><span class=\"o\">⟩</span> <span class=\"n\">he'</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set_coe.exists</span><span class=\"o\">,</span>\n      <span class=\"n\">subtype.mk_eq_mk</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_filter</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">he'</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">degree_equals_sum_of_incidence_row</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.degree</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inc_matrix</span><span class=\"o\">,</span> <span class=\"n\">finset.sum_boole</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_id</span><span class=\"o\">,</span>\n       <span class=\"bp\">←</span><span class=\"n\">fintype.card_coe_filter</span> <span class=\"o\">(</span><span class=\"n\">G.incidence_set_subset</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">card_incidence_set_eq_degree</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229251502,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1615182926
    },
    {
        "content": "<p>Can I get some help with this, I encounter this situation very often, when I have to prove stuff about the sum of elements from a type, but I struggle with splitting the sum into two parts based on some property: in the following case, I know that the sum can be split into the sum where x is not the edge between i and j (in which case the sum is 0) and the sum (consisting of one element) when x is the edge (therefore the sum will be 1) and altogether the sum will equal 1 as I need. Can you give me a direction regarding this kind of problems? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">|</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_def</span> <span class=\"o\">:</span> <span class=\"n\">G.inc_matrix</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adj_sum_of_prod_inc_one</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">G.adj</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">G.edge_set</span><span class=\"o\">)),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- If x is the edge between i and j, then the product is 1, else it is 0, and since there is only</span>\n  <span class=\"c1\">-- one edge between i and j, the sum will be 1</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229465411,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615291411
    },
    {
        "content": "<p>There is <code>finset.sum_filter</code> that might be helpful for that</p>",
        "id": 229465770,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1615291594
    },
    {
        "content": "<p>Your statement is probably easier to prove as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"c1\">-- maybe use ℕ instead of ℤ?</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_def</span> <span class=\"o\">:</span> <span class=\"n\">G.inc_matrix</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adj_sum_of_prod_inc_one</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">G.adj</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">G.edge_finset</span><span class=\"o\">,</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>The subtype and coercion stuff is a distraction</p>",
        "id": 229466321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615291904
    },
    {
        "content": "<p>This is a good start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">adj_sum_of_prod_inc_one</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n<span class=\"n\">G.adj</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"bp\">∑</span> <span class=\"n\">x</span> <span class=\"k\">in</span> <span class=\"n\">G.edge_finset</span><span class=\"o\">,</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">j</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"bp\">∈</span> <span class=\"n\">G.edge_finset</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">G.mem_edge_finset</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">hyp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">finset.insert_erase</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.sum_insert</span> <span class=\"o\">(</span><span class=\"n\">finset.not_mem_erase</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">convert</span> <span class=\"n\">add_zero</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">finset.sum_eq_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">finset.mem_erase</span> <span class=\"n\">at</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 229466928,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615292236
    },
    {
        "content": "<p>Wouldn't it be a mistake to define the incidence matrix on the whole sym2 V type? Like it's definition is on the edge set of the graph from what I know.</p>",
        "id": 229471672,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615294579
    },
    {
        "content": "<p>When defined over the whole sym2 V type, you'll just have all zero columns</p>",
        "id": 229475829,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1615296539
    },
    {
        "content": "<p>Yes, I see that, but I thought it would have been better to follow the mathematical definition of the incidence matrix, but I guess that this solves me a lot of coercion problems since I don't have the G.edge_set type anymore.</p>",
        "id": 229477943,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615297349
    },
    {
        "content": "<p>You're always free to have separate <code>inc_matrix'</code> and <code>inc_matrix</code> definitions, where one is the mathetmatically \"clean\" one, while the other is the one that is easy to prove things about</p>",
        "id": 229478905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615297733
    },
    {
        "content": "<p>Then all you need is a lemma saying how they relate to each other</p>",
        "id": 229478937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615297748
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"366674\">@Gabriel Moise</span> There's a missing graph theory lemma that makes this easier.  After that, the main (non-math) complexity is to get things into the right form for <code>finset.filter_eq</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"sd\">/-- `inc_matrix G` is the matrix `M` with `∀ i ∈ V, ∀ e ∈ V x V :` :</span>\n<span class=\"sd\">` | M i e = 1` if `i` is endpoint of `e`</span>\n<span class=\"sd\">` | M i e = 0` otherwise -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">inc_matrix</span> <span class=\"o\">:</span> <span class=\"n\">matrix</span> <span class=\"n\">V</span> <span class=\"n\">G.edge_set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inc_matrix_apply</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_incidence_sets_iff_eq_of_adj</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">i</span> <span class=\"bp\">∧</span> <span class=\"n\">e</span> <span class=\"bp\">∈</span> <span class=\"n\">G.incidence_set</span> <span class=\"n\">j</span> <span class=\"bp\">↔</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">⟧</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">quotient.rec_on_subsingleton</span> <span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">sym2.eq_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">incidence_set</span><span class=\"o\">],</span>\n  <span class=\"n\">tidy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">adj_sum_of_prod_inc_one</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">),</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">i</span> <span class=\"n\">e</span> <span class=\"bp\">*</span> <span class=\"n\">G.inc_matrix</span> <span class=\"n\">j</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">inc_matrix_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">ite_and</span><span class=\"o\">,</span> <span class=\"n\">G.mem_incidence_sets_iff_eq_of_adj</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">finset.sum_boole</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_id</span><span class=\"o\">,</span> <span class=\"n\">boole_mul</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"n\">finset.card</span> <span class=\"o\">(</span><span class=\"n\">finset.filter_eq</span> <span class=\"n\">finset.univ</span> <span class=\"o\">(⟨</span><span class=\"bp\">⟦</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">⟧</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">G.edge_set</span><span class=\"o\">)),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">if_true</span><span class=\"o\">,</span> <span class=\"n\">finset.card_singleton</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">subtype.coe_mk</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 229612875,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1615360347
    },
    {
        "content": "<p>There is also one thing that always appears in my proofs and I always improvise with lemma's that I create specifically for the current thing I am solving, but I was wondering if there is a simple proof for this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.matrix</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">sum_simplification</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">ℤ</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">decidable_pred</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n<span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It is close to the lemma \"sum_apply_ite\", however there the function h that is applied is independent of x. I apologize for the narrowing to \\Z, but this will perfectly do for my work. I don't need a full solution, some hints are more than welcomed as well <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 230082356,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615576331
    },
    {
        "content": "<p>I think you want <a href=\"https://leanprover-community.github.io/mathlib_docs/find/apply_ite\">docs#apply_ite</a>?</p>",
        "id": 230085268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1615577726
    },
    {
        "content": "<p>Oh I forgot about working on the internal elements, thank you so much! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 230086527,
        "sender_full_name": "Gabriel Moise",
        "timestamp": 1615578325
    }
]
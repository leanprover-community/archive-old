[
    {
        "content": "<p>I don't know what this is actually called....</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">prefunctor</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_hom</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>Does this exist somewhere in mathlib?</p>",
        "id": 209886466,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599925281
    },
    {
        "content": "<p>it's like <code>functor</code> (the <code>_root_</code> one)</p>",
        "id": 209886531,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599925356
    },
    {
        "content": "<p>Right, I know that. But I would like to use it with <code>has_hom</code>, as above.</p>",
        "id": 209886547,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599925378
    },
    {
        "content": "<p>I'm building the free category associated to a type <code>C</code> with a <code>has_hom</code> instance, and this is what is needed to state its universal property.</p>",
        "id": 209886570,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599925436
    },
    {
        "content": "<p>it probably doesn't exist (otherwise <code>functor</code> would have depended on it)</p>",
        "id": 209886778,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599925716
    },
    {
        "content": "<p>I was at one point meaning to give this the perhaps controversial name of \"diagram\"</p>",
        "id": 209886800,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599925775
    },
    {
        "content": "<p>These things do actually show up in math. One thing I know about specifically is in defining Nori's version of the motivic Galois group, and he does indeed call them \"diagrams\"</p>",
        "id": 209886860,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599925822
    },
    {
        "content": "<p>\"pregraph\" also makes sense for a name.</p>",
        "id": 209886951,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599925962
    },
    {
        "content": "<p>Anyway, in case anyone is interested:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean\">https://github.com/leanprover-community/mathlib/blob/free_cat/src/category_theory/category/free.lean</a></p>",
        "id": 209886976,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599926019
    },
    {
        "content": "<p>You can also define what it means to be the (co)limit of one of these things--having a functor and, in particular, a domain <em>category</em> isn't necessary, and not always convenient. (I guess this is to some extent related to wanting to use these things to talk about free categories.)</p>",
        "id": 209886985,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599926036
    },
    {
        "content": "<p>Right.</p>",
        "id": 209887027,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599926049
    },
    {
        "content": "<p>e.g. a pushout is a colimit of a diagram indexed on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋅</mo><mo>←</mo><mo>⋅</mo><mo>→</mo><mo>⋅</mo></mrow><annotation encoding=\"application/x-tex\">\\cdot \\leftarrow \\cdot \\to \\cdot</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.44445em;vertical-align:0em;\"></span><span class=\"mord\">⋅</span></span></span></span>, with no category structure implied &amp; therefore no identity morphisms</p>",
        "id": 209887042,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599926083
    },
    {
        "content": "<p>so in that context, the name diagram makes some sense.</p>",
        "id": 209887053,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599926109
    },
    {
        "content": "<p>Yeah I agree. A guess a lot of the stuff in the <code>shapes</code> dir can be made into diagrams (or free categories associated with a diagram).</p>",
        "id": 209887255,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599926277
    },
    {
        "content": "<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 209889547,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599929192
    },
    {
        "content": "<p>nope</p>",
        "id": 209889556,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599929222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547\">said</a>:</p>\n<blockquote>\n<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span></p>\n</blockquote>\n<p>On the \"unrelated\" topic -- I recently did something with those given I wanted to keep using vim for lean -- the most straightforward way for all the unicode stuff without getting too far inside the lean LSP was I basically used the translations.json file from the lean vscode extension and autogenerated snippets from it for vim to use, which I put here: <a href=\"https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets\">https://github.com/Julian/lean-unicode.vim/blob/main/Ultisnips/lean.snippets</a> -- presuming emacs has a way to load ultisnips formatted snippets that may already be usable exactly as is)</p>",
        "id": 209889842,
        "sender_full_name": "Julian Berman",
        "timestamp": 1599929595
    },
    {
        "content": "<p>Yeah I guess I can do something with <code>yasnippet</code> (the canonocal(?) snippet package in emacs)</p>",
        "id": 209889897,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599929650
    },
    {
        "content": "<p>Okay, that works. I just made a snippet file for <code>yasnippet</code> that looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">#</span> <span class=\"n\">key</span><span class=\"o\">:</span> <span class=\"n\">funct</span>\n<span class=\"bp\">#</span> <span class=\"n\">name</span><span class=\"o\">:</span> <span class=\"n\">func_symb</span>\n<span class=\"bp\">#</span> <span class=\"c1\">--</span>\n<span class=\"err\">⥤$</span><span class=\"mi\">0</span>\n</code></pre></div>",
        "id": 209890071,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599929888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209889547\">said</a>:</p>\n<blockquote>\n<p>This is completely unrelated, but is there a simple way to input the functor symbol in emacs? <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span></p>\n</blockquote>\n<p>I think we might be allowed to add it to <code>lean-mode</code>.  All the input translations are defined by <code>lean-input-translations</code> in <a href=\"https://github.com/leanprover/lean-mode/blob/master/lean-input.el\">https://github.com/leanprover/lean-mode/blob/master/lean-input.el</a>  (though if you want to experiment locally, you can customize <code>lean-input-user-translations</code>)</p>\n<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\\Functor</code> (vs <code>\\functor</code>)?</p>",
        "id": 209896928,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599940000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209896928\">said</a>:</p>\n<blockquote>\n<p>Does VSCode already have a way to input the category theory functor symbol?  If not, maybe <code>\\Functor</code> (vs <code>\\functor</code>)?</p>\n</blockquote>\n<p>Yeah it's <code>\\functor</code> currently (<a href=\"https://github.com/leanprover/vscode-lean/blob/v0.16.13/translations.json#L1075\">source</a>)</p>",
        "id": 209897607,
        "sender_full_name": "Alex Peattie",
        "timestamp": 1599941116
    },
    {
        "content": "<p>oh sorry, I misunderstood <code>\\functor</code> is mapped to ⥤</p>",
        "id": 209897659,
        "sender_full_name": "Alex Peattie",
        "timestamp": 1599941170
    },
    {
        "content": "<p>I think \\func suffices in vscode.</p>",
        "id": 209897852,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599941499
    },
    {
        "content": "<p>Actually, that's useful to know.  It seems like <code>\\functor</code> in VSCode is <code>⥤</code> and <code>\\Rightarrow</code> is <code>⇒</code>, where in emacs <code>\\functor</code> and various other options give only <code>⇒</code>.</p>",
        "id": 209897896,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599941529
    },
    {
        "content": "<p>I wouldn't mind if <code>\\functor</code> in emacs were <code>⥤</code></p>",
        "id": 209897902,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599941561
    },
    {
        "content": "<p>Ok, here's a PR: <a href=\"https://github.com/leanprover/lean-mode/pull/29\">https://github.com/leanprover/lean-mode/pull/29</a></p>",
        "id": 209898224,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599942117
    },
    {
        "content": "<p>Does the melpa package mirror this?</p>",
        "id": 209898298,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599942203
    },
    {
        "content": "<p>I don't know how it works, other than changes I've made in the past eventually appear in melpa</p>",
        "id": 209898385,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599942315
    },
    {
        "content": "<p>Ok cool</p>",
        "id": 209898393,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599942340
    },
    {
        "content": "<p>I look forward to this getting merged!</p>",
        "id": 209898407,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599942361
    },
    {
        "content": "<p>If there are other missing symbols, this might be a good time to add them</p>",
        "id": 209898462,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1599942409
    },
    {
        "content": "<p>That's the main one I've been frustrated with. Maybe <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> has others he would like to see?</p>",
        "id": 209898527,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599942496
    },
    {
        "content": "<p>Nothing else comes to mind</p>",
        "id": 209898532,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599942530
    },
    {
        "content": "<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>",
        "id": 209903664,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599951665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/prefunctor.3F/near/209903664\">said</a>:</p>\n<blockquote>\n<p>Refactoring <code>functor</code> to use <code>prefunctor</code> (I like <code>diagram</code>!) sounds like a great idea.</p>\n</blockquote>\n<p>I agree. The question is how to do it. Note that to define a sufficiently nontrivial notion of a morphism between <code>prefunctor</code>s, you need to make some sort of <code>has_comp</code> class (in order to state the naturality condition).</p>",
        "id": 209905117,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599954312
    },
    {
        "content": "<p>Isn't <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.category_struct/src\">src#category_theory.category_struct</a> all that we need?</p>",
        "id": 209905932,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599955614
    },
    {
        "content": "<p>Oh right. And that also allows us to define an \"indentity\" morphism.</p>",
        "id": 209906341,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599956380
    },
    {
        "content": "<p>you guys can use <code>func</code> for <code>⥤</code> in Emacs by adding the following snippet as part of your <code>lean-mode-hook</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"p\">(</span><span class=\"nv\">lean-input-incorporate-changed-setting</span>\n   <span class=\"ss\">&#39;lean-input-user-translations</span>\n   <span class=\"o\">`</span><span class=\"p\">(</span> <span class=\"p\">(</span><span class=\"s\">&quot;func&quot;</span> <span class=\"s\">&quot;⥤&quot;</span><span class=\"p\">)</span>\n      <span class=\"p\">(</span><span class=\"s\">&quot;tf&quot;</span> <span class=\"s\">&quot;⟨╯°□°⟩╯︵┻━┻&quot;</span><span class=\"p\">)</span>\n<span class=\"p\">))</span>\n</code></pre></div>",
        "id": 209955189,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1600041297
    },
    {
        "content": "<p>tf?</p>",
        "id": 209955981,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600042684
    },
    {
        "content": "<p>It must be the little-used principle of <em>tabula furorem</em></p>",
        "id": 209956372,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600043319
    },
    {
        "content": "<p>Did you make any progress on <code>prefunctor</code> / <code>diagram</code>, <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>? We'll soon have three copies of the <code>lift</code>/ <code>ι</code> relationship ((<code>free</code>|<code>exterior</code>|<code>universal_enveloping</code>) <code>_algebra</code>), and I was looking at adding <code>clifford_algebra</code> too...</p>",
        "id": 211927329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601565807
    },
    {
        "content": "<p>Sorry, I've been busy with teaching :(</p>",
        "id": 211927376,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601565827
    },
    {
        "content": "<p>But I'm not sure the <code>lift</code> / <code>\\iota</code> stuff really relates to this.</p>",
        "id": 211927569,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601565890
    },
    {
        "content": "<p>How would you like to use these <code>diagram</code>s in this context?</p>",
        "id": 211927801,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601565971
    },
    {
        "content": "<p>You said yourself you wanted to use it to state the universal property, and I think somehow I saw a connection - but I can't see it any more.</p>",
        "id": 211928281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601566184
    },
    {
        "content": "<p>Oh, I was referring to the universal property specifically for the free category associated to a <code>diagram</code>.</p>",
        "id": 211928526,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601566265
    },
    {
        "content": "<p>the analogue of <code>\\iota</code> in that case is a <code>prefunctor</code>.</p>",
        "id": 211928555,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601566281
    },
    {
        "content": "<p>I think I was hoping for a bundling of <code>lift</code> and  <code>ι</code>, so that we can state the theorems about the bundle in just one place rather than repeating them</p>",
        "id": 211929072,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601566499
    },
    {
        "content": "<p>The bundle of <code>lift</code> and <code>\\iota</code> in this case just means that you have an initial object in some category, and initial objects are in mathlib already. But I don't necessarily think that's a more useful description than just keeping <code>lift</code> and <code>\\iota</code> around as is.</p>",
        "id": 211952981,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601576694
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 211955224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601577653
    },
    {
        "content": "<p>My preference would be for adding <em>in addition</em> to the existing <code>lift</code> and <code>\\iota</code> the formulation as an initial object.</p>",
        "id": 211990000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601596232
    },
    {
        "content": "<p>In practice one is usually happy to use the explicit <code>lift</code> and <code>\\iota</code> in most places. But it is a nice verification that we've really stated the right properties to have the initial object formulation.</p>",
        "id": 211990031,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1601596293
    },
    {
        "content": "<p>I agree with this. But the examples <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> mentioned are all left adjoints. I presume a better route would be to prove the adjunction <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 211992673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601598814
    },
    {
        "content": "<p>Some other category libraries have a notion like \"something determined by a universal property\", generally an initial/terminal object of a comma category, I think. Then this can be used to define limits and maybe adjunctions and so on.</p>",
        "id": 211993171,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599316
    },
    {
        "content": "<p>I think it's the kind of concept that in informal mathematics we can recognize but don't really have a name for.</p>",
        "id": 211993226,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599352
    },
    {
        "content": "<p>Because it is too basic/central somehow.</p>",
        "id": 211993234,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599365
    },
    {
        "content": "<p>Do you have an example of such a library in mind?</p>",
        "id": 211993241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601599382
    },
    {
        "content": "<p>Could this be a replacement for, e.g.  the localization stuff?</p>",
        "id": 211993274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601599431
    },
    {
        "content": "<p>e.g. <a href=\"https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168\">https://github.com/HoTT/HoTT/blob/master/theories/Categories/KanExtensions/Core.v#L167-L168</a></p>",
        "id": 211993322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599455
    },
    {
        "content": "<p><a href=\"https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69\">https://github.com/HoTT/HoTT/blob/master/theories/Categories/UniversalProperties.v#L68-L69</a></p>",
        "id": 211993346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599505
    },
    {
        "content": "<p><a href=\"https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37\">https://github.com/HoTT/HoTT/blob/092ebba509710c6e3eadbe03bc68049dd0b4ea0c/theories/Categories/Category/Objects.v#L36-L37</a></p>",
        "id": 211993383,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599562
    },
    {
        "content": "<p><a href=\"https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108\">https://github.com/HoTT/HoTT/blob/master/theories/Categories/Limits/Core.v#L107-L108</a></p>",
        "id": 211993440,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599582
    },
    {
        "content": "<p>Is this definition of initial objects correct? is the empty type contractible (in HoTT)?</p>",
        "id": 211993613,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601599821
    },
    {
        "content": "<p>It's the homsets out that are contractible</p>",
        "id": 211993639,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601599901
    },
    {
        "content": "<p>Oh right</p>",
        "id": 211993648,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601599916
    },
    {
        "content": "<p>wait I mean what happens if there are no morphisms from x to x'?</p>",
        "id": 211993727,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601600001
    },
    {
        "content": "<p>The empty type is not contractible</p>",
        "id": 211993741,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600039
    },
    {
        "content": "<p>(whoops internet is flaky in that room)</p>",
        "id": 211993782,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600052
    },
    {
        "content": "<p>I think one version of this concept is as follows. Sometimes, you have a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">U : D \\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> which doesn't necessarily have a left adjoint but for some particular <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">X \\in C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>, you can still find an object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>X</mi><mo>∈</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">FX \\in D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> such that for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> there's an iso <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>F</mi><mi>X</mi><mo separator=\"true\">,</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mrow><mi mathvariant=\"normal\">H</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">m</mi></mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo separator=\"true\">,</mo><mi>U</mi><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Hom}(FX, Y) = \\mathrm{Hom}(X, UY)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 211993900,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600246
    },
    {
        "content": "<p>for example, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi><mo>:</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mi>I</mi></msup></mrow><annotation encoding=\"application/x-tex\">U : C \\to C^I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span></span></span></span></span></span></span></span> could be the diagonal functor and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">FX</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> the colimit of a specific diagram <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">X : I \\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span></p>",
        "id": 211993960,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600301
    },
    {
        "content": "<p>We have the notion of a colimit of a specific diagram, and we know (I guess, or could easily add) that the whole colimit <em>functor</em> is adjoint to the diagonal functor when it exists, but AFAIK we don't have a way to say how an individual colimit is related to the diagonal functor.</p>",
        "id": 211994066,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600431
    },
    {
        "content": "<p>You can probably do something with cones</p>",
        "id": 211994109,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601600489
    },
    {
        "content": "<p>The cone category we have is basically a one-off construction of the comma category of the diagonal functor.</p>",
        "id": 211994191,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600584
    },
    {
        "content": "<p>whereas those HoTT library snippets I linked to build it up incrementally</p>",
        "id": 211994285,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600665
    },
    {
        "content": "<p>I have no idea how well that works for usability, of course</p>",
        "id": 211994290,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600673
    },
    {
        "content": "<p>For localization (of a ring, say, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><msup><mi>S</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[S^{-1}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>) you could look for an initial object of the full subcategory of the slice category consisting of the guys where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> gets sent to invertible elements. But I don't know if it's the most convenient way to say it.</p>",
        "id": 211994417,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601600860
    },
    {
        "content": "<p>I imagine there are a few styles that might possibly work, such as \"every concept is an initial/terminal object in some auxiliary category\", or \"every concept is a Kan extension\", or to do everything with profunctors and the coend calculus.</p>",
        "id": 211995032,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601601556
    },
    {
        "content": "<p>None of these approaches (if implemented in lean) would solve the issue of universes when defining the universal properties, would they?</p>",
        "id": 211995753,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601602384
    },
    {
        "content": "<p>I don't think so, and moreover I think this is actually a real math issue that we usually ignore (generally it's obvious once you've constructed the object that satisfies the universal property, but a priori the object could depend on the ambient universe).</p>",
        "id": 211997278,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601604392
    },
    {
        "content": "<p>I was just looking up a result in Makkai and Paré's book on accessible categories and I notice that they define the notions of (co)limit (co)cone in the generality being discussed here. They call a <code>has_hom</code> a \"graph* (actually I don't think they ever define the term \"graph\", but it's clear this must be what they mean) and a <code>prefunctor</code> a \"diagram\".</p>",
        "id": 214778481,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603841950
    },
    {
        "content": "<p>Also, I think in Higher Topos Theory (co)limits can be indexed on any simplicial set, which are basically the higher equivalent of graphs in this context.</p>",
        "id": 214778592,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603842039
    },
    {
        "content": "<p>Sounds good to me! (I wonder what the people in the secret graph theory stream think about this <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> ?)</p>",
        "id": 214783351,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603845825
    },
    {
        "content": "<p>It's public now!</p>",
        "id": 214783441,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1603845866
    },
    {
        "content": "<p>I think the graphs in mathlib are not so great at carrying data for other structures yet, but I bet Kyle would have useful opinions.</p>",
        "id": 214783478,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1603845904
    },
    {
        "content": "<p>I guess this was meant to lend weight more to the term \"diagram\" than the term \"graph\", which might mean other things elsewhere (though <code>category_theory.graph</code> seems okay, for a renaming of <code>category_theory.has_hom</code>?)</p>",
        "id": 214783644,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603846041
    },
    {
        "content": "<p>Maybe <code>has_arrow</code> instead of <code>has_hom</code>?</p>",
        "id": 214783722,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603846094
    },
    {
        "content": "<p>Or more precisely <code>has_arrow</code> (in the root namespace) instead of <code>category_theory.has_hom</code>?</p>",
        "id": 214783820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603846188
    },
    {
        "content": "<p>This notion of a graph sounds like a quiver to me (and quivers evoke category theory, which is a nice perk, compared to \"directed graph\").  Calling it a <code>quiver</code> might be too restrictive, though, if you want to study different collections of arrows on the same objects type, but I can't immediately think of a case where you'd want to do this.</p>\n<p>I like <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s suggestion, but maybe plural as <code>has_arrows</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_arrows</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">arrows</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"bp\">→</span> <span class=\"n\">obj</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 214799371,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603865844
    },
    {
        "content": "<p>To me (as someone working on representation theory of finite dimensional algebras and quivers), quiver sounds like the correct notion for that kind of object. It means precisely directed graph (with multiple arrows and loops allowed, and typically also has no finiteness restrictions). I definitely know use-cases where one would like to study different collections of arrows on the same object type. As discussed in some other graph theory thread previously, a typical other way to encode a quiver is via a collection of vertices (objects), a collection of arrows (homs) and two functions (in my area called either s and t or t and h, indicating the start and terminal vertex).</p>",
        "id": 214829321,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1603888394
    },
    {
        "content": "<p>The nlab agrees: <a href=\"https://ncatlab.org/nlab/show/quiver\">https://ncatlab.org/nlab/show/quiver</a></p>",
        "id": 214843257,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895108
    },
    {
        "content": "<p>Although my brain associates the term <code>quiver</code> specifically to a <code>diagram</code> with values in the category of <code>k</code>-vector spaces.</p>",
        "id": 214843563,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895235
    },
    {
        "content": "<p>Presumably this object is still going to underlie every category, though. I don't think it's really normal to say that the category of groups has an underlying \"quiver\" (<a href=\"https://ncatlab.org/nlab/show/concept+with+an+attitude#quivers\">https://ncatlab.org/nlab/show/concept+with+an+attitude#quivers</a>)</p>",
        "id": 214843655,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603895275
    },
    {
        "content": "<p>I agree. That's why I think <code>has_arrow(s)</code> is a good compromise between category theory and graph theory.</p>",
        "id": 214843820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895336
    },
    {
        "content": "<p>It still means we would change the name <code>hom</code> for the homsets of a category. Would we change the field name for the action of a functor too?</p>",
        "id": 214843936,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603895382
    },
    {
        "content": "<p>We could keep the name <code>hom X Y</code> for <code>has_arrow.arrow X Y</code> in the case where <code>X Y : C</code> and <code>C</code> is a category.</p>",
        "id": 214844207,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895491
    },
    {
        "content": "<p>How would we do that?</p>",
        "id": 214844346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603895544
    },
    {
        "content": "<p>Or just make <code>hom</code> an alias for <code>has_arrow.arrow</code>.</p>",
        "id": 214844370,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895560
    },
    {
        "content": "<p>Like as an abbreviation?</p>",
        "id": 214844372,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603895561
    },
    {
        "content": "<p>It's used in so many places in record constructor syntax, and as a component in other names, that it just feels like stirring up trouble to think about changing it...</p>",
        "id": 214844492,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603895630
    },
    {
        "content": "<p>Will this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.category</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_arrow</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">category_theory.has_hom</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 214845059,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603895888
    },
    {
        "content": "<p>It seems like the easiest thing is to call it a \"hom-graph\" in the docstring and then do nothing <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A \"hom-graph\" is a directed graph attached to a vertex type.  The</span>\n<span class=\"sd\">set of directed edges (\"arrows\") from vertex `a` to vertex `b` is</span>\n<span class=\"sd\">given by `hom a b`, for which this module provides the notation `a ⟶ b` -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_hom</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"o\">:</span> <span class=\"n\">obj</span> <span class=\"bp\">→</span> <span class=\"n\">obj</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n<p>Then we can say a quiver \"is\" a hom-graph, in the sense that a quiver's vertex type can be given a <code>has_hom</code> instance.  With one possible definition of a quiver:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">quiver</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">homs</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">homs</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">quiver.has_hom</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">quiver</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_hom</span> <span class=\"n\">Q.V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Q.homs</span> <span class=\"bp\">|</span> <span class=\"n\">Q.s</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">Q.t</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n<p>With this setup, it would be nice if prefunctors (or preprefunctors?) would apply to <code>has_hom</code> to be able to study quiver representations.</p>",
        "id": 214880606,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603910518
    },
    {
        "content": "<p>(I've wondered about the duality between defining directed graphs in terms of directed edge sets (<code>has_hom</code>) or as spans (<code>quiver</code>).  Is there a category theoretic name for the kind of object <code>has_hom</code> is?)</p>",
        "id": 214883599,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1603911846
    },
    {
        "content": "<p>In the case of graphs (without composition/category structure) this is the equivalence of categories between, for a fixed set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, the category of sets with a map to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and the category of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-indexed families of sets. I think this one is too basic to really have a name, but fancier versions of it go by names like the Grothendieck construction or straightening/unstraightening.</p>",
        "id": 214905554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603924159
    },
    {
        "content": "<p>For graphs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> would be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>×</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V \\times V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>.</p>",
        "id": 214905562,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603924169
    },
    {
        "content": "<p>For categories, the presentation in terms of <code>s</code> and <code>t</code> is as the models of an <a href=\"https://ncatlab.org/nlab/show/essentially+algebraic+theory\">essentially algebraic theory</a> while the one in terms of a family of sets indexed by two objects is as the modules of a <a href=\"https://ncatlab.org/nlab/show/generalized+algebraic+theory\">generalized algebraic theory</a>.</p>",
        "id": 214905693,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603924264
    },
    {
        "content": "<p>I also like to think of the first one as \"categories internal to Set\" and the second as \"categories enriched in Set\" although those phrases are likely to be confusing.</p>",
        "id": 214905923,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603924417
    },
    {
        "content": "<p>Another applications of quivers and diagrams that I dream of leanifying is the category of Nori motives, which built as quiver representation on a quiver of schemes.</p>",
        "id": 214929604,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603951623
    }
]
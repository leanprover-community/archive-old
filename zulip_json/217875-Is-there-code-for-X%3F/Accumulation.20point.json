[
    {
        "content": "<p>Since we now have a version of the identity theorem in mathlib, I'm trying to write a version which matches <a href=\"https://en.wikipedia.org/wiki/Identity_theorem\">wikipedia's statement</a> more closely - in particular using accumulation points. My understanding was that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cluster_pt\">docs#cluster_pt</a> is how mathlib talks about accumulation points, but stating the theorem like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">identity_theorem</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">â„‚</span> <span class=\"bp\">â†’</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hfD</span> <span class=\"o\">:</span> <span class=\"n\">analytic_on</span> <span class=\"n\">â„‚</span> <span class=\"n\">f</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hD</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hD'</span> <span class=\"o\">:</span> <span class=\"n\">is_connected</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"c1\">-- probably preconnected is enough</span>\n  <span class=\"o\">(</span><span class=\"n\">hSD</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">âŠ†</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hfS</span> <span class=\"o\">:</span> <span class=\"n\">S.eq_on</span> <span class=\"n\">f</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">cluster_pt</span> <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"c1\">-- z is an accumulation point of S</span>\n  <span class=\"n\">D.eq_on</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>can't work (it's not hard to show this is false). So what am I misunderstanding here? Presumably it's about accumulation points vs cluster_pt, but I can't quite figure it out</p>",
        "id": 302725931,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665084653
    },
    {
        "content": "<p>I commeted about this here: <a href=\"https://github.com/leanprover-community/mathlib/pull/16489#discussion_r971039654\">https://github.com/leanprover-community/mathlib/pull/16489#discussion_r971039654</a></p>",
        "id": 302726895,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665085071
    },
    {
        "content": "<p>Ah I see, so <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cluster_pt\">docs#cluster_pt</a> on principal filters doesn't correspond to accumulation points of sets, thanks!</p>",
        "id": 302727296,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665085228
    },
    {
        "content": "<p>Don't you simply want the analogue of <code>cluster_pt</code> but with punctured neighborhoods?</p>",
        "id": 302727350,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665085248
    },
    {
        "content": "<p>I mean <code>ğ“[â‰ ]  x</code> instead of  <code>ğ“ x</code></p>",
        "id": 302727487,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665085300
    },
    {
        "content": "<p>Ah, so <code>hz</code> should instead be <code>(hz : (ğ“[â‰ ] z âŠ“ ğ“Ÿ S).ne_bot)</code>? That seems reasonable to me</p>",
        "id": 302727609,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665085342
    },
    {
        "content": "<p>Indeed it is suspicious that <code>cluster_pt</code> doesn't give back the right notion for set. Maybe mathlib's definition is not the right one. We should check that.</p>",
        "id": 302727682,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665085372
    },
    {
        "content": "<p>I checked the definition of cluster point of a filter is the same in Bourbaki and in mathlib.</p>",
        "id": 302728896,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665085866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302728896\">said</a>:</p>\n<blockquote>\n<p>I checked the definition of cluster point of a filter is the same in Bourbaki and in mathlib.</p>\n</blockquote>\n<p>Hmm, does this then mean that cluster points of filters don't align as closely as I guessed to cluster points of sets?</p>",
        "id": 302729347,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665086041
    },
    {
        "content": "<p>No, it's just that cluster points and accumulation points are in general different concepts.</p>",
        "id": 302729796,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665086186
    },
    {
        "content": "<p>(At least, with the terminology I am used to)</p>",
        "id": 302730002,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665086260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302729796\">said</a>:</p>\n<blockquote>\n<p>No, it's just that cluster points and accumulation points are in general different concepts.</p>\n</blockquote>\n<p>In this case I'm confused at the docstring for <code>cluster_pt</code>, which says that these are also called accumulation points</p>",
        "id": 302730003,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665086260
    },
    {
        "content": "<p>aha, well, Wikipedia says my version of the terminology is nonstandard. It says that cluster point, accumulation point and limit point are all synonymous (with punctured nhds definition), and that <em>adherent point</em> is what mathlib currently calls cluster point. (I've never heard anyone use the term \"adherent point\" before though.)</p>",
        "id": 302730598,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665086454
    },
    {
        "content": "<p>Personally, I've frequently heard \"cluster point\" or \"limit point\" for the nhds version, and \"accumulation point\" for the punctured nhds version, but maybe I have just been exposed to weird sources.</p>",
        "id": 302731026,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665086594
    },
    {
        "content": "<p>It's pretty clear there are different notions and people disagree on terminology. It simply means we need to write really clear docstrings.</p>",
        "id": 302731462,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665086739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302730598\">said</a>:</p>\n<blockquote>\n<p>(I've never heard anyone use the term \"adherent point\" before though.)</p>\n</blockquote>\n<p>This may come from French. In French the closure of a set is called the \"adhÃ©rence\" of the set.</p>",
        "id": 302731743,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665086854
    },
    {
        "content": "<p>So now that I understand <code>cluster_pt</code>, my new goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Any hints?</p>",
        "id": 302732725,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665087273
    },
    {
        "content": "<p>It would certainly be useful to have some API around accumulation points and variants of that. I chose to spell it as <code>âˆƒá¶  z in ğ“[â‰ ] w, p z</code> because that felt natural at the time, but it probably isn't optimal.</p>",
        "id": 302734206,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665087895
    },
    {
        "content": "<p>Bahvik, are you asking for a Lean proof or a paper proof?</p>",
        "id": 302734405,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665087971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302734405\">said</a>:</p>\n<blockquote>\n<p>Bahvik, are you asking for a Lean proof or a paper proof?</p>\n</blockquote>\n<p>I understand the proof on paper - but I suspected there'd be a cleaner filter proof that I wouldn't be able to come up with on paper</p>",
        "id": 302734506,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665088018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302732725\">said</a>:</p>\n<blockquote>\n<p>So now that I understand <code>cluster_pt</code>, my new goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Any hints?</p>\n</blockquote>\n<p>The same statement is true with bounded, instead of compact, right?  It might be easier to prove with bounded, since any subset of a bounded set is again bounded.</p>",
        "id": 302734879,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1665088172
    },
    {
        "content": "<p>(In particular, on paper I'd pick a point from S, construct a sequence in S which is never equal to that point, then find a convergent subsequence, and its limit would be my choice of z. But my hope was that a cleverer filters proof could avoid going to sequences at all?)</p>",
        "id": 302734880,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665088173
    },
    {
        "content": "<p>Ah, sorry, I missed <code>z</code> is in <code>S</code>, not in the closure!</p>",
        "id": 302735004,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1665088208
    },
    {
        "content": "<p>There is no need to use sequences</p>",
        "id": 302735259,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665088313
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302735259\">said</a>:</p>\n<blockquote>\n<p>There is no need to use sequences</p>\n</blockquote>\n<p>In that case I don't see how to proceed, other than using sequences... I can't seem to find much linking infinite sets and topology in mathlib</p>",
        "id": 302736127,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665088640
    },
    {
        "content": "<p>Something to do with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_seq_compact.subseq_of_frequently_in\">docs#is_seq_compact.subseq_of_frequently_in</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_compact.is_seq_compact\">docs#is_compact.is_seq_compact</a> and <code>(âˆƒá¶  x in ğ“[â‰ ] z, x âˆˆ s) â†” (ğ“[â‰ ] z âŠ“ ğ“Ÿ s).ne_bot</code> (which I'm not sure is true)?</p>",
        "id": 302738368,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665089471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302738368\">said</a>:</p>\n<blockquote>\n<p>Something to do with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_seq_compact.subseq_of_frequently_in\">docs#is_seq_compact.subseq_of_frequently_in</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_compact.is_seq_compact\">docs#is_compact.is_seq_compact</a> and <code>(âˆƒá¶  x in ğ“[â‰ ] z, x âˆˆ s) â†” (ğ“[â‰ ] z âŠ“ ğ“Ÿ s).ne_bot</code> (which I'm not sure is true)?</p>\n</blockquote>\n<p>Yeah this is what I guessed too - but this uses sequences!</p>",
        "id": 302738450,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665089509
    },
    {
        "content": "<p>Ok, I'll have a look.</p>",
        "id": 302739092,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665089762
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 302739118,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665089768
    },
    {
        "content": "<p>you can always choose a nonprincipal ultrafilter on S, push it forward to C, and take its limit as your z.</p>",
        "id": 302739347,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665089876
    },
    {
        "content": "<p>I'm sure Patrick has a more elegant argument in mind ;)</p>",
        "id": 302739453,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665089907
    },
    {
        "content": "<p>It's getting late here so I wrote a blunt proof.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">inf_principal_ne_bot_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hS'</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">ne_empty_iff_nonempty</span><span class=\"o\">,</span> <span class=\"n\">not_ne_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hU'</span> <span class=\"n\">using</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">âˆˆ</span> <span class=\"bp\">ğ“</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">insert_mem_nhds_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hS.elim_nhds_subcover</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨</span><span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">hT</span><span class=\"o\">,</span> <span class=\"n\">hT'</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">âŠ†</span> <span class=\"bp\">â‹ƒ</span> <span class=\"n\">x</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">)âŸ©,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">subset.antisymm</span> <span class=\"n\">_</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hT'</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_Union</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hT'</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hT'</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hzy</span><span class=\"o\">âŸ©,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">U</span> <span class=\"n\">y</span> <span class=\"bp\">âˆ©</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">âŸ¨</span><span class=\"n\">hzy</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">hU'</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">hT</span> <span class=\"n\">y</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">T.finite_to_set</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302740447,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665090253
    },
    {
        "content": "<p>It's really not polished at all, but it types-check.</p>",
        "id": 302740498,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665090272
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 302740532,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665090284
    },
    {
        "content": "<p>A bit of polish:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">inf_principal_ne_bot_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hS'</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">ne_empty_iff_nonempty</span><span class=\"o\">,</span> <span class=\"n\">not_ne_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">choose</span><span class=\"bp\">!</span> <span class=\"n\">U</span> <span class=\"n\">hU</span> <span class=\"n\">hU'</span> <span class=\"n\">using</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">Î±</span><span class=\"o\">,</span>  <span class=\"n\">hT</span> <span class=\"o\">:</span> <span class=\"bp\">â†‘</span><span class=\"n\">T</span> <span class=\"bp\">âŠ†</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">hT'</span><span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">âŠ†</span> <span class=\"bp\">â‹ƒ</span> <span class=\"n\">x</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">x</span><span class=\"o\">)âŸ©</span> <span class=\"o\">:=</span>\n    <span class=\"n\">hS.elim_nhds_subcover</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">insert_mem_nhds_iff.mpr</span> <span class=\"o\">(</span><span class=\"n\">hU</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">)),</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">subset.antisymm</span> <span class=\"n\">_</span> <span class=\"n\">hT</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hT'</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_Union</span><span class=\"o\">,</span> <span class=\"n\">mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hT'</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hT'</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">hzy</span><span class=\"o\">âŸ©,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">U</span> <span class=\"n\">y</span> <span class=\"bp\">âˆ©</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"o\">âŸ¨</span><span class=\"n\">hzy</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">hU'</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">hT</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">T.finite_to_set</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302741786,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665090732
    },
    {
        "content": "<p>With a sequence <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">â„‚</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hS'.nat_embedding</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">â„“</span><span class=\"o\">,</span> <span class=\"n\">hâ„“</span><span class=\"o\">,</span> <span class=\"n\">Ï†</span><span class=\"o\">,</span> <span class=\"n\">hÏ†1</span><span class=\"o\">,</span> <span class=\"n\">hÏ†2</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">hS.is_seq_compact</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prop</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">â„“</span><span class=\"o\">,</span> <span class=\"n\">hâ„“</span><span class=\"o\">,</span> <span class=\"n\">inf_principal_ne_bot_iff.mpr</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">U</span> <span class=\"n\">hU</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)âŸ©,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:=</span> <span class=\"n\">hÏ†2</span> <span class=\"o\">(</span><span class=\"n\">insert_mem_nhds_iff.mpr</span> <span class=\"n\">hU</span><span class=\"o\">),</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">âˆƒ</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">N</span> <span class=\"bp\">â‰¤</span> <span class=\"n\">n</span> <span class=\"bp\">â†’</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">â‰ </span> <span class=\"n\">â„“</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">by_contra'</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">nâ‚</span><span class=\"o\">,</span> <span class=\"n\">hâ‚</span><span class=\"o\">,</span> <span class=\"n\">h'â‚</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">nâ‚‚</span><span class=\"o\">,</span> <span class=\"n\">hâ‚‚</span><span class=\"o\">,</span> <span class=\"n\">h'â‚‚</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">nâ‚</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n      <span class=\"n\">linarith</span> <span class=\"o\">[</span><span class=\"n\">f.inj'</span> <span class=\"o\">(</span><span class=\"n\">subtype.coe_injective</span> <span class=\"o\">(</span><span class=\"n\">h'â‚.trans</span> <span class=\"n\">h'â‚‚.symm</span><span class=\"o\">))]</span> <span class=\"o\">},</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">hN</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">N'</span><span class=\"o\">,</span> <span class=\"n\">hN'</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hN'</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">âŠ”</span> <span class=\"n\">N'</span><span class=\"o\">)</span> <span class=\"n\">le_sup_right</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hN</span> <span class=\"o\">(</span><span class=\"n\">Ï†</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">âŠ”</span> <span class=\"n\">N'</span><span class=\"o\">))</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_sup_left.trans</span> <span class=\"o\">(</span><span class=\"n\">hÏ†1.id_le</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">Ï†</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"bp\">âŠ”</span> <span class=\"n\">N'</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hN</span><span class=\"o\">,</span> <span class=\"n\">hN'</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hN'.resolve_left</span> <span class=\"n\">hN</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302751965,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665095254
    },
    {
        "content": "<p>Generalization to any topological space:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">hS'</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">filter.not_ne_bot</span><span class=\"o\">,</span> <span class=\"n\">filter.inf_principal_eq_bot</span><span class=\"o\">,</span> <span class=\"n\">mem_nhds_within</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hS'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">hS.elim_nhds_subcover'</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">S</span><span class=\"bp\">á¶œ</span> <span class=\"bp\">âˆª</span> <span class=\"o\">{</span><span class=\"n\">z</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.not_infinite.2</span> <span class=\"o\">((</span><span class=\"n\">t.finite_to_set.image</span> <span class=\"bp\">$</span> <span class=\"bp\">Î»</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">x.1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subset</span> <span class=\"bp\">$</span> <span class=\"bp\">Î»</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">ht</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">simp_rw</span> <span class=\"n\">set.mem_Union</span> <span class=\"n\">at</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hx'</span><span class=\"bp\">|</span><span class=\"n\">hx'</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">exacts</span> <span class=\"o\">[(</span><span class=\"n\">hx'</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span> <span class=\"o\">âŸ¨</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hx'.symm</span><span class=\"o\">âŸ©]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">âŸ¨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hzu</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"o\">âŸ©</span> <span class=\"o\">:=</span> <span class=\"n\">hS'</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_nhds_iff</span><span class=\"o\">,</span> <span class=\"n\">set.union_comm</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"o\">âŸ¨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">set.diff_subset_iff.1</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">hzu</span><span class=\"o\">âŸ©</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302757275,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665098323
    },
    {
        "content": "<p>The idea is that if S has no accumulation point then every point is isolated so it's a discrete subspace of X, which is compact iff it's finite.</p>",
        "id": 302757361,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665098389
    },
    {
        "content": "<p>My version was already in the same generality, with almost the same proof. The issue is not to compress a couple of lines, it is adding some api lemmas to make it obvious. Concretely, the target is to avoid using covers (which are really bad taste from a mathlib point of view). I'm away from my computer all day but I will do it tonight.</p>",
        "id": 302798494,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665129839
    },
    {
        "content": "<p>Ah, itâ€™s a shame that I didnâ€™t see that earlier because Iâ€™ve thought quite deeply about this last year during my course on holomorphic functions (and Iâ€™ve been explaining it periodically to some of my friends since then). Of course we werenâ€™t talking about filters but the generalization is pretty straightforward. The proof Iâ€™ve been taught is the one Junyan describes, and I think that this is the right one but we donâ€™t have the API ready for this. Basically I think any mathlib proof should go through <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_of_compact_of_discrete\">docs#finite_of_compact_of_discrete</a>.</p>",
        "id": 302799774,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665130380
    },
    {
        "content": "<p>We might also be able to cook up a direct proof not going through covers, but I think we want to have all the API to make that proof trivial anyway, so I donâ€™t think it is a problem to transitively use covers</p>",
        "id": 302800586,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665130692
    },
    {
        "content": "<p>That said, Adam's suggestion <em>does</em> look nice, at least in the non-relative case:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">infinite</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hyperfilter</span> <span class=\"n\">Î±</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">{</span><span class=\"n\">f.Lim</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">â†</span> <span class=\"n\">not_mem_iff_inf_principal_compl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finite_singleton</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nmem_hyperfilter</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">âŸ¨</span><span class=\"n\">f.Lim</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf_right</span> <span class=\"o\">(</span><span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">{</span><span class=\"n\">f.Lim</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">)</span> <span class=\"n\">f.le_nhds_Lim</span><span class=\"o\">)âŸ©</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302812397,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665135365
    },
    {
        "content": "<p>Going from the absolute case to the relative case is then a bit annoying, but here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">infinite</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">hS'.to_subtype</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">foo</span> <span class=\"n\">S</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">âŸ©,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"o\">(</span><span class=\"bp\">@@</span><span class=\"n\">filter.map_ne_bot</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"n\">hz</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">map_inf</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span> <span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"n\">inf_principal</span><span class=\"o\">,</span>\n      <span class=\"n\">map_principal</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">subtype.image_preimage_coe</span><span class=\"o\">,</span> <span class=\"n\">preimage_compl</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">continuous_subtype_coe</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">continuous_at</span>\n    <span class=\"o\">(</span><span class=\"n\">principal_mono.mpr</span> <span class=\"bp\">$</span> <span class=\"n\">monotone_image</span> <span class=\"bp\">$</span> <span class=\"n\">compl_subset_compl.mpr</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">coe</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">),</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302814523,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665136292
    },
    {
        "content": "<p>Here is my last word, now I have to focus on the lecture:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">infinite</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hyperfilter</span> <span class=\"n\">Î±</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">{</span><span class=\"n\">f.Lim</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">â†</span> <span class=\"n\">not_mem_iff_inf_principal_compl</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finite_singleton</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nmem_hyperfilter</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">âŸ¨</span><span class=\"n\">f.Lim</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf_right</span> <span class=\"o\">(</span><span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">{</span><span class=\"n\">f.Lim</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">)</span> <span class=\"n\">f.le_nhds_Lim</span><span class=\"o\">)âŸ©</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nhds_within_inf_principal</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">inf_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"bp\">â†</span> <span class=\"n\">inf_assoc</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">infinite</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">hS'.to_subtype</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">foo</span> <span class=\"n\">S</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">âŸ©,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"o\">(</span><span class=\"bp\">@@</span><span class=\"n\">filter.map_ne_bot</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"n\">hz</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">map_inf</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">nhds_within_eq_map_subtype_coe</span><span class=\"o\">,</span>\n      <span class=\"n\">nhds_within_inf_principal</span><span class=\"o\">,</span> <span class=\"n\">map_principal</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"n\">inf_le_inf_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">principal_mono.mpr</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">convert</span> <span class=\"n\">image_compl_subset</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_singleton</span><span class=\"o\">,</span> <span class=\"n\">singleton_eq_singleton_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302817386,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665137380
    },
    {
        "content": "<p>I realised that we can use <code>cluster_pt</code>, just slightly differently: <code>cluster_pt x (ğ“Ÿ (S \\ {x})) â†” (ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot â†” x âˆˆ closure (S \\ {x})</code></p>",
        "id": 302862405,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665152443
    },
    {
        "content": "<p>Last version, proving directly the relative case, is still not satisfying, and I need to stop playing with this <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_coe_le_principal</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">map</span> <span class=\"n\">coe</span> <span class=\"n\">f</span> <span class=\"bp\">â‰¤</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"n\">le_principal_iff.mpr</span> <span class=\"bp\">$</span> <span class=\"bp\">@@</span><span class=\"n\">mem_of_superset</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">univ_mem</span> <span class=\"n\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">x.2</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"n\">inf_principal</span><span class=\"o\">],</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">infinite</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">hS'.to_subtype</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ultrafilter</span> <span class=\"n\">Î±</span> <span class=\"o\">:=</span> <span class=\"n\">ultrafilter.map</span> <span class=\"n\">coe</span> <span class=\"o\">(</span><span class=\"n\">hyperfilter</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">hS.ultrafilter_le_nhds</span> <span class=\"n\">f</span> <span class=\"n\">map_coe_le_principal</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">({</span><span class=\"n\">z</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span> <span class=\"bp\">âˆ©</span> <span class=\"n\">S</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">compl_compl</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">compl_union</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">not_mem_iff_inf_principal_compl</span><span class=\"o\">],</span>\n    <span class=\"n\">change</span> <span class=\"n\">coe</span> <span class=\"bp\">â»Â¹'</span> <span class=\"n\">_</span> <span class=\"bp\">âˆ‰</span> <span class=\"n\">hyperfilter</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">preimage_union</span><span class=\"o\">,</span> <span class=\"n\">subtype.preimage_coe_compl</span><span class=\"o\">,</span> <span class=\"n\">union_empty</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">finite_singleton</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">preimage</span> <span class=\"bp\">$</span> <span class=\"n\">subtype.coe_injective.inj_on</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nmem_hyperfilter</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf_right</span> <span class=\"n\">_</span> <span class=\"n\">hz</span><span class=\"o\">)âŸ©</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302875216,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665155693
    },
    {
        "content": "<p>I'd say we should add API for both the version through <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_of_compact_of_discrete\">docs#finite_of_compact_of_discrete</a> and the version using ultrafilters and then see which one is cleaner, because both proofs should be easier than what they are right now</p>",
        "id": 302875604,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1665155802
    },
    {
        "content": "<p>Here is my proposal filling API holes for the <code>finite_of_compact_of_discrete</code> route:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.principal_eq_map_coe_top</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ¤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.inf_principal_eq_bot_iff_comap</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"bp\">â†”</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter.principal_eq_map_coe_top</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">filter.push_pull'</span><span class=\"o\">,</span><span class=\"n\">inf_top_eq</span><span class=\"o\">,</span> <span class=\"n\">map_eq_bot_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">discrete_topology_iff_nhds</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">Î±</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span> <span class=\"bp\">;</span> <span class=\"n\">introI</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nhds_discrete</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq_of_nhds_eq_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nhds_discrete</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">discrete_topology_iff_nhds_neq</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">Î±</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">discrete_topology_iff_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">inf_principal_eq_bot</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span> <span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">singleton_mem_pure</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_pure_iff.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pure_le_nhds</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype.discrete_topology_iff</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">S</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">discrete_topology_iff_nhds_neq</span><span class=\"o\">,</span> <span class=\"n\">set_coe.forall'</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter.inf_principal_eq_bot_iff_comap</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">comap_inf</span><span class=\"o\">,</span> <span class=\"n\">comap_principal</span><span class=\"o\">,</span>\n      <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">image_singleton</span><span class=\"o\">,</span> <span class=\"n\">function.injective.preimage_image</span> <span class=\"n\">subtype.coe_injective</span><span class=\"o\">,</span>\n      <span class=\"n\">nhds_induced</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_compact.finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S.finite</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite_coe_iff.mp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finite_of_compact_of_discrete</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"n\">hS</span><span class=\"o\">)</span> <span class=\"n\">hS'</span><span class=\"o\">)</span>\n\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">not_ne_bot</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hS'</span> <span class=\"o\">(</span><span class=\"n\">hS.finite</span> <span class=\"bp\">$</span> <span class=\"n\">subtype.discrete_topology_iff.mpr</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302914085,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665168104
    },
    {
        "content": "<p>I'll do the ultrafilter road later.</p>",
        "id": 302914136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665168122
    },
    {
        "content": "<p>I went back to this. Now I claim the preliminaries for both roads are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.subset_properties</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">filter</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">principal_eq_map_coe_top</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ¤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inf_principal_eq_bot_iff_comap</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"bp\">â†”</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">filter.principal_eq_map_coe_top</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">filter.push_pull'</span><span class=\"o\">,</span><span class=\"n\">inf_top_eq</span><span class=\"o\">,</span> <span class=\"n\">map_eq_bot_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ne_bot_of_comap</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"n\">Î²</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î²</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î²</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F.ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ne_bot_iff</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">comap_bot</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">end</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">discrete_topology_iff_nhds</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">Î±</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">pure</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span> <span class=\"bp\">;</span> <span class=\"n\">introI</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nhds_discrete</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">constructor</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">eq_of_nhds_eq_nhds</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nhds_discrete</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">discrete_topology_iff_nhds_neq</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">Î±</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">discrete_topology_iff_nhds</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">forall_congr</span> <span class=\"o\">(</span><span class=\"bp\">Î»</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">inf_principal_eq_bot</span><span class=\"o\">,</span> <span class=\"n\">compl_compl</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span> <span class=\"bp\">;</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">singleton_mem_pure</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">le_pure_iff.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pure_le_nhds</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype.nhds_within_eq_bot_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">ğ“</span><span class=\"o\">[(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">â†’</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">â»Â¹'</span> <span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"bp\">â†”</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"n\">t</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inf_principal_eq_bot_iff_comap</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">nhds_within</span><span class=\"o\">,</span> <span class=\"n\">comap_inf</span><span class=\"o\">,</span> <span class=\"n\">comap_principal</span><span class=\"o\">,</span>\n       <span class=\"n\">nhds_induced</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype.nhds_ne_eq_bot_iff</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">ğ“</span><span class=\"o\">[{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"bp\">â†”</span> <span class=\"bp\">ğ“</span><span class=\"o\">[{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">â†</span> <span class=\"n\">subtype.nhds_within_eq_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">preimage_compl</span><span class=\"o\">,</span> <span class=\"bp\">â†</span> <span class=\"n\">image_singleton</span><span class=\"o\">,</span>\n       <span class=\"n\">subtype.coe_injective.preimage_image</span> <span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype.nhds_ne_ne_bot_iff</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">]</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"bp\">â†”</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[{</span><span class=\"n\">x</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ne_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">ne_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">not_iff_not</span><span class=\"o\">,</span> <span class=\"n\">subtype.nhds_ne_eq_bot_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subtype.discrete_topology_iff</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">S</span> <span class=\"bp\">â†”</span> <span class=\"bp\">âˆ€</span> <span class=\"n\">x</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">x</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span> <span class=\"bp\">=</span> <span class=\"bp\">âŠ¥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">discrete_topology_iff_nhds_neq</span><span class=\"o\">,</span> <span class=\"n\">set_coe.forall'</span><span class=\"o\">,</span> <span class=\"n\">subtype.nhds_ne_eq_bot_iff</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_compact.finite</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">discrete_topology</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">S.finite</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite_coe_iff.mp</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finite_of_compact_of_discrete</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"n\">hS</span><span class=\"o\">)</span> <span class=\"n\">hS'</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 302940875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665180148
    },
    {
        "content": "<p>And then we get to choose between the discrete road:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">infinite</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">not_ne_bot</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">discrete_topology_iff_nhds_neq.mpr</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">infinite.not_finite</span> <span class=\"o\">(</span><span class=\"n\">finite_of_compact_of_discrete</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">Î±</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_contra'</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"n\">not_ne_bot</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hS'</span> <span class=\"o\">(</span><span class=\"n\">hS.finite</span> <span class=\"bp\">$</span> <span class=\"n\">subtype.discrete_topology_iff.mpr</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and the ultrafilter road:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">compact_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">infinite</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Î±</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">hyperfilter</span> <span class=\"n\">Î±</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">Î±</span><span class=\"o\">)</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"o\">{</span><span class=\"n\">f.Lim</span><span class=\"o\">}</span><span class=\"bp\">á¶œ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span><span class=\"o\">,</span>\n    <span class=\"k\">from</span> <span class=\"n\">not_mem_iff_inf_principal_compl.mp</span> <span class=\"o\">(</span><span class=\"n\">finite_singleton</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">nmem_hyperfilter</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">âŸ¨</span><span class=\"n\">f.Lim</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ne_bot_of_le</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf_right</span> <span class=\"n\">_</span> <span class=\"n\">f.le_nhds_Lim</span><span class=\"o\">)âŸ©</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">Î±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Î±</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Î±</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hS</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hS'</span> <span class=\"o\">:</span> <span class=\"n\">S.infinite</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">âˆƒ</span> <span class=\"n\">z</span> <span class=\"bp\">âˆˆ</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">ğ“</span><span class=\"o\">[</span><span class=\"bp\">â‰ </span><span class=\"o\">]</span> <span class=\"n\">z</span> <span class=\"bp\">âŠ“</span> <span class=\"bp\">ğ“Ÿ</span> <span class=\"n\">S</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ne_bot</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">compact_space</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">is_compact_iff_compact_space.mp</span> <span class=\"n\">hS</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">infinite</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">hS'.to_subtype</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">foo</span> <span class=\"n\">S</span> <span class=\"k\">with</span> <span class=\"o\">âŸ¨âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">âŸ©,</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">âŸ¨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hzS</span><span class=\"o\">,</span> <span class=\"n\">subtype.nhds_ne_ne_bot_iff.mp</span> <span class=\"n\">hz</span><span class=\"o\">âŸ©</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 302940941,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665180190
    },
    {
        "content": "<p>Anatole, note in particular how deducing the relative version from the absolute one is now painless.</p>",
        "id": 302940972,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665180212
    },
    {
        "content": "<p>And of course the last proof above deducing the relative version from the absolute one could also be used in the discrete road.</p>",
        "id": 302941531,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665180537
    },
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/16862\">#16862</a>. I used the discrete set path since it is more elementary and not longer, but I included preliminary lemmas for both proofs.</p>",
        "id": 302985670,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665219992
    },
    {
        "content": "<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>",
        "id": 303005021,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665229496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303005021\">said</a>:</p>\n<blockquote>\n<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>\n</blockquote>\n<p>I don't think this is necessary any more, since we can use <code>cluster_pt x (ğ“Ÿ (S \\ {x}))</code> in place of <code>(ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot</code></p>",
        "id": 303044122,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665249286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/302985670\">said</a>:</p>\n<blockquote>\n<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/16862\">#16862</a>. I used the discrete set path since it is more elementary and not longer, but I included preliminary lemmas for both proofs.</p>\n</blockquote>\n<p>Thanks so much for this Patrick!</p>",
        "id": 303044210,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1665249343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303044122\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"242586\">Vincent Beffara</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Accumulation.20point/near/303005021\">said</a>:</p>\n<blockquote>\n<p>Should we also settle on one definition to be named <code>accumulation_pt</code> and something or other for the relative version, and add two tfae lemmas for the various equivalent versions? And use that instead of the explicit <code>ne_bot</code> version in mathlib where possible?</p>\n</blockquote>\n<p>I don't think this is necessary any more, since we can use <code>cluster_pt x (ğ“Ÿ (S \\ {x}))</code> in place of <code>(ğ“[â‰ ] x âŠ“ ğ“Ÿ S).ne_bot</code></p>\n</blockquote>\n<p>I'm not sure I agree with this, especially if one of our goals is to cover the whole undergrad curriculum and be accessible to \"normal mathematicians\" who know about accumulation points and not about filters. They would likely prefer either <code>x âˆˆ closure (S \\ {x})</code> or perhaps  <code>âˆƒá¶  z in ğ“[â‰ ] x, z âˆˆ S</code> (which I always read in my head as \"there is a sequence tending to x, except without the pathological stuff about sequences not appearing because something something filter). That being the same as a statement in terms of principal filters, which indeed make some proofs easier further down the line, is an \"implementation detail\", and IMHO should be hidden from the API.</p>\n<p>After all we do have a definition of <code>continuous_at</code> in mathlib even though we could inline it everywhere as <code>tendsto f (ğ“ x) (ğ“ (f x))</code> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 303205628,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665384881
    },
    {
        "content": "<p>The <code>cluster_pt</code> definition was already introduced  for the sake of having more readable statements. This has a cost since every definition must come with lemmas, otherwise the first step in any proof is always to unfold the definition. But if there are sufficiently many statements that would benefit from the definition then it can be worth the trouble. So you can try. Note also that <code>tendsto f A B</code> is already a somewhat useless wrapper around the core definitions which are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.map\">docs#filter.map</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.partial_order\">docs#filter.partial_order</a>, and <code>map f A â‰¤ B</code> is actually shorter to type and more evocative. And you can read <code>âˆƒá¶  z in ğ“[â‰ ] x, z âˆˆ S</code> as \"there exist a point near x but different from x that belongs to S\", without thinking in terms of sequences.</p>",
        "id": 303214785,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665389804
    },
    {
        "content": "<p>Agreed on everything, except that very few people in math departments would find <code>map f A â‰¤ B</code> on filters to be more evocative than <code>tendsto</code> or <code>continuous_at</code> :-) and <code>tendsto</code> is not so useless if it is close to everyday mathematicians' use while at the same time enabling dot-notation use in proofs.</p>\n<p>I was partly joking about <code>âˆƒá¶ </code> (only partly because depending on the kind of math one is doing, \"you can find a point arbitrarily close to x\" and \"you can find a sequence that converges to x\" can feel indistinguishable), but I maintain that informal mathematicians would prefer it to cluster points of filters...</p>",
        "id": 303219530,
        "sender_full_name": "Vincent Beffara",
        "timestamp": 1665391566
    },
    {
        "content": "<p>Sure, I wasn't suggesting we get rid of <code>tendsto</code>, this was an argument in favor of keeping \"useless\" definitions. It would still be nice to have more mathematicians thinking in terms of filters, but this is unlikely to happen.</p>",
        "id": 303220114,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1665391811
    }
]
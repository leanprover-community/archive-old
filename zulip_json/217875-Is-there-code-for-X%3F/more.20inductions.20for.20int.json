[
    {
        "content": "<p>I (think I) currently need the int-equivalents of <code>nat.le_induction</code> and <code>nat.decreasing_induction</code>. I’d add them unless someone tells me that my abilities to search for existing lemmas have proven insufficient.</p>",
        "id": 276121282,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1647901086
    },
    {
        "content": "<p>I guess they are just specializations of <a href=\"https://leanprover-community.github.io/mathlib_docs/data/int/basic.html#int.induction_on%27\">https://leanprover-community.github.io/mathlib_docs/data/int/basic.html#int.induction_on%27</a></p>",
        "id": 276122729,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1647902209
    },
    {
        "content": "<p>Ouch, that has nasty equation lemmas</p>",
        "id": 276124263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647903434
    },
    {
        "content": "<p>Both lemmas follow directly from <code>int.induction_on'</code></p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.le_induction</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">int.induction_on'</span> <span class=\"n\">n</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"n\">ih</span> <span class=\"n\">P</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">k</span> <span class=\"n\">h₁</span> <span class=\"n\">ih</span> <span class=\"n\">P</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:=</span> <span class=\"n\">h₁.trans</span> <span class=\"n\">h₄</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">h₅</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">sub_one_lt</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.decreasing_induction</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">P</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">int.induction_on'</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">k</span> <span class=\"n\">h₁</span> <span class=\"n\">ih</span> <span class=\"n\">P</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"n\">h₅</span> <span class=\"o\">:=</span> <span class=\"n\">h₂.trans</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">h₅</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">lt_add_one</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">k</span> <span class=\"n\">h₁</span> <span class=\"n\">ih</span> <span class=\"n\">P</span> <span class=\"n\">h₂</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">sub_add_cancel</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ih</span> <span class=\"n\">h₁</span> <span class=\"n\">h₃</span> <span class=\"n\">h₄</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>\n<p>I think the bias is against adding new induction principles if they follow from existing ones (see <a href=\"#narrow/stream/116395-maths/topic/induction.20on.20degree.20of.20polynomial/near/275915403\">this</a> for example).</p>",
        "id": 276129671,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1647907633
    },
    {
        "content": "<p>In LTE I recently added</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- src/for_mathlib/triangle_shift.lean L426L433</span>\n<span class=\"kd\">@[elab_as_eliminator]</span> <span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">_root_.int.induction_on_iff</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">i</span> <span class=\"n\">using</span> <span class=\"n\">int.induction_on</span> <span class=\"k\">with</span> <span class=\"n\">i</span> <span class=\"n\">IH</span> <span class=\"n\">i</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hz</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rwa</span> <span class=\"bp\">←</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_add_cancel</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276148304,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647930875
    },
    {
        "content": "<p>Another thing that's missing is something which is definitionally <code>nat.rec</code> but uses +1 instead of <code>succ</code>. I would like to see this one in mathlib but it definitely follows from something which is already there :-)</p>",
        "id": 276154014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647936464
    },
    {
        "content": "<p><code>match n with | 0 := _ | (n + 1) := _ end</code> is one way to spell that recursor, but I guess that's annoying</p>",
        "id": 276160413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647940751
    },
    {
        "content": "<p>I have written a \"multiplicative induction\" principle, since I needed it for my work on the Hilbert symbol:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">### Establish an induction principle for multiplicatively closed properties</span>\n\n<span class=\"cm\">If `P : ℕ → Prop` satisfies `P 0`, `P 1`, `P p` for every prime number `p`</span>\n<span class=\"cm\">and `∀ (m n : ℕ), P m → P n → P (m*n)`, then `P n` holds for all `n : ℕ`.</span>\n\n<span class=\"cm\">Similarly for `P : ℤ → Prop`, with `P (-1)` added for good measure.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">multiplicative_induction</span>\n\n<span class=\"sd\">/-- The principle of multiplicative induction for natural numbers -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">nat_multiplicative_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmult</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- easy case `n = 0`</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h0</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- now `n &gt; 0`; take its factors</span>\n  <span class=\"k\">let</span> <span class=\"n\">nf</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">n.factors</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">nfp</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">nf</span><span class=\"o\">,</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nf</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">nat.prime_of_mem_factors</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hp'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">nf</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hp</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nfp</span> <span class=\"n\">p</span> <span class=\"n\">hyp</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">nf.prod</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nf</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">nat.prod_factors</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">multiset.prod_induction</span> <span class=\"n\">P</span> <span class=\"n\">nf</span> <span class=\"n\">hmult</span> <span class=\"n\">h1</span> <span class=\"n\">hp'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- The principle of multiplicative induction for natural numbers -/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">int_multiplicative_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmult</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"c1\">-- reduce to the case of natural numbers</span>\n  <span class=\"k\">let</span> <span class=\"n\">P'</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"bp\">↑</span><span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hmult'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">P'</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P'</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P'</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">P'</span><span class=\"o\">],</span> <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hmult</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- this gives us the statement for `|n|`</span>\n  <span class=\"k\">have</span> <span class=\"n\">hP'</span> <span class=\"o\">:=</span> <span class=\"n\">nat_multiplicative_induction</span> <span class=\"n\">P'</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption_mod_cast</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption_mod_cast</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">assumption_mod_cast</span><span class=\"o\">)</span> <span class=\"n\">hmult'</span> <span class=\"n\">n.nat_abs</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">P'</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hP'</span><span class=\"o\">,</span> <span class=\"c1\">-- gives `P ↑n.nat_abs`</span>\n  <span class=\"c1\">-- split according to sign</span>\n  <span class=\"n\">cases</span> <span class=\"n\">int.nat_abs_eq</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">hn</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- `n = ↑n.nat_abs`</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hn</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hP'</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- `n = -↑n.nat_abs`</span>\n    <span class=\"n\">rw</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">ring</span> <span class=\"o\">:</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">n.nat_abs</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">*↑</span><span class=\"n\">n.nat_abs</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hmult</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">n.nat_abs</span> <span class=\"n\">hn1</span> <span class=\"n\">hP'</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">multiplicative_induction</span>\n</code></pre></div>\n<p>Would it make sense to include that?</p>",
        "id": 276162376,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647941995
    },
    {
        "content": "<p>Yes, those look useful to me. Note that the second docstring should say <code>integers</code> instead of <code>natural numbers</code></p>",
        "id": 276162659,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647942164
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">induction_on_primes</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 276162681,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647942184
    },
    {
        "content": "<p>Ooh, does that already exist?</p>",
        "id": 276162714,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1647942212
    },
    {
        "content": "<p>Yup: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/induction_on_primes\">docs#induction_on_primes</a> which is based on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.induction_on_prime\">docs#unique_factorization_monoid.induction_on_prime</a></p>",
        "id": 276162844,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647942295
    },
    {
        "content": "<p>Not sure why one is \"prime\" and the other \"primes\"</p>",
        "id": 276162870,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647942306
    },
    {
        "content": "<p>But note that my main assumption is different (multiplicative closure instead of closure under multiplication by a prime).</p>",
        "id": 276163109,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647942477
    },
    {
        "content": "<p>And I really needed the version for integers.</p>",
        "id": 276163575,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647942748
    },
    {
        "content": "<p>The nat one is pretty similar:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nat_multiplicative_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmult</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"n\">induction_on_primes</span> <span class=\"n\">h0</span> <span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"n\">pp</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hmult</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"n\">pp</span><span class=\"o\">)</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"n\">n</span>\n</code></pre></div>",
        "id": 276165382,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647943725
    },
    {
        "content": "<p>OK, that simplifies things a bit...</p>",
        "id": 276165729,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647943920
    },
    {
        "content": "<p>Michael, one thing that I have learned using mathlib, is that if I can prove a result in <code>n</code> lines, someone in this chat can prove it in 1.</p>",
        "id": 276166354,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647944271
    },
    {
        "content": "<p>... by induction <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 276166420,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647944293
    },
    {
        "content": "<p>The library already contains <em>a lot</em> of results and someone will certainly know the exact one that is closest to the one you want and will be able to tell you.</p>",
        "id": 276166460,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647944316
    },
    {
        "content": "<p>Yeah, but it would really help to have a way of finding these oneself <em>quickly</em>!</p>",
        "id": 276166696,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944462
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276166749,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944504
    },
    {
        "content": "<p>This is what this chat is for!</p>",
        "id": 276166750,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647944504
    },
    {
        "content": "<p>And the naming convention!</p>",
        "id": 276166762,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647944513
    },
    {
        "content": "<p>With time, you will be able to prove your results in <code>n/2</code> lines...</p>",
        "id": 276166767,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647944519
    },
    {
        "content": "<p>I find that what is holding me up the most is<br>\n(1) getting Lean to prove the obvious<br>\n(2) figuring out where to find what I need in mathlib</p>",
        "id": 276166869,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944574
    },
    {
        "content": "<p>Is there work under way addressing these issues?</p>",
        "id": 276166911,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944600
    },
    {
        "content": "<p>Regarding (1), I would imagine some amount of (most likely AI-supported) heuristic proof search that goes more than one level deep.</p>",
        "id": 276167025,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944650
    },
    {
        "content": "<p>When I was even more of a beginner than now, I found <code>tidy</code> very useful.</p>",
        "id": 276167144,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647944732
    },
    {
        "content": "<p>int is perhaps worth adding, though:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">int_multiplicative_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmult</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hp'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">prime</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">pp</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">p.nat_abs</span> <span class=\"o\">:=</span> <span class=\"n\">hp</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">int.prime_iff_nat_abs_prime.mp</span> <span class=\"n\">pp</span><span class=\"o\">),</span>\n    <span class=\"n\">obtain</span> <span class=\"n\">hp'</span><span class=\"bp\">|</span><span class=\"n\">hp'</span> <span class=\"o\">:=</span> <span class=\"n\">int.nat_abs_eq</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">hp'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">neg_one_mul</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">hmult</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hn1</span> <span class=\"n\">this</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">unique_factorization_monoid.induction_on_prime</span> <span class=\"n\">n</span> <span class=\"n\">h0</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">int.is_unit_eq_one_or</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">h1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hn1</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">p</span> <span class=\"n\">haz</span> <span class=\"n\">pp</span> <span class=\"n\">hpa</span><span class=\"o\">,</span> <span class=\"n\">hmult</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hp'</span> <span class=\"n\">_</span> <span class=\"n\">pp</span><span class=\"o\">)</span> <span class=\"n\">hpa</span><span class=\"o\">),</span>\n<span class=\"c\">/-</span><span class=\"cm\"> Or more painful:</span>\n<span class=\"cm\">  induction h : n.nat_abs using nat_multiplicative_induction with k ih generalizing n,</span>\n<span class=\"cm\">  { rwa int.eq_zero_of_nat_abs_eq_zero h, },</span>\n<span class=\"cm\">  { simp only [int.nat_abs_eq_iff, int.coe_nat_zero, int.coe_nat_succ, zero_add] at h,</span>\n<span class=\"cm\">    obtain rfl|rfl := h; assumption },</span>\n<span class=\"cm\">  { exact hp' n (int.prime_iff_nat_abs_prime.mpr (h.symm ▸ ih)), },</span>\n<span class=\"cm\">  { rw ←int.sign_mul_nat_abs n_1,</span>\n<span class=\"cm\">    apply hmult,</span>\n<span class=\"cm\">    { obtain hs|rfl|hs := lt_trichotomy 0 n_1,</span>\n<span class=\"cm\">      { rwa int.sign_eq_one_of_pos hs, },</span>\n<span class=\"cm\">      { rwa int.sign_zero },</span>\n<span class=\"cm\">      { rwa int.sign_eq_neg_one_of_neg hs } },</span>\n<span class=\"cm\">    { rw [h, int.coe_nat_mul],</span>\n<span class=\"cm\">      apply hmult,</span>\n<span class=\"cm\">      apply ᾰ,</span>\n<span class=\"cm\">      apply int.nat_abs_of_nat,</span>\n<span class=\"cm\">      apply ᾰ_1,</span>\n<span class=\"cm\">      apply int.nat_abs_of_nat } },</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276167167,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647944750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/more.20inductions.20for.20int/near/276166869\">said</a>:</p>\n<blockquote>\n<p>(2) figuring out where to find what I need in mathlib</p>\n</blockquote>\n<p>Maybe it's Stockholm system, but all of us, even the \"experts\", have got very used to this human-based library search.  It's so fast (and sociable) that it becomes less urgent to find automated alternatives.</p>",
        "id": 276167239,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647944774
    },
    {
        "content": "<p>I frequently try <code>suggest</code>, but I find it rarely to be helpful. Sometimes it comes up with <code>exact ...</code>and then I'm happy, but mostly I get a long list of useless stuff. E.g., when the goal is an equality, you get a list of results that can in principle prove an equality, but which are completely unrelated to the shape of the terms involved. (This could be related to the fact(?) that <code>suggest</code> sorts the results by length of lemma name, which tends to put unspecific ones first. Perhaps this could be changed so that the most specific ones appear on top?)</p>",
        "id": 276167282,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944805
    },
    {
        "content": "<p>There is <code>suggest ... using ...</code> which filters out the results to the ones that use the hypotheses you give in the second <code>...</code></p>",
        "id": 276167406,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647944864
    },
    {
        "content": "<p>Often I find that using Zulip is faster than waiting for <code>library_search</code> on my machine</p>",
        "id": 276167415,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647944871
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> My proof was not that much longer (minus the comment lines) <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276167422,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944875
    },
    {
        "content": "<p>Nobody can know the full library, but you sure can know your own little folder by heart.</p>",
        "id": 276167498,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647944903
    },
    {
        "content": "<p>I find myself not remembering the names of lemmas that I used yesterday. Maybe this is just old age approaching...</p>",
        "id": 276167559,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647944943
    },
    {
        "content": "<p>I can recite you everything that's under <code>order.</code>, <code>combinatorics.</code>, <code>analysis.convex.</code>. I have no idea what's under <code>measure_theory.</code> however.</p>",
        "id": 276167561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647944943
    },
    {
        "content": "<p>The idea is that you can then know about any bit of the library by asking the right person.</p>",
        "id": 276167831,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647945102
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.rec_on_prime_pow\">docs#nat.rec_on_prime_pow</a> too, created as I was unaware (until today!) of the induction that Ruben mentioned</p>",
        "id": 276167838,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647945106
    },
    {
        "content": "<p>(there's some other spellings below that, too, which are helpful)</p>",
        "id": 276167976,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647945177
    },
    {
        "content": "<p>I started a list of all <code>ℕ</code> recursors in the module docstring of <a href=\"https://tqft.net/mathlib/data/nat/basic\">file#data/nat/basic</a> to avoid this precise situation. Please add yours!</p>",
        "id": 276167978,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647945180
    },
    {
        "content": "<p>Surely we should only put the ones in that file there? I'm happy to plop them there regardless <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span>🏻‍♀️</p>",
        "id": 276168414,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1647945401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/more.20inductions.20for.20int/near/276167422\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> My proof was not that much longer (minus the comment lines) <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>Yeah, it wasn't as easy to derive from the general result as I'd hoped; it didn't really like the <code>∀ (p : ℕ), nat.prime p → P ↑p</code> formulation. If that formulation is more useful for you, it's probably different enough to add to mathlib</p>",
        "id": 276168428,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1647945406
    },
    {
        "content": "<p>At the time I could only those in the file, but if there more just create a section gathering them all</p>",
        "id": 276168736,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647945568
    },
    {
        "content": "<p>Michael, in case it is helpful, I have used your proof of <code>nat_multiplicative_induction</code> and simply rewrote it in a more Lean-friendly way.  I always find looking at the diffs in these proofs useful.  Note, in particular, that I hold my breath and do not tell Lean on what to apply the lemmas, but wait for Lean to let me know what it wants.  All the <code>have</code> and <code>let</code> have disappeared (and of course their content reappears when Lean wants it).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">nat_multiplicative_induction</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">p.prime</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hmult</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">*</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- easy case `n = 0`</span>\n    <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n  <span class=\"c1\">-- now `n &gt; 0`; take its factors</span>\n  <span class=\"n\">convert</span> <span class=\"n\">multiset.prod_induction</span> <span class=\"n\">P</span> <span class=\"n\">n.succ.factors</span> <span class=\"n\">hmult</span> <span class=\"n\">h1</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">multiset.coe_prod</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">nat.prod_factors</span> <span class=\"o\">(</span><span class=\"n\">n.succ_ne_zero</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">hyp</span><span class=\"o\">,</span> <span class=\"n\">hp</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nat.prime_of_mem_factors</span> <span class=\"n\">hyp</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 276169051,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647945728
    },
    {
        "content": "<p>BTW, I just found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.rec_on_mul\">docs#nat.rec_on_mul</a> .</p>",
        "id": 276169126,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647945771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I guess it's a question whether one should try to write in a \"Lean-friendly\" or a \"human-friendly\" way. While developing a proof, I guess the latter makes more sense. For the former, you need experience to know what Lean prefers. Is there any documentation on this?</p>",
        "id": 276169342,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647945882
    },
    {
        "content": "<p>My approach is that if the statement has a proof that is \"obvious\", then I go for the quickest available proof that I can find.  If the statement has some content, then I prefer a more discursive proof (better even if with comments, like you did).</p>",
        "id": 276169524,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647945970
    },
    {
        "content": "<p>I would categorize these induction statements as \"obvious\": once you know what to prove, you simply do it.</p>",
        "id": 276169582,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1647946011
    },
    {
        "content": "<p>A search for \"int.rec_on\" doesn't seem to produce anything, though.</p>",
        "id": 276169606,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1647946026
    },
    {
        "content": "<p>There's <code>int.induction_on</code></p>",
        "id": 276235786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647974203
    }
]
[
    {
        "content": "<p>Is there a library or any kind of formalization of Basic Euclidean Geometry? <br>\nLike the kind you would find in a high school geometry course.</p>",
        "id": 265880551,
        "sender_full_name": "Adam Millar",
        "timestamp": 1640231038
    },
    {
        "content": "<p>mathlib has a <code>geometry/euclidean</code> section, but it's quite different to what you'd usually see..</p>",
        "id": 265880881,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640231466
    },
    {
        "content": "<p>Different indeed. <br>\nGoing to have to brush up on my linear algebra. <br>\nThings around line 370 are closer to what I was looking for. <br>\nThank you.</p>",
        "id": 265881658,
        "sender_full_name": "Adam Millar",
        "timestamp": 1640232398
    },
    {
        "content": "<p>Here's a student project doing some of Euclid book one in lean: <a href=\"https://ja1941.github.io/hilberts-axioms/\">https://ja1941.github.io/hilberts-axioms/</a> and there are others too. Mathlib's main focus is the kind of mathematics being used and taught in a modern university course so Euclid is not high priority for mathlib, although personally I am looking forward to the day I can take lean into schools and prove the \"seven circle theorems\" (apparently UK schoolchildren are taught that there are seven, see eg <a href=\"https://www.bbc.co.uk/bitesize/guides/zsw397h/revision/1\">https://www.bbc.co.uk/bitesize/guides/zsw397h/revision/1</a>)</p>",
        "id": 265887856,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640241079
    },
    {
        "content": "<p>I think that proving these circle theorems would make a really nice game. The main issue to solve is how to make all the geometrically obvious assertions that points are on certain sides of lines easy</p>",
        "id": 265887938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640241195
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> and his axiomatic geometry</p>",
        "id": 265889631,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1640243502
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  and <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> <br>\nThat is part of my motivation as well. There are some 'non-rigorous' things that bug me in some of the proofs presented, and I was curious exactly how much needs to be done under the hood to formalize it. <br>\nI want to find out if it feels rewarding, or if there are just too many cases where 'obvious' things are tedious to prove. <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 265892117,
        "sender_full_name": "Adam Millar",
        "timestamp": 1640246448
    },
    {
        "content": "<p>Proving obvious things should not too bother you too much, when formalizing mathematics...  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 265897412,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1640251050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"462042\">@Adam Millar</span> if you are specifically interested in elementary Euclidean geometry you should have a look at <a href=\"http://geocoq.github.io/GeoCoq/\">http://geocoq.github.io/GeoCoq/</a></p>",
        "id": 265897861,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1640251325
    },
    {
        "content": "<p>My work on orientations is aiming towards defining oriented angles, which should be more convenient for circle theorems and most other uses of angles than the existing unoriented angles because they reduce configuration dependence (e.g. \"angles in same segment\" and \"opposite angles of cyclic quadrilateral\" become the same theorem for oriented angles mod π, and to apply that theorem you only need that the points are concyclic and distinct, without needing to be concerned about what order they appear on the circle in). I'm currently expecting to use <code>real.angle</code> (angles mod 2π) for those angles, and, where something is only true mod π, to express it in terms of twice those angles to keep it as an equality of angles mod 2π (not sure if <code>(2:ℤ) • θ</code> or <code>(2:ℕ) • θ</code> is the best expression to use in such statements).</p>\n<p>To go from there to separate theorems \"angles in same segment\" and \"opposite angles of cyclic quadrilateral\" (whether for unoriented angles, or as equalities mod 2π rather than just mod π for oriented angles) would involve setting up a lot more API to talk about the order in which points appear on circles (probably involving bundled circles and arcs thereof, as distinct from bundled spheres which will be useful for talking about other concepts that work naturally in any dimension). We'll need that API anyway for the IMO Grand Challenge to be able to state those geometry problems that explicitly refer to arcs, cyclic quadrilaterals, etc., but I suspect for most geometry problems not referring to those concepts it will be more convenient to do things in a way with less configuration dependence.</p>",
        "id": 265933509,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1640278429
    },
    {
        "content": "<p>\"angle at centre equals twice angle at circumference\" also becomes much nicer with oriented angles, although here one has to work mod 2pi</p>",
        "id": 265938904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640282541
    },
    {
        "content": "<p>I ported a pretty big section of GeoCoq into lean in the GeoLean branch of mathlib, although mostly following Coq conventions and textbook ordering, rather than mathlib conventions</p>",
        "id": 265944361,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1640286680
    },
    {
        "content": "<p>hello <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> , I was wondering if triangle similarities will be added to lean, because that seems to be the only thing missing in order to prove IMO geometry problems in Lean. I read that you want to add similarities in a very general form, but the main things needed for IMO problems are angle angle, and side angle side similarities for oriented angles.</p>",
        "id": 321364199,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673706108
    },
    {
        "content": "<p>I also noticed that there is a proof of the isosceles triangle theorem, but if you already have triangle similarity, that can be proven very easily by considering the triangle being similar to itself, with the 2 base points swapped.</p>",
        "id": 321365737,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673706764
    },
    {
        "content": "<p>This question raises various issues that I'll discuss in the following order: (A) principles of generality; (B) similarities; (C) triangle lemmas; (D) implementation plans; (E) the overall state of Euclidean geometry in mathlib at present.</p>",
        "id": 321385256,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673715521
    },
    {
        "content": "<p>(A) The design of mathlib is that it's a highly integrated library of mathematics as a whole, with everything done in appropriate generality rather than just the particular case of interest for someone's problem. Sometimes we might find it useful to have both more and less general versions of a result, if the less general version is more convenient to apply in practical use cases, and sometimes we might decide a less general version is appropriate to accept (with possible future refactoring) when a more general version is significantly harder to prove, or when we need to develop applications of different versions before it becomes clear what a more general version should look like. But the starting point is that when adding a definition or lemma we work out what the appropriately general version of it is to add (and then a reviewer may point out a further generalization that was missed).</p>",
        "id": 321385801,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673715762
    },
    {
        "content": "<p>Euclidean geometry is no exception to this principle of generality. It may be almost a leaf of the import tree (the only import of anything in <code>geometry.euclidean</code> from elsewhere in mathlib proper is that of <code>geometry.euclidean.inversion</code> from <code>analysis.complex.upper_half_plane.metric</code>, and <code>geometry.euclidean.inversion</code> doesn't import any other <code>geometry.euclidean</code> files). But the same principle still applies - and many lemmas used in geometry in fact are proved in more general contexts, such as affine spaces or strictly convex spaces, and thus appear elsewhere in mathlib.</p>",
        "id": 321386087,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673715902
    },
    {
        "content": "<p>Thus, for geometry results we consider if there's a more general context they should be stated for - whether that's something more general than just a Euclidean context, or, in the Euclidean case, whether something can e.g. be defined in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> dimensions rather than just the two-dimensional case. For example, we define <code>circumcenter</code> for a simplex, not just a triangle, and define the <code>monge_point</code> of a simplex, not just the <code>orthocenter</code> of a triangle (though we prove that in the triangle case, it satisfies the expected <code>orthocenter</code> properties).</p>",
        "id": 321386309,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673716028
    },
    {
        "content": "<p>(B) Similarity and congruence results in geometry tend to be analogous, so I'll discuss both together. Typical questions to determine the right form of a particular result include: does it genuinely require three points, or work for more; does it genuinely require those points to be affinely independent, or does it work for a more general family of points? These will determine whether a result should be stated for a general indexed family of points, or more specifically for one that is affinely independent (a <code>simplex</code>, if also required to be finite), or only for three points (a <code>triangle</code>, if required to be affinely independent, or just three points passed as separate hypotheses, if not).</p>",
        "id": 321386807,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673716245
    },
    {
        "content": "<p>For example, SSS congruence or similarity will work for any indexed family of points. However, if the family is infinite and its affine span has infinite dimension, you have extra complications. (If we define two indexed families as congruent if there is an isometric equivalence between their spaces that maps one to the other, then two indexed families with the same pairwise distances are congruent if they span the whole of their respective spaces. But even if you only have a single space, in infinite dimensions you could e.g. have one family spanning the whole space and one spanning a subspace such that you can't find such an equivalence.) Those complications serve to justify having a separate version of the lemma, simpler to use, for the common case of families in the same space and indexed by a <code>finite</code> type - but I don't think there's any need to specialize further to a case for <code>simplex</code> or <code>triangle</code>.</p>",
        "id": 321387453,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673716570
    },
    {
        "content": "<p>As another example, if you're showing that equal angles imply similarity, that does genuinely need affine independence - or at least it doesn't work for three collinear points, maybe some condition weaker than affine independence suffices. But it's also the case that you don't need to have all angles between all triples of distinct points, if you take just two points and know all the angles at those two points then that's sufficient (and I think instead of affine independence it's enough that no triple of points that includes both of the points at which you're given the angles is collinear). So it's appropriate to state the result with such weaker conditions, and then probably have a special case for <code>simplex</code> (but that special case would still only involve the angles at two points, and not be limited to <code>triangle</code>).</p>",
        "id": 321388215,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717009
    },
    {
        "content": "<p>When results involve oriented angles, they <em>are</em> genuinely limited to a planar context (so if they also involve a simplex, that simplex is a triangle, but they may well make sense for more general indexed families of points in the plane).</p>",
        "id": 321388352,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717075
    },
    {
        "content": "<p>In order to state at all that two indexed families of points are similar, we first need <a href=\"https://github.com/leanprover-community/mathlib/pull/14315\">#14315</a> (Dilations on metric spaces). Once my current open PR <a href=\"https://github.com/leanprover-community/mathlib/pull/17993\">#17993</a> is in, I might look at picking up that old PR and seeing if I can get it ready for inclusion, if no-one else gets there first. I expect there will be lots more to do to make dilations and <code>dilation_class</code> as defined there as conveniently usable as isometries. There will also be work setting up things such as <code>isometry_class</code> and other missing pieces of the API for isometries. That sort of thing might sensibly start by updating Yaël's <a href=\"https://github.com/leanprover-community/mathlib/tree/rename_isometry\">branch#rename_isometry</a> and getting it into mathlib, as I mentioned in a comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/14315\">#14315</a>.</p>",
        "id": 321388987,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717414
    },
    {
        "content": "<p>(C) You remarked on the proof of pons asinorum. <code>geometry.euclidean.triangle</code> is really a very miscellaneous collection of results without much coherent design. Some I added, some other people added; sometimes the main goal was to check something off on Freek's list. I have some thoughts about how to split up and rearrange other geometry files, but don't know what a good arrangement for the current contents of <code>geometry.euclidean.triangle</code> is. Certainly some results should have oriented angle versions added, and quite possibly some unoriented angle results might best be proved via oriented angles; the proofs I added very early on in the development of Euclidean geometry in mathlib may not be the best ones now.</p>",
        "id": 321389394,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717702
    },
    {
        "content": "<p>I suspect incidentally that proving unoriented angle results via oriented angles will be fiddly, given the need to move to a two-dimensional subspace (dealing with degenerate cases where the points are collinear and the ambient space may have less than two dimensions), prove things there and move back (with appropriate lemmas to transport geometrical properties in both directions, which may not currently exist in mathlib). As usual, the principles of generality apply to such lemmas for transporting results to and from a two-dimensional subspace; typically a transport lemma will apply to any similarity or any isometry, with the coercion map from a subtype to the full space being only a special case of that. Maybe the transport process could be simplified with appropriate tactics, but it would be necessary to prove several unoriented angle results using oriented angles by hand before it becomes clear what such a tactic should look like.</p>",
        "id": 321389662,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717869
    },
    {
        "content": "<p>There is, in fact, one ad hoc similarity result for three points in <code>geometry.euclidean.triangle</code>: <code>dist_mul_of_eq_angle_of_dist_mul</code>. Maybe that result would be justified even in a more general context, as a lemma that might well be used in proving the more general forms of similarly results.</p>",
        "id": 321389807,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673717974
    },
    {
        "content": "<p>I think that for IMO problems, an oriented version of triangle similarities is very useful. This requires a concept of similar triangles having either the same orientation, or the opposite orientation, because this determines whether the oriented angles of the triangles are equal to each other, or are negative each other.<br>\nI saw there is the definition of the sign of an oriented angle, being 1 if it is in (0, pi) and -1 if it is in (-pi, 0) and 0 otherwise. If you already know that two triangles are similar in an absolute sense, this sign can be used to find the similarity in the oriented sense.<br>\nThe theorems I would in particular like to have are the following 2, and each has two cases, one for the same orientation, and one for mirrored orientation:<br>\n(aa) if 2 triangles share 2 oriented angles, then they are similar. Here it is sufficient to have the given angles modulo pi, instead of modulo 2pi. It requires the 3 points to be affine linearly independent.<br>\n(sas) if 2 triangles share an angle and a ratio of side lengths around that angle, they are similar. this does require the angle to be known modulo 2pi, but there is no restriction on the points, and this also includes the case where some of the points coincide. The length ratio just needs to be given as a multiplication, to avoid division by zero.<br>\nThe proofs of these 2 theorems follow respectively from the uniqueness of the intersection of non-parallel lines, and from the uniqueness of a complex number given the norm and argument. Because in both cases, you can find some distance-ratio preserving map that sends two of the points of one triangle to the corresponding points of the other triangle, and you just need to prove that then the third point also is mapped to the corresponding third point.</p>",
        "id": 321394498,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673720590
    },
    {
        "content": "<p>(D) The answer to almost any question about whether mathlib will get some feature is that it depends on whether someone implements it, but that's not very helpful. My current olympiad formalization project is to get all the problems from IMO 2019 into the mathlib archive. After Q2 (<a href=\"https://github.com/leanprover-community/mathlib/pull/17993\">#17993</a>) my inclination would be to do the remaining problems in the order Q5, Q3, Q6, but probably not until after the mathlib4 transition is complete; Q5 and Q3 are close to the rising tide of Lean 4 conversion, while Q6, another geometry problem, is a large project. I don't have concrete formalization plans after that; maybe I'll do IMO 2024 problems, maybe I'll do problems on which I was a coordinator, maybe I'll do other problems chosen for their formalization challenges or for the additional API they'll require to be added to mathlib, maybe I'll do pieces of the de facto IMO syllabus without reference to particular problems, maybe I'll take on a non-olympiad formalization project.</p>",
        "id": 321394931,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673720851
    },
    {
        "content": "<p>For IMO 2019 Q6 I'd probably go for solution 1 (which might end up involving some similarity results, in that it is using a form of converse of power of a point, which is very close to a combination of (opposite orientation) similar triangles and converse of inscribed angles). There's an extended set of six solutions from the coordinators, in which solution 5 (complex numbers) and solution 6 (a lot more use of similar triangles) might have lower dependencies than solution 1 (which involves developing various projective geometry) - but lower dependencies is not necessarily a feature when doing olympiad formalizations (much of the benefit of such formalizations is the API they result in being added to mathlib proper, see archive/imo/README.md, so arguably it's a good thing to choose a solution to formalize with substantial dependencies not yet in mathlib).</p>",
        "id": 321395563,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673721216
    },
    {
        "content": "<p>(E) \"the only thing missing in order to prove IMO geometry problems in Lean\" is wildly optimistic about the actual level of geometry coverage in mathlib at present. I've done two olympiad geometry problems in Lean (British MO 2020 problem 2, and IMO 2019 problem 2). The specific geometry used in those two solutions is well-covered; the vast bulk of other geometry isn't. Here are some of the many things (other than similarity / congruence definitions and lemmas) that should be added to cover the more basic concepts common in IMO geometry problems and solutions:</p>",
        "id": 321395991,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673721482
    },
    {
        "content": "<p>*actually for the oriented (sas) on triangles ABC and A'B'C', we do require a little bit, namely that A,B are different and A', B' are different, so that we can do the transformation sending A to A' and B to B' in the proof.</p>",
        "id": 321396047,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673721496
    },
    {
        "content": "<ul>\n<li>incenter, excenter, angle bisectors (in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> dimensions, so the bisectors are of angles between oriented hyperplanes; I've thought quite a bit about how to set this up, which will involve manipulating orientations of up to three subspaces at the same time);</li>\n<li>tangency between sphere and affine subspace;</li>\n<li>tangency between two spheres;</li>\n<li>Ceva (in an affine space context);</li>\n<li>Menelaus (in an affine space context);</li>\n<li>diameters as an explicit notion, and Thales;</li>\n<li>cyclic polygons, i.e. ordering of points on a circle (see discussion in <a href=\"https://github.com/leanprover-community/mathlib/pull/16733\">#16733</a>);</li>\n<li>convex polygons;</li>\n<li>interior of a (not necessarily convex) polygon, or of a simplex (the latter involving more linkage of convexity to affine spaces; when you're dealing with nonconvex polygons a definition is probably based on topology rather than convex hulls);</li>\n<li>lots of things about areas of triangles / volumes of simplexes, via appropriate linkage of geometry to the measure theory parts of mathlib;</li>\n<li>an explicit definition of power of a point and the radical axis;</li>\n<li>various projective geometry, poles and polars,</li>\n<li>a notion of a list of points being in a given (weak or strict) order on a line (generalization to more than three points of the betweenness notions we have; often appears in IMO problem statements).</li>\n</ul>",
        "id": 321396912,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673721999
    },
    {
        "content": "<p>Some of those things are straightforward to define and set up API for, some are much more involved. The bulk of IMO problems need some of them; indeed most can't even be stated cleanly without more geometry than we currently have.</p>",
        "id": 321397024,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673722075
    },
    {
        "content": "<p>what do you mean with incenter, excenter, angle bisectors in more than 2 dimensions? is the incenter of a n dimensional simplex the point inside the simplex with equal distance to all n-1 dimensional sides?</p>",
        "id": 321398034,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673722708
    },
    {
        "content": "<p>By way of example, this is what I think is needed (and not yet present) just to cleanly <em>state</em> IMO geometry (non-combinatorial) problems from the past 10 years (proofs may well need more). IMO 2013 Q3: excircles / extouch points and tangency. IMO 2013 Q4: diameters. IMO 2014 Q3: convex polygons (quadrilateral), interior of a triangle, tangency. IMO 2014 Q4: I think that one can be stated right now. IMO 2015 Q3: cyclic order of five points on a circle, tangency of circles. IMO 2015 Q4: order of four points on a line. IMO 2016 Q1: angle bisectors. IMO 2017 Q4: diameters, tangency, major and minor arcs. IMO 2018 Q1: major and minor arcs. IMO 2018 Q6: convex quadrilateral and its interior. IMO 2019 Q2: can be stated, but that's because I did about 200 PRs aiming at stating and proving that problem. IMO 2019 Q6: incenter / incircle and tangency / intouch points. IMO 2020 Q1: convex quadrilateral and its interior, angle bisectors. IMO 2021 Q3: interior of a triangle. IMO 2021 Q4: convex quadrilateral, tangency. IMO 2022 Q4: convex pentagon and its interior, order of four points on a line. (End of points A to E above, following remarks are replies to other things in this discussion.)</p>",
        "id": 321398735,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673723110
    },
    {
        "content": "<p>For orientation-preserving / reversing similarities, I think Heather had ideas on setting up API to refer to an operation (<code>linear_equiv</code>, <code>affine_equiv</code>, etc.) as orientation-preserving / reversing more conveniently than at present. There are some things about such API that would naturally apply in any dimension (e.g. saying what a homothety with negative scale factor does to the orientation, depending on the parity of the dimension), though results about orientated angles would be two-dimensional.</p>",
        "id": 321399151,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673723363
    },
    {
        "content": "<p>Yes, the incenter of a simplex is inside the simplex and has equal distance to all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-dimensional faces. It's the intersection of the internal angle bisectors, where the bisectors in question are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-dimensional subspaces bisecting the angle between two <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-dimensional faces. In <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> dimensions there are up to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> points equidistant from all the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-dimensional faces. The incenter always exists, and the excenter opposite each vertex always exists. The other generalized excenters may not exist, depending on the choice of simplex (the barycentric coordinates are proportional to plus or minus the volumes of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(n-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>-dimensional faces, and if the signed sum is zero, there is no corresponding center for that choice of signs).</p>\n<p>Note that if you set up consistent orientations of all the faces, reflecting in an internal angle bisector sends the orientation of one face to the <em>negation</em> of the orientation of the other face adjacent to that angle; it's the external bisector that sends the orientation of one edge to the orientation of the other when you reflect in it. (For example, in two dimensions, a consistent orientation of the edges has arrows cycling round the triangle - so at a vertex, one of the edges is oriented pointing in and one pointing out.)</p>",
        "id": 321400108,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673723901
    },
    {
        "content": "<p>Incidentally, there should be a place for the well known SSA congruence/similarity fallacy in mathlib. Correct statements relating the two possible triangles given two sides and an angle not between them would go in mathlib proper, as would variants giving a unique triangle up to congruence under additional hypotheses; these correct versions of SSA are occasionally useful, though not as much as congruent/similar triangles results that don't need such extra conditions. Then the <code>counterexamples</code> directory would be an appropriate place for an explicit construction of two triangles for which it's proved that two sides and an angle not between them are equal in the two triangles, but that the two triangles are not congruent.</p>",
        "id": 321407286,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673729103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321399151\">said</a>:</p>\n<blockquote>\n<p>For orientation-preserving / reversing similarities, I think Heather had ideas on setting up API to refer to an operation (<code>linear_equiv</code>, <code>affine_equiv</code>, etc.) as orientation-preserving / reversing more conveniently than at present. There are some things about such API that would naturally apply in any dimension (e.g. saying what a homothety with negative scale factor does to the orientation, depending on the parity of the dimension), though results about orientated angles would be two-dimensional.</p>\n</blockquote>\n<p>I think a design akin to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom_comp_triple\">docs#ring_hom_comp_triple</a> will help us with orientation of maps.</p>",
        "id": 321409851,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673731211
    },
    {
        "content": "<p>If we want everything to be of the greatest generality, why do we restrict this geometry to real vector spaces? I would think that angles are also possible to define in something like a two dimensional vector space over rational numbers for example (or over any other subfield of R)?</p>",
        "id": 321410572,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673731850
    },
    {
        "content": "<p>*two dimensional inner product spaces</p>",
        "id": 321410834,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673732087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321409851\">said</a>:</p>\n<blockquote>\n<p>I think a design akin to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom_comp_triple\">docs#ring_hom_comp_triple</a> will help us with orientation of maps.</p>\n</blockquote>\n<p>what sort of design do you mean?</p>",
        "id": 321411017,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673732261
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/blog/posts/classification-of-one-dimensional-isocrystals/\">https://leanprover-community.github.io/blog/posts/classification-of-one-dimensional-isocrystals/</a></p>",
        "id": 321411641,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673732783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321387453\">said</a>:</p>\n<blockquote>\n<p>For example, SSS congruence or similarity will work for any indexed family of points. However, if the family is infinite and its affine span has infinite dimension, you have extra complications. (If we define two indexed families as congruent if there is an isometric equivalence between their spaces that maps one to the other, then two indexed families with the same pairwise distances are congruent if they span the whole of their respective spaces. But even if you only have a single space, in infinite dimensions you could e.g. have one family spanning the whole space and one spanning a subspace such that you can't find such an equivalence.) Those complications serve to justify having a separate version of the lemma, simpler to use, for the common case of families in the same space and indexed by a <code>finite</code> type - but I don't think there's any need to specialize further to a case for <code>simplex</code> or <code>triangle</code>.</p>\n</blockquote>\n<p>You want to define two sets of points to be congruent if there is an isometry between the whole spaces, mapping one to the other. Maybe it is more convenient to define two sets of point to be congruent if there is an isometry between the respective spans of the two sets of points, mapping one to the other. This is a more general definition and means we can talk about congruence of a triangle in the plane, and a triangle in a higher dimensional space.</p>",
        "id": 321412195,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673733279
    },
    {
        "content": "<p>Regarding other inner product spaces, there's a difference between generality that is actually of mathematical interest and generality for generality's sake. Euclidean spaces in dimensions higher than two are legitimate objects of mathematical study; three-dimensional geometry hasn't appeared in post-1979 IMO problems (other than as a setting for combinatorial problems), but mathlib is for mathematics in general, not just the IMO syllabus. Whereas applying the same arguments to a subfield of the reals is of questionable interest, in a very well-defined way: anything you can do there could be done more conveniently by starting with extending the vector space to a real vector space and then working there. (So far mathlib's inner product spaces are only over the reals or the complex numbers.)</p>\n<p>(There are cases where the most general form of some definition or result is not uniquely defined, because there are multiple ways to generalize something and they yield different consequences, and in those cases it's appropriate to include multiple generalizations in mathlib.)</p>",
        "id": 321413983,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673734817
    },
    {
        "content": "<p>Regarding the definition of congruence, I'd argue that defining in terms of existence of an isometric equivalence between the full spaces is more general than involving spans, because isometric equivalences are meaningful for general metric spaces and affine spans aren't. If you add a definition for mapping an indexed family of points from the ambient space to their span, you can then talk about congruence of the results of applying that operation, in cases where that's the form of congruence you want.</p>",
        "id": 321414300,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673735097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321414300\">said</a>:</p>\n<blockquote>\n<p>Regarding the definition of congruence, I'd argue that defining in terms of existence of an isometric equivalence between the full spaces is more general than involving spans, because isometric equivalences are meaningful for general metric spaces and affine spans aren't. If you add a definition for mapping an indexed family of points from the ambient space to their span, you can then talk about congruence of the results of applying that operation, in cases where that's the form of congruence you want.</p>\n</blockquote>\n<p>Yes, I agree</p>",
        "id": 321418758,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673738915
    },
    {
        "content": "<p>So we want to define congruence using isometry equivalences, and not affine isometry equivalences, because of the fact that all isometries of real inner product spaces are linear isometries, right?</p>",
        "id": 321437952,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673755442
    },
    {
        "content": "<p>Is there already a proof of this somewhere in mathlib?</p>",
        "id": 321438926,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673756594
    },
    {
        "content": "<p>Maybe you could also define a congruence between two family of points <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">f, g: I \\to X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi>d</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d_X(f(i),f(j))=d_X(g(i),g(j))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">))</span></span></span></span> for all <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">i, j \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.854em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>. If you consider <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> equipped with the common metric, these are just two isometric embeddings. This gives a sensible definition in infinite-dimensions (without talking about spans) and spaces that are not isotropic/homogeneous like Euclidean spaces.</p>",
        "id": 321448322,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673765448
    },
    {
        "content": "<p>Such congruence of distances does appear in the context of comparison triangles (where an arbitrary metric space is compared against a nicely behaved (homogeneous and isotropic) model space (Euclidean space, sphere, or hyperbolic space)), but maybe it's not to be considered a form of congruence. The following pictures are taken from Bridson-Haefliger, <em>Metric Spaces of Non-positive Curvature</em>:<br>\n<a href=\"/user_uploads/3121/YGO0YqyPoTXWzw14ZomWB5QL/image.png\">image.png</a><br>\n<a href=\"/user_uploads/3121/sp03ROPVtYx-VQUIt1ROxnfS/image.png\">image.png</a><br>\n<a href=\"/user_uploads/3121/nB3GzeI472MgGzSoGZmFr9lQ/image.png\">image.png</a><br>\nThe current triangle APIs in mathlib is probably not developed with this in mind, and I'm not sure how well it generalizes to spheres and hyperbolic spaces.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/YGO0YqyPoTXWzw14ZomWB5QL/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/YGO0YqyPoTXWzw14ZomWB5QL/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/sp03ROPVtYx-VQUIt1ROxnfS/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/sp03ROPVtYx-VQUIt1ROxnfS/image.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/3121/nB3GzeI472MgGzSoGZmFr9lQ/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/nB3GzeI472MgGzSoGZmFr9lQ/image.png\"></a></div>",
        "id": 321452393,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673769173
    },
    {
        "content": "<p>Yes, that seems like a more natural definition to me. And the embeddings can also be in two different metric spaces X and Y.</p>",
        "id": 321482134,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673787447
    },
    {
        "content": "<p>we currently have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">angle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">real.arccos</span> <span class=\"o\">(</span><span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖</span> <span class=\"bp\">*</span> <span class=\"bp\">‖</span><span class=\"n\">y</span><span class=\"bp\">‖</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but I suppose this can be generalized to any metric space using the fact that in all real inner product spaces:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">‖</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"bp\">‖^</span><span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"bp\">‖</span><span class=\"n\">x</span><span class=\"bp\">‖^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">⟪</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟫</span> <span class=\"bp\">+</span> <span class=\"bp\">‖</span><span class=\"n\">y</span><span class=\"bp\">‖^</span><span class=\"mi\">2</span>\n</code></pre></div>",
        "id": 321484011,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673788340
    },
    {
        "content": "<p>Which gives the same angles as using those comparison triangles</p>",
        "id": 321484169,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673788455
    },
    {
        "content": "<p>In this case all results about congruences generalize to arbitrary metric spaces.</p>",
        "id": 321484534,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673788685
    },
    {
        "content": "<p>You mean normed spaces, right?</p>",
        "id": 321484540,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673788695
    },
    {
        "content": "<p>I think it works even for general metric spaces like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">angle'</span> <span class=\"o\">(</span><span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"n\">p₃</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">real.arccos</span> <span class=\"o\">((</span><span class=\"n\">dist</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">p₂</span> <span class=\"n\">p₃</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">p₁</span> <span class=\"n\">p₃</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">p₂</span> <span class=\"n\">p₃</span><span class=\"o\">)))</span>\n</code></pre></div>",
        "id": 321485401,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673789124
    },
    {
        "content": "<p>But not all congruence results will generalise, because you will need homogeneity at some point.</p>",
        "id": 321485542,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673789175
    },
    {
        "content": "<p>We define what angles are based on the length, so any arguments about angle equalities and length equalities in a triangle implying each other don't care about what the ambient metric space is. We basically define angles so that the cosine rule holds, and then use that to prove SS and SAS congruences. AA will be a bit harder.</p>",
        "id": 321486352,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673789631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321437952\">said</a>:</p>\n<blockquote>\n<p>So we want to define congruence using isometry equivalences, and not affine isometry equivalences, because of the fact that all isometries of real inner product spaces are linear isometries, right?</p>\n</blockquote>\n<p>Yes. The fact that an isometry of (affine spaces for) real inner product spaces is an affine isometry is a property of strictly convex spaces; see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/isometry.affine_isometry_of_strict_convex_space\">docs#isometry.affine_isometry_of_strict_convex_space</a> (alternatively, since we're talking about isometric equivalences, strict convexity isn't needed and you can use Mazur-Ulam; see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/isometric.to_real_affine_isometry_equiv\">docs#isometric.to_real_affine_isometry_equiv</a>).</p>",
        "id": 321486632,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673789770
    },
    {
        "content": "<p>I tend to think the definition of congruence in terms of existence of an isometric equivalence is more useful, since it means, for example, that given a congruence from some of the points in a configuration, you can apply that isometry to the whole diagram and start deducing things from there (and likewise for similarities, of course). Ultimately there are two mathematically meaningful concepts (pairwise equal distances, and existence of an isometric equivalence mapping one family of points to the other), and it's a theorem that needs to be proved in mathlib that, in appropriate circumstances (such as the family of points spanning the whole space, or a finite-dimensional subspace when the two spaces are the same), they coincide in Euclidean spaces: that equal distances implies the existence of an isometric equivalence.</p>",
        "id": 321487217,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673790079
    },
    {
        "content": "<p>I don't think defining angles in terms of distance like that for general metric spaces is a good idea. It certainly gives the wrong results on the sphere (where the angles in an equilateral triangle depend on its side length), and I doubt it gives good results in hyperbolic space either. Maybe at some point we want a type class for spaces with a notion of angle, so that it can be applied on Riemannian manifolds as well, but the definition wouldn't be the one in this discussion.</p>",
        "id": 321487728,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673790348
    },
    {
        "content": "<p>Isn't there a general definition of angles coming from topological surfaces?</p>",
        "id": 321487894,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673790424
    },
    {
        "content": "<p>I don't see why congruence in terms of existence of an isometric equivalence is more useful, because you can just use the appropriate theorem to create this isometry on the whole diagram when you need it. Congruence in terms of pairwise equal distances seems like a simpler and more general definition, because we can talk about congruence of objects with different dimension ambient spaces. And you won't run into problems with spans in infinite dimensional spaces.</p>",
        "id": 321488596,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673790811
    },
    {
        "content": "<p>How would you state pairwise equal distance? It seems like you would need an equivalence of the base type, sending each point in one family to a prescribed point in the second, and then separately state that the distances are pairwise preserved. Arguably, asking the distance to be preserved everywhere is a simpler definition.</p>",
        "id": 321491318,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673791933
    },
    {
        "content": "<p>I guess on topological surfaces, you can define oriented angles, modulo 2pi, if the surface is orientable, and in general you can define absolute angles, by considering the geodesics (assuming that the geodesic is unique). That uses the definition of (oriented) angles in the plane.</p>",
        "id": 321491406,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673791969
    },
    {
        "content": "<p>Existence of an isometric equivalence is more useful in the sense that if you're actually doing anything with congruence in a Euclidean context, you're probably transporting geometrical properties using a result that transports such properties across an isometry, and so you need the isometry. It may not matter so much which gets used as the definition, given that in the general (pseudo)(e)metric space context there's not much that can be said about either congruence concept (mainly that it's an equivalence relation, that congruences are also similarities, etc.), and that in the Euclidean context, the existence of the isometry is one of the most basic results to prove first (probably using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/euclidean_geometry.inner_weighted_vsub\">docs#euclidean_geometry.inner_weighted_vsub</a> / <a href=\"https://leanprover-community.github.io/mathlib_docs/find/euclidean_geometry.dist_affine_combination\">docs#euclidean_geometry.dist_affine_combination</a>) and then you can use that isometry as needed.</p>\n<p>Both concepts are genuinely mathematically meaningful with a mathematically meaningful result to be proved relating them in Euclidean space.</p>",
        "id": 321491626,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673792090
    },
    {
        "content": "<p>I think you need a Riemannian metric on your surface, not just a topology, to get meaningful angles.</p>",
        "id": 321491716,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673792138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/321491318\">said</a>:</p>\n<blockquote>\n<p>How would you state pairwise equal distance? It seems like you would need an equivalence of the base type, sending each point in one family to a prescribed point in the second, and then separately state that the distances are pairwise preserved. Arguably, asking the distance to be preserved everywhere is a simpler definition.</p>\n</blockquote>\n<p>I would take an index type <code>ι</code>, and indexed sets of vertices <code>(v₁ : ι → P₁) (v₂ : ι → P₂)</code>, and then require that all the corresponding lengths are the same.</p>",
        "id": 321491862,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673792215
    },
    {
        "content": "<p>We don't yet have Riemannian manifolds to define angles there, but there's a recent discussion: <a href=\"#narrow/stream/116395-maths/topic/riemannian.20geometry\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/riemannian.20geometry</a></p>",
        "id": 321492924,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673792651
    },
    {
        "content": "<p>So if you want to define <code>congruent</code> for indexed families of points in terms of pairwise equal distances, and so make SSS congruence a theorem about <code>congruent</code> implying the existence of isometries (for arbitrary indexed families of points in Euclidean space, with appropriate spanning or finite-dimensional conditions - not just for triangles) rather than a theorem saying \"equal distances implies congruent\", that will probably work reasonably well, since it's still proving sensible results about sensible mathematical concepts. (I don't think \"take a relation of angles to distances in Euclidean space and then use that to define angles in other spaces\" results in a sensible mathematical concept, however.)</p>",
        "id": 321493830,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673793118
    },
    {
        "content": "<p>For orientational congruence, I think we should implement it as a linear isomorphism of the whole spaces, preserving the points, in finite dimensional real inner product spaces, where the sign of the congruence is equal to the sign of the determinant of the linear map, which is +1 or -1. This generalizes it to higher dimensions, but I don't think there is any further generalization.</p>",
        "id": 321529906,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673815505
    },
    {
        "content": "<p>Do you have suggestions for what notation to use for this, as we want to be able to express congruence for same or opposite orientation. Maybe something like <code>≅ₒ₊  ≅ₒ₋ </code> for positive and negative sign orientation?</p>",
        "id": 321530509,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673815922
    },
    {
        "content": "<p>Also, is the <code>≅</code> symbol for congruence used anywhere else in mathematics, or can we freely use it for congruence?</p>",
        "id": 321530792,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673816159
    },
    {
        "content": "<p><code>~</code> is already taken by list permutation equivalence, so for similarity we could take <code>~ₛ</code> for example? And then the consistent <code>∼ₒ₊ ∼ₒ₋</code> for orientational similarity?</p>",
        "id": 321531439,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673816654
    },
    {
        "content": "<p>To take care of the orientation, I reiterate that we should use something akin to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semilinear_map_class\">docs#semilinear_map_class</a>, where we take a parameter <code>± 1</code> so that we can freely compose orientation-preserving and orientation-reversing maps.</p>",
        "id": 321533597,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673818484
    },
    {
        "content": "<p>In fact, I think the current setup is almost what we want already</p>",
        "id": 321533625,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673818515
    },
    {
        "content": "<p>I haven't thought in detail about exactly what types for bundled orientation-preserving and orientation-reversing maps should look like; other people here have clearly thought more about that. I will note that for most geometry purposes we're dealing with affine maps, not just linear ones, so you want such versions of <code>affine_isometry_equiv</code> as well as <code>linear_isometry_equiv</code> (and <code>affine_dilation_equiv</code> as well as <code>linear_dilation_equiv</code> once those exist). We do already have a range of lemmas about how linear equivs affect an orientation based on the sign of the determinant.</p>",
        "id": 321537339,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673821676
    },
    {
        "content": "<p>Adding those extra types of bundled isometries makes it all the more important to set up all the type classes for bundled isometries so we don't need to duplicate many lemmas for those new bundled types (for which <a href=\"https://github.com/leanprover-community/mathlib/tree/rename_isometry\">branch#rename_isometry</a> might be a sensible start, even though formally renaming existing definitions related to isometries is independent of adding new ones).</p>",
        "id": 321537536,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1673821855
    },
    {
        "content": "<p>Jovan is getting started so I thought I would let him perform the rename himself to get accustomed to the PR process. Hopefully the PR is out soon!</p>",
        "id": 321537634,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673821936
    },
    {
        "content": "<p>I did the renaming, but I didn't have PR rights, and then I couldn't use Gitpod anymore because I had used it too much, so I'd have to do it again once I get everything working with mathlib on my pc.</p>",
        "id": 321537752,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673822090
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span>, could <code>JovanGerb</code> get mathlib access?</p>",
        "id": 321599938,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673862890
    },
    {
        "content": "<p>\" Already has access to this repository \"</p>",
        "id": 321600060,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1673862944
    },
    {
        "content": "<p>Ahah <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 321600181,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1673862979
    },
    {
        "content": "<p>thanks!</p>",
        "id": 321643184,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1673876412
    },
    {
        "content": "<p>I've formalized the basic (unoriented) congruence cases for triangles, with congruence implemented as written above.<br>\nThe proofs are as follows: from the definition of angles, we get the cosine rule, from which you can prove the SSS and SAS cases. Then use the cosine rule to prove the sine rule, by expressing the sine in terms of the cosine. Then use this to prove AAS congruence.<br>\nThis is all in the setting of a general real affine space.</p>\n<p>I'm not so familiar with the process, should I create a pull request so that you can see and comment on the code?</p>",
        "id": 322055680,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674049546
    },
    {
        "content": "<p>Yes, pull requests are a great way to gather feedback <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 322055902,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1674049611
    },
    {
        "content": "<p>From here, we can also add more specific congruences, like SSR for right triangles. And proving the analogous results for triangle similarities will be quite simple, using these congruence results.<br>\nWhen the space is finite dimensional, we'll want to show that the isometry between the two triangles (or general sets of vertices) extends to a linear isometry on the span of the point, and to a linear isometry on the whole spaces. I found the theorem affine_basis.exists_affine_subbasis, which, given an affine spanning set, gives a basis. But what we want here is the more general result that we can restrict to a subset that has the same span and in independent, so I think that should be added there.</p>",
        "id": 322056752,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674049839
    },
    {
        "content": "<p>I was also wondering if there are any ideas about generalizing angles to for example angles between hyperplanes. And maybe oriented angles can be generalized too. But I don't know if this is useful.</p>",
        "id": 322057241,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674049991
    },
    {
        "content": "<p>Angles between hyperplanes are complicated because they involve dealing with three orientations at once (for the two hyperplanes and for the two-dimensional subspace used to define the sign of the angles), so there will probably be a lot of API to set up for manipulating orientations of multiple subspaces and how they relate to each other.</p>",
        "id": 322058728,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674050386
    },
    {
        "content": "<p>(\"angles between planes\" in undergrad.yaml looks like a questionable translation to me; I'd understand \"angles de droites\" in the original French as \"angles between lines\", though I don't know what exact mathematical definition is intended.)</p>",
        "id": 322059502,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674050568
    },
    {
        "content": "<p>Yes, droites ≠ planes, definitely.</p>",
        "id": 322059963,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1674050669
    },
    {
        "content": "<p>Ok, I made the pull request</p>",
        "id": 322079169,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674055387
    },
    {
        "content": "<p>We can also define angles between lines, defining a line to be a one dimensional affine subspace. Then an oriented angle between lines would be modulo pi, instead of modulo 2pi. This could help to have a nicer form of theorems that use a silly 2* factor in the modulo 2pi angles.</p>",
        "id": 322090824,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674058093
    },
    {
        "content": "<p>The issue with angles mod pi is that then you need lots of extra API: either for an <code>angle_mod_pi</code> type (probably ending up duplicating much of the API for <code>real.angle</code>, as well as providing ways to move between both kinds of angles) or for an <code>eq_mod_pi</code> operation on angles (including various lemmas to allow rewriting by <code>eq_mod_pi</code> inside operands of <code>eq_mod_pi</code>; see discussion in <a href=\"https://github.com/leanprover-community/mathlib/pull/17993\">#17993</a>). If adding a new type or definition, there's a trade-off between more convenient API attached to that type or definition and it being more convenient just to use existing types and definitions directly without needing to convert between different pieces of API, and it's not clear if some API for angles mod pi would have sufficient advantages to justify the extra API and converting between the two APIs as needed.</p>",
        "id": 322149041,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674074702
    },
    {
        "content": "<p>If I were to define similarities, what variant of the definition works best? I'd think the most natural is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">dist</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"n\">i₂</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but more generally we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i₁</span> <span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">edist</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"n\">i₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">edist</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"n\">i₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"n\">i₂</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 322609690,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674246802
    },
    {
        "content": "<p>Or I could make it bundled as a structure with the value of r given, instead of having r in an existential quantifier.</p>",
        "id": 322609967,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674246889
    },
    {
        "content": "<p>for the definition of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">similarity</span> <span class=\"o\">(</span><span class=\"n\">v₁</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">P₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v₂</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">P₂</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">pseudo_emetric_space</span> <span class=\"n\">P₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">pseudo_emetric_space</span> <span class=\"n\">P₂</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 322610442,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674246970
    },
    {
        "content": "<p>Whatever is done, it should be consistent with whatever form of <a href=\"https://github.com/leanprover-community/mathlib/pull/14315\">#14315</a> (dliations in metric spaces) gets in, which currently indicates using <code>edist</code> and <code>pseudo_emetric_space</code>.</p>",
        "id": 322647036,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674263583
    },
    {
        "content": "<p>And it seems like a good idea to get congruences into good shape and into mathlib before starting on similarities, since the API for similarities should end up looking very much like that for congruences.</p>",
        "id": 322647094,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674263641
    },
    {
        "content": "<p>I think that congruence lemmas, and similarity lemmas about triangles should go in the trianlge.lean file, because the angle angle case needs to use the sine rule (which I put in triangle.lean), but conversely, I'd like to change the proof of pons asinorum (in triangle.lean) to use congruence, so that it is much shorter.</p>",
        "id": 322908919,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674422718
    },
    {
        "content": "<p>currently the file is ordered to first have the vector space results, and then the affine results, but this order then wouldn't be possible for the vector form of pons asinorum.</p>",
        "id": 322909251,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674422965
    },
    {
        "content": "<p>or that version can just be omitted</p>",
        "id": 322909354,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674423022
    },
    {
        "content": "<p>Instead of having 6 version of congruence.angle_angle_side and 3 versions of congruence.angle_side_angle, I think it's better to just have 3 versions of similarity.angle_angle and to have a congruence.of_similarity which uses an equal length to turn a similarity into a congruence.</p>",
        "id": 322910584,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674423932
    },
    {
        "content": "<p>Is there a generalization of euclidean_geometry.eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two,<br>\nsaying that the intersection of 2 spheres is a sphere in an affine subspace?</p>",
        "id": 322914489,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674426855
    },
    {
        "content": "<p>This affine subspace would be the radical axis of the two speres</p>",
        "id": 322914665,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674427007
    },
    {
        "content": "<p>I want to use this property to prove that, in finite dimension, a point is uniquely determined by the distances to the points in a fixed affine spanning set. I think the infinite dimensional version can then be concluded from the finite dimensional one.</p>",
        "id": 322915045,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674427266
    },
    {
        "content": "<p>I'm guessing that that should be proven in the new power.lean file, after defining the power and the radical axis.</p>",
        "id": 322916700,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674428559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/322915045\">said</a>:</p>\n<blockquote>\n<p>I want to use this property to prove that, in finite dimension, a point is uniquely determined by the distances to the points in a fixed affine spanning set. I think the infinite dimensional version can then be concluded from the finite dimensional one.</p>\n</blockquote>\n<p>I realize now that I can prove this in a different way, so we don't need to have the radical axis quite yet.</p>",
        "id": 323058435,
        "sender_full_name": "Jovan Gerbscheid",
        "timestamp": 1674490092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/322908919\">said</a>:</p>\n<blockquote>\n<p>I think that congruence lemmas, and similarity lemmas about triangles should go in the trianlge.lean file, because the angle angle case needs to use the sine rule (which I put in triangle.lean), but conversely, I'd like to change the proof of pons asinorum (in triangle.lean) to use congruence, so that it is much shorter.</p>\n</blockquote>\n<p>If it's useful to reorder that file, doing so is reasonable. I think pons asinorum is a basic enough result that it ought to have both vector and affine versions, but that doesn't say which is deduced from which.</p>",
        "id": 323144197,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674520474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/322910584\">said</a>:</p>\n<blockquote>\n<p>Instead of having 6 version of congruence.angle_angle_side and 3 versions of congruence.angle_side_angle, I think it's better to just have 3 versions of similarity.angle_angle and to have a congruence.of_similarity which uses an equal length to turn a similarity into a congruence.</p>\n</blockquote>\n<p>I think for these sorts of unbundled lemmas, it's best to have both congruence versions (set up so people can use them for any ordering of points) and similarity versions (likewise), to make it convenient for people to apply them. Yes, that does mean lots of similar lemma statements.</p>\n<p>Now, for <em>bundled</em> isometries and similarities, some duplication can be avoided by having an instance deducing <code>dilation_class</code> from <code>isometry_class</code>, and then any result true for bundled dilations can be stated and proved just once for <code>dilation_class</code>, rather than for both, or, worse, separately for each of the many types of bundled isometries and dilations. But I'm not sure type class inference has a way to handle saying that the same lemma works for both the congruence predicate on two indexed families of points and the corresponding similarity predicate, so I think those get to be stated separately (even if one is proved using the other).</p>",
        "id": 323144675,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674520745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479299\">Jovan Gerbscheid</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Euclidean.20Geometry/near/322915045\">said</a>:</p>\n<blockquote>\n<p>I want to use this property to prove that, in finite dimension, a point is uniquely determined by the distances to the points in a fixed affine spanning set. I think the infinite dimensional version can then be concluded from the finite dimensional one.</p>\n</blockquote>\n<p>I think this could sensibly be deduced from <code>inner_weighted_vsub</code> / <code>dist_affine_combination</code>. Suppose you have a set of points, and two other points P and Q, such that the distances from P to points in the set equal those from Q to points in the set, and also that P lies in the affine span of that set. By <code>dist_affine_combination</code> on an appropriate indexed family of points, the same property holds for distances from P and Q to any point in the affine span of that set (via expressing that point in the affine span as an affine combination, and then <code>dist_affine_combination</code> gives the distance explicitly in terms of the various pairwise distances and the weights in the affine combination). But since we supposed P lies in the affine span, take an affine combination equal to P, and then the distances from P and Q to that combination are equal, so both 0, so P and Q are the same point. Note that nothing depends on the set spanning the whole space; you just need at least one of P and Q to lie in the span of the set to which they have equal distances.</p>",
        "id": 323145395,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1674521126
    }
]
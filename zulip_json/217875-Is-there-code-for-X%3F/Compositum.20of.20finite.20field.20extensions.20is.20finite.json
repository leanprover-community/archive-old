[
    {
        "content": "<p>(This question is copy-pasted from one in New Members)</p>\n<p>I need the fact that for finite field extensions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">E_1/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">E_2/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, contained in some larger field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span>, we have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><msub><mi>E</mi><mn>2</mn></msub><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">E_1E_2 / K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is also finite. Here is a statement of the lemma in Lean:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.galois</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comp_finrank_is_finrank</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E1</span> <span class=\"bp\">∧</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E2</span> <span class=\"bp\">→</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">Sup</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"bp\">|</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">E1</span> <span class=\"bp\">∨</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">E2</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Does anyone know if this lemma already exists in mathlib? I've looked through a few of the field theory entries and I can't find anything that looks like this.</p>",
        "id": 265322898,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1639758760
    },
    {
        "content": "<p><del>Your LaTeX is a sup but your code is an inf.</del>(fixed)</p>",
        "id": 265323171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639758883
    },
    {
        "content": "<p>I think the idiomatic way to ask the LaTeX question is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">field_theory.galois</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.group.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">subalgebra.finite_dimensional_sup</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⊔</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and I agree that we don't seem to have it. Note that it won't follow from the corresponding statement about submodules <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.finite_dimensional_sup\">docs#submodule.finite_dimensional_sup</a> because the submodule sup is in general smaller than the subalgebra sup.</p>",
        "id": 265323480,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639759015
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Compositum.20of.20finite.20field.20extensions.20is.20finite/near/265323171\">said</a>:</p>\n<blockquote>\n<p>Your LaTeX is a sup but your code is an inf.</p>\n</blockquote>\n<p>Fixed</p>",
        "id": 265323706,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1639759102
    },
    {
        "content": "<p>AFAIR, we have transitivity, so you need to prove that the dimension of <code>E1 ⊔ E2</code> over <code>E1</code> is less than or equal to the dimension of <code>E2</code> over <code>K</code>.</p>",
        "id": 265323914,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639759197
    },
    {
        "content": "<p>But I never used this part of the library.</p>",
        "id": 265323981,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1639759209
    },
    {
        "content": "<p>Do we know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>⊗</mo><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">E_1 \\otimes E_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> surjects onto it?</p>",
        "id": 265324097,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1639759260
    },
    {
        "content": "<p>Oh I guess it should be called <code>intermediate_field.finite_dimensional_sup</code></p>",
        "id": 265324106,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639759266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span> did you need this stuff for e.g. normal closure?</p>",
        "id": 265324552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639759465
    },
    {
        "content": "<p>I can't remember seeing/using this sort of thing. We were just working with towers, I think.</p>",
        "id": 265356306,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1639772925
    },
    {
        "content": "<p>It's a shame that this isn't there, this is the sort of thing which is quite fiddly if you're not an expert, and Sebastian is just starting.</p>",
        "id": 265378924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639786210
    },
    {
        "content": "<p>I guess the lemma to prove is that if X spans E2 as a K-module then it spans E1 cup E2 as an E1-module</p>",
        "id": 265379032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639786300
    },
    {
        "content": "<p>But stating that is fiddly</p>",
        "id": 265379048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639786318
    },
    {
        "content": "<p>Here's a proof. I can start PRing it tomorrow, if you would like.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>lemma alg_hom.range_comp {R A B C : Type*} [comm_semiring R] [semiring A] [semiring B]<br>\n  [semiring C]<br>\n  [algebra R A] [algebra R B] [algebra R C] (f : A →ₐ[R] B) (g : B →ₐ[R] C) :<br>\n  (g.comp f).range = <a href=\"http://f.range.map\">f.range.map</a> g :=<br>\nset_like.coe_injective (set.range_comp g f)</p>\n<p>lemma alg_hom.range_comp_le_range {R A B C : Type*} [comm_semiring R] [semiring A] [semiring B]<br>\n  [semiring C]<br>\n  [algebra R A] [algebra R B] [algebra R C] (f : A →ₐ[R] B) (g : B →ₐ[R] C) :<br>\n  (g.comp f).range ≤ g.range :=<br>\nset_like.coe_mono (set.range_comp_subset_range f g)</p>\n<p>lemma subalgebra.mem_sup_left {R A : Type*} [comm_semiring R] [semiring A] [algebra R A]<br>\n  {S T : subalgebra R A} : ∀ {x : A}, x ∈ S → x ∈ S ⊔ T :=<br>\nshow S ≤ S ⊔ T, from le_sup_left</p>\n<p>lemma subalgebra.mem_sup_right {R A : Type*} [comm_semiring R] [semiring A] [algebra R A]<br>\n  {S T : subalgebra R A} : ∀ {x : A}, x ∈ T → x ∈ S ⊔ T :=<br>\nshow T ≤ S ⊔ T, from le_sup_right</p>\n<p>lemma subalgebra.mul_mem_sup {R A : Type*} [comm_semiring R] [semiring A] [algebra R A]<br>\n  {S T : subalgebra R A} {x y : A} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=<br>\n(S ⊔ T).mul_mem (subalgebra.mem_sup_left hx) (subalgebra.mem_sup_right hy)</p>\n<p>lemma algebra.tensor_product.product_map_range {R A B S : Type*} [comm_semiring R]<br>\n  [semiring A] [semiring B] [comm_semiring S] [algebra R A] [algebra R B] [algebra R S]<br>\n  (f : A →ₐ[R] S) (g : B →ₐ[R] S) :<br>\n  (algebra.tensor_product.product_map f g).range = f.range ⊔ g.range :=<br>\nbegin<br>\n  refine le_antisymm _ (sup_le _ _),<br>\n  { have := tensor_product.span_tmul_eq_top R A B,<br>\n    replace : algebra.adjoin R {t : A ⊗ B | ∃ (a : A) (b : B), a ⊗ₜ[R] b = t} = ⊤ :=<br>\n<a href=\"http://top_le_iff.mp\">top_le_iff.mp</a> ((<a href=\"http://eq_top_iff.mp\">eq_top_iff.mp</a> this).trans (algebra.span_le_adjoin R _)),<br>\n    rw [←algebra.map_top, ←this, ←algebra.adjoin_image, algebra.adjoin_le_iff],<br>\n    rintros _ ⟨_, ⟨a, b, rfl⟩, rfl⟩,<br>\n    rw algebra.tensor_product.product_map_apply_tmul,<br>\n    exact subalgebra.mul_mem_sup (f.mem_range_self a) (g.mem_range_self b) },<br>\n  { conv_lhs { rw ← algebra.tensor_product.product_map_left f g },<br>\n    apply alg_hom.range_comp_le_range },<br>\n  { conv_lhs { rw ← algebra.tensor_product.product_map_right f g },<br>\n    apply alg_hom.range_comp_le_range },<br>\nend</p>\n<p>lemma subalgebra.finite_dimensional_sup {K L : Type*} [field K] [comm_ring L] [algebra K L]<br>\n  (E1 E2 : subalgebra K L) [finite_dimensional K E1] [finite_dimensional K E2] :<br>\n  finite_dimensional K ↥(E1 ⊔ E2) :=<br>\nbegin<br>\n  let g := algebra.tensor_product.product_map E1.val E2.val,<br>\n  suffices : g.to_linear_map.range = (E1 ⊔ E2).to_submodule,<br>\n  { have key := g.to_linear_map.finite_dimensional_range,<br>\n    rwa this at key },<br>\n  suffices : g.range = E1 ⊔ E2,<br>\n  { rw ← this,<br>\n    refl },<br>\n  rw [algebra.tensor_product.product_map_range, E1.range_val, E2.range_val],<br>\nend</p>\n<p>lemma intermediate_field.range_val {K L : Type*} [field K] [field L] [algebra K L]<br>\n  (S : intermediate_field K L) : S.val.range = S.to_subalgebra :=<br>\nS.to_subalgebra.range_val</p>\n<p>lemma le_integral_closure_iff_is_integral {R A : Type*} [comm_ring R] [comm_ring A]<br>\n  [algebra R A] {S : subalgebra R A} : S ≤ integral_closure R A ↔ algebra.is_integral R S :=<br>\nbegin<br>\n  have : (∀ x : S, is_integral R (algebra_map S A x)) ↔ (∀ x : S, is_integral R x) :=<br>\n  forall_congr (λ x, is_integral_algebra_map_iff subtype.coe_injective),<br>\n  exact set_like.forall.symm.trans this,<br>\nend</p>\n<p>lemma is_field_of_is_integral_of_is_field'<br>\n  {R S : Type*} [field R] [comm_ring S] [is_domain S]<br>\n  [algebra R S] (H : algebra.is_integral R S) (hRS : function.injective (algebra_map R S)) :<br>\n  is_field S :=<br>\nbegin<br>\n  refine ⟨⟨0, 1, zero_ne_one⟩, mul_comm, λ x hx, _⟩,<br>\n  have key0 := fg_adjoin_singleton_of_integral x (H x),<br>\n  let A := algebra.adjoin R ({x} : set S),<br>\n  let f : A →ₗ[R] A :=<br>\n  { to_fun := λ y, ⟨x, algebra.mem_adjoin_iff.mpr (subring.mem_closure.mpr (λ T hT,<br>\n      show _, from <a href=\"http://set.singleton_subset_iff.mp\">set.singleton_subset_iff.mp</a> (<a href=\"http://set.union_subset_iff.mp\">set.union_subset_iff.mp</a> hT).2))⟩ * y,<br>\n    map_add' := λ y z, mul_add _ y z,<br>\n    map_smul' := λ y z, mul_smul_comm y _ z, },<br>\n  have key : function.injective f,<br>\n  { rw [←linear_map.ker_eq_bot, eq_bot_iff],<br>\n    intros y hy,<br>\n    exact (eq_zero_or_eq_zero_of_mul_eq_zero hy).resolve_left (λ h, hx (<a href=\"http://subtype.ext_iff.mp\">subtype.ext_iff.mp</a> h)) },<br>\n  haveI key' : is_noetherian R A.to_submodule := is_noetherian_of_fg_of_noetherian A.to_submodule<br>\n    (fg_adjoin_singleton_of_integral x (H x)),<br>\n  haveI this : module.finite R A.to_submodule := module.is_noetherian.finite R A,<br>\n  tactic.unfreeze_local_instances,<br>\n  change module.finite R A at this,<br>\n  obtain ⟨y, hy⟩ := @linear_map.surjective_of_injective R A _ _ _ _ f key 1,<br>\n  exact ⟨y, <a href=\"http://subtype.ext_iff.mp\">subtype.ext_iff.mp</a> hy⟩,<br>\nend</p>\n<p>lemma intermediate_field.sup_to_subalgebra {K L : Type*} [field K] [field L] [algebra K L]<br>\n  (E1 E2 : intermediate_field K L) [finite_dimensional K E1] [finite_dimensional K E2] :<br>\n  (E1 ⊔ E2).to_subalgebra = E1.to_subalgebra ⊔ E2.to_subalgebra :=<br>\nbegin<br>\n  have h1 : algebra.is_integral K E1 :=<br>\n  (is_algebraic_iff_is_integral' K).mp algebra.is_algebraic_of_finite,<br>\n  have h2 : algebra.is_integral K E2 :=<br>\n  (is_algebraic_iff_is_integral' K).mp algebra.is_algebraic_of_finite,<br>\n  have h3 : algebra.is_integral K ↥(E1.to_subalgebra ⊔ E2.to_subalgebra) :=<br>\n<a href=\"http://le_integral_closure_iff_is_integral.mp\">le_integral_closure_iff_is_integral.mp</a> (sup_le<br>\n    (le_integral_closure_iff_is_integral.mpr h1) (le_integral_closure_iff_is_integral.mpr h2)),<br>\n  have h4 := is_field_of_is_integral_of_is_field' h3 (ring_hom.injective _),<br>\n  let S : intermediate_field K L := (E1.to_subalgebra ⊔ E2.to_subalgebra).to_intermediate_field<br>\n    (λ x hx, by<br>\n    { by_cases hx' : x = 0,<br>\n      { rw [hx', inv_zero],<br>\n        exact (E1.to_subalgebra ⊔ E2.to_subalgebra).zero_mem },<br>\n      { obtain ⟨y, hy⟩ := h4.mul_inv_cancel<br>\n          (show (⟨x, hx⟩ : E1.to_subalgebra ⊔ E2.to_subalgebra) ≠ 0,<br>\n            from (λ h, hx' (<a href=\"http://subtype.ext_iff.mp\">subtype.ext_iff.mp</a> h))),<br>\n        have key : ↑y = x⁻¹ := eq_inv_of_mul_right_eq_one (<a href=\"http://subtype.ext_iff.mp\">subtype.ext_iff.mp</a> hy),<br>\n        rw ← key,<br>\n        exact y.2 } }),<br>\n  exact le_antisymm (show E1 ⊔ E2 ≤ S, from sup_le<br>\n    (show E1.to_subalgebra ≤ E1.to_subalgebra ⊔ E2.to_subalgebra, from le_sup_left)<br>\n    (show E2.to_subalgebra ≤ E1.to_subalgebra ⊔ E2.to_subalgebra, from le_sup_right))<br>\n    (sup_le (show E1 ≤ E1 ⊔ E2, from le_sup_left)<br>\n    (show E2 ≤ E1 ⊔ E2, from le_sup_right)),<br>\nend</p>\n<p>lemma intermediate_field.finite_dimensional_sup {K L : Type*} [field K] [field L] [algebra K L]<br>\n  (E1 E2 : intermediate_field K L) [h1 : finite_dimensional K E1] [h2 : finite_dimensional K E2] :<br>\n  finite_dimensional K ↥(E1 ⊔ E2) :=<br>\nbegin<br>\n  let g := algebra.tensor_product.product_map E1.val E2.val,<br>\n  suffices : g.to_linear_map.range = (E1 ⊔ E2).to_subalgebra.to_submodule,<br>\n  { have key := g.to_linear_map.finite_dimensional_range,<br>\n    rwa this at key },<br>\n  suffices : g.range = (E1 ⊔ E2).to_subalgebra,<br>\n  { rw ← this,<br>\n    refl },<br>\n  rw [algebra.tensor_product.product_map_range, E1.range_val, E2.range_val],<br>\n  exact (intermediate_field.sup_to_subalgebra E1 E2).symm,<br>\nend</p>\n</div></div>",
        "id": 265397048,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1639809699
    },
    {
        "content": "<p>Oh my goodness! Thank you so much Thomas!</p>",
        "id": 265407578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639818640
    },
    {
        "content": "<p>Thanks Thomas, that’s incredibly helpful!</p>",
        "id": 265409566,
        "sender_full_name": "Sebastian Monnet",
        "timestamp": 1639821433
    },
    {
        "content": "<p>So I can't quite get Thomas' code running because I seem to be missing an instance.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>Am I missing an import?</p>",
        "id": 265416355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639831299
    },
    {
        "content": "<p>You're probably missing <code>linear_algebra/tensor_product_basis.lean</code>. Sorry, I should have added imports.</p>",
        "id": 265434903,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1639852445
    },
    {
        "content": "<p>Here's the PR: <a href=\"https://github.com/leanprover-community/mathlib/pull/10938\">#10938</a></p>",
        "id": 265617486,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640035429
    },
    {
        "content": "<p>Thanks Thomas!</p>\n<p>I think that to do the stuff with normality we need a little more about splitting fields, for example \"if L/K is an extension, and f in K[X] splits in E_i for a bunch of subfields, then it splits in their Inf\".</p>",
        "id": 265622594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640038735
    },
    {
        "content": "<p>That particular thing doesn't sound too hard, since you can look at the roots of f. One way of doing this is to factor f in L (in terms of a multiset of elements of L), show that each root lies in the Inf, then construct a multiset in the Inf, and finally invoke the lemma about splitting iff there exists a multiset.</p>",
        "id": 265623599,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640039471
    },
    {
        "content": "<p>Is there a specific goal that all this is building up to?</p>",
        "id": 265623861,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1640039651
    },
    {
        "content": "<p>Topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi></mrow><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"true\">‾</mo></mover><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Gal}(\\overline{\\mathbb{Q}}/\\mathbb{Q}).</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1389em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Gal</span></span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1667em;\"><span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord mathbb\">Q</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span></p>",
        "id": 265623888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640039676
    },
    {
        "content": "<p>We already have it, but we're trying to do it properly (i.e. make a better definition for which it will be possible to develop an API)</p>",
        "id": 265623902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640039697
    }
]
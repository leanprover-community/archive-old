[
    {
        "content": "<p>Hi ! </p>\n<p>Say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> R </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a commutative ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo separator=\"true\">,</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\"> I,J</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> are ideals of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> R </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>J</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\"> J&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is the ideal corresponding to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>J</mi></mrow><annotation encoding=\"application/x-tex\"> J </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\"> R/I </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>.<br>\nDoes anyone know of results of the form <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mo stretchy=\"false\">(</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><msup><mi>J</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\"> R/(I+J) \\cong (R/I)/J&#x27; </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> in matlib ? (I couldn't find any when browsing through the files I thought might contain something like that).</p>\n<p>The context is I am trying to show that for an integer <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\"> p </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> (of course later I will be taking <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span> to be prime, hence the choice of notation <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)  and a polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\"> f </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> with integer coefficients,  there is an isomorphism <br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>≅</mo><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mi>p</mi><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>f</mi><mo stretchy=\"true\">‾</mo></mover><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> \\mathbb{Z}[x] / (p, f(x) ) \\cong \\mathbb{Z}/p\\mathbb{Z}[x] / ( \\overline{f}(x) ) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.14444em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.89444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span><span style=\"top:-3.81444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> that sends <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mo separator=\"true\">,</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> g + (p , f(x) )</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>g</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>p</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>f</mi><mo stretchy=\"true\">‾</mo></mover><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(g +( p )) + (\\overline{f}(x))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">p</span><span class=\"mclose\">))</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.14444em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.89444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span><span style=\"top:-3.81444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">))</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>f</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{f}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.08888em;vertical-align:-0.19444em;\"></span><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.89444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span><span style=\"top:-3.81444em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span></span></span></span> is the reduction of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> mod <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>.</p>\n<p>Many thanks in advance !</p>",
        "id": 246947751,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627025163
    },
    {
        "content": "<p>I also can't find this exact result (or anything much approaching it) in mathlib. Here's the definitions, but I've not filled in any of the proofs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.operations</span>\n\n<span class=\"c1\">-- let R be a commutative ring and let I,J be ideals of R</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.lift</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">ideal.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Then f₂ is an isomorphism</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ring_equiv.of_bijective</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>To me this indicates that we're missing some API for this sort of thing.</p>",
        "id": 246953302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627029622
    },
    {
        "content": "<p>Actually I think I'm being overly pessimistic making it noncomputable...</p>",
        "id": 246953749,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627029951
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.operations</span>\n\n<span class=\"c1\">-- let R be a commutative ring and let I,J be ideals of R</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.lift</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">ideal.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- define g₁ to be the composite of the maps R → (R/I) and (R/I) → (R/I)/J'</span>\n<span class=\"kd\">def</span> <span class=\"n\">g₁</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- define g₂ to be the induced map R/(I+J) → (R/I)/J'</span>\n<span class=\"kd\">def</span> <span class=\"n\">g₂</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- Then f₂ and g₂ are inverse isomorphisms</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">g₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_add</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 246954185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627030321
    },
    {
        "content": "<p>Thanks a lot ! I'd started to try and write some code towards a proof, but had some trouble understanding how Lean works with defining maps on quotients. I'd be happy to work on a bit of API for this sort of thing, since it seems I'll be needing it for the stuff I'm working on at the minute <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 246954572,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627030574
    },
    {
        "content": "<p>I found quotients In lean hard to understand so I <a href=\"https://wp.me/p9bxpM-LQ\">wrote a workshop on them</a> as part of my formalising mathematics course. The main thing to know is that quotients are defined by their universal property and what Lean calls <code>lift</code> is what a mathematician would think of as descent (<code>lift</code> is the function you use to get a map from the quotient given a map from the original ring and a proof that the ideal is in the kernel)</p>",
        "id": 246964781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627038716
    },
    {
        "content": "<p>Some of those sorries might be a little tricky by the way, I suspect they'll all have pretty slick solutions in Lean which will only be a few lines long but they might be hard to find!</p>",
        "id": 246964896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627038820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/246964781\">said</a>:</p>\n<blockquote>\n<p>I found quotients In lean hard to understand so I <a href=\"https://wp.me/p9bxpM-LQ\">wrote a workshop on them</a> as part of my formalising mathematics course. The main thing to know is that quotients are defined by their universal property and what Lean calls <code>lift</code> is what a mathematician would think of as descent (<code>lift</code> is the function you use to get a map from the quotient given a map from the original ring and a proof that the ideal is in the kernel)</p>\n</blockquote>\n<p>I've just read through the workshop, it makes a lot more sense now. I quite like the universal property approach !</p>",
        "id": 246971458,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627043786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/246964896\">said</a>:</p>\n<blockquote>\n<p>Some of those sorries might be a little tricky by the way, I suspect they'll all have pretty slick solutions in Lean which will only be a few lines long but they might be hard to find!</p>\n</blockquote>\n<p>Good to know ! My initial attempt had around 50 lines of code, and I wasn't even half way through, so I'll probably have to do some rewriting !</p>",
        "id": 246971596,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627043885
    },
    {
        "content": "<p>I've been able to spell out the proofs fully, but my code is still somewhat long-ish. Do you have any tips for making it more concise ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.operations</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">ideal</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ideal_quot</span>\n\n<span class=\"c1\">-- let R be a commutative ring and let I,J be ideals of R</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"bp\">+</span><span class=\"n\">I</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ideal.add_eq_sup</span><span class=\"o\">,</span> <span class=\"n\">sup_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ideal.add_eq_sup</span><span class=\"o\">]}</span>\n\n\n<span class=\"c1\">-- a few lemmas to help shorten the proofs later</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"bp\">→</span>  <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_left</span> <span class=\"n\">hx</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">right_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span> <span class=\"bp\">→</span>  <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_right</span> <span class=\"n\">hx</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">in_ker_proj_to_sum_left</span> <span class=\"o\">:</span> <span class=\"n\">I.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ideal.map</span><span class=\"o\">,</span><span class=\"n\">ideal.span_eq_bot</span><span class=\"o\">],</span>\n  <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">set.mem_image</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">left_proj_quot_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">x</span> <span class=\"n\">hx.1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">in_ker_proj_to_sum_right</span> <span class=\"o\">:</span> <span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">in_ker_proj_to_sum_left</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- define f₁ to be the obvious ring hom R/I → R/(I+J)</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.lift</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">left_proj_quot_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- one of the longer proofs. This will be used to lift f₁ to a map (R/I)/J' → R/(I+J)</span>\n<span class=\"kd\">def</span> <span class=\"n\">H_proj_J</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hIJmap</span><span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">''</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.ext</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n\n    <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image</span> <span class=\"o\">((</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"n\">J</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₁</span> <span class=\"n\">at</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.comp_apply</span><span class=\"o\">,</span><span class=\"n\">ideal.quotient.lift_mk</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hz</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hz.right</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.mem_image_of_mem</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"n\">hz.left</span><span class=\"o\">},</span>\n\n    <span class=\"o\">{</span><span class=\"n\">intro</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span><span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"n\">J</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">set.mem_image_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">ring_hom.comp_apply</span><span class=\"o\">,</span><span class=\"n\">ideal.quotient.lift_mk</span><span class=\"o\">]},</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">hJ</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span>\n    <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ideal.map_map</span><span class=\"o\">,</span><span class=\"n\">ideal.map</span><span class=\"o\">,</span><span class=\"n\">hIJmap</span><span class=\"o\">,</span><span class=\"bp\">←</span> <span class=\"n\">ideal.map</span><span class=\"o\">],</span>\n\n  <span class=\"k\">have</span> <span class=\"n\">hf₁a</span> <span class=\"o\">:</span> <span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ideal.map</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">set.mem_of_subset_of_mem</span> <span class=\"o\">(</span><span class=\"n\">ideal.subset_span</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">set.mem_image_of_mem</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">hx</span><span class=\"o\">),</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">hJ</span><span class=\"o\">,</span> <span class=\"n\">in_ker_proj_to_sum_right</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf₁a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c1\">-- define f₂ to be the induced ring hom (R/I)/J' -&gt;R/(I+J), where J' is the image of J in R/I</span>\n<span class=\"kd\">def</span> <span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">ideal.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_proj_J</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- define g₁ to be the composite of the maps R → (R/I) and (R/I) → (R/I)/J'</span>\n<span class=\"kd\">def</span> <span class=\"n\">g₁</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Another short result for lifting map g₁ to a map R/(I+J) → (R/I)/J'</span>\n<span class=\"kd\">def</span> <span class=\"n\">H_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">):</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span> <span class=\"bp\">→</span> <span class=\"n\">g₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hIJtoJ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ideal.add_eq_sup</span><span class=\"o\">,</span> <span class=\"n\">ideal.map_sup</span><span class=\"o\">,</span><span class=\"n\">map_quotient_self</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span><span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hJto0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span><span class=\"o\">(</span><span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n    <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">map_quotient_self</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span>\n    <span class=\"o\">(</span><span class=\"n\">J.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hIJtoJ</span><span class=\"o\">,</span> <span class=\"n\">hJto0</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">g₁</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">ideal.mem_bot</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.comp_apply</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ideal.mem_map_of_mem</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ideal.mem_map_of_mem</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"c1\">-- define g₂ to be the induced map R/(I+J) → (R/I)/J'</span>\n<span class=\"kd\">def</span> <span class=\"n\">g₂</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.lift</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Then f₂ and g₂ are inverse isomorphisms</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">f₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">g₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function.left_inverse</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hu</span><span class=\"o\">,</span><span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_proj_J</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)],</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hv</span><span class=\"o\">,</span><span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">left_proj_quot_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)],</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">g₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">g₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ring_hom.comp_apply</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">function.right_inverse</span> <span class=\"n\">function.left_inverse</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">u</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">hu</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">g₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">g₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ring_hom.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₂</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f₁</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H_proj_J</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">f₁</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ideal.quotient.lift_mk</span> <span class=\"n\">I</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span>  <span class=\"o\">(</span><span class=\"n\">left_proj_quot_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n  <span class=\"kd\">end</span>\n  <span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_mul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.map_add</span> <span class=\"n\">_</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 247310079,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627377037
    },
    {
        "content": "<p>A general comment: in mathlib <code>sum</code> in a lemma name refers to an n-ary sum, not the binary addition you use there which mathlib calls <code>add</code>.</p>",
        "id": 247310469,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627377360
    },
    {
        "content": "<p>Ah thanks that's good to know, I'll edit the names of the lemmas !</p>",
        "id": 247310686,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627377495
    },
    {
        "content": "<p>Here's a much shorter way to close your last example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this should maybe be in mathlib</span>\n<span class=\"sd\">/-- Any two ring homs out of a quotient are equal if their composition with quotient.mk is equal -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ideal.quotient.ring_hom_ext</span> <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Then f₂ and g₂ are inverse isomorphisms</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ring_equiv.of_hom_inv</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 247311238,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627377959
    },
    {
        "content": "<p>Your first two lemmas can be golfed slightly be removing the <code>intro</code> - if your goal state has a <code>→</code> in it, and the first line of your proof is an <code>intro</code>, then you should have used a <code>:</code> instead of a <code>→</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- as mentioned above these should have `add` not `sum` in their names.</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_left</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">right_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_right</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 247311622,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627378215
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/247311238\">said</a>:</p>\n<blockquote>\n<p>Here's a much shorter way to close your last example:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this should maybe be in mathlib</span>\n<span class=\"sd\">/-- Any two ring homs out of a quotient are equal if their composition with quotient.mk is equal -/</span>\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ideal.quotient.ring_hom_ext</span> <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">I.quotient</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g.comp</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.mk_surjective</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.congr_fun</span> <span class=\"n\">h</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Then f₂ and g₂ are inverse isomorphisms</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">J.map</span> <span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span> <span class=\"n\">I</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"bp\">≃+*</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">+</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">:=</span>\n<span class=\"n\">ring_equiv.of_hom_inv</span> <span class=\"o\">(</span><span class=\"n\">f₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g₂</span> <span class=\"n\">I</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah, I didn't know about the ext tactic, thanks a lot for showing me that !</p>",
        "id": 247313746,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627379799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Quotient.20of.20a.20ring.20by.20a.20sum.20of.20ideals/near/247311622\">said</a>:</p>\n<blockquote>\n<p>Your first two lemmas can be golfed slightly be removing the <code>intro</code> - if your goal state has a <code>→</code> in it, and the first line of your proof is an <code>intro</code>, then you should have used a <code>:</code> instead of a <code>→</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- as mentioned above these should have `add` not `sum` in their names.</span>\n<span class=\"kd\">def</span> <span class=\"n\">left_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_left</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">right_proj_quot_sum</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal.quotient.mk</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.eq_zero_iff_mem.2</span> <span class=\"o\">(</span><span class=\"n\">ideal.mem_sup_right</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I've noticed a few other of my lemmas have a similar issue, I'll make the relevant modifications</p>",
        "id": 247313793,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627379847
    },
    {
        "content": "<p>Unfold's are quite often not necessary in a proof, while they are useful to see what's going on and what you want to do next of course, it can make proofs more readable / short by removing them after, so I'd recommend trying to see which ones can be removed. Doing this you can combine some rewrites onto one line too when they are only small steps.<br>\nAlso the tactics <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rcases\">tactic#rcases</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#rintros\">tactic#rintros</a> can be very helpful when you just want to introduce something and then split it up immediately, definitely worth looking at examples of how they are used in mathlib to see some of the tricks <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>.</p>",
        "id": 247354939,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1627402257
    },
    {
        "content": "<p>For example <code>in_ker_proj_to_sum_left</code> can be proved with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">in_ker_proj_to_sum_left</span> <span class=\"o\">:</span> <span class=\"n\">I.map</span><span class=\"o\">(</span><span class=\"n\">ideal.quotient.mk</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">+</span><span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">ideal.map</span><span class=\"o\">,</span> <span class=\"n\">ideal.span_eq_bot</span><span class=\"o\">,</span> <span class=\"n\">set.mem_image</span><span class=\"o\">],</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">y</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">left_proj_quot_sum</span> <span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 247355960,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1627402798
    },
    {
        "content": "<p><code>rintro</code> is a synonym of <code>rintros</code> and <code>obtain</code> makes more semantical sense than <code>rcases</code> when you <em>obtain</em> an object and its property from an <code>exists</code> for example.</p>",
        "id": 247360554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1627405036
    },
    {
        "content": "<p>Thanks a lot for the advice ! I've been trying to expand the repertoire of tactics I know how to use so I'll try and have a go at using those !</p>",
        "id": 247432867,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627460278
    },
    {
        "content": "<p>On a slightly unrelated issue I've encountered when playing around with the code, say we have two rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\"> S </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> which we can prove are equal (although they aren't equal by definition - in my case, this is the quotients <code>(I+J).quotient</code> and <code>(J+I).quotient</code> ). Is there :</p>\n<ol>\n<li>An easy way of defining the identity isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">R \\to S </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> ? </li>\n<li>Given another type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\"> T </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>, can we get Lean to understand <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\"> f : R \\to T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> as a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>S</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\"> f : S \\to T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> ?</li>\n</ol>\n<p>For the first question, the case I am interested in seems to be approachable using <code>quot_equiv_of_eq</code> in <code>ring_theory.ideals.basic</code>, but is there a way to get an explicit description of the isomorphism ? (if possible, I would need to show that the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mi>x</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">x + (I+J) \\mapsto x + (J+I) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span></span></span></span> is an isomorphism. This could be done by lifting the canonical map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> R \\to R/(J+I) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span></span></span></span> to a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>I</mi><mo>+</mo><mi>J</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mo stretchy=\"false\">(</mo><mi>J</mi><mo>+</mo><mi>I</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\"> R/(I+J) \\to R/(J+I) </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mclose\">)</span></span></span></span>, but I'm sure there's a slicker approach !)</p>",
        "id": 247434270,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627461316
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal.quot_equiv_of_eq\">docs#ideal.quot_equiv_of_eq</a> is indeed what you want</p>",
        "id": 247434430,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627461430
    },
    {
        "content": "<p>It looks like it (along with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.congr\">docs#quotient.congr</a> which it builds upon) is missing the lemmas about how it applies</p>",
        "id": 247434696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627461613
    },
    {
        "content": "<p>Fair enough, thanks ! <br>\n Out of curiosity, how would we do this for the general case of equal rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\"> R </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\"> S </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> ?</p>",
        "id": 247436010,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627462666
    },
    {
        "content": "<p>You mean when you can prove <code>R = S</code>?</p>",
        "id": 247437027,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627463379
    },
    {
        "content": "<p>That's not enough, to make a ring_equiv you have to prove the ring structures agree too</p>",
        "id": 247437121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627463429
    },
    {
        "content": "<p>Oh right, of course ! Thanks !<br>\nI should be more careful when I use the equal sign, I was getting confused between equality of types and equivalence of ring structures <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 247437795,
        "sender_full_name": "Paul Lezeau",
        "timestamp": 1627463965
    },
    {
        "content": "<p>For the case of the quotients you know that the two ring structures are equal by construction</p>",
        "id": 247438393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627464397
    },
    {
        "content": "<p>Oh I had never realised that!</p>",
        "id": 247439162,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627464955
    },
    {
        "content": "<p>The quotient only depends on the underlying equivalence relation which are equal for the two quotients.</p>",
        "id": 247439248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1627464997
    }
]
[
    {
        "content": "<p>I'm using the <code>finsum</code> API for the first time. Do we have this anywhere?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.finprod</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">ab.fst</span> <span class=\"n\">ab.snd</span> <span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 236801997,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619771054
    },
    {
        "content": "<p>I think it's not true</p>",
        "id": 236804761,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619772817
    },
    {
        "content": "<p>Consider <code>f (x : bool) (y : nat) = if (x and y = 0) or not x then 1 else 0</code></p>",
        "id": 236804946,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619772925
    },
    {
        "content": "<p>I think your example then reduces to  <code>0 = 1</code></p>",
        "id": 236805039,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619772966
    },
    {
        "content": "<p>LOL, thanks.</p>",
        "id": 236806449,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619773782
    },
    {
        "content": "<p>Although proving that was awful:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">ab.fst</span> <span class=\"n\">ab.snd</span> <span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"k\">if</span> <span class=\"n\">b</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">×</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">function.support</span> <span class=\"n\">f'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">infinite</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">set.infinite_of_injective_forall_mem</span> <span class=\"o\">(</span><span class=\"n\">prod.mk.inj_left</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">function.support</span><span class=\"o\">,</span> <span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsum_of_infinite_support</span> <span class=\"n\">this</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finsum_eq_sum_of_fintype</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fintype.sum_eq_single</span> <span class=\"n\">ff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">@</span><span class=\"n\">finsum_eq_sum_of_support_subset</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">finset.sum_singleton</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,},</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">finsum_of_infinite_support</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">set.infinite_of_injective_forall_mem</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nat.succ.inj</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">function.support</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 236807687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774519
    },
    {
        "content": "<p>This is brilliant. Refutation by formal proof <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 236807800,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774560
    },
    {
        "content": "<p>How hard would it be to have a <code>counterexample</code> notation do you think?</p>",
        "id": 236807864,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774611
    },
    {
        "content": "<p>That handles the <code>¬ </code> and <code>by exactI</code></p>",
        "id": 236807884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774624
    },
    {
        "content": "<p>I have no idea but it's an interesting thought.</p>",
        "id": 236807954,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774646
    },
    {
        "content": "<p>Vaguely related thought: I have occasionally thought that if the machine learning people really are to have any chance of getting somewhere using Mathlib as a dataset then they would need a wealth of counterexamples.</p>",
        "id": 236808082,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774708
    },
    {
        "content": "<p>This does sort of make me worry that the <code>finsum</code> API is awkward, in that \"infinities\" don't propagate</p>",
        "id": 236808107,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774724
    },
    {
        "content": "<p>Like that's probably how we secretly reason about mathematics more than half the time.</p>",
        "id": 236808113,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/finsum.20over.20product.20of.20types/near/236808107\">said</a>:</p>\n<blockquote>\n<p>This does sort of make me worry that the <code>finsum</code> API is awkward</p>\n</blockquote>\n<p>I'm currently thinking about this too.</p>",
        "id": 236808204,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774773
    },
    {
        "content": "<p>For instance, perhaps it should return <code>with_top M</code> instead</p>",
        "id": 236808258,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774806
    },
    {
        "content": "<p>Exactly what I'm asking myself!</p>",
        "id": 236808270,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619774818
    },
    {
        "content": "<p>Although you need something clever somewhere to avoid ending up with <code>with_top (with_top M)</code></p>",
        "id": 236808280,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619774826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> had a <code>counterexamples</code> branch (but pre the huge changes so it might have rotted by now). I wonder if we could have a directory of counterexamples but not in <code>src</code>?</p>",
        "id": 236808417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619774910
    },
    {
        "content": "<p>Maybe it belongs to <code>archive</code>?</p>",
        "id": 236808508,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1619774987
    },
    {
        "content": "<p>I'd be in favour of at least experimenting with a <code>counterexamples</code> section of <code>archive</code>.</p>",
        "id": 236808586,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619775017
    },
    {
        "content": "<p>Damiano has a branch with exactly that name (-;<br>\n(Edit: I now see that Kevin wrote this 3 posts up <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span>)</p>",
        "id": 236809319,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619775409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/finsum.20over.20product.20of.20types/near/236808280\">said</a>:</p>\n<blockquote>\n<p>Although you need something clever somewhere to avoid ending up with <code>with_top (with_top M)</code></p>\n</blockquote>\n<p>This is what the option monad is for</p>",
        "id": 236809560,
        "sender_full_name": "David Wärn",
        "timestamp": 1619775573
    },
    {
        "content": "<p>I think <code>with_top</code> is just <code>option</code>.</p>",
        "id": 236809749,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619775671
    },
    {
        "content": "<p>Yes, so the monad multiplication takes you from <code>with_top (with_top X)</code> to <code>with_top X</code></p>",
        "id": 236809870,
        "sender_full_name": "David Wärn",
        "timestamp": 1619775747
    },
    {
        "content": "<p>Agreed. I think this should work.</p>",
        "id": 236809925,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619775779
    },
    {
        "content": "<p>I don't really see how to apply that here - what would the signature of <code>finsum</code> become?</p>",
        "id": 236810022,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619775846
    },
    {
        "content": "<p>The first step would be to make its output <code>option M</code></p>",
        "id": 236810074,
        "sender_full_name": "David Wärn",
        "timestamp": 1619775891
    },
    {
        "content": "<p>Currently its</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">finsum</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 236810081,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619775894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> <code>with_top := option</code></p>",
        "id": 236810116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619775917
    },
    {
        "content": "<p>I think Eric's point is that the input would have to be <code>with_top M</code> also.</p>",
        "id": 236810134,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619775925
    },
    {
        "content": "<p>If you made it</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">finsum</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>then how do you prevent <code>∑ᶠ a b, f a b</code> having type <code>option (option m))</code>?</p>",
        "id": 236810136,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619775927
    },
    {
        "content": "<p>That's certainly what my point should have been! Indeed,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">finsum</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">M</span>\n</code></pre></div>\n<p>would solve the problem</p>",
        "id": 236810263,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619776004
    },
    {
        "content": "<p>I think we'd want to use <code>def finsum.result M := option M</code> rather than <code>option</code> directly</p>",
        "id": 236810366,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619776061
    },
    {
        "content": "<p>And then we could add a coercion from <code>finsum.result M</code> to <code>M</code> that sends <code>top</code> to <code>0</code></p>",
        "id": 236810385,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619776077
    },
    {
        "content": "<p>Which would preserve the current API in some form</p>",
        "id": 236810393,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619776083
    },
    {
        "content": "<p>If that last coercion trick works, it would be really neat. Best of all worlds.</p>",
        "id": 236810475,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619776112
    },
    {
        "content": "<p>You can sort of get the second signature from the first:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.option.basic</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">whats_this_called</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_some</span> <span class=\"k\">then</span> <span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">option.get</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"k\">else</span> <span class=\"n\">none</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">finsum</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">finsum'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">option</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">whats_this_called</span> <span class=\"n\">f</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">finsum</span>\n</code></pre></div>",
        "id": 236812670,
        "sender_full_name": "David Wärn",
        "timestamp": 1619777444
    },
    {
        "content": "<p>The option monad is basically a principled way of making sure undefined values propagate. But mathlib generally prefers to use <code>0</code> for undefined values</p>",
        "id": 236812850,
        "sender_full_name": "David Wärn",
        "timestamp": 1619777569
    },
    {
        "content": "<p>For undefined values of add_monoid, 1 for monoid for finprod, of course</p>",
        "id": 236831522,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619788299
    },
    {
        "content": "<p>What's this called is ((&gt;&gt;= f) o pure) I think</p>",
        "id": 236832245,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619788661
    },
    {
        "content": "<p>The whole point of this function is that it doesn't have undefinedness handling</p>",
        "id": 236832909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619788950
    },
    {
        "content": "<p>because that handling is exactly what causes all the pain</p>",
        "id": 236832936,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619788965
    },
    {
        "content": "<p>But we still have all that handling as obligations in the lemmas anyway</p>",
        "id": 236833235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619789099
    },
    {
        "content": "<p>And the compromise finsum makes seems to make a bunch of \"obvious\" statements not true without annoying side conditions</p>",
        "id": 236833286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619789126
    },
    {
        "content": "<p>The statements are true as long as you ignore the fact that <code>finsum</code> is defined on useless inputs</p>",
        "id": 236833346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789152
    },
    {
        "content": "<p>just assume everything is reasonable in the lemmas</p>",
        "id": 236833361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789159
    },
    {
        "content": "<p><code>finsum</code> is not actually any different from <code>finset.sum</code> in terms of assumptions</p>",
        "id": 236833439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789182
    },
    {
        "content": "<p>it's just possible to state theorems that lie outside those assumptions now</p>",
        "id": 236833496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789205
    },
    {
        "content": "<p>your first response to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">ab.fst</span> <span class=\"n\">ab.snd</span> <span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>should be \"that doesn't typecheck, let me add assumptions so I don't have to deal with places where the function is crazy\"</p>",
        "id": 236833568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789247
    },
    {
        "content": "<p>for example <code>[fintype α] [fintype β]</code></p>",
        "id": 236833665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789286
    },
    {
        "content": "<p>Oh, I guess an argument for why <code>option</code> wouldn't really help is the sum over <code>f (z : units int \\times int) := z.1 * z.2</code></p>",
        "id": 236833825,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619789371
    },
    {
        "content": "<p>this is a little bit overconstrained, but the nice thing about <code>finsum</code> is that it is defined whenever it can possibly be defined so you can later revisit and generalize the theorem to any context where it remains reasonable. But the fully general statement is probably not the first thing you want</p>",
        "id": 236833844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789384
    },
    {
        "content": "<p>You will need monads everywhere with the <code>option</code> approach</p>",
        "id": 236833921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789405
    },
    {
        "content": "<p>plus it's not even computable, you need to use <code>whats_this_called</code> which is more naturally stated on <code>roption</code></p>",
        "id": 236833988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789436
    },
    {
        "content": "<p>If you want to propagate a well definedness condition through multiple operations, I would suggest <code>roption</code> instead of <code>option</code>. The latter is better when the function itself can tell you whether or not it is defined</p>",
        "id": 236834189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789530
    },
    {
        "content": "<p>But at a certain point this starts to look like the situation with integrals and derivatives where you have to do everything twice, first prove that the value is defined and then prove it is equal to something (and neither implies the other)</p>",
        "id": 236834333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789595
    },
    {
        "content": "<p>The nice thing about <code>finset.sum</code> is that it is always defined, so the first part is absent. It's still possible to have this with <code>finsum</code> provided the definedness proof is \"easy\" or typeclassable</p>",
        "id": 236834528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789669
    },
    {
        "content": "<p>Presumably having <code>finsum</code> match the design of integrals makes a lot of sense?</p>",
        "id": 236834656,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619789737
    },
    {
        "content": "<p>not if it makes the easy case harder</p>",
        "id": 236834748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789766
    },
    {
        "content": "<p>because the whole reason it exists is to make dealing with finite sums easier than the existing method using <code>finset.sum</code></p>",
        "id": 236834850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619789808
    },
    {
        "content": "<p>It is a bit funny to me that <code>finsum</code> is converging on the design of finite sums that I did in metamath, <a href=\"http://us.metamath.org/mpeuni/df-gsum.html\">df-gsum</a>. The idea behind it is that it is defined to be the sum if it is at all reasonable to call a unique thing \"the sum\" of a function. It's still a bit more crazy than <code>finsum</code> since it also special cases when the summing set is a sequence of integers, in which case it is the left-associative ordered sum; otherwise it is the sum of the nonzero values up to associativity and commutativity</p>",
        "id": 236835800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619790188
    },
    {
        "content": "<p>doing something like that would be harder in lean since type equality tests don't work very well</p>",
        "id": 236835883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619790230
    },
    {
        "content": "<p>My armchair understanding is that using <code>roption / option</code> for partial values like these could be really nice, if only we had some nice way of dealing with all the monad stuff (as well as <code>whats_this_called</code>, which I guess can't be defined in terms of monad operations since it's noncomputable). For example the false theorem at the start of this thread is a true unconditional equality in <code>roption M</code>. A lot of other lemmas, like <code>finsum (f + g) = finsum f + finsum g</code> aren't equalities since the LHS can be defined even when the RHS isn't. Here there's a directedness to the lemma: if you know the values of<code>finsum f</code> and <code>finsum g</code>, then you also know the value of <code>finsum (f + g)</code>. Of course this is still easy to express with <code>roption</code>. Fubini's theorem for infinite sums is worse: knowing that <code>some x = ∑ a b, f a b</code> doesn't tell you that <code>∑ ab, f ab.fst ab.snd</code> exists. Still the way you compute the latter sum in practice is that you compute the former sum, and during these computations observe that <code>∑ a b, |f a b|</code> is finite...</p>",
        "id": 236841170,
        "sender_full_name": "David Wärn",
        "timestamp": 1619792360
    },
    {
        "content": "<p>If you go too far in this direction you end up at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tsum\">docs#tsum</a></p>",
        "id": 236841528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619792478
    },
    {
        "content": "<blockquote>\n<p>and during these computations observe that ∑ a b, |f a b| is finite...</p>\n</blockquote>\n<p>This of course assumes that <code>|f a b|</code> is a thing</p>",
        "id": 236842818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619792951
    },
    {
        "content": "<p>If the target type is canonically ordered, then I think you do have Fubini's theorem (with suitable undefinedness preserving sum operations)</p>",
        "id": 236843005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793011
    },
    {
        "content": "<p>Yes, the problem is with negative terms</p>",
        "id": 236843059,
        "sender_full_name": "David Wärn",
        "timestamp": 1619793032
    },
    {
        "content": "<p>But eric is right that if you want to handle convergence of absolute values that's what <code>tsum</code> does</p>",
        "id": 236843179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793088
    },
    {
        "content": "<p>Personally, I think the lemmas should just assume the indexing set is finite because that's the easy case where all the lemmas go through</p>",
        "id": 236843304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793138
    },
    {
        "content": "<p>There will be a second series of lemmas with more subtle conditions when you only have finite support</p>",
        "id": 236843346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793157
    },
    {
        "content": "<p>This sounds like a reasonable pragmatic approach</p>",
        "id": 236844611,
        "sender_full_name": "David Wärn",
        "timestamp": 1619793663
    },
    {
        "content": "<p>BTW, a sum where some term is ill-defined should be thought of as ill-defined. This is why you should be able to factor the sum of <code>f : A -&gt; roption B</code> through <code>whats_this_called</code> as sketched above. This is not true of integrals: the integral of <code>f : A -&gt; roption B</code> should only require <code>f</code> to be a.e. well-defined.</p>",
        "id": 236844649,
        "sender_full_name": "David Wärn",
        "timestamp": 1619793687
    },
    {
        "content": "<p>You should be able to do so, since I think <code>roption A</code> is a comm monoid if <code>A</code> is</p>",
        "id": 236844847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793773
    },
    {
        "content": "<p>maybe that instance doesn't exist</p>",
        "id": 236844878,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793785
    },
    {
        "content": "<p>I guess that's what <code>with_top</code> will do for you</p>",
        "id": 236845059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793855
    },
    {
        "content": "<p>Aha, that's nice!</p>",
        "id": 236845125,
        "sender_full_name": "David Wärn",
        "timestamp": 1619793891
    },
    {
        "content": "<p>Oh, actually if there are infinitely many tops then you will get 0 instead of top</p>",
        "id": 236845175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793914
    },
    {
        "content": "<p>so the <code>finsum</code> implementation has to be aware of the top element</p>",
        "id": 236845236,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619793939
    },
    {
        "content": "<p>BTW here's the roption version of <code>whats_this_called</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.pfun</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">pfun.totalize</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→.</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roption</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">)⟩</span>\n</code></pre></div>",
        "id": 236845576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619794074
    },
    {
        "content": "<p>But <code>pfun.totalize</code> isn't in mathlib yet right?</p>",
        "id": 236845938,
        "sender_full_name": "David Wärn",
        "timestamp": 1619794224
    },
    {
        "content": "<p>no, I just made it up</p>",
        "id": 236846016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619794266
    },
    {
        "content": "<p>Dear All,</p>\n<p>I have not followed the discussion yet, but indeed there is a <code>counterexamples</code> branch to mathlib.  I have maintained it by merging master into it every once in a whole, but have not done so after the two big <code>nat/int</code> refactors.</p>\n<p>The branch might break now, but I would still love to have more counterexamples!  Feel free to push something onto it: in the branch counterexamples, there is a counterexamples folder in src.</p>",
        "id": 236873734,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619804428
    },
    {
        "content": "<p>I am on holidays for a week, so I will not have a chance to update master soon, but will do so as soon as I can!</p>",
        "id": 236873804,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619804467
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Enjoy your holidays. I will keep the <code>counterexamples</code> branch in mind.</p>",
        "id": 236888423,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619810730
    },
    {
        "content": "<p>I’ve also wanted a Fubini for <code>finsum</code> for my work on Hahn series, and an analog of <code>finset.sum_sigma</code>. An option version would be great because you could use <code>simp</code> and only have to check finiteness at the beginning and end, but it would also be awful because yet. another. API.</p>",
        "id": 236922804,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619830862
    },
    {
        "content": "<p>I don't have time right now but I might at least try to prove this version (which would suffice for my purposes) this evening:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.big_operators.finprod</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∑ᶠ</span> <span class=\"n\">ab</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ab</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">ab</span> <span class=\"bp\">=</span> <span class=\"bp\">∑ᶠ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 236961309,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619870065
    },
    {
        "content": "<p>(On the off chance some good citizen was going to work on <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span>  I now have a proof of this which I will PR tomorrow)</p>",
        "id": 236996369,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619901039
    },
    {
        "content": "<p>Just pushed up my attempt as <a href=\"https://github.com/leanprover-community/mathlib/issues/7439\">#7439</a></p>",
        "id": 237052797,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619962011
    }
]
[
    {
        "content": "<p>If <code>Pr</code> is a probability measure on a sample space <code>α</code>, and <code>X</code> is a <code>β</code>-valued random variable, then I suppose the right way in Lean to talk about the distribution of <code>X</code> (i.e. the law of <code>X</code>) is as <code>measure.map X Pr</code>, right?</p>\n<p>Do we have an <code>instance</code> that the law of a random variable is a probability measure? Is <code>instance</code> even the right way to implement this, to free the user from ever having to explicitly explain that the distribution of a random variable, which is a <code>(measure.map X Pr : measure β)</code> by construction, is moreover a <code>probability_measure</code>?</p>\n<p>In other words, is there something like the following? Or is there a better way?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">probability_measure.map_is_probability_measure</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Pr</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_measure</span> <span class=\"n\">Pr</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X_mble</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">probability_measure</span> <span class=\"o\">(</span><span class=\"n\">measure.map</span> <span class=\"n\">X</span> <span class=\"n\">Pr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">measure_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">measure.map_apply</span> <span class=\"n\">X_mble</span> <span class=\"n\">measurable_set.univ</span><span class=\"o\">,</span> <span class=\"n\">set.preimage_univ</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">measure_univ</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248151189,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627948133
    },
    {
        "content": "<p>is there a bundled morphism type for measurable functions? Because you could have that be an instance of <code>probability_measure (measure.map (\\u X) Pr)</code> where <code>X</code> is a bundled morphism</p>",
        "id": 248151386,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627948324
    },
    {
        "content": "<p>alternatively, you could add a wrapper around <code>measure.map</code> that takes an extra argument for <code>X_mble</code> and give that the <code>probability_measure</code> instance</p>",
        "id": 248151475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627948390
    },
    {
        "content": "<p>I believe the closest thing we have to bundled measurable maps is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_eq_fun\">docs#measure_theory.ae_eq_fun</a>, which is about a.e.-measurable maps, and also takes a quotient...</p>",
        "id": 248172456,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1627952988
    },
    {
        "content": "<p>Note that <code>probability_theory/integration.lean</code> has lemmas regarding real-valued random variables, without specifying that the measure is a probability measure. <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> pointed out a problem <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245614036\">here</a> with too many measurable_space instances. My tentative definition of expected value for real-valued random variables (which I have not committed) is: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">expected_value</span> <span class=\"o\">[</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ennreal</span> <span class=\"bp\">=</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"n\">a</span> <span class=\"bp\">∂</span><span class=\"n\">μ</span>\n</code></pre></div>\n<p>I am also working on a proof of the Borel-Cantelli partial converse where the constraint that the measure be a probability measure is an added assumption:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">measure_limsup_eq_one</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measurable_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hs'</span> <span class=\"o\">:</span> <span class=\"bp\">∑'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∞</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hi</span><span class=\"o\">:</span> <span class=\"n\">Indep_set</span> <span class=\"n\">s</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_measure</span> <span class=\"n\">μ</span> <span class=\"o\">]:</span>  <span class=\"n\">μ</span> <span class=\"o\">(</span><span class=\"n\">limsup</span> <span class=\"n\">at_top</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 248182671,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1627967240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397140\">Hunter Monroe</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/the.20law.20of.20a.20random.20variable.20is.20a.20probability.20measure/near/248182671\">said</a>:</p>\n<blockquote>\n<p>Note that <code>probability_theory/integration.lean</code> has lemmas regarding real-valued random variables, without specifying that the measure is a probability measure. </p>\n</blockquote>\n<p>I agree one doesn't always need to have the assumption that a measure is a probability measure, even for \"probability\" results. In particular I fully agree the expected value should be written as just an <code>integral</code> or a <code>lintegral</code>, depending on whether one is doing expected values of nonnegative or expected values of integrable random variables.</p>\n<p>But there <em>are</em> cases when you do need to know that the law of a random variable is a probability measure. My suggestion was that if there is already a <code>probability_measure</code> instance on the (probability) measure <code>Pr</code> on the sample space, then it should be up to the typeclass inference to get a probabability measure instance on the law <code>measure.map X Pr</code> of a random variable <code>X</code>. The alternatives are to leave it to the user (which I would not like), or some more clever implementation.</p>",
        "id": 248190874,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627976532
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> pointed out a problem <a href=\"#narrow/stream/113489-new-members/topic/Probability.20theory/near/245614036\">here</a> with too many measurable_space instances.</p>\n</blockquote>\n<p>I read that somewhat differently: my takeaway was that the typeclass inference is designed to have only one instance of a class, whereas in probability theory one often needs several sigma-algebras (<code>measurable_space</code> \"instances\") on the same type. The appropriate implementation for conveniently working with several sigma-algebras is a good question. But I was anyway not suggesting adding any new <code>measurable_space</code> instances above, only a <code>probability_measure</code> instance on an existing <code>measure</code> (namely <code>measure.map X Pr</code>). I am pretty sure one doesn't ever want many <code>probability_measure</code> instances on the same measure <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>, so here the typeclass seems a priori quite appropriate. (Although I realize that if there is no consensus on the best implementation, then playing with any alternatives a bit might be good before deciding about the mathlib way.)</p>",
        "id": 248190959,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627976633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/the.20law.20of.20a.20random.20variable.20is.20a.20probability.20measure/near/248172456\">said</a>:</p>\n<blockquote>\n<p>I believe the closest thing we have to bundled measurable maps is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.ae_eq_fun\">docs#measure_theory.ae_eq_fun</a>, which is about a.e.-measurable maps, and also takes a quotient...</p>\n</blockquote>\n<p>Thanks Floris! I also thought there is no bundled measurable maps as such. (Although I don't know if there should be; for example <code>bounded_continuous_function</code>s seem to be working nicely.) And I would have guessed indeed the issue is that occasionally one would prefer <code>ae_measurable</code> and occasionally <code>measurable</code> (in particular one doesn't always have a measure to determine the meaning of a.e., or one wants measurability irrespective of the measure).</p>\n<p>I don't know if creating bundled versions of both \"measurable functions\" and \"a.e. measurable functions\" separately would be a reasonable option... (I have nothing in principle against it, but looks like a nonnegligible refactor). I was anyway hoping that the <code>probability_measure</code> instance on the law of a random variable, when one already has a <code>probability_measure</code> on the probability measure on the sample space, would be a minor thing.</p>",
        "id": 248191647,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627977221
    },
    {
        "content": "<p>Maybe to return more to the law of a random variable, a related question:</p>\n<p>What is the canonical mathlib way to express that \"these random variables are identically distributed\"? </p>\n<p>In terms of <code>measure.map</code>, one can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.integration</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">identically_distributed</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Pr</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_measure</span> <span class=\"n\">Pr</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">Xs</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Xs_mbles</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">Xs</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">measure.map</span> <span class=\"o\">(</span><span class=\"n\">Xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">Pr</span> <span class=\"bp\">=</span> <span class=\"n\">measure.map</span> <span class=\"o\">(</span><span class=\"n\">Xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">Pr</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">identically_distributed_with_law</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measurable_space</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">Pr</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">probability_measure</span> <span class=\"n\">Pr</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">Xs</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">Xs_mbles</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">Xs</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">law</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measure.map</span> <span class=\"o\">(</span><span class=\"n\">Xs</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">Pr</span> <span class=\"bp\">=</span> <span class=\"n\">law</span>\n</code></pre></div>\n<p>Is this the intended way?</p>\n<p>(If it is, then I'm back to wanting a <code>probability_measure (measure.map (Xs i) Pr)</code> instance. <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 248192364,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627977691
    },
    {
        "content": "<p><del>You can probably spell <code>measure.map (Xs i) Pr</code> as <code>Pr.map (Xs i)</code>, not that that answers any of your questions</del></p>",
        "id": 248194957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627979673
    },
    {
        "content": "<p>I actually tried <code>Pr.map X</code> etc., since I recently started to like the dot-notation a lot (that would be a nice notation here, in particular).</p>\n<p>But it gives the error:<br>\n<code>invalid field notation, function 'measure_theory.measure.map' does not have explicit argument with type (measure_theory.measure ...)</code>.</p>",
        "id": 248195628,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627980100
    },
    {
        "content": "<p>This is in fact quite puzzling to me, since I think there <em>is</em> an explicit argument of type <code>measure α</code> --- just right of colon.</p>",
        "id": 248195834,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627980239
    },
    {
        "content": "<p>Oh, is it because the right-of-colon argument in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.map\">docs#measure_theory.measure.map</a> is not mapped simply by <code>→</code> but by the bundled <code>→ₗ[ℝ≥0∞]</code>?</p>",
        "id": 248195985,
        "sender_full_name": "Kalle Kytölä",
        "timestamp": 1627980330
    },
    {
        "content": "<p>Yes, that's exactly what the problem is!</p>",
        "id": 248196984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1627981066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/the.20law.20of.20a.20random.20variable.20is.20a.20probability.20measure/near/248192364\">said</a>:</p>\n<blockquote>\n<p>What is the canonical mathlib way to express that \"these random variables are identically distributed\"? </p>\n</blockquote>\n<p>A canonical approach to \"identical and independently distributed random variables\" should build on <code>Indep_fun</code>.  The <a href=\"https://github.com/google/formal-ml/blob/master/src/formal_ml/probability_space.lean\">formal-ml</a> repository,  has <code>random_variables_IID</code>--this repository is not canonical and hard-to-make canonical.</p>",
        "id": 248429055,
        "sender_full_name": "Hunter Monroe",
        "timestamp": 1628127081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373986\">Kalle Kytölä</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/the.20law.20of.20a.20random.20variable.20is.20a.20probability.20measure/near/248195985\">said</a>:</p>\n<blockquote>\n<p>Oh, is it because the right-of-colon argument in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.map\">docs#measure_theory.measure.map</a> is not mapped simply by <code>→</code> but by the bundled <code>→ₗ[ℝ≥0∞]</code>?</p>\n</blockquote>\n<p>I've been thinking about this recently, see <a href=\"https://github.com/leanprover-community/mathlib/pull/12345\">#12345</a>. Could we not just make a wrapper like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.restrict\">docs#measure_theory.measure.restrict</a> does over the linear map? I would be happy to do any needed refactoring, just not sure if we had a particular reason against it.</p>",
        "id": 273424684,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1645995505
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12350\">#12350</a></p>",
        "id": 273439268,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1646015070
    }
]
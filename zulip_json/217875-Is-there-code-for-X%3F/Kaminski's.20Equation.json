[
    {
        "content": "<p>Hi, I would like to add the following identity to the mathlib, but I'm unsure what to call it.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">kaminski</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">tt</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">ff</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I guess by <a href=\"https://leanprover-community.github.io/contribute/naming.html\">#naming</a>, it should be <code>bool.f_f_f_eq_f</code> or <code>bool.f_of_f_f_f</code> or maybe just <code>bool.f_f_f</code>?</p>",
        "id": 282404222,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652613055
    },
    {
        "content": "<p>... except that <code>f</code> is the name of a free variable. I would rather call it <code>bool.apply_apply_apply</code> or <code>bool.apply_apply_apply_eq_apply</code></p>",
        "id": 282404471,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652613401
    },
    {
        "content": "<p>Yeah, naming things after a free variable is generally not so good</p>",
        "id": 282404815,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652613918
    },
    {
        "content": "<p>Fair point, <code>bool.apply_apply_apply</code> it is</p>",
        "id": 282404954,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652614190
    },
    {
        "content": "<p>An alternative proof using <code>fin_cases</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">fin_cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 282405174,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1652614542
    },
    {
        "content": "<p>Note that this can't be a <code>@[simp]</code> lemma, as the head of the LHS is a metavariable.</p>",
        "id": 282407174,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652617605
    },
    {
        "content": "<p>Wow, I'm happy that <code>fin_cases</code> works here. :-)</p>",
        "id": 282407177,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652617623
    },
    {
        "content": "<p>I'm curious, is this identity actually \"good for anything\"? Is it \"true for any reason\" besides case bashing? I want (being highly prejudiced) to say that because it isn't \"true for any reason\" it can't be \"good for anything\". Convince me I'm wrong. :-)</p>",
        "id": 282407275,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652617800
    },
    {
        "content": "<p>Is there an analogous statement for endomorphisms of finite types? Hmm, I guess by pure thought there exist smallest numbers a(n) &lt; b(n) such that f^a = f^b for all f:fin n -&gt; fin n and this proof above shows a(2)=1, b(2)=3.</p>",
        "id": 282407333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652617852
    },
    {
        "content": "<p>Okay, I guess that general fact is more or less good for something. But since it was true by pure thought, that's okay. (I think we've exhausted this line of thought, sorry. :-)</p>",
        "id": 282407396,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652617996
    },
    {
        "content": "<p>Quick let's call it the Buzzard-Morrison Equation in case it's useful for something.</p>",
        "id": 282407444,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652618044
    },
    {
        "content": "<p>My guess is that a(n)=O(n) and b(n)=O(n!)</p>",
        "id": 282407460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652618095
    },
    {
        "content": "<p>To me, it's because functions bool -&gt; bool are involutive, constant, or identity, and only because of the constant functions does f(f(x)) = x not hold. I guess this means b(n) = lcm(1...n) which surely has a nice value</p>",
        "id": 282407542,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652618231
    },
    {
        "content": "<p>... it is asymptotically <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>e</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">e^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></p>",
        "id": 282407557,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652618272
    },
    {
        "content": "<p>Wow, according to oeis: \"An assertion equivalent to the Riemann hypothesis is: | log(a(n)) - n | &lt; sqrt(n) * log(n)^2. \" (for a(n) our b(n))</p>",
        "id": 282407608,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652618319
    },
    {
        "content": "<p>Whoops <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 282407618,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652618341
    },
    {
        "content": "<p>Maybe you just solved RH, Yaël ;b</p>",
        "id": 282407808,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652618535
    },
    {
        "content": "<p>Who's going to PR it?</p>",
        "id": 282407871,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652618642
    },
    {
        "content": "<p>RH? I skip my turn <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 282407885,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652618660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282405174\">said</a>:</p>\n<blockquote>\n<p>An alternative proof using <code>fin_cases</code>:</p>\n</blockquote>\n<p>Here's an even easier proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">},</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 282408829,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652620012
    },
    {
        "content": "<p>The issue is not about the growth (which is equivalent to the prime number theorem), it's about the error bounds (which is equivalent to the Riemann Hypothesis).</p>",
        "id": 282408970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652620205
    },
    {
        "content": "<p>Damn this thread exploded while I was doing the dishes</p>",
        "id": 282409256,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652620774
    },
    {
        "content": "<p>My PR for this is <a href=\"https://github.com/leanprover-community/mathlib/pull/14159\">#14159</a></p>",
        "id": 282409257,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652620791
    },
    {
        "content": "<p>Where did you find this name for this equation, Aaron? I can't seem to find kaminski's equation on Google...</p>",
        "id": 282409957,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652621907
    },
    {
        "content": "<p>It was taught to me by Gert Smolka; He also mentions it in <a href=\"https://www.ps.uni-saarland.de/courses/cl-ss14/script/icl.pdf\">his script</a> in chapter 3.8</p>",
        "id": 282410393,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652622628
    },
    {
        "content": "<p>It says there:</p>\n<blockquote>\n<p>The equation was brought up as a proof challenge by Mark Kaminski in 2005 when he wrote<br>\nhis Bachelor’s thesis on classical higher-order logic.</p>\n</blockquote>",
        "id": 282410575,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652622952
    },
    {
        "content": "<p>The thesis at at <a href=\"https://www.ps.uni-saarland.de/Publications/documents/kaminski-bthesis.pdf\">https://www.ps.uni-saarland.de/Publications/documents/kaminski-bthesis.pdf</a>, but I can't find the thing being referenced</p>",
        "id": 282410708,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652623136
    },
    {
        "content": "<p>hmm, I guess it came up while he was writing his thesis, but it didn't actually make it into the thesis</p>",
        "id": 282411261,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652623886
    },
    {
        "content": "<p>The thesis does reason about functions on booleans a lot, so it makes sense he'd stumble across this identity</p>",
        "id": 282411413,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652624147
    },
    {
        "content": "<p>It's entirely possible it's in there, just not in a form that's easy to spot</p>",
        "id": 282491573,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1652706254
    },
    {
        "content": "<p>It would have been funny if</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">↔</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>were constructively true, since then <a href=\"https://leanprover-community.github.io/mathlib_docs/find/not_of_not_not_not\">docs#not_of_not_not_not</a> would just be a consequence.</p>\n<p>It's not constructively true though. Using the Heyting algebra of open sets of the real line, f could be a translation one unit to the right, and that translation turns out not to have finite order.</p>",
        "id": 282506267,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652712447
    },
    {
        "content": "<p>so you can even prove that there's no distinct a and b with f^a=f^b :-(</p>",
        "id": 282519104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652717782
    },
    {
        "content": "<p>Something seems fishy about that argument; you can give the same counterexample for the boolean algebra of sets on the real line</p>",
        "id": 282531571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652722181
    },
    {
        "content": "<p>Well, I think that shows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">boolean_algebra</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is false.</p>",
        "id": 282532023,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652722370
    },
    {
        "content": "<p>I think I found a definable counterexample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.itauto</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">itauto</span> <span class=\"c1\">-- fail</span>\n</code></pre></div>\n<p><code>itauto</code> is super useful here for being a complete decision procedure for intuitionistic logic</p>",
        "id": 282533742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652723045
    },
    {
        "content": "<p>here's a more comprehensible explanation of why it fails:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">itauto</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">false</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">itauto</span><span class=\"o\">,</span> <span class=\"n\">false_or</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">not_true</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- the hypothesis was useless, the goal is now</span>\n    <span class=\"c1\">-- h: true ⊢ ¬p ∨ ¬¬p</span>\n    <span class=\"n\">itauto</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282534825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652723454
    },
    {
        "content": "<p>alternatively:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.itauto</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span> <span class=\"bp\">¬</span> <span class=\"n\">p</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">f</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">itauto</span> <span class=\"c1\">-- ok</span>\n</code></pre></div>",
        "id": 282535198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652723610
    },
    {
        "content": "<p>Related to the generalized case, how does one arrive at the conclusion that <a href=\"https://oeis.org/A065500\">A0665500</a> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mn>1...</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">lcm(1...n)+n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord\">1...</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>?</p>",
        "id": 282545310,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652727682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282531571\">said</a>:</p>\n<blockquote>\n<p>Something seems fishy about that argument; you can give the same counterexample for the boolean algebra of sets on the real line</p>\n</blockquote>\n<p>I was wondering about that -- I guess it comes down to what <code>Prop -&gt; Prop</code> is supposed to mean? The translation example is at least an isomorphism of Heyting algebras induced by a symmetric of the underlying space, but, beyond that, it seems like you might not want to allow arbitrary functions on a Heyting algebra...</p>",
        "id": 282549517,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652729778
    },
    {
        "content": "<p>That's cool that you can prove the weak law of the excluded middle with this.</p>",
        "id": 282549826,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652729969
    },
    {
        "content": "<p>I've had this question for a while, apologies for jumping in with a slightly off-topic question: In intuitionistic logic, is the weak law of the excluded middle both unprovable and strictly weaker than actual excluded middle? It feels like that's the case but I've never seen a proof.</p>",
        "id": 282556624,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1652733200
    },
    {
        "content": "<p>I don't know the answer, but at least <code>itauto</code> can't prove it, and it can't prove <code>em</code> from the weak <code>em</code> applied to the same <code>p</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">itauto</span> <span class=\"c1\">-- not ok</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">itauto</span> <span class=\"c1\">-- ok</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬¬</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∨</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">itauto</span> <span class=\"c1\">-- not ok</span>\n</code></pre></div>",
        "id": 282557162,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652733460
    },
    {
        "content": "<p>I guess the interesting alternative would be \"weak EM =&gt; EM\"  being unprovable.</p>",
        "id": 282557832,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1652733822
    },
    {
        "content": "<p>Afair, there's a hierarchy of Em's, but this isn't it. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> sent me the link before.</p>",
        "id": 282558224,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652734002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>Are you referring to this? <a href=\"#narrow/stream/113488-general/topic/.E2.9C.94.20How.20to.20prove.20.22.C2.AC.28p.20.E2.86.94.20.C2.ACp.29.22.20without.20classical.20reasoning.3F/near/252024545\">mario's post</a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Intuitionistic_logic#/media/File:Rieger-Nishimura.svg\">Direct link</a> to an illustration of the Rieger-Nishimura lattice</p>",
        "id": 282558883,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652734340
    },
    {
        "content": "<p>Yea, that's the one!!!</p>",
        "id": 282559134,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652734469
    },
    {
        "content": "<p>Yep exactly. This is also the free lattice on three elements.</p>",
        "id": 282561197,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1652735409
    },
    {
        "content": "<p>This is very interesting! It seems to suggest that \"weak EM =&gt; EM\"  is really unprovable, but I am not 100% sure this is the same question. In the lattice, it looks like everything is specialized to a particular proposition.</p>",
        "id": 282561698,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1652735718
    },
    {
        "content": "<p>yes, weak EM =&gt; EM is unprovable, but it's true that the distinctness of the relevant points in the Rieger-Nishimura lattice does not prove this, only that <code>weak_EM(p) -&gt; EM(p)</code> is unprovable (it could be that <code>weak_EM(f(p)) -&gt; EM(p)</code> for some <code>f</code>)</p>",
        "id": 282563602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652736725
    },
    {
        "content": "<p>In fact, weak EM is the <em>only</em> thing you can deduce from kaminski's equation (on definable formulas <code>f</code>). More precisely, if <code>f</code> is a univariate function on propositions built from <code>[p, ⊤, ⊥, →, ¬, ∧, ∨]</code>, then <code>¬p ∨ ¬¬p → f (f (f p)) ↔ f p</code> holds.</p>\n<p>Proof: By cases on <code>¬p ∨ ¬¬p</code>.</p>\n<ul>\n<li>If <code>¬p</code> is true, then <code>p &lt;-&gt; false</code> so we are in the <code>bool</code> subset of the logic and therefore <code>f (f (f p)) ↔ f p</code> by evaluating it to true or false and observing that this is a classical theorem.</li>\n<li>If <code>¬¬p</code>, we end up in a three-valued logic, because <code>¬p &lt;-&gt; false</code> and all the other operators are closed in the set <code>[p, ⊤, ⊥]</code>. There are only six reachable functions in this logic: <code>⊥, ⊤, x, ¬x, ¬¬x, x ∨ ¬x</code>, and for all of these functions Kaminski's theorem holds:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive [decidable_eq, fintype]</span><span class=\"o\">]</span> <span class=\"kd\">inductive</span> <span class=\"n\">val</span> <span class=\"bp\">|</span> <span class=\"n\">true</span> <span class=\"bp\">|</span> <span class=\"n\">false</span> <span class=\"bp\">|</span> <span class=\"n\">p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">val.not</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.true</span> <span class=\"o\">:=</span> <span class=\"n\">val.false</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.false</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.p</span> <span class=\"o\">:=</span> <span class=\"n\">val.false</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">val.and</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.true</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">val.true</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.false</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">val.false</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">val.false</span> <span class=\"o\">:=</span> <span class=\"n\">val.false</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.p</span> <span class=\"n\">val.p</span> <span class=\"o\">:=</span> <span class=\"n\">val.p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">val.or</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.false</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">val.false</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.true</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">val.true</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.p</span> <span class=\"n\">val.p</span> <span class=\"o\">:=</span> <span class=\"n\">val.p</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">val.imp</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.false</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">val.false</span> <span class=\"o\">:=</span> <span class=\"n\">val.not</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.true</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"n\">val.true</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n<span class=\"bp\">|</span> <span class=\"n\">val.p</span> <span class=\"n\">val.p</span> <span class=\"o\">:=</span> <span class=\"n\">val.true</span>\n\n<span class=\"kd\">@[derive decidable]</span> <span class=\"kd\">def</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">val.p</span> <span class=\"bp\">→</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">val.p</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i.or</span> <span class=\"n\">i.not</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"n\">val.true</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">val.p</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">true.is_valid</span> <span class=\"o\">:</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">val.true</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">false.is_valid</span> <span class=\"o\">:</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">val.false</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">id.is_valid</span> <span class=\"o\">:</span> <span class=\"n\">is_valid</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">not.is_valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"n\">is_valid</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">not</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">and.is_valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"n\">is_valid</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">and</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">or.is_valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"n\">is_valid</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">or</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">imp.is_valid</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"n\">is_valid</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">is_valid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">kaminski</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">val</span> <span class=\"bp\">→</span> <span class=\"n\">val</span><span class=\"o\">),</span>\n  <span class=\"n\">is_valid</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span>\n</code></pre></div>",
        "id": 282577823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652746779
    },
    {
        "content": "<p>ha ha this is funny because abstractly the answer for f : fin 3 -&gt; fin 3 is: if it's a 3-cycles then f^3=f^0 and if it's not then the image has size &lt;= 2 so Kaminski kicks in after one application and we deduce f^4=f^2, so always f^8=f^2 (in particular strictly worse).</p>",
        "id": 282606895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652775863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282407333\">said</a>:</p>\n<blockquote>\n<p>Is there an analogous statement for endomorphisms of finite types? Hmm, I guess by pure thought there exist smallest numbers a(n) &lt; b(n) such that f^a = f^b for all f:fin n -&gt; fin n and this proof above shows a(2)=1, b(2)=3.</p>\n</blockquote>\n<p>Do we actually have this (or similar) in mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282634923,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1652792024
    },
    {
        "content": "<p>I actually looked into a more generalised version of kaminski for my own practice and <a href=\"https://gist.github.com/slerpyyy/b7f98d9c50adba97f7609f1b94628ba9\">this</a> is how far I got</p>",
        "id": 282641902,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652795027
    },
    {
        "content": "<p>(Also, if anyone here has an idea on how to prove the last statement, please let me know)</p>",
        "id": 282642645,
        "sender_full_name": "Aaron Bies",
        "timestamp": 1652795320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456794\">Patrick Johnson</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282634923\">said</a>:</p>\n<blockquote>\n<p>Do we actually have this (or similar) in mathlib?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>It's basically <a href=\"https://leanprover-community.github.io/mathlib_docs/find/not_injective_infinite_fintype\">docs#not_injective_infinite_fintype</a> applied to <code>(fin n → fin n) → (fin n → fin n)</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_order.injective_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">injective</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">f</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span> <span class=\"n\">hfab</span><span class=\"o\">,</span> <span class=\"n\">hab.ne</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"n\">hfab</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hfab</span><span class=\"o\">,</span> <span class=\"n\">by_contra</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">hab.lt_or_lt.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hab</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">hab</span> <span class=\"n\">hfab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hba</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">b</span> <span class=\"n\">a</span> <span class=\"n\">hba</span> <span class=\"n\">hfab.symm</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n  <span class=\"n\">not_injective_infinite_fintype</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">linear_order.injective_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">push_neg</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">funext_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">{</span><span class=\"n\">single_pass</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"n\">this</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 282642746,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1652795362
    },
    {
        "content": "<p>Or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.exists_ne_map_eq_of_infinite\">docs#fintype.exists_ne_map_eq_of_infinite</a></p>",
        "id": 282642820,
        "sender_full_name": "Reid Barton",
        "timestamp": 1652795400
    },
    {
        "content": "<p>Oh, that one is a little closer indeed (with the negation of <code>injective</code> unfolded).</p>",
        "id": 282642929,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1652795434
    },
    {
        "content": "<p>Reminds me of <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20f.5E.5Bn.5D.20x.20.3D.20x/near/266557825\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20f.5E.5Bn.5D.20x.20.3D.20x/near/266557825</a>, so I ended up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.exponent</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.hom.iterate</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"bp\">.</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">key</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"o\">:</span> <span class=\"n\">function.End</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">a_ih</span><span class=\"o\">,</span> <span class=\"n\">pow_succ'</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n<span class=\"kn\">open</span> <span class=\"n\">monoid</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">function.End</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">delta_instance</span> <span class=\"n\">function.End</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">])</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">^</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">])</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">function.End</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">function.End</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">Exists₂.imp</span> <span class=\"n\">_</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">],</span>\n    <span class=\"n\">intro</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h₂</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">pi.pow_apply</span><span class=\"o\">,</span> <span class=\"n\">pi.pow_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">key</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">set.infinite_univ.exists_lt_map_eq_of_maps_to</span> <span class=\"o\">(</span><span class=\"n\">set.maps_to_univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">function.End</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">set.finite_univ</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Floris's is much cleaner!</p>",
        "id": 282644288,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1652796015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456794\">@Patrick Johnson</span> That reminded me that a while back <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.E2.9C.94.20f.5E.5Bn.5D.20x.20.3D.20x/near/266650589\">I built out some theory</a> as an exercise, and it could be used to prove this. The core idea is that for a fintype, there's some positive n such that <code>f^[n]</code> is a bijection when restricted to its image, and then you can take the order <code>k</code> of that permutation to get that <code>f^[n] = f^[n+k]</code>.</p>",
        "id": 282644570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652796117
    },
    {
        "content": "<p>Oh, that's in the same thread Alex just linked to.</p>",
        "id": 282644718,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652796173
    },
    {
        "content": "<p>I think the \"Kaminski-Buzzard-Morrison\" numbers can be found the following way:</p>\n<p>Supposing a &lt; b and f^a = f^b, then f restricted to f^a is a bijection. Hence b-a &lt;= g(|im f^a|), where g(n) is the <a href=\"https://en.wikipedia.org/wiki/Landau%27s_function\">Landau function</a> (the largest order of an element of the symmetric group).</p>\n<p>Given any finite set X, subset S, and permutation p of S, then that permutation can be extended to be a function f : X -&gt; X such that the image of some power of f is S. There is such an f such that the least such power is |X - S|, and this is the maximal least power over all f. In this case, a=|X-S| and b=a+order(p). So, one can maximize b by taking p with maximal order, getting a=|X-S| and b=a+g(|S|).</p>\n<p>Hence, the set of all Kaminski-Buzzard-Morrison numbers for a particular set X of cardinality n is {(n-k, n-k+g(k)) | k in 1..n}.  I'm defining the numbers to be pairs (a,b) from those equations f^a=f^b with a&lt;b such that there is no smaller a for the given f and, for that a, no other f that can make b larger.</p>",
        "id": 282662124,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652802825
    },
    {
        "content": "<p>I just realized I made a mistake there -- these aren't the universal numbers since you do need to take the lcm of all the orders.</p>",
        "id": 282662428,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652802923
    },
    {
        "content": "<p>Anyway, you need a(n) = n-1 since <code>f</code> could be <code>pred</code> on <code>fin n</code>, and then b(n) = lcm(1,2,...,n) + n - 1.  That matches what Kevin said for the n=3 case (f^8 = f^2).</p>",
        "id": 282663520,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652803304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373970\">Aaron Bies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282545310\">said</a>:</p>\n<blockquote>\n<p>Related to the generalized case, how does one arrive at the conclusion that <a href=\"https://oeis.org/A065500\">A0665500</a> is equivalent to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>c</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mn>1...</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">lcm(1...n)+n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord\">1...</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>?</p>\n</blockquote>\n<p>I see you already mentioned this formula. I think what's going on is that the only functions you can really define using the typed lambda calculus are iterates, so 1, f, f^1, f^2, ..., f^(b-1) are the only functions.</p>",
        "id": 282664957,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1652803806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282606895\">said</a>:</p>\n<blockquote>\n<p>ha ha this is funny because abstractly the answer for f : fin 3 -&gt; fin 3 is: if it's a 3-cycles then f^3=f^0 and if it's not then the image has size &lt;= 2 so Kaminski kicks in after one application and we deduce f^4=f^2, so always f^8=f^2 (in particular strictly worse).</p>\n</blockquote>\n<p>Note that it's not really <code>fin 3 -&gt; fin 3</code>; although there are three values in the domain the third element is rather special since you can't just map it arbitrarily, and <code>true</code> and <code>false</code> can never map to <code>p</code>. I ended up with the list of conditions in <code>is_valid</code> more or less by seeing what things were preserved by the operations.</p>",
        "id": 282697157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1652816946
    },
    {
        "content": "<p>Yes exactly, the weird logic stuff saves you; the fin 3 argument is what you get for free but you teased more out of it</p>",
        "id": 282699667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652818018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373970\">Aaron Bies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Kaminski's.20Equation/near/282641902\">said</a>:</p>\n<blockquote>\n<p>I actually looked into a more generalised version of kaminski for my own practice and <a href=\"https://gist.github.com/slerpyyy/b7f98d9c50adba97f7609f1b94628ba9\">this</a> is how far I got<br>\n(Also, if anyone here has an idea on how to prove the last statement, please let me know)</p>\n</blockquote>\n<p>I proved it for <code>a = n</code> and <code>b = n + n.factorial</code> (<a href=\"https://github.com/user7230724/lean-projects/blob/master/src/other/func_iter_eq.lean\">proof</a>).   It's probably easy to reduce it to <code>b = list.foldr nat.lcm 1 (list.iota n) + n</code>, but the problem is <code>-1</code> both in <code>a</code> and <code>b</code>, which I didn't manage to prove.</p>",
        "id": 301682542,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1664554012
    }
]
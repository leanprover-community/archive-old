[
    {
        "content": "<p>I've been working on filling out some of the API around <a href=\"https://en.wikipedia.org/wiki/Dual_space#Quotient_spaces_and_annihilators\">dual annihilators</a> of submodules, and an isomorphism that would be nice to have is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mi mathvariant=\"normal\">/</mi><mi>W</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup><mo>≈</mo><mi mathvariant=\"normal\">ann</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(V/W)^* \\approx \\operatorname{ann}(W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">ann</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>W</mi></mrow><annotation encoding=\"application/x-tex\">W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span></span></span></span> is a subspace of a vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>.</p>\n<p>The argument I was thinking of is that you can take the short exact sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mi>W</mi><mo>→</mo><mi>V</mi><mo>→</mo><mi>V</mi><mi mathvariant=\"normal\">/</mi><mi>W</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\to W \\to V \\to V/W \\to 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, dualize it to get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mo stretchy=\"false\">(</mo><mi>V</mi><mi mathvariant=\"normal\">/</mi><mi>W</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup><mo>→</mo><msup><mi>W</mi><mo>∗</mo></msup><mo>→</mo><msup><mi>V</mi><mo>∗</mo></msup><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0 \\to (V/W)^* \\to W^* \\to V^* \\to 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, and then identify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>V</mi><mi mathvariant=\"normal\">/</mi><mi>W</mi><msup><mo stretchy=\"false\">)</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">(V/W)^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span> with the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>W</mi><mo>∗</mo></msup><mo>→</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">W^* \\to V^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>, which happens to be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ann</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mi>W</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{ann}(W)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">ann</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">)</span></span></span></span> by definition.</p>\n<p>This is where I'm working: <a href=\"https://github.com/leanprover-community/mathlib/pull/17521/files#diff-44f047eef7a6b2bf415612b8834b73544a7697e940b4b7f81e5359560e28ab7cR936\">https://github.com/leanprover-community/mathlib/pull/17521/files#diff-44f047eef7a6b2bf415612b8834b73544a7697e940b4b7f81e5359560e28ab7cR936</a></p>\n<p>Here's the sorried definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dual</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">V₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dual_quot_equiv_dual_annihilator</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">module.dual</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">V₁</span> <span class=\"bp\">⧸</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">W.dual_annihilator</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 309479374,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668359972
    },
    {
        "content": "<p>While the high-powered fact is that taking duals of vector spaces is an exact functor so colimits become limits, maybe there's an easier construction that comes from pre-existing linear algebra in mathlib?</p>",
        "id": 309480068,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668360434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I think I proved this result in <a href=\"https://github.com/adamtopaz/lean-acl-pairs\">https://github.com/adamtopaz/lean-acl-pairs</a></p>",
        "id": 309483255,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668362253
    },
    {
        "content": "<p>I was planning to put the general duality stuff proved there in mathlib, but haven't gotten to it yet</p>",
        "id": 309483323,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668362289
    },
    {
        "content": "<p>No need of <code>field</code> here, <code>comm_ring</code> suffices (and no need of (dualizing) exact sequences, it's pretty much by definition):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dual</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">V₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dual_quot_equiv_dual_annihilator</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">module.dual</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">V₁</span> <span class=\"bp\">⧸</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">W.dual_annihilator</span> <span class=\"o\">:=</span>\n<span class=\"n\">linear_equiv.of_linear</span>\n  <span class=\"o\">(</span><span class=\"n\">linear_map.cod_restrict</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">module.dual.transpose</span> <span class=\"n\">W.mkq</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">submodule.mem_dual_annihilator</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">φ</span> <span class=\"bp\">$</span> <span class=\"n\">W</span><span class=\"bp\">^.</span><span class=\"n\">quotient.mk_eq_zero.2</span> <span class=\"n\">hw</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">φ.map_zero</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">linear_map.flip</span> <span class=\"bp\">$</span> <span class=\"n\">W.liftq</span> <span class=\"o\">(</span><span class=\"n\">linear_map.dom_restrict</span> <span class=\"o\">(</span><span class=\"n\">module.dual_pairing</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"bp\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">w</span> <span class=\"n\">hw</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">hφ</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">submodule.mem_dual_annihilator</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hφ</span> <span class=\"n\">w</span> <span class=\"n\">hw</span> <span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">})</span>\n</code></pre></div>",
        "id": 309490250,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668366664
    },
    {
        "content": "<p>You need <code>field</code> (or some projectivity assumption) for the cokernel on the dual side.</p>",
        "id": 309491682,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668367675
    },
    {
        "content": "<p>In general, <code>V₁ ⧸ W →ₗ[K] V</code> can be identified with a <code>K</code>-submodule of <code>V₁ →ₗ[K] V</code>. More generally, if <code>U →ₗ[K] V</code> is surjective then the induced map <code>(V →ₗ[K] W) →ₗ[K] (U →ₗ[K] W)</code> is injective for any <code>W</code>, so we can identify <code>V →ₗ[K] W</code> with a K-submodule of <code>U →ₗ[K] W</code>.</p>\n<p>By the way, <code>W* → V*</code> should be <code>V* → W*</code> in the first post.</p>",
        "id": 309492135,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668367910
    },
    {
        "content": "<blockquote>\n<p>You need field (or some projectivity assumption) for the cokernel on the dual side.</p>\n</blockquote>\n<p>Where is cokernel on the dual side used? In your repo or in Kyle's work?</p>",
        "id": 309492228,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668367942
    },
    {
        "content": "<p>Oh I don't think it appears in the original post. Or in the repo. I just mentioned this because it's part of having a \"good\" duality theory. You want quotients in the dual to correspond to submodules in the original module, and vice versa.</p>",
        "id": 309492344,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668368040
    },
    {
        "content": "<p>I think it's actually an interesting question regarding how to best set up such \"duality\" theories. In the case that I needed for my repo linked above, I had a vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> over a field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, and, essentially, obtained a duality between quotients of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and closed (w.r.t. the weak topology) subspaces of the dual. I'm sure the functional analysts have developed a general approach to such things... does anyone know of a good reference for this?</p>",
        "id": 309494381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668369423
    },
    {
        "content": "<p>Section IV.1.4 in Bourbaki TVS seems to be related, but there are probably ways to make it way easier for the special case of the weak dual topology.</p>",
        "id": 309499923,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1668373845
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>!</p>\n<p>I extracted this characterization you mentioned of the dual annihilator as a quick corollary of the equivalence:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_dual_map_mkq_eq_dual_annihilator</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">submodule.mkq</span> <span class=\"n\">W</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dual_map.range</span> <span class=\"bp\">=</span> <span class=\"n\">W.dual_annihilator</span>\n</code></pre></div>\n<p>In <a href=\"https://github.com/leanprover-community/mathlib/pull/17521\">#17521</a> I also have the following lemma for vector spaces</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_dual_map_eq_dual_annihilator_ker</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V₁</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">V₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.dual_map.range</span> <span class=\"bp\">=</span> <span class=\"n\">f.ker.dual_annihilator</span>\n</code></pre></div>\n<p>Do you think this could be generalized to commutative rings as well? I've already added a version for when <code>f</code> is a surjection as a corollary to <code>range_dual_map_mkq_eq_dual_annihilator</code>.</p>",
        "id": 309910638,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668446506
    },
    {
        "content": "<p>Looks nice! I think you can get <code>f.dual_map.range ≤ f.ker.dual_annihilator</code> but for the other direction you can only get a R-linear functional on <code>V₁ ⧸ f.ker</code> but can't necessarily extend it to a functional on <code>V₂</code>.</p>",
        "id": 309917600,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668448688
    },
    {
        "content": "<p>Yeah, I just realized it doesn't generalize. For example, the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">f : \\mathbb{Z}\\to\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> from multiplication by two.</p>",
        "id": 309917672,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668448711
    },
    {
        "content": "<p>you need projectivity :)</p>",
        "id": 309917722,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668448731
    },
    {
        "content": "<p>Yeah, you can prove it with a very weak form of projectivity:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_dual_map_eq_dual_annihilator_ker</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"o\">((</span><span class=\"n\">linear_map.range</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype.dual_map</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.dual_map.range</span> <span class=\"bp\">=</span> <span class=\"n\">f.ker.dual_annihilator</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">rr_surj</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">f.range_restrict</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">linear_map.range_eq_top</span><span class=\"o\">,</span> <span class=\"n\">linear_map.range_range_restrict</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">range_dual_map_eq_dual_annihilator_ker_of_surjective</span> <span class=\"n\">f.range_restrict</span> <span class=\"n\">rr_surj</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">this</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">transitivity</span> <span class=\"o\">((</span><span class=\"n\">submodule.subtype</span> <span class=\"n\">f.range</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f.range_restrict</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dual_map.range</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">linear_map.dual_map_comp_dual_map</span><span class=\"o\">,</span> <span class=\"n\">linear_map.range_comp_of_range_eq_top</span><span class=\"o\">],</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">linear_map.range_eq_top</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">linear_map.ker_range_restrict</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 309919271,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668449209
    },
    {
        "content": "<p>That's probably useful as is (using a surjectivity assumption) but I think it's worthwhile to formulate a lemma using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.projective\">docs#module.projective</a> as well, since that's a typeclass, and any module over a field is projective</p>",
        "id": 309919624,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668449326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> That inequality is very easy in comparison and works for commutative semirings too. It looks like @JasonKYi added it two years ago (thanks!)</p>",
        "id": 309919675,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668449341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> I wasn't sure I was going to include it in the PR since the condition is rather technical and I don't need any of this (I'm just trying to add everything that might be considered to be basic theory for dual annihilators to check off the \"orthogonality\" item off the undergrad list!), but a projective version seems reasonable, though perhaps not to undergrads</p>",
        "id": 309920037,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668449459
    },
    {
        "content": "<p>Hmm, <code>module.projective</code> isn't available in <code>linear_algebra/dual</code>. Would it be bad to import it?</p>",
        "id": 309920344,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668449552
    },
    {
        "content": "<p>Given what we've been seeing in the lower parts of the import graph lately, I would suggest this import is \"bad\".</p>",
        "id": 309920757,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1668449674
    },
    {
        "content": "<p>A priori, <code>projective</code> and <code>dual</code> seem orthogonal concepts. So neither should import the other.</p>",
        "id": 309920822,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1668449695
    },
    {
        "content": "<p>I don't know what their lub should be though.</p>",
        "id": 309920879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1668449715
    },
    {
        "content": "<p>Maybe there should be a separate file for some sort of \"duality theory\" (and perhaps the current <code>dual</code> should be renamed)?</p>",
        "id": 309920927,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668449737
    },
    {
        "content": "<p>OTOH, I would guess that <code>dual</code> is pretty close to being a leaf in the import tree</p>",
        "id": 309921148,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668449802
    },
    {
        "content": "<p>Actually, I'm getting confused. Is projectivity the right concept, or is it injectivity? It seems like <code>function.surjective f.range.subtype.dual_map</code> is true if <code>R</code> is an injective <code>R</code>-module.</p>",
        "id": 309922307,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668450129
    },
    {
        "content": "<p>You just need an Ext term to vanish, so you can either assume the ring is injective, or some module is projective</p>",
        "id": 309922462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668450188
    },
    {
        "content": "<p>What about the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">f:\\mathbb{Z}\\to\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> example where it's multiplication by 2? All of these are projective <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-modules.</p>",
        "id": 309922772,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668450268
    },
    {
        "content": "<p>But the cokernel isnt</p>",
        "id": 309923033,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668450354
    },
    {
        "content": "<p>The issue is that Z/2 is not projective</p>",
        "id": 309923139,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668450376
    },
    {
        "content": "<p>Note that at least for domains <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is injective if and only if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is a field, so I think using a projectivity assumption on the quotient would be more useful in more cases.</p>",
        "id": 309925069,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668450960
    },
    {
        "content": "<p>For now, I'll leave the PR with this technical version, and maybe I'll look into where to put a projective version (maybe one answer is to add a lemma that gives this surjectivity assumption given projectivity of the cokernel?)</p>",
        "id": 309925706,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668451156
    },
    {
        "content": "<p>Here's another question. I've got</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">dual_annihilator_infi_eq</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_root_.finite</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">K</span> <span class=\"n\">V₁</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨅</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">W</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dual_annihilator</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">⨆</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">dual_annihilator</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with this finiteness condition. It's surely true in more cases (like probably if <code>W</code> is a cofiltered family). Is there an obviously good condition to state?</p>",
        "id": 309925986,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668451236
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.dual_annihilator\">docs#submodule.dual_annihilator</a></p>",
        "id": 309926149,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668451302
    },
    {
        "content": "<p>right, in general there is some (topological) closure that needs to happen as well.</p>",
        "id": 309926275,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668451336
    },
    {
        "content": "<p>I'm very tempted to leave this with a finite indexing type, or at best see if when the vector space is finite-dimensional then there is good API for restricting infinite indexing sets to equivalent finite ones.</p>",
        "id": 309926313,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668451348
    },
    {
        "content": "<p>It should be easy to obtain an inclusion in one direction in the general case. Maybe that's enough for now?</p>",
        "id": 309927586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1668451785
    },
    {
        "content": "<p>Yeah, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.supr_dual_annihilator_le_infi\">docs#submodule.supr_dual_annihilator_le_infi</a> was straightforward.</p>",
        "id": 309928113,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1668451941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Obtain.20isomorphism.20from.20short.20exact.20sequence/near/309920822\">said</a>:</p>\n<blockquote>\n<p>A priori, <code>projective</code> and <code>dual</code> seem orthogonal concepts. So neither should import the other.</p>\n</blockquote>\n<p>Yes probably we should add another file, but I've previously noticed that a lot of stuff around dual and contraction <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280956947\">could be generalized</a> from finite free modules to finite projective modules, so they would need to be moved to the new file when generalized. Also note that projective modules of rank 1 are invertible sheaves / line bundles, and the dual is the inverse. For Dedekind domains all nonzero ideals are projective (invertible). So there's definitely a lot of overlapping theory to be developed.</p>\n<p>About the generalization from comm_ring to comm_semiring: It's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.has_quotient\">docs#submodule.has_quotient</a> that requires [ring R], and we should probably generalize it as well. (If there's an initial ring that a semiring maps to (not sure if one of commutativity and addition cancellativity is needed) then we may use that, but that's more complicated and the construction isn't in mathlib AFAIK.)</p>",
        "id": 310083421,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1668460684
    },
    {
        "content": "<p>I think that rather than generalizing by hand a lot of stuff from free to projective modules, what we should do is to prove that these properties are local for the Zariski topology (and characterize projective modules, something is not in mathlib I am afraid).</p>",
        "id": 310087012,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1668462054
    }
]
[
    {
        "content": "<p>I have a multiset <code>s : multiset α</code>, and I want to filter by <code>p : α → ℕ → Prop</code>, giving a subset <code>t</code> where <code>t.count a</code> is the maximum <code>n ≤ s.count </code> s.t. <code>p a n</code>. More specifically, <code>x : R</code> has a prime factorization <code>s</code> and for <code>y | x</code> I want to show <code>y</code> has a prime factorization <code>t ≤ s</code>. I don't have a <code>normalization_monoid R</code> structure, so I can't use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.dvd_iff_factors_le_factors\">docs#unique_factorization_monoid.dvd_iff_factors_le_factors</a>.</p>",
        "id": 220364686,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608293562
    },
    {
        "content": "<p>I guess I could use the noncomputable choice of normalization monoid <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unique_factorization_monoid.normalization_monoid\">docs#unique_factorization_monoid.normalization_monoid</a> and try to do special cases where <code>[nontrivial R]</code> doesn't hold?</p>",
        "id": 220364839,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608293659
    },
    {
        "content": "<p>Of course, because I have an <code>x ≠ 0</code> in my assumptions anyway. Thanks for the rubber-ducking, everyone <span aria-label=\"duck\" class=\"emoji emoji-1f986\" role=\"img\" title=\"duck\">:duck:</span></p>",
        "id": 220364939,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1608293757
    }
]
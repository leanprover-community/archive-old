[
    {
        "content": "<p>Do we have this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I am building it up manually, juggling all sorts of <code>gcd</code> and <code>dvd</code> proofs. Perhaps we have this equivalence explicitly?</p>",
        "id": 264745311,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639418244
    },
    {
        "content": "<p>This should already be there, maybe the other way round. I'm quite sure.</p>",
        "id": 264745976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1639418449
    },
    {
        "content": "<p>grep gave me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">ring_theory</span><span class=\"bp\">/</span><span class=\"n\">localization.lean</span>\n<span class=\"mi\">1747</span><span class=\"o\">:</span><span class=\"kd\">instance</span> <span class=\"n\">rat.is_fraction_ring</span> <span class=\"o\">:</span> <span class=\"n\">is_fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 264746024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1639418470
    },
    {
        "content": "<p>Yes, but that is a Prop. But that does not give the \"canonical\" iso, right? Also, the API is a little missing here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">is_fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"n\">rat.is_fraction_ring</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">is_fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">localization.is_localization</span> <span class=\"c1\">-- library_search or suggest don't solve this</span>\n</code></pre></div>",
        "id": 264747142,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639418929
    },
    {
        "content": "<p>Maybe you can use  <a href=\"https://leanprover-community.github.io/mathlib_docs/ring_theory/localization.html#is_localization.ring_equiv_of_ring_equiv\">https://leanprover-community.github.io/mathlib_docs/ring_theory/localization.html#is_localization.ring_equiv_of_ring_equiv</a> to get the iso?</p>",
        "id": 264757736,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1639423839
    },
    {
        "content": "<p>What do you call the \"canonical\" iso? When working on Dedekind domain, we somewhat convinced ourselves that having <em>one</em> proof of the iso was enough.</p>",
        "id": 264757761,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1639423848
    },
    {
        "content": "<p>Here's what I have so far. It's a WIP, could be I stated something wrong:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.nat_abs_sign</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">z.sign.nat_abs</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rcases</span> <span class=\"n\">z</span> <span class=\"k\">with</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">_</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">int.nat_abs_sign_of_nonzero</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">z.sign.nat_abs</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int.nat_abs_sign</span><span class=\"o\">,</span> <span class=\"n\">if_neg</span> <span class=\"n\">hz</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- field of fractions ℚ</span>\n<span class=\"kd\">def</span> <span class=\"n\">fwd</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n    <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rev</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">int.sign</span> <span class=\"n\">d</span> <span class=\"bp\">*</span> <span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">n.gcd</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">int.nat_abs</span> <span class=\"n\">d</span> <span class=\"bp\">/</span> <span class=\"n\">n.gcd</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">hn</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">zero_lt_one</span> <span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">_</span> <span class=\"bp\">|</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">n.gcd</span> <span class=\"n\">d</span> <span class=\"bp\">∣</span> <span class=\"n\">d.nat_abs</span> <span class=\"o\">:=</span>\n      <span class=\"o\">(</span><span class=\"n\">int.nat_abs</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">gcd_dvd_right</span> <span class=\"o\">(</span><span class=\"n\">int.nat_abs</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hd</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hk</span> <span class=\"o\">},</span>\n    <span class=\"n\">replace</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d.nat_abs</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n      <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hd</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n.gcd</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">int.gcd_pos_of_non_zero_left</span> <span class=\"n\">d</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">nat.mul_div_assoc</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">dvd_refl</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">hpos</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">hn</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">d</span> <span class=\"k\">with</span> <span class=\"n\">d</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hpos</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n.gcd</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"n\">int.gcd_pos_of_non_zero_left</span> <span class=\"n\">d</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span> <span class=\"n\">at</span> <span class=\"n\">hd</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">int.nat_abs_div</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">n.gcd_dvd_left</span> <span class=\"n\">d</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_left</span> <span class=\"n\">d.sign</span><span class=\"o\">),</span>\n        <span class=\"n\">int.nat_abs_mul</span><span class=\"o\">,</span> <span class=\"n\">int.nat_abs_sign_of_nonzero</span> <span class=\"n\">hd</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">nat.coprime_div_gcd_div_gcd</span> <span class=\"n\">hpos</span>\n  <span class=\"kd\">end</span><span class=\"o\">⟩)</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">eq_rec_constant</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_mk</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">localization.r_iff_exists</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span> <span class=\"n\">at</span> <span class=\"n\">hb</span> <span class=\"n\">hd</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_eq_mul_right_iff</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">or_false</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">ha</span> <span class=\"n\">hc</span> <span class=\"n\">hc</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"n\">hc'</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">int.mul_div_assoc</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">dvd_refl</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">int.div_self</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">subst</span> <span class=\"n\">hc'</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">int.div_eq_div_of_mul_eq_mul</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">int.gcd_dvd_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mul_left</span> <span class=\"n\">_</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">int.gcd_eq_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">int.gcd_eq_zero_iff</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span>\n  <span class=\"n\">q</span>\n</code></pre></div>",
        "id": 264758185,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639424050
    },
    {
        "content": "<p><code>is_fraction_ring</code> asserts that the algebra map <code>ℤ → ℚ</code> is an iso. I'm sure that there is something in mathlib that lets you turn this assertion + <code>algebra_map ℤ ℚ</code> into a <code>ring_equiv</code>.</p>",
        "id": 264758203,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1639424060
    },
    {
        "content": "<p>Is this what you are looking for?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_localization.ring_equiv_of_ring_equiv</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_equiv.refl</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">:</span> <span class=\"n\">submonoid.map</span> <span class=\"o\">(</span><span class=\"n\">ring_equiv.refl</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_hom</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors</span> <span class=\"n\">ℤ</span><span class=\"o\">))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">iso</span>\n</code></pre></div>",
        "id": 264759889,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1639424878
    },
    {
        "content": "<p><del>Isn't there</del>There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_localization.alg_equiv\">docs#is_localization.alg_equiv</a> which doesn't need the <code>_of_ring_equiv</code> parameters</p>",
        "id": 264771712,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639430556
    },
    {
        "content": "<p>In particular its specialization <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fraction_ring.alg_equiv\">docs#fraction_ring.alg_equiv</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_ring_equiv</span>\n</code></pre></div>",
        "id": 264771909,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1639430650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> now ask him to do Dedekind reals = Cauchy reals = uniform completion reals = Eudoxus reals!</p>",
        "id": 264790554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639441545
    },
    {
        "content": "<p>You joke, but I think that the fact that this statement isn't easily proven is helping me identify some API holes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fwd</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n    <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rev</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.lift_on</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">rat.mk</span> <span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">myiso</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">fwd</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">rev</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">myiso.symm</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 264791109,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639441981
    },
    {
        "content": "<p>Specifically, API in dealing with <code>int.sign</code>, a missing <code>rat.ext</code>, and linking <code>localization</code> and <code>is_localization</code>.</p>",
        "id": 264791145,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639442010
    },
    {
        "content": "<p>I think <code>n / d</code> is the API, not <code>rat.mk</code></p>",
        "id": 264791186,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639442040
    },
    {
        "content": "<p>Right, but that requires me to actually juggle the gcd or lcm, no?</p>",
        "id": 264791312,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639442148
    },
    {
        "content": "<p>Definitely something went wrong if you're talking about gcds</p>",
        "id": 264792127,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639442837
    },
    {
        "content": "<p>It does seem annoying though, this is what I came up with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">fwd</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n     <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rev</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.lift_on</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">localization.r_iff_exists</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">div_eq_div_iff</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">int.eq_of_mul_eq_mul_right</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors.ne_zero</span> <span class=\"n\">k.2</span><span class=\"o\">)</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors.ne_zero</span> <span class=\"n\">b.2</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors.ne_zero</span> <span class=\"n\">d.2</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">myiso</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">fwd</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">rev</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">rat.num_div_denom</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">localization.ind</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">change</span> <span class=\"n\">fwd</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">localization.mk</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">localization.mk</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">set</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">localization.mk_eq_mk_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">localization.r_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">submonoid.coe_one</span><span class=\"o\">],</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">r.denom</span> <span class=\"bp\">=</span> <span class=\"n\">r.num</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">div_eq_div_iff</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">rat.num_div_denom</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">non_zero_divisors.ne_zero</span> <span class=\"n\">b.2</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact_mod_cast</span> <span class=\"n\">r.denom_ne_zero</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 264796003,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639446020
    },
    {
        "content": "<p>I think you're really not supposed to use it this way, and it would be easier to prove that the <code>iso</code> from above equals these functions if you really want that</p>",
        "id": 264796035,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639446044
    },
    {
        "content": "<p>I tried to follow your suggestion, but I'm having trouble with one of the directions:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.ratfunc</span>\n\n<span class=\"c1\">-- field of fractions ℚ</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">≃+*</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.to_ring_equiv</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simps</span><span class=\"o\">]</span> <span class=\"n\">fraction_ring.alg_equiv</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span> <span class=\"o\">:</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.lift_on</span> <span class=\"n\">q</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">/</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">))</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">rintro</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">hd</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">localization.r_iff_exists</span><span class=\"o\">,</span>\n      <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">⟩,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero</span> <span class=\"n\">at</span> <span class=\"n\">hb</span> <span class=\"n\">hd</span> <span class=\"n\">hk</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"n\">div_eq_div_iff</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">int.cast_mul</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">int.cast_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hb</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">int.cast_eq_zero</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hd</span> <span class=\"o\">},</span>\n    <span class=\"kd\">end</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">fraction_ring.alg_equiv_apply</span><span class=\"o\">,</span> <span class=\"n\">localization.lift_on_mk</span><span class=\"o\">,</span> <span class=\"n\">localization.mk_eq_mk'</span><span class=\"o\">,</span>\n      <span class=\"n\">is_localization.map_mk'</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- the equivalence between the two fields is what we expect</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n    <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">int.cast_coe_nat</span><span class=\"o\">,</span> <span class=\"n\">set_like.coe_mk</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.eq_int_cast</span><span class=\"o\">,</span>\n             <span class=\"n\">fraction_ring.alg_equiv_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">localization.mk_eq_mk'</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 264816820,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639462517
    },
    {
        "content": "<p>Ehhh I guess I can just use the \"forward\" result and cheat :)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"bp\">→</span> <span class=\"n\">fraction_ring</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n    <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">fraction_ring.alg_equiv_apply</span><span class=\"o\">,</span> <span class=\"n\">localization.mk_eq_mk'</span><span class=\"o\">,</span>\n      <span class=\"n\">is_localization.map_mk'</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 264816980,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639462693
    },
    {
        "content": "<p>This proof is coming into use to verify that the localization action is <code>c • ⟨a, b⟩ = ⟨c • a, b⟩</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">localization.smul</span> <span class=\"n\">z</span> <span class=\"o\">((</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">•</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">q</span> <span class=\"bp\">=</span>\n    <span class=\"n\">localization.mk</span> <span class=\"n\">q.num</span>\n    <span class=\"o\">⟨</span><span class=\"n\">q.denom</span><span class=\"o\">,</span> <span class=\"n\">mem_non_zero_divisors_iff_ne_zero.mpr</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">q.pos.ne'</span><span class=\"o\">)⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">alg_equiv.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">fraction_ring.alg_equiv_apply</span><span class=\"o\">,</span> <span class=\"n\">localization.mk_eq_mk'</span><span class=\"o\">,</span>\n        <span class=\"n\">is_localization.map_mk'</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">fraction_ring.alg_equiv</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">localization.smul_mk</span><span class=\"o\">,</span> <span class=\"n\">alg_equiv.apply_symm_apply</span><span class=\"o\">,</span> <span class=\"n\">fraction_ring.alg_equiv_apply</span><span class=\"o\">,</span>\n      <span class=\"n\">localization.mk_eq_mk'</span><span class=\"o\">,</span> <span class=\"n\">is_localization.map_mk'</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_div_assoc</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 264960028,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639537990
    },
    {
        "content": "<p>Am I misusing the API here? I feel like there are some simp lemmas that I have to avoid because otherwise I get into a difficult-to-wrangle goal.</p>",
        "id": 264960043,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639538026
    },
    {
        "content": "<p>The docstring for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/localization.smul\">docs#localization.smul</a> says</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Scalar multiplication in a ring localization is defined as `c • ⟨a, b⟩ = ⟨c • a, c • b⟩`. -/</span>\n</code></pre></div>\n<p>but for \"rat ~ fraction_ring int\" it seems like it is the <code>z • q.num / q.denom</code> as I would expect. Am I misunderstanding the constructor syntax in the docstring, or something more broadly about how scalar actions on localizations work?</p>",
        "id": 264960140,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639538142
    },
    {
        "content": "<p>I think the docstring is wrong, judging from the next lemma...</p>",
        "id": 264960790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639538776
    },
    {
        "content": "<p>Right. I wanted to make sure that I understood the definition correctly and how <code>localization.mk</code> works by proving an example I thought would differentiate.</p>",
        "id": 264960842,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639538869
    },
    {
        "content": "<p>Is there a good textbook / outside-of-mathlib reference for the \"canonical\" choice? A cursory search only found <a href=\"https://math.stackexchange.com/q/2965345\">https://math.stackexchange.com/q/2965345</a>, which indicated to me that the choice might have been what the docstring wrote. That's why I was checking.</p>",
        "id": 264961022,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1639539014
    },
    {
        "content": "<p>Right, this is something that Eric and I keep talking about. There are two different situations. If a group (or monoid) acts on a ring, then that means <code>g . (a * b) = (g . a) * (g . b)</code>. In that case, in the localization you should also have <code>g . (a / b) = (g . a) / (g . b)</code>. The other situation is when considering a localization of an R-algebra. In that case you have <code>r . (a * b) = (r . a) * b</code> and so <code>r . (a / b) = (r . a) / b</code>.<br>\nIn Lean we write both of these with <code>•</code> and call it <code>mul_action</code> but only the first one is \"an action on a ring\". (The second one is an action on the underlying set of a ring.)</p>",
        "id": 265051669,
        "sender_full_name": "Reid Barton",
        "timestamp": 1639592114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, I think part of the problem is that we don't really have many instances of the type of action you're referring to, according to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_distrib_mul_action\">docs#mul_distrib_mul_action</a>; pretty much the only interesting actions in that list are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_aut.apply_mul_distrib_mul_action\">docs#mul_aut.apply_mul_distrib_mul_action</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/conj_act.mul_distrib_mul_action\">docs#conj_act.mul_distrib_mul_action</a>, all the rest are inherited actions.</p>",
        "id": 265068329,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639598974
    },
    {
        "content": "<p>Maybe we should just use new notation for (the rarer) one of these?</p>",
        "id": 265084450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639606883
    },
    {
        "content": "<p>Mathematical notation is a bit of an art. We know <code>a * (b + c) = a * b + a * c</code> and choose notation wisely to make this sort of thing happen (\"times distributes over plus\" is indicated with notation and is probably the reason for BIDMAS/PEMDAS). We also know <code>a * (b * c) = (a * b) * c</code> (\"times associates with times\")-- Turns out that <code>•</code> definitely distributes over <code>+</code>, and definitely associates with itself, but it can't work out whether it distributes over or associates with <code>*</code>. So maybe it's two notations.</p>",
        "id": 265084813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639607091
    }
]
[
    {
        "content": "<p>I'm just itching to contribute something to mathlib. I can't find that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group\">docs#matrix.general_linear_group</a> is a Lie group, or the definitions of other common matrix Lie groups, or how to obtain a Lie algebra from a Lie group. Is somebody working on any of these, or should I try to tackle some of these? What would some missing prerequisites be?</p>",
        "id": 290702410,
        "sender_full_name": "Winston Yin",
        "timestamp": 1658700483
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span></p>",
        "id": 290702432,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658700550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span>  You should see the stub at this file<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/geometry/manifold/instances/units_of_normed_algebra.html\">https://leanprover-community.github.io/mathlib_docs/geometry/manifold/instances/units_of_normed_algebra.html</a></p>",
        "id": 290703175,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658701618
    },
    {
        "content": "<p>Your timing is good actually, because one of the prerequisites mentioned in the TODO, </p>\n<blockquote>\n<p><code>cont_diff_mul</code> (needs to be generalized from field to algebra)</p>\n</blockquote>\n<p>was just completed last week, <a href=\"https://github.com/leanprover-community/mathlib/pull/15595\">#15595</a></p>",
        "id": 290703237,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658701698
    },
    {
        "content": "<p>So the main prerequisite is the other TODO mentioned,</p>\n<blockquote>\n<ul>\n<li>for an open embedding <code>f</code>, whose domain is equipped with the induced manifold structure <code>f.singleton_smooth_manifold_with_corners</code>, characterization of smoothness of functions to/from this manifold in terms of smoothness in the target space.  See the pair of lemmas <code>cont_mdiff_coe_sphere</code> and <code>cont_mdiff.cod_restrict_sphere</code> for a model.</li>\n</ul>\n</blockquote>",
        "id": 290703249,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658701742
    },
    {
        "content": "<p>After that, you should be well on the way to proving that GL(n) (in the form of the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/units\">docs#units</a> of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map\">docs#continuous_linear_map</a>, not the form <a href=\"https://leanprover-community.github.io/mathlib_docs/find/matrix.general_linear_group\">docs#matrix.general_linear_group</a> you mentioned) is a Lie group.</p>",
        "id": 290703373,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658701951
    },
    {
        "content": "<p>Thanks for the guide!</p>",
        "id": 290703392,
        "sender_full_name": "Winston Yin",
        "timestamp": 1658702019
    },
    {
        "content": "<p>In case you missed it we also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.general_linear_group\">docs#linear_map.general_linear_group</a>, but that's not with continuity</p>",
        "id": 290704507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658703604
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> and I counted last week that there are at least five things in mathlib that could claim to be the general linear group.  \"Sameness\" is difficult in formalization!</p>",
        "id": 290704534,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658703670
    },
    {
        "content": "<p>I'm curious what that list was, if you have it to hand</p>",
        "id": 290705302,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658704821
    },
    {
        "content": "<p>I do, in fact:</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/module/equiv.html#linear_equiv.automorphism_group\">the group of automorphisms</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/basic.html#linear_map.general_linear_group\">units of the ring of endomorphisms</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/topology/algebra/module/basic.html#continuous_linear_equiv.automorphism_group\">the group of bicontinuous automorphisms</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/topology/algebra/module/basic.html#continuous_linear_equiv.of_unit\">units of the ring of continuous endomorphisms</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/general_linear_group.html\">matrix version</a></li>\n</ul>",
        "id": 290705332,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658704913
    },
    {
        "content": "<p>Number 4 is the one which will be made a Lie group by the above strategy.</p>",
        "id": 290705373,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658704937
    },
    {
        "content": "<p>Oh of course, I forgot about the versions stated via equivs</p>",
        "id": 290705507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658705163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/matrix.20groups.20and.20Lie.20groups/near/290702410\">said</a>:</p>\n<blockquote>\n<p>or how to obtain a Lie algebra from a Lie group</p>\n</blockquote>\n<p>I think we have something in this direction, but I forgot where to find it <span aria-label=\"oops\" class=\"emoji emoji-1f643\" role=\"img\" title=\"oops\">:oops:</span></p>",
        "id": 290717930,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1658722666
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/left_invariant_derivation.lie_algebra\">docs#left_invariant_derivation.lie_algebra</a> which is one possible approach.</p>",
        "id": 290732018,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1658738007
    },
    {
        "content": "<p>I think a valuable addition would be to construct the Lie bracket on smooth sections of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tangent_bundle\">docs#tangent_bundle</a> (for any manifold).</p>",
        "id": 290732139,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1658738092
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 290979022,
        "sender_full_name": "Winston Yin",
        "timestamp": 1658887515
    },
    {
        "content": "<p>Lie group of ring units in PR <a href=\"https://github.com/leanprover-community/mathlib/pull/15763\">#15763</a>. Still needs some cleanup</p>",
        "id": 291383162,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659130252
    },
    {
        "content": "<p>Update: I've generalised the proofs so that <code>smooth_mul</code> and <code>smooth_inv</code> are now consequences of the theorem that the differentiability of a function <code>g : M → M'</code> between manifolds can be stated in terms of the differentiability of the corresponding function <code>f : E → E'</code> between the model vector spaces, given that there are open embeddings <code>e : M → E</code> and <code>e' : M' → E'</code>, and that the extended charts on <code>M</code> and <code>M'</code> coincide with <code>e</code> and <code>e'</code>, respectively.</p>",
        "id": 291781106,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659481746
    },
    {
        "content": "<p>The actual file is still a mess. I'll need to wrestle with the type checker to find the least verbose arrangement of variables</p>",
        "id": 291781238,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659481845
    },
    {
        "content": "<p>Because product manifolds are weird when formalised, there are two theorems, one more general (used to prove <code>smooth_mul</code>) but super verbose and the other only applying to manifolds made with <code>singleton_smooth_manifold_with_corners</code> (used to prove <code>smooth_inv</code>)</p>",
        "id": 291781585,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659482111
    },
    {
        "content": "<p>Nice work!  I would recommend dividing into two separate lemmas, though.  One lemma should be just about when <code>M'</code>, the target, is made from an open embedding <code>e' : M' → E'</code>.  And the other lemma, which should cover everything you need about the domain, should be that when <code>M</code> is made from an open embedding <code>e : M → E</code>, then <code>e</code> itself is <code>cont_mdiff</code>.</p>",
        "id": 291781838,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659482299
    },
    {
        "content": "<p>You can see what's done with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_mdiff.cod_restrict_sphere\">docs#cont_mdiff.cod_restrict_sphere</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_mdiff_coe_sphere\">docs#cont_mdiff_coe_sphere</a> , respectively, as a model.</p>",
        "id": 291781884,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659482358
    },
    {
        "content": "<p>I'm having some trouble using the sphere example as a model. What I'm trying to do is a generalisation of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_diff_on.cont_mdiff_on\">docs#cont_diff_on.cont_mdiff_on</a> that can be used to show both <code>smooth_mul</code> and <code>smooth_inv</code> for ring units. While the inverse is a map from <code>Rˣ</code> to <code>Rˣ</code>, which is made from <code>singleton_smooth_manifold_with_corners</code>, the multiplication is a map from the product manifold <code>Rˣ × Rˣ</code>, whose manifold structure isn't defeq to the one induced from a single open embedding <code>f : Rˣ × Rˣ → R × R</code>.</p>\n<p>The way I've generalised the lemma to take care of this case is to assume the model with corners <code>I</code> for the domain <code>M</code> to be an open map, and to assume that the extended chart at every point on the codomain <code>M'</code> to cover the whole space <code>M'</code>. These two assumptions are obviously true in the case of manifolds made with <code>singleton_charted_space</code> and <code>model_with_corners_self</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">E'</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">M'</span><span class=\"o\">}</span>\n<span class=\"o\">(</span><span class=\"n\">hI</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hI'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">ext_chart_at</span> <span class=\"n\">I'</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">source</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">cont_diff_on</span> <span class=\"bp\">𝕜</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">ext_chart_at</span> <span class=\"n\">I</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">target</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">ext_chart_at</span> <span class=\"n\">I</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ext_chart_at</span> <span class=\"n\">I'</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">cont_mdiff</span> <span class=\"n\">I</span> <span class=\"n\">I'</span> <span class=\"n\">n</span> <span class=\"n\">g</span>\n</code></pre></div>\n<p>If I'm understanding the suggestion correctly, we want the equivalent of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_mdiff_coe_sphere\">docs#cont_mdiff_coe_sphere</a> to show that the extended chart is smooth, and then the smoothness of <code>g</code> can be shown by first replacing it with <code>(ext_chart_at I' y).symm ∘ f ∘ (ext_chart_at I x)</code> and then using composition of smooth maps. However, the assumptions above appear to be too weak to show the smoothness of, say, <code>(ext_chart_at I x)</code> itself.</p>",
        "id": 292084083,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659656247
    },
    {
        "content": "<p>I'd be happy to write some lemmas about the smoothness of open embeddings themselves, and they can certainly be used to show <code>smooth_inv</code>, but for the purpose of showing <code>smooth_mul</code>, the assumptions above seem to be relatively more general. Please let me know if I'm missing something!</p>",
        "id": 292084723,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659656672
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15763\">#15763</a> has a current version of the lemmas</p>",
        "id": 292084752,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659656694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> Let's check we're on the same page.  Here are the two lemmas I was proposing you write.  The idea is that all manipulation of charts gets hidden inside them.  Did you try something along these lines?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.manifold.cont_mdiff</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">topological_space.opens</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- move this copy of `topological_space.opens.charted_space` to near the original lemma,</span>\n<span class=\"c1\">-- apparently need the variant because of the distinction between `↥s` and `↥↑s`</span>\n<span class=\"kd\">instance</span> <span class=\"n\">topological_space.opens.charted_space'</span> <span class=\"o\">:</span> <span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">topological_space.opens.charted_space</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cont_mdiff_coe_opens</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">cont_mdiff</span> <span class=\"n\">I</span> <span class=\"n\">I</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">E'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H'</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I'</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span> <span class=\"n\">H'</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H'</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I'</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cont_mdiff.cod_restrict_opens</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M'</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">cont_mdiff</span> <span class=\"n\">I'</span> <span class=\"n\">I</span> <span class=\"n\">m</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">cont_mdiff</span> <span class=\"n\">I'</span> <span class=\"n\">I</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">set.cod_restrict</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"n\">hf'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 292086714,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659658021
    },
    {
        "content": "<p>You can also look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/circle.lie_group\">docs#circle.lie_group</a> to see how the analogues of these two lemmas turn up in the proof that the circle is a Lie group.</p>",
        "id": 292086775,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659658079
    },
    {
        "content": "<p>If you hit problems in the with-boundary case (there are certainly subtleties there with products, and I haven't thought about whether the lemmas should still be true), you can drop the <code>H</code>'s and <code>I</code>'s and just work with <code>𝓘(𝕜, E)</code> or <code>𝓘(𝕜, E')</code> as needed.</p>",
        "id": 292086999,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659658239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> PS Sorry, I just noticed that in your use case the units are not literally an open subset of the algebra, but rather are some type with a natural embedding to that algebra.  So you need the version of the above lemmas for an open embedding, rather than just subtype inclusion.  This should do it (again modulo caveats in the with-boundary case):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.manifold.cont_mdiff</span>\n\n<span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">H</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">open_embedding</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cont_mdiff_open_embedding</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">cont_mdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">I</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h.singleton_charted_space</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">I</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">m</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n\n<span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">E'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H'</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I'</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span> <span class=\"n\">H'</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H'</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I'</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cont_mdiff.of_comp_open_embedding</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M'</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">cont_mdiff</span> <span class=\"n\">I'</span> <span class=\"n\">I</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">cont_mdiff</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">I'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">I</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h.singleton_charted_space</span> <span class=\"n\">m</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 292089596,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659660591
    },
    {
        "content": "<p>Thanks for the detailed explanation. Suppose we have your <code>cont_mdiff.of_comp_open_embedding</code>. Is the strategy to then show <code>cont_mdiff I' I m (f ∘ φ)</code> by equivalently showing <code>cont_mdiff I' I m (φ' ∘ f')</code>, where <code>f' : M' → H'</code> is an open embedding and <code>φ'</code> is the \"same\" map as <code>φ</code> but on <code>E' → E</code>?</p>",
        "id": 292098781,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659666845
    },
    {
        "content": "<p>Because the goal as I understand it is to express <code>cont_mdiff</code> on the manifolds in terms of the much simpler <code>cont_diff</code> on the model spaces, when there's an open embedding of the manifolds into the model space, on which a <code>cont_diff</code> lemma is already proven. A single theorem like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_diff_on.cont_mdiff_on\">docs#cont_diff_on.cont_mdiff_on</a> but more general</p>",
        "id": 292099440,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659667009
    },
    {
        "content": "<p>I'm sorry if I'm fundamentally misunderstanding the intended use case of your suggested lemmas</p>",
        "id": 292099690,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659667065
    },
    {
        "content": "<p>In particular for inversion of ring units, your <code>cont_mdiff.of_comp_open_embedding</code> would leave us with the goal <code>cont_mdiff 𝓘(𝕜, R) 𝓘(𝕜, R) ⊤ (coe ∘ λ (a : Rˣ), a⁻¹)</code>. A few more steps are still needed before <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_diff_at_ring_inverse\">docs#cont_diff_at_ring_inverse</a> is applicable.</p>",
        "id": 292100547,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659667343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> You can look at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/circle.lie_group\">docs#circle.lie_group</a> for a model.  So, e.g., to show that <code>inv : Rˣ → Rˣ</code> is m-smooth</p>\n<ol>\n<li>by <code>cont_mdiff.of_comp_open_embedding</code> it suffices to show that <code>coe ∘ inv : Rˣ → R</code> is m-smooth</li>\n<li>the map <code>coe ∘ inv : Rˣ → R</code> is equal to <code>ring.inverse ∘ coe</code> (here <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring.inverse\">docs#ring.inverse</a> is this extended-by-junk-values \"inverse\")</li>\n<li>by <code>cont_mdiff_open_embedding</code> the map <code>coe : Rˣ → R</code> is m-smooth</li>\n<li>by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cont_diff_at_ring_inverse\">docs#cont_diff_at_ring_inverse</a> the map <code>ring.inverse : R → R</code> is smooth (on the needed domain) and therefore m-smooth</li>\n<li>composition of m-smooth maps is m-smooth</li>\n</ol>",
        "id": 292101726,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659668638
    },
    {
        "content": "<p>That coincides with my understanding. Thank you.</p>",
        "id": 292101821,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659668716
    },
    {
        "content": "<p>This 5 step process is what I initially imagined the generalised lemmas to be, hence the ones I wrote in the linked PR</p>",
        "id": 292101869,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659668763
    },
    {
        "content": "<p>I will further break them down and rephrase them. Stay tuned :)</p>",
        "id": 292101921,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659668819
    },
    {
        "content": "<p>By the way, I'll be on holiday next week, and not replying quite so fast!</p>",
        "id": 292102001,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659668907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> One more suggestion.  The lemmas I suggested you route through are awkward, because of all the <code>_</code>.  When you <em>prove</em> them you can make it less awkward within the proofs by starting with a line like,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">letI</span> <span class=\"o\">:=</span> <span class=\"n\">h.singleton_charted_space</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>And afterwards, when you're <em>using</em> them, you can make it less awkward by restating them in the context when typeclass inference will be able to find the arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_space</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nontrivially_normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_algebra</span> <span class=\"bp\">𝕜</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">units.cont_mdiff_coe</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">cont_mdiff</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"bp\">ˣ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">cont_mdiff_open_embedding</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">units.open_embedding_coe</span>\n\n<span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">E'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_add_comm_group</span> <span class=\"n\">E'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H'</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I'</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E'</span> <span class=\"n\">H'</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">M'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H'</span> <span class=\"n\">M'</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I'</span> <span class=\"n\">M'</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">cont_mdiff.of_comp_units_coe</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">with_top</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M'</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"bp\">ˣ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">cont_mdiff</span> <span class=\"n\">I'</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"bp\">∘</span> <span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M'</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">cont_mdiff</span> <span class=\"n\">I'</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">φ</span> <span class=\"o\">:=</span>\n<span class=\"n\">cont_mdiff.of_comp_open_embedding</span> <span class=\"bp\">𝓘</span><span class=\"o\">(</span><span class=\"bp\">𝕜</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">units.open_embedding_coe</span> <span class=\"n\">hφ</span>\n</code></pre></div>",
        "id": 292104042,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1659671256
    },
    {
        "content": "<p>That’s good to know! Have a great holiday :)</p>",
        "id": 292106065,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659673645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> Your suggested lemma statements required no modification. I was able to prove them and use them to show <code>units.smooth_mul</code> and <code>units.smooth_inv</code>. These are pushed to the PR. I'll also do a little more cleanup.</p>",
        "id": 292217441,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659740649
    },
    {
        "content": "<p>My initial approach was conceptually complicated because when showing <code>g : M → M'</code> is <code>cont_mdiff</code>, in the step <code>coe ∘ g = f ∘ coe'</code>, I was trying very hard to specify the factors on the RHS exactly, so that <code>coe'</code> must coincide with the manifold structure on <code>M'</code>. This requirement caused problems with product manifolds. I now see that one may freely choose the factorisation <code>f ∘ coe'</code> depending on what theorem already exists for <code>f</code> being <code>cont_mdiff</code>. So, thanks for clarifying this for me!</p>",
        "id": 292218004,
        "sender_full_name": "Winston Yin",
        "timestamp": 1659741305
    }
]
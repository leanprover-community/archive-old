[
    {
        "content": "<p>Dear All,</p>\n<p>I discovered today that <a href=\"https://mathoverflow.net/questions/172530/kaplanskys-unit-conjecture-and-unique-products\">unique products</a> is a thing.  I am thinking of implementing them.  What do people think of the code below?</p>\n<p>Any comments are greatly appreciated!</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra.basic</span>\n\n<span class=\"sd\">/--  `unique_mul G A B a0 b0` means that the element `a0 * b0` can be written</span>\n<span class=\"sd\">uniquely as a product of an element of `A` and an element of `B`. -/</span>\n<span class=\"kd\">@[to_additive \"`unique_add A B a0 b0` means that the element `a0 + b0` can be written</span>\n<span class=\"kd\">uniquely as a sum of an element from `A` and an element from `B`.\"]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unique_mul</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b0</span>\n\n<span class=\"sd\">/--  `unique_summands G` asserts that any two non-empty finite subsets of `G`</span>\n<span class=\"sd\">have the `unique_add` property. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">unique_summands</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">adds</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B.nonempty</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">unique_add</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">a0</span> <span class=\"n\">b0</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--  `unique_products G` asserts that any two non-empty finite subsets of `G`</span>\n<span class=\"sd\">have the `unique_mul` property. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">unique_products</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">muls</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B.nonempty</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b0</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">unique_mul</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">a0</span> <span class=\"n\">b0</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span> <span class=\"n\">unique_summands</span><span class=\"o\">]</span> <span class=\"n\">unique_products</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unique_summands</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">unique_products</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">muls</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">hA</span> <span class=\"n\">hB</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"n\">A'</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">A</span> <span class=\"k\">in</span> <span class=\"k\">have</span> <span class=\"n\">hA'</span><span class=\"o\">:</span> <span class=\"n\">A'.nonempty</span> <span class=\"o\">:=</span> <span class=\"n\">hA</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">hA0</span><span class=\"o\">,</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">hB0</span><span class=\"o\">,</span> <span class=\"n\">J</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">unique_summands.adds</span> <span class=\"n\">hA'</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">additive.to_mul</span> <span class=\"n\">a0</span><span class=\"o\">,</span> <span class=\"n\">hA0</span><span class=\"o\">,</span> <span class=\"n\">additive.to_mul</span> <span class=\"n\">b0</span><span class=\"o\">,</span> <span class=\"n\">hB0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">aA</span> <span class=\"n\">bB</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">J</span> <span class=\"n\">aA</span> <span class=\"n\">bB</span> <span class=\"n\">H</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 296258988,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661924354
    },
    {
        "content": "<p>This is a thing in additive combinatorics, actually!</p>",
        "id": 296262523,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661926711
    },
    {
        "content": "<p>Yes, I put the import of where I was going to use it, but actually it is much lower than that.  Anyway, I'm going to make a PR, but do give comments on the definition!  I have checked that this would work smoothly with non-zero divisors.</p>",
        "id": 296262597,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661926769
    },
    {
        "content": "<p>(The application is fairly direct: if the grading type of an <code>add_monoid_algebra</code> satisfies the <code>unique_summands</code> property, then the <code>add_monoid_algebra</code> has no non-zero zero-divisors as soon as the base ring has no non-zero zero-divisors.</p>\n<p>As far as I can tell, this easy result implies easily all(?) the <code>no_zero_divisors</code> instances around <code>add_monoid_algebra, polynomial, mv_polynomial</code> in mathlib.)</p>",
        "id": 296262970,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927023
    },
    {
        "content": "<p>How often is this satisfied in practice? I guess <code>pnat</code> has this property?</p>",
        "id": 296263065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927082
    },
    {
        "content": "<p>I have a proof of what is below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive covariants.to_unique_summands]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">covariants.to_unique_products</span> <span class=\"o\">{</span><span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">covariant_class</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">covariant_class</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"n\">contravariant_class</span> <span class=\"n\">A</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">unique_products</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 296263229,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927197
    },
    {
        "content": "<p>Basically, if you have a linear order and with an operation and the operation is \"sufficiently monotone\", then <code>unique_products</code> holds.</p>",
        "id": 296263289,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927232
    },
    {
        "content": "<p>This applies to the grading types of <code>mv_polynomials</code>, for instance.</p>",
        "id": 296263344,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927264
    },
    {
        "content": "<p>Both of these work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">unique_summands</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">unique_products</span> <span class=\"n\">pnat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">unique_summands</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 296263481,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927347
    },
    {
        "content": "<p>Aah, of course <code>ℕ</code> also satisfies it.</p>",
        "id": 296263526,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927379
    },
    {
        "content": "<p><code>0</code> is not a problem.</p>",
        "id": 296263534,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927385
    },
    {
        "content": "<p>(I added <code>int</code> above.)</p>",
        "id": 296263658,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927443
    },
    {
        "content": "<p>Wait, I'm still confused. What is the motivation again for these classes? You mentioned something with gradings.<br>\nAre we morally more interested in <code>unique_summands</code> or <code>unique_products</code>?</p>",
        "id": 296263802,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927555
    },
    {
        "content": "<p>Btw Johan, while what I wrote is correct, this is what you probably had in mind:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">unique_summands</span> <span class=\"n\">pnat</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 296263816,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927572
    },
    {
        "content": "<p>By the way, <code>unique_mul</code> is equivalent to <code>(A * B).card = A.card * B.card</code></p>",
        "id": 296263887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661927639
    },
    {
        "content": "<p><code>unique_products ℕ</code> is false, right?</p>",
        "id": 296263905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927643
    },
    {
        "content": "<p>For <code>add_monoid_algebra</code>, summands would make more sense.  But in more general group theory, people do study the \"unique property\" and in that context the operation is not commutative and they tend to use products.</p>",
        "id": 296263928,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296263905\">said</a>:</p>\n<blockquote>\n<p><code>unique_products ℕ</code> is false, right?</p>\n</blockquote>\n<p>I guess so!</p>",
        "id": 296263944,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661927657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296263887\">said</a>:</p>\n<blockquote>\n<p>By the way, <code>unique_mul</code> is equivalent to <code>(A * B).card = A.card * B.card</code></p>\n</blockquote>\n<p>I don't think so</p>",
        "id": 296264001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927708
    },
    {
        "content": "<p>You are leaving out <code>a0</code> and <code>b0</code></p>",
        "id": 296264027,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927728
    },
    {
        "content": "<p>Rain, so I'm closing my laptop</p>",
        "id": 296264051,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1661927746
    },
    {
        "content": "<p>Ah yes, you're talking about a single element. Then you should replace <code>a0 * b0</code> by a single variable.</p>",
        "id": 296264134,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661927796
    },
    {
        "content": "<p>Yaël, so should I should also quantify over 4 elements?</p>",
        "id": 296264651,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661928165
    },
    {
        "content": "<p>(or two pairs?)</p>",
        "id": 296264684,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661928186
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> here is a concrete proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unique_mul</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">d</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">d</span>\n</code></pre></div>\n<p>To me, it seems a little more cumbersome, but maybe I am wrong.  Likely, there is a better way of expressing this concept.</p>",
        "id": 296265121,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661928424
    },
    {
        "content": "<p>I'll have time later today to find the correct combinatorial definition.</p>",
        "id": 296265263,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661928520
    },
    {
        "content": "<p><code>unique_products pnat</code> is equivalent to <code>unique_summands (ℕ →₀ ℕ)</code> via a monoid isomorphism. <code>unique_products ℕ</code> is not true since A={0}, B={1,2} admit no unique product.</p>\n<p>I don't like the disparity between the names <code>summand</code> and <code>product</code>. Could the former just be <code>sum</code>?</p>\n<p>The property could also be phrased to say there is an element of G that has a unique preimage in A×B under multiplication; maybe this is what Yaël means?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">unique_products</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">muls</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B.nonempty</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">ab</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">ab.1</span> <span class=\"bp\">*</span> <span class=\"n\">ab.2</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">unique_products'</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">muls</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B.nonempty</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">unique</span> <span class=\"o\">(</span><span class=\"n\">function.uncurry</span> <span class=\"n\">has_mul.mul</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">g</span><span class=\"o\">}</span> <span class=\"bp\">∩</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 296265684,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661928835
    },
    {
        "content": "<p>Sorry for the sudden silence: I was talking to a student.</p>\n<p>Without trying them out, I would say that the last definition <code>unique_products'</code> may be harder to work with than the other candidates.</p>\n<p>Does anyone have any strong opinion on which one should be the definition of <code>unique_products</code>?</p>",
        "id": 296274727,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661933035
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> I am happy to use <code>unique_sum</code> for what is called <code>unique_summads</code> above.</p>",
        "id": 296274880,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661933103
    },
    {
        "content": "<p>That would suggest <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a>. What about <code>unique_mul</code>/<code>unique_add</code>?</p>",
        "id": 296274948,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661933138
    },
    {
        "content": "<p>Unique products is the established name in the literature, so I would rather keep that one.</p>",
        "id": 296275051,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661933179
    },
    {
        "content": "<p>Can't we use <code>to_additive</code> on classes? Would the name <code>unique_prod</code> be automatically additivized to <code>unique_sum</code>?</p>",
        "id": 296283016,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661936452
    },
    {
        "content": "<p>How about calling them <code>unique_prods</code> and <code>unique_sums</code>?  It is easy enough to get <code>to_additive</code> to learn about <code>prods -&gt; sums</code>, the \"multiplicative\" name would be closer to the usual convention and <code>unique_sums</code> would probably clash less with <code>finset.sum</code>?</p>",
        "id": 296285387,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661937412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/unique.20products/near/296283016\">said</a>:</p>\n<blockquote>\n<p>Can't we use <code>to_additive</code> on classes? Would the name <code>unique_prod</code> be automatically additivized to <code>unique_sum</code>?</p>\n</blockquote>\n<p>From the <code>to_additive</code> doc-module:</p>\n<blockquote>\n<p>This file defines an attribute <code>to_additive</code> that can be used to<br>\nautomatically transport theorems and definitions (but not inductive<br>\ntypes and structures) from a multiplicative theory to an additive theory.</p>\n</blockquote>\n<p>When I use simply to_additive on the class it creates something with the right name, but adds a single declaration to the environment: there is exactly one declaration with the same prefix.</p>\n<p>I will define the two classes separately and will bind them with <code>to_additive</code> after the fact.</p>",
        "id": 296292321,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661940180
    },
    {
        "content": "<p>Yes that's how you should do it.</p>",
        "id": 296292512,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661940246
    },
    {
        "content": "<p>Honestly, I am finding </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">unique_products</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">muls</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A.nonempty</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B.nonempty</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">∃!</span> <span class=\"n\">ab</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">ab.1</span> <span class=\"bp\">*</span> <span class=\"n\">ab.2</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">)</span>\n</code></pre></div>\n<p>very hard to work with.  I agree that it looks very nice, but it is a nightmare of proof obligations, angle bracket and repeated fields.</p>",
        "id": 296305601,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661945815
    },
    {
        "content": "<p>I am trying to see how workable this definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">def</span> <span class=\"n\">unique_mul'</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">subsingleton</span> <span class=\"o\">{</span> <span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span> <span class=\"bp\">|</span> <span class=\"n\">ab.1</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">∧</span> <span class=\"n\">ab.2</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">∧</span> <span class=\"n\">ab.1</span> <span class=\"bp\">*</span> <span class=\"n\">ab.2</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>(where I still need to think about how to make sure that there actually is a witness when we want one!)</p>",
        "id": 296305681,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661945849
    },
    {
        "content": "<p>Your original version looks best to me.</p>",
        "id": 296307046,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661946443
    },
    {
        "content": "<p>How so? Carrying around these non-empty hypotheses that need to be checked all the time, when the existence isn't really what we are worried about definitely seems onerous to me.</p>",
        "id": 296308610,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661947012
    },
    {
        "content": "<p>Maybe using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.image2\">docs#set.image2</a> in the definition would give you a lot of useful structure to start with?</p>",
        "id": 296310184,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1661947533
    },
    {
        "content": "<p>I am having difficulties of two kind with the <code>exists ... exists!...</code> definition.  First, <code>g</code> is determined by what comes next, <code>ab</code> but you really need to snake your way around angle brackets and <code>rfl</code>s to get to a stage where you can use this.  I could get used to it, but it seems too much effort for such a simple concept.  Second, if you have <code>unique_mul'</code> as your goal and you use <code>rintro?</code> you obtain a mess of hypotheses that are very hard to parse for me, unless I <code>dsimp</code> them and even after that, it is not clear what to do.  Here is a sample:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">unique_mul_forall</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a0</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">aA</span> <span class=\"o\">:</span> <span class=\"n\">a0</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bB</span> <span class=\"o\">:</span> <span class=\"n\">b0</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">unique_mul</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">ᾰ_h_left_w</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_h_left_h_left</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_h_left_h_right</span><span class=\"o\">⟩,</span> <span class=\"n\">ᾰ_h_right</span><span class=\"o\">⟩</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">ᾰ_1</span> <span class=\"n\">ᾰ_2</span> <span class=\"n\">ᾰ_3</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>leaving as state:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">G</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">_inst_1</span><span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"n\">G</span>\n<span class=\"n\">AB</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span>\n<span class=\"n\">a0b0ab</span><span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"n\">ᾰ_1</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span>\n<span class=\"n\">ᾰ_2</span><span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span>\n<span class=\"n\">ᾰ_3</span><span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span>\n<span class=\"n\">ᾰ_w_fstᾰ_w_snd</span><span class=\"o\">:</span> <span class=\"n\">G</span>\n<span class=\"n\">ᾰ_h_right</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">×</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">∃!</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">ab</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">ab.fst</span> <span class=\"bp\">*</span> <span class=\"n\">ab.snd</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span>\n<span class=\"n\">ᾰ_h_left_w</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span>\n<span class=\"n\">ᾰ_h_left_h_left</span><span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span>\n<span class=\"n\">ᾰ_h_left_h_right</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">ᾰ_w_fst</span><span class=\"o\">,</span> <span class=\"n\">ᾰ_w_snd</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">snd</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_h_left_w</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b0</span>\n</code></pre></div>",
        "id": 296310557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661947664
    },
    {
        "content": "<p>(the <code>rintro</code> is the uncleaned output of <code>rintro?</code>, but, ignoring the weird variable names, the end result is a mess anyway)</p>",
        "id": 296310703,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661947707
    },
    {
        "content": "<p>The initial definition that I posted may not be as snappy, but does not expand to something unwieldy if you are not careful to tame it.</p>\n<p>The non-empty assertions are fairly common to have in context, at least for my use case.  Also, note that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">unique_mul</span> <span class=\"o\">{</span><span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a0</span> <span class=\"n\">b0</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">⦄,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">*</span> <span class=\"n\">b0</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a0</span> <span class=\"bp\">∧</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b0</span>\n</code></pre></div>\n<p>does not have a proof obligation: you start with elements on <code>G</code> but then the proofs that you need to provide are harmless and are really dealing with the substance of <code>unique_mul</code>.</p>",
        "id": 296311100,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661947894
    },
    {
        "content": "<p>As always, this is my impression and it is not set in stone!  I am simply reporting that for me, the <code>exists...exists!...</code> definition is hard to use.</p>",
        "id": 296311230,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661947951
    },
    {
        "content": "<p>Trying to find slogans why I prefer the other definition:</p>\n<ul>\n<li>it uses more universal quantifiers than existential ones;</li>\n<li>it works with compositions of arrows, instead of products.</li>\n</ul>\n<p>In my experience, both of the above provide a smoother user experience.</p>",
        "id": 296312021,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661948281
    },
    {
        "content": "<p>In any case, I am also aware that the only thing that is important is that whatever definition is used, there is also a lemma to states that it is equivalent to the one that I like!  Thus, if everyone prefers the <code>exists...exists!...</code> one, then all this means is that I will roll my sleeves up, prove that it is equivalent to the one that I want and then never look at the implemented definition again!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 296312505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661948455
    },
    {
        "content": "<p>I opened a PR with the initial definition.  I can certainly change it, but mostly wanted to have <code>olean</code>s, since modifying <code>to_additive</code> is never easy on the CPU of my computer!</p>",
        "id": 296318903,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661950679
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16329\">#16329</a></p>",
        "id": 296318915,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661950682
    },
    {
        "content": "<p>I'm struggling to see how <code>unique_summands</code> holds for <code>nat</code>; if <code>A=B={0,1}</code> and <code>g = 1</code> then surely there is no unique choice <code>ab</code>?</p>",
        "id": 296331925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661954804
    },
    {
        "content": "<p>The <code>g</code> is bound by an existential quantifier, not a universal one.</p>",
        "id": 296332209,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661954889
    },
    {
        "content": "<p>You usually choose the smallest or largest elements and take it from there.</p>",
        "id": 296332268,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661954906
    },
    {
        "content": "<p>In your example, <code>g=0</code> or <code>g=2</code> work, but <code>g=1</code> does not.</p>",
        "id": 296332404,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661954961
    },
    {
        "content": "<p>But since we are asking for the existence of a good <code>g</code>, all is ok!</p>",
        "id": 296332487,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661954988
    },
    {
        "content": "<p>Yaël also thought that it was universal quantification earlier in the thread.</p>",
        "id": 296332606,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661955015
    },
    {
        "content": "<p>In case it helps, this is where <code>unique_sums</code> is heading.  When you multiply two elements of an <code>add_monoid_algebra</code>, the \"generic\" monomial in the resulting product is a sum of several contributions.  <code>unique_sums</code> isolates, if they exist, the monomials that receive a unique contribution.  These monomials are unlikely to be \"in the middle\", they tend to be \"on the boundary\".  This explains why, when you have an order, you end up seeing either <code>min</code>s or <code>max</code>s.</p>\n<p>I hope that this helps with the intuition!</p>",
        "id": 296334014,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661955415
    },
    {
        "content": "<p>Curse android and it not showing ∃ <del>or ∀</del> in your example and leaving me to guess!</p>",
        "id": 296335001,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1661955670
    },
    {
        "content": "<p>I pushed two implications relating the definition in the PR with two of the definitions in this thread.</p>\n<p>I have not yet thought of what is needed to make them iffs, since I was not yet ready to think about such hard concepts as whether a finset is empty or not.</p>\n<p>Also, <code>olean</code>s with the <code>to_additive</code> change are available, I simply stopped CI before it could finish linting/testing, in case you want to experiment yourself.</p>",
        "id": 296401458,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1661963253
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16329\">#16329</a> now has a more extensive doc-module and the lemmas that I wanted in (and some more).</p>\n<p>Does anyone want more lemmas added to this file?  Are there more comments on the definition?  I proved the equivalence of Junyan Xu's version and the one that I initially had, so I do not mind swapping the definitions.  However, I still find it easier to work with the current one than with the other.</p>",
        "id": 296568017,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662032512
    },
    {
        "content": "<p>I wonder whether we want that to go under <code>combinatorics.additive</code>. <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, thoughts?</p>",
        "id": 296570035,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662033308
    },
    {
        "content": "<p>Ah, I am glad that you brought the issue of where it goes!  I was thinking maybe in <code>finset</code>.</p>",
        "id": 296572637,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662034363
    },
    {
        "content": "<p>Sidon sets are certainly additive combinatorics, but it would say something for all elements, not for a single one</p>",
        "id": 296573105,
        "sender_full_name": "Mauricio Collares",
        "timestamp": 1662034540
    },
    {
        "content": "<p>So far, everything that's about pointwise operations of finsets is either in <code>data.finset.pointwise</code> or under <code>combinatorics.additive</code>. But I don't know whether this qualifies as additive combinatorics or not.</p>",
        "id": 296573166,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662034560
    },
    {
        "content": "<p>While I realize that combinatorics does not only deal with finite sets, <code>unique_prods</code> should fail on any finite set with at least two elements and an operation.  This makes me a little skeptical about putting it in combinatorics: I am not sure that I would ever look for it there, whereas I would want to use this for zero-divisors in add_monoid_algebras.</p>",
        "id": 296573491,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662034671
    },
    {
        "content": "<p>I think that <code>finset.something</code> is a better fit: I would look there if I were thinking about support of elements of <code>add_monoid_algebra</code>s and I guess that combinatorics stuff can easily be found in <code>finset</code>, right?</p>",
        "id": 296573741,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1662034758
    },
    {
        "content": "<p>Given that combinatorics is often concerned about finite things embedded into infinite ones, that wouldn't bother me much.</p>",
        "id": 296573752,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662034763
    }
]
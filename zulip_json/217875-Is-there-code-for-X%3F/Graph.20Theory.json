[
    {
        "content": "<p>Do we have Graph Theory in mathlib ? If not, I'd be happy to give it a try this summer</p>",
        "id": 201783213,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592946425
    },
    {
        "content": "<p>There was some work on it with the goal of formalizing the disproof of hedetniemis conjecture at <a href=\"https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory\">https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory</a></p>",
        "id": 201783410,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592946524
    },
    {
        "content": "<p>There's some stuff like Ramsey theory, Kruskal-Katona/Erdos-Ko-Rado (not in mathlib yet, they're on personal repos)</p>",
        "id": 201783550,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1592946602
    },
    {
        "content": "<p>Searching for Hedetniemi in chat will bring up some threads I guess.</p>",
        "id": 201783603,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592946622
    },
    {
        "content": "<p>See also this thread: <a href=\"#narrow/stream/113489-new-members/topic/Feasibility.20of.20graph.20or.20simplicial.20complex.20statement/near/187842633\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Feasibility.20of.20graph.20or.20simplicial.20complex.20statement/near/187842633</a></p>",
        "id": 201783704,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592946681
    },
    {
        "content": "<p>Sorry those things aren't in mathlib btw</p>",
        "id": 201783729,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1592946692
    },
    {
        "content": "<p>I started trying to work on some basic definitions but I kept changing my mind on how I wanted to do that lol</p>",
        "id": 201783982,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1592946799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303889\">Alena Gusakov</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201783982\">said</a>:</p>\n<blockquote>\n<p>I started trying to work on some basic definitions but I kept changing my mind on how I wanted to do that lol</p>\n</blockquote>\n<p>I think this is the same reason no-one else has made a PR yet either</p>",
        "id": 201784151,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592946848
    },
    {
        "content": "<p>There's an even older post here: <a href=\"#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type.20classes.20again/near/167340123</a> (this could probably be PR'd to <code>archive/</code> once we get some of the stuff into mathlib)</p>",
        "id": 201784173,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592946863
    },
    {
        "content": "<p>I'm doing some graph theory things right now.  There are a few ways of defining graphs, depending on what you're wanting to do.  One version is using relations, another is Type-valued \"relations\" for multiple edges between vertices, and one I have now is like 1-D CW complexes.  With the latter, I proved yesterday the handshaking lemma, that the sum of the degrees of the vertices is twice the number of edges.</p>",
        "id": 201784346,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592946945
    },
    {
        "content": "<p>There are some papers on formalizing graph theory in Coq by Doczkal and collaborators <a href=\"https://perso.ens-lyon.fr/christian.doczkal/index.html\">here</a> which might be helpful when thinking about design decisions. I haven't had a chance to really dig in though.</p>",
        "id": 201784554,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592947025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201784346\">said</a>:</p>\n<blockquote>\n<p>I proved yesterday the handshaking lemma, that the sum of the degrees of the vertices is twice the number of edges.</p>\n</blockquote>\n<p>Yeah this is a good exercise - I did it too when I proved Ramsey: <a href=\"https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean#L122\">https://github.com/b-mehta/combinatorics/blob/extras/src/handshaking.lean#L122</a></p>",
        "id": 201784602,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592947052
    },
    {
        "content": "<p>Ok so it has been done a lot but not in mathlib</p>",
        "id": 201785075,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592947271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201783410\">said</a>:</p>\n<blockquote>\n<p>There was some work on it with the goal of formalizing the disproof of hedetniemis conjecture at <a href=\"https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory\">https://github.com/leanprover-community/mathlib/tree/hedetniemi/src/graph_theory</a></p>\n</blockquote>\n<p>By \"was\" do you mean it's inactive ?</p>",
        "id": 201785116,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592947297
    },
    {
        "content": "<p>Yeah, there's no one actively working on it any more unfortunately; though as far as I know it's the biggest bit of graph theory that's been done in lean</p>",
        "id": 201785201,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592947334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>  It looks like you have it for simple graphs.  Since I'm going to need it, I used a definition that allows loops and multiple edges: <a href=\"https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25\">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25</a></p>",
        "id": 201785223,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592947349
    },
    {
        "content": "<p>Well the last commit  was a couple of months ago, and the thread died off, but it was only this year so it should be in good shape still.</p>",
        "id": 201785248,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592947366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201785223\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span>  It looks like you have it for simple graphs.  Since I'm going to need it, I used a definition that allows loops and multiple edges: <a href=\"https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25\">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L25</a></p>\n</blockquote>\n<p>Ah nice, yeah I see</p>",
        "id": 201785271,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592947382
    },
    {
        "content": "<p>(and every relation-based graph can be represented as such a graph using the constructor at <a href=\"https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L128\">https://github.com/kmill/lean-graphs/blob/master/src/graphs.lean#L128</a>)</p>",
        "id": 201785298,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592947399
    },
    {
        "content": "<p>I wasn't too involved, but an important part of the disproof is the construction of some specific graph with a particular girth and chromatic number, the paper used a probabilistic argument here and my impression was that such arguments are harder to develop in lean at present. Might be better to try a more explicit approach to constructing this part of the proof instead.</p>",
        "id": 201785480,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592947483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201785248\">said</a>:</p>\n<blockquote>\n<p>Well the last commit  was a couple of months ago, and the thread died off, but it was only this year so it should be in good shape still.</p>\n</blockquote>\n<p>I'll have a look and see if I can help, though I may be overestimating myself here <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 201785767,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592947646
    },
    {
        "content": "<p>Yeah I'm thinking of the paper <a href=\"https://arxiv.org/abs/2004.09028\">https://arxiv.org/abs/2004.09028</a> which looks like it might give a more explicit example for that step than the Erdos-Renyi stuff (but once again I am not a graph theorist so would welcome corrections!)</p>",
        "id": 201786359,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1592947949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201784554\">said</a>:</p>\n<blockquote>\n<p>There are some papers on formalizing graph theory in Coq by Doczkal and collaborators <a href=\"https://perso.ens-lyon.fr/christian.doczkal/index.html\">here</a> which might be helpful when thinking about design decisions. I haven't had a chance to really dig in though.</p>\n</blockquote>\n<p>If I wanna work on a generic-purpose approach, I think I'm going to keep that as a reference</p>",
        "id": 201786784,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592948203
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 201786881,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592948259
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 201786886,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592948262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span>  Given my experiences so far with graphs (where I need non-simple graphs with multiple edges) and what I've seen in those papers that <span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> kindly shared, here's how I might define directed and undirected non-simple graphs (optionally edge-labeled):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- An edge-labeled directed graph</span>\n<span class=\"kn\">structure</span> <span class=\"n\">dgraph</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">×</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"kn\">inductive</span> <span class=\"n\">sym2_rel</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sym2_rel</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">|</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sym2_rel</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span><span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"o\">,</span><span class=\"n\">x</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- The symmetric square is the cartesian product α × α modulo `swap`.</span>\n<span class=\"n\">def</span> <span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">quot</span> <span class=\"o\">(</span><span class=\"n\">sym2_rel</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">incl_diag</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sym2</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">quot</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">sym2_rel</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- An edge-labeled undirected graph</span>\n<span class=\"kn\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- For example,</span>\n<span class=\"n\">def</span> <span class=\"n\">loopless</span> <span class=\"o\">{</span><span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">graph</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"bp\">¬∃</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">p</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">incl_diag</span> <span class=\"n\">v</span>\n</code></pre></div>\n\n\n<p>The benefit with this definition for undirected graphs is that the edges are <em>intrinsically</em> undirected.  (Depending on your tastes, you might change <code>sym2</code> to <code>finset</code> and add in the axiom that <code>(p e).card</code> is either 1 or 2.)</p>",
        "id": 201788634,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592949164
    },
    {
        "content": "<p>Yeah I think I'd have done something like that. In classical logic I would rather have used quotient, but I've never used them in Lean yet, so I don't really know</p>",
        "id": 201788979,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592949396
    },
    {
        "content": "<p>See also David and Johan's definition here: <a href=\"https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean\">https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean</a></p>",
        "id": 201789218,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1592949537
    },
    {
        "content": "<p>I'd move <code>V</code> to the arguments because sometimes you want to consider a graph on a given type and having two ways to represent a type (<code>α</code> and <code>g.V</code>) can be bad for <code>simp</code> etc. But this is not too important, and it would be nice of someone finally PRs one of the definitions + basic theory to <code>mathlib</code>.</p>",
        "id": 201790716,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592950411
    },
    {
        "content": "<p>Yup that is true indeed, in some sense we are building a structure of graph on the type of its vertices</p>",
        "id": 201791017,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592950614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>  Yeah, the \"Type/Sort-valued relation\" seems like a good generalization of the Prop-valued relation approach to graphs, and it probably also makes edge labelings sort of come for free if you want them.  One thing I want to do is induct on the edge set in a graph, and I went for the sort of dual definition (edges are <em>attached</em> to the vertices) in anticipation of that.  You also get the number of edges in the graph by looking at the cardinality of the edge set this way, rather than having to sum up the edge sets over all pairs of vertices.</p>\n<p>One thing I've struggled with when thinking about a graph library is how a lot of graph theory can be turned into statements about irreflexive symmetric relations on a (finite) type.  It makes me think that there should be some part of mathlib about this specific case, maybe defining <code>relation.graph</code> and giving basic statements about these sorts of relations.  However, there's also the part of graph theory that considers non-simple graphs, and for this you might have something like the definitions I gave.  <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> Do you think it's reasonable to have both definitions in mathlib?</p>",
        "id": 201791488,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592950933
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201791017\">said</a>:</p>\n<blockquote>\n<p>Yup that is true indeed, in some sense we are building a structure of graph on the type of its vertices</p>\n</blockquote>\n<p>I think the decision might be more based on whether you think you want to consider lots of different graphs on the same vertex set.  I wasn't sure which way to go with the above definitions (and, in fact, I've been doing it with <code>graph V</code> in my own code).  It seems like it would be annoying working with <code>{g // g.V = V}</code>, and if you really did need the type of all graphs, there's always <code>Σ (V : Type*), graph V</code>.</p>",
        "id": 201791930,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592951255
    },
    {
        "content": "<p>It's <code>Σ V, graph V</code>, not <code>Π</code>.</p>",
        "id": 201792026,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592951303
    },
    {
        "content": "<p>Oh, thanks!</p>",
        "id": 201792048,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592951322
    },
    {
        "content": "<p><code>Π</code> type is the type of functions sending each <code>V</code> to some graph on <code>V</code>.</p>",
        "id": 201792066,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592951339
    },
    {
        "content": "<p>I'm not sure how many definitions of a graph do we want to have in <code>mathlib</code> but I'm pretty sure that we need at least one.</p>",
        "id": 201792243,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592951466
    },
    {
        "content": "<p>I'd suggest starting with some general definition, then see what special cases do we need.</p>",
        "id": 201792286,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592951500
    },
    {
        "content": "<p>Do you know if mathlib already has symmetric products (like sym2)?  If not, where would be a good place to put their definition?</p>",
        "id": 201793169,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592951973
    },
    {
        "content": "<p>I'd encourage PR'ing parts of the hedetniemi branch. The definitions there have been at least partially battle-tested.</p>",
        "id": 201793291,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592952047
    },
    {
        "content": "<p>It seems like the <a href=\"https://github.com/leanprover-community/mathlib/blob/hedetniemi/src/graph_theory/basic.lean#L16\">definition of a multigraph</a> isn't quite right for loop edges.  You'd want <code>inv</code> to be the identity equivalence on the diagonal, I think.</p>",
        "id": 201794754,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592953046
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> and I have done all of the graph theory in a proof of the Friendship Theorem, but we've slowed down on the linear algebra. <a href=\"https://github.com/jalex-stark/friendship-theorem/tree/master/src\">https://github.com/jalex-stark/friendship-theorem/tree/master/src</a></p>",
        "id": 201797911,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1592955604
    },
    {
        "content": "<p>I'd be happy to join a bigger graph theory (or other combinatorics) project, if people want a summer collaboration.</p>",
        "id": 201798048,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1592955781
    },
    {
        "content": "<p>Don't forget: whatever is not PRed, will stop compiling against <code>master</code> soon.</p>",
        "id": 201806292,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592965676
    },
    {
        "content": "<p>And it's better to make 10 small PRs than one huge PR.</p>",
        "id": 201806340,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592965713
    },
    {
        "content": "<p>So, don't wait till you have nice theorems.</p>",
        "id": 201806430,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592965839
    },
    {
        "content": "<p>A PR with basic definitions and \"obvious\" <code>simp</code> lemmas is a good start.</p>",
        "id": 201806442,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1592965863
    },
    {
        "content": "<p>We can always fix the definitions in later PRs. :-)</p>",
        "id": 201809646,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592971263
    },
    {
        "content": "<p>If no one is already working on a PR, I propose that someone who worked on the <code>hedetniemi</code> branch either:</p>\n<ol>\n<li>makes a PR, or </li>\n<li>gives pointers to what files are in PR-ready shape </li>\n</ol>\n<p><span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 201811054,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592973630
    },
    {
        "content": "<p>I'm working on a PR.  I'm taking some of what's in hedetniemi and reworking it for multigraphs.  I'm just trying to prove that the definition I'm using is equivalent to (a corrected version) of what's already there.</p>",
        "id": 201811934,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592975049
    },
    {
        "content": "<p>Great! I've sent you an invitation to collaborate, so you can push to a branch in mathlib and PR from that.</p>",
        "id": 201812159,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1592975358
    },
    {
        "content": "<p>Thanks, received!</p>",
        "id": 201812236,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592975444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, what was the mistake that needed correcting?</p>",
        "id": 201818158,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592983610
    },
    {
        "content": "<p>Will your generalisation to multigraphs still be usable for simple graphs?</p>",
        "id": 201818172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1592983626
    },
    {
        "content": "<p>The mistake is that in</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">directed_multigraph</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">),</span> <span class=\"n\">edge</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"err\">≃</span> <span class=\"n\">edge</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>the <code>inv x x</code> permutation might not be trivial, so you can do some weird quantum thing where you keep flipping over the edge and get a totally new one.  It seems loop edges aren't particularly popular to consider, but I use them a lot in my own work so I'd like them to be supported.</p>",
        "id": 201818432,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592983827
    },
    {
        "content": "<p>My plan for graphs is something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">sym2</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">multigraph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">single_edge</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">ends</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"bp\">¬</span><span class=\"o\">(</span><span class=\"n\">ends</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_diag</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>There would be a number of constructors to put the main ways of working with graphs into one of these forms.  For example, there's one that takes a corrected version of the hedetniemi-branch multigraph in the following format:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">edge_set_desc</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">edge</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"err\">≃</span> <span class=\"n\">edge</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loops</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inv</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">edge</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 201818570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592983980
    },
    {
        "content": "<p>Another constructor (not yet written) would be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">from_relation</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">r</span><span class=\"o\">):</span> <span class=\"n\">simple_graph</span> <span class=\"n\">α</span>\n</code></pre></div>",
        "id": 201818836,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592984175
    },
    {
        "content": "<p>Does this use of structure extensions seem OK?</p>",
        "id": 201818889,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592984245
    },
    {
        "content": "<p>I'm also unsure about the terminology.  And, maybe it would make sense to combine <code>graph</code> and <code>simple_graph</code>, since now that I think about it, <code>graph</code> doesn't seem particularly useful.</p>",
        "id": 201818977,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592984335
    },
    {
        "content": "<p>It's good to hear that you're working on a PR! There are a lot of questions here about how to set up definitions. One of the most basic is whether we want a type <code>E</code> of all edges together with an assignment of endpoints, or an indexed family <code>V -&gt; V -&gt; Sort u</code>. One issue with the former definition is that when you say \"given <code>a b : V</code>, consider an edge <code>e</code> with endpoints <code>a b</code>\", then the endpoints of <code>e</code> will never be definitionally equal to <code>a b</code> -- instead you will have some equalities to rewrite along. (It's easier to bundle an unbundled definition than it is to unbundle a bundled definition.)</p>",
        "id": 201823848,
        "sender_full_name": "David Wärn",
        "timestamp": 1592988231
    },
    {
        "content": "<p>I think this issue of loops being their own reversal never came up because Johan was working exclusively with the <code>Prop</code>-case, where loops definitionally equal their reversals. Another lawfulness issue is that edge reversal should be involutive -- the reversal of the reversal is the original loop. I think sometimes you might want this condition, while allowing loops which do not equal their reversal? (The example I have in mind is a groupoid, where the reversal of an arrow / edge is its inverse.)</p>",
        "id": 201824515,
        "sender_full_name": "David Wärn",
        "timestamp": 1592988822
    },
    {
        "content": "<p>An awkwardness with undirected graphs is that edges don't really have endpoints in a specific order.  It seems the indexed family approach requires you to sort of keep track of a quotient type yourself by having some involution that inverts edges.  The dual to the approach I was considering might be having the edges be an indexed family <code>sym2 V -&gt; Sort u</code>, which makes the edges inherently unoriented.</p>\n<p>I need to go to sleep now, but here's what I have so far: <a href=\"https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs\">https://github.com/leanprover-community/mathlib/tree/graphs/src/combinatorics/graphs</a></p>",
        "id": 201824534,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592988839
    },
    {
        "content": "<p>Yes, undirected graphs are awkward in the indexed approach. <code>edge : sym2 V -&gt; Sort u</code> might also be problematic since <code>edge (a, b)</code> and <code>edge (b, a)</code> are still not def eq.</p>",
        "id": 201824970,
        "sender_full_name": "David Wärn",
        "timestamp": 1592989153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/201824515\">said</a>:</p>\n<blockquote>\n<p>I think this issue of loops being their own reversal never came up because Johan was working exclusively with the <code>Prop</code>-case, where loops definitionally equal their reversals. Another lawfulness issue is that edge reversal should be involutive -- the reversal of the reversal is the original loop. I think sometimes you might want this condition, while allowing loops which do not equal their reversal? (The example I have in mind is a groupoid, where the reversal of an arrow / edge is its inverse.)</p>\n</blockquote>\n<p>Loops don't seem to be too popular, so that's fair.  The sorts of things I have in mind in the future (say, Tutte polynomials) involve any numbers of loops at vertex, so it would be nice to make sure this works.  </p>\n<p>(I sort of like the approach of gluing edges to the vertices, but I'm probably just biased as a topologist.)</p>",
        "id": 201825071,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592989210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span> Another approach I was using in a different project is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ε</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ϕ</span> <span class=\"o\">:</span> <span class=\"n\">D</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ε_inv</span> <span class=\"o\">:</span> <span class=\"n\">involutive</span> <span class=\"n\">ε</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ε_fp_free</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">has_fixed_point</span> <span class=\"n\">ε</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Here, <code>D</code> is the set of \"darts,\" which are the two ends of an edge.  The edges are the orbits under <code>ε</code>.  This, at least, makes accounting easier for the proof that <code>∑ (v : V), g.deg v = 2 * g.nedges</code>, since it has an intermediate <code>g.ndarts</code>.</p>",
        "id": 201825758,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1592989738
    },
    {
        "content": "<p>Wow great to see someone taking care of it ! <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Are you restarting from scratch or do you use the hedetniemi base ?</p>",
        "id": 201835546,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1592997393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> Right now, I'm looking deeper into the literature and trying to prove some basic theorems with a given formalism to evaluate the options, and the plan is to port over the hedetniemi branch as much as possible.  I'm happy to have some help, especially since you wanted to work on graphs, too -- I mostly just want to make sure whatever graph formalism mathlib has is general enough for the sorts of things I like to do with graphs.</p>\n<p><a href=\"https://link.springer.com/chapter/10.1007/3-540-58450-1_40\">This paper's</a> approach looks very promising.  It avoids the mess of dealing with quotient types (<code>sym2</code>), which has been OK but leaves something to be desired.  Here's the paper's definition in Lean (modified a bit to make use of some Lean features):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"c1\">-- A *link* represents an edge along with its endpoints in some given</span>\n<span class=\"c1\">-- order.</span>\n<span class=\"kn\">structure</span> <span class=\"n\">links</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">src</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">via</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dest</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">links</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">rev</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">dest</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">via</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">src</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- Since we are modeling undirected graphs, two links are essentially</span>\n<span class=\"c1\">-- the same if they correspond to the same edge.</span>\n<span class=\"n\">def</span> <span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">almost_equal</span> <span class=\"o\">:</span> <span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x₁</span> <span class=\"n\">x₂</span><span class=\"o\">,</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span> <span class=\"bp\">∨</span> <span class=\"n\">x₁</span> <span class=\"bp\">=</span> <span class=\"n\">x₂</span><span class=\"bp\">.</span><span class=\"n\">rev</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_equiv</span> <span class=\"o\">(</span><span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">almost_equal</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">links</span>\n\n<span class=\"c1\">-- Surjectivity of f restricted to s.</span>\n<span class=\"n\">def</span> <span class=\"n\">surjective_on</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- Injectivity of f on a given set s modulo a given relation R.</span>\n<span class=\"n\">def</span> <span class=\"n\">injective_mod_on</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span>\n\n<span class=\"c1\">-- A multigraph consists of a vertex set and an edge set along with</span>\n<span class=\"c1\">-- exactly two links per non-loop edge and one link per loop edge,</span>\n<span class=\"c1\">-- representing how the edge is glued to the vertices.</span>\n<span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">links</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">all_edges</span> <span class=\"o\">:</span> <span class=\"n\">surjective_on</span> <span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">via</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">all_links</span> <span class=\"o\">:</span> <span class=\"n\">surjective_on</span> <span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">rev</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adequate</span> <span class=\"o\">:</span> <span class=\"n\">injective_mod_on</span> <span class=\"o\">(</span><span class=\"bp\">≈</span><span class=\"o\">)</span> <span class=\"n\">links</span><span class=\"bp\">.</span><span class=\"n\">via</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This definition will support things like paths through a graph as a sequence of links with compatible <code>src</code> and <code>dest</code> fields.</p>\n<p>A \"dual\" version, like in hedetneimi, might be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">multigraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">all_edges</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">reversible</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">edges</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">edges</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adequate</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span><span class=\"o\">},</span> <span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">edges</span> <span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y&#39;</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x&#39;</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>This unbundles the hedetneimi graph definition even further, I think, since we don't need to think of edges as being equivalence classes under the <code>inv</code> operation: there is an actual type representing the edges.</p>\n<p>I need to think about <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>'s point about definitional equalities.  It seems to me that the first definition might indirectly address it: you ask for the set of <em>links</em> between vertices <code>a</code> and <code>b</code>, and these carry the corresponding edges.  The second definition gives you edge sets, and the <code>reversible</code> axiom identifies <code>edge a b</code> with <code>edge b a</code>.  I'd like having a total edge set, like in this definition, since you can do things like define a finite graph as one where both <code>V</code> and <code>g.E</code> are <code>fintype</code>s, so perhaps this is a nice variation on the hedetneimi branch's definition.</p>\n<p>I'm going to try rewriting everything I have using this second definition and see how it goes -- while many things were OK already, I think this one will go more smoothly.  (I would appreciate any thoughts about improving these definitions, including finding better names for the structure's fields, especially <code>adequate</code>.)</p>",
        "id": 201884493,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1593022870
    },
    {
        "content": "<p>This all looks very promising ! To be honest I'm not at all a specialist of graph theory, so I'm happy you're doing the hard part of choosing the best definition, I wouldn't have been self-confident enough to do it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> . But once you've made your choice I'll be glad to help you stating and proving as many useful lemmas as I can (I even do know some friends who might be interested too) !</p>",
        "id": 202000395,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1593106650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/202000395\">said</a>:</p>\n<blockquote>\n<p>But once you've made your choice I'll be glad to help you stating and proving as many useful lemmas as I can (I even do know some friends who might be interested too) !</p>\n</blockquote>\n<p>Great! My goal is to finish up this current design today or tomorrow, since a variation on <a href=\"https://link.springer.com/chapter/10.1007/3-540-58450-1_40\">Chou94</a>'s approach seems like it's working out well enough for what you'd want out of multigraphs and simple graphs.</p>\n<p>There are some surprising issues when it comes to some basic graph operations.  For example, none of the approaches seem to let you define a computable function that gives you the vertex opposite a given edge from a vertex.  The Chou approach sidesteps this by having you work with links instead, which already carry that opposite vertex (proving it was computable).  I'm wanting to avoid anything noncomputable as far as possible.</p>\n<p>The definition ends up being very similar to the one in <code>hedetneimi</code>.  There, you effectively have a function <code>edges : V → V → set E</code> that gives the edge set between two vertices along with an axiom <code>∀ v w, edges v w = edges w v</code>.  Here, it's instead essentially a function <code>links : set (V × E × V)</code> with an axiom that reversing a link is still a link.  While this is just an uncurried version of the <code>edges</code> function (recall, a set is a function to <code>Prop</code>), it's proven to be convenient working with elements of <code>V × E × V</code>.  (Don't worry, I'm just expanding definitions here for sake of explanation.  There is a structure definition for links.)</p>",
        "id": 202006605,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1593109669
    },
    {
        "content": "<p>Hmm, it's interesting that \"the other end\" should be noncomputable. Fwiw, I think the issue is with <code>Prop</code> -- it generally causes issues when you want things to be computable. Here I computably define \"the other element\" of an unordered pair, by defining membership using <code>trunc</code> instead of <code>Prop</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">trunc</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- the relation &quot;equal as unordered pairs&quot;</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">swap_rel</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">same</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">swap_rel</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">swap</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">swap_rel</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- the relation &quot;equal as unordered pairs&quot; is an equivalence</span>\n<span class=\"kn\">instance</span> <span class=\"n\">swap_setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine_struct</span> <span class=\"o\">{</span> <span class=\"n\">r</span><span class=\"o\">:=</span> <span class=\"n\">swap_rel</span> <span class=\"n\">α</span> <span class=\"o\">},</span> <span class=\"n\">tidy</span><span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases_matching</span><span class=\"bp\">*</span> <span class=\"n\">swap_rel</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_;</span>\n    <span class=\"n\">apply</span> <span class=\"n\">swap_rel</span><span class=\"bp\">.</span><span class=\"n\">same</span> <span class=\"bp\">&lt;|&gt;</span> <span class=\"n\">apply</span> <span class=\"n\">swap_rel</span><span class=\"bp\">.</span><span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- hence we can quotient by it</span>\n<span class=\"n\">def</span> <span class=\"n\">unordered_pair</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">swap_setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- swapping order really does give the same unordered pair</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">eq_swap</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">swap_rel</span><span class=\"bp\">.</span><span class=\"n\">swap</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- the &quot;other element&quot; of an unordered pair is unique</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">other_unique</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- `trunc_mem a p` is a constructive way of saying that `a` is an element of `p`.</span>\n<span class=\"c1\">-- Crucially, it is a subsingleton, but not a `Prop`.</span>\n<span class=\"n\">def</span> <span class=\"n\">trunc_mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">unordered_pair</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span> <span class=\"err\">$</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"bp\">//</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"err\">⟧</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- if `a` is an element of `p`, then we can computably extract &quot;the other element&quot; of `p`</span>\n<span class=\"n\">def</span> <span class=\"n\">other</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">unordered_pair</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">trunc_mem</span> <span class=\"n\">a</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">h</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">other_unique</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">cc</span><span class=\"o\">),</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- checking that `other` computes as expected</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"n\">other</span> <span class=\"n\">a</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"c1\">-- b</span>\n<span class=\"bp\">#</span><span class=\"n\">reduce</span> <span class=\"n\">other</span> <span class=\"n\">b</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"o\">(</span><span class=\"n\">trunc</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">eq_swap</span><span class=\"bp\">⟩</span><span class=\"o\">)</span> <span class=\"c1\">-- a</span>\n</code></pre></div>",
        "id": 202023925,
        "sender_full_name": "David Wärn",
        "timestamp": 1593118622
    },
    {
        "content": "<p>Thanks for showing me this use of <code>trunc</code>.  A few days ago I was trying to prove <code>other</code> for <code>unordered_pair</code>, but I ran into issues because I only had <code>a ∈ p</code> with a <code>has_mem</code> instance that checked if <code>a</code> equaled either component of the pair.</p>",
        "id": 202027529,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1593120547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span> and I are almost done with the Friendship Theorem, and have started breaking up non-graph-theoretic parts into PRs. <a href=\"https://github.com/jalex-stark/friendship-theorem\">https://github.com/jalex-stark/friendship-theorem</a></p>",
        "id": 204281837,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595043697
    },
    {
        "content": "<p>The definition of a graph is on <code>adjacency_matrix.lean</code>. Does anyone with experience on Hedetniemi want to discuss with me whether I should change that definition? Perhaps model theory has biased me, but I like thinking of simple graphs as basically just relations, which can be coerced to be two-sorted multigraphs when relevant.</p>",
        "id": 204281969,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595043860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"130377\">@David Wärn</span>  <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 204281995,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595043947
    },
    {
        "content": "<p>While some of this is just going in the Freek 100 archive, I want to be consistent with whatever else is going into mathlib.</p>",
        "id": 204282057,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595044072
    },
    {
        "content": "<p>This seems to be the correct definition for a simple graph.  In what I've been working on, I have the same <code>simple_graph</code> (though I decided to reserve <code>E</code> for <code>sym2.from_rel</code> of the relation) and a <code>multigraphs</code> typeclass for giving it the structure of a multigraph when needed.</p>",
        "id": 204284022,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595047494
    },
    {
        "content": "<p>Cool. It sounds like merging eventually will be easy, but link me to some code if you want me to adjust mine.</p>",
        "id": 204284493,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595048400
    },
    {
        "content": "<p>I've been mostly focusing on multigraphs, but here's what the simple graphs version might look like.  This seems like a good enough time to check the underlying idea with everyone.  One design goal is to be able to treat subgraphs of a given graph as graphs themselves.</p>\n<p>A conceptual problem with graphs is that the usual synecdoche of referring to a structure by its carrier type fails: a graph is both its vertex and edge sets simultaneously.  A way I found to get around this is to say a type <em>consists</em> of graphs.  Then, you can have the variables <code>{α : Type*} [simple_graphs α] (G : α) </code> to be able to refer to <code>G</code> as a graph, as you'd want.  We can also write <code>G' : subgraph G</code> to denote a subgraph, and there is an instance so that the graph interface applies to <code>G'</code>, too.</p>\n<p>I'd like to hear if there are any problems with this approach, or better ways of doing things.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">sym2</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A type consists of simple graphs if each term has a corresponding</span>\n<span class=\"cm\">vertex type and symmetric irreflexive adjacency relation on the</span>\n<span class=\"cm\">vertices.  See `simple_graph` for the primary implementation.</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">class</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graphs</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">The edge set of a simple graph consists of all the unordered pairs</span>\n<span class=\"cm\">that satisfy the adjacency relation.</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">E</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel</span> <span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">simple_graphs</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A simple graph on a vertex set `V` is an irreflexive symmetric</span>\n<span class=\"cm\">relation, representing which vertices are adjacent.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">sym</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Of course, the type of simple graphs on a vertex set consists of</span>\n<span class=\"cm\">simple graphs.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">sym</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">simple_graph</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"bp\">≠</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">simple_graphs</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A subgraph of a simple graph `G`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">subgraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_subset</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_ends</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"err\">∈</span> <span class=\"n\">E&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"err\">∈</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"err\">∈</span> <span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">E&#39;</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rwa</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">eq_swap</span> <span class=\"o\">},</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel_irreflexive</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">simple_graphs</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span><span class=\"bp\">.</span><span class=\"n\">edge_subset</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">is_diag_iff_proj_eq</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">The type of subgraphs on a given simple graph is a bounded lattice.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bounded_lattice</span> <span class=\"o\">(</span><span class=\"n\">subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A spanning subgraph consists of all of the vertices along with a</span>\n<span class=\"cm\">subset of the edges.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">spanning_subgraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">sym2</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">edge_subset</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graphs</span> <span class=\"o\">(</span><span class=\"n\">spanning_subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">)</span><span class=\"err\">⟧</span> <span class=\"err\">∈</span> <span class=\"n\">spanning_subgraph</span><span class=\"bp\">.</span><span class=\"n\">E&#39;</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">sym</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rwa</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">eq_swap</span> <span class=\"o\">},</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">G&#39;</span> <span class=\"n\">v</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">from_rel_irreflexive</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"o\">(</span><span class=\"n\">simple_graphs</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">spanning_subgraph</span><span class=\"bp\">.</span><span class=\"n\">edge_subset</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sym2</span><span class=\"bp\">.</span><span class=\"n\">is_diag_iff_proj_eq</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">simple_graphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bounded_lattice</span> <span class=\"o\">(</span><span class=\"n\">spanning_subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 204286472,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595052131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>, <span class=\"user-mention\" data-user-id=\"252300\">@Jalex Stark</span>  and I are about to PR a tiny bit of graph theory. We put your name on one of the files because I incorporated some of that text into it.</p>",
        "id": 204370338,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595191944
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3458\">#3458</a></p>",
        "id": 204370777,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1595192786
    },
    {
        "content": "<p>Maybe naive question, but is there a reason why not to use <code>has_hom</code> from the category theory library for directed multigraphs (or vice versa). They seem more or less the same thing to me (apart from the fact that one is a structure and the other is a class).</p>",
        "id": 204538485,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1595332693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> A reason I can think of is that a given vertex set might have multiple possible edge sets associated to it.  In category theory, we assume that the object type determines a natural collection of morphisms.  This assumption breaks down for graphs.</p>\n<p>This, perhaps, is a way to make it work:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edges</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This says that each term <code>G : α</code> has an associated vertex type and <code>has_hom</code> structure on it.</p>\n<p>There's also a dual version of this.  Something like it is used in a paper about labeled multigraphs:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>A benefit is that there is a concrete edge set.  This is useful, for example, in defining what a finite graph is.</p>\n<p>Yet another possible definition, which is one step away from undirected multigraphs (which is what I was working on) is</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">link</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">links</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">link</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">all_edges</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">links</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">link</span><span class=\"bp\">.</span><span class=\"n\">e</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edge_inj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inj_on</span> <span class=\"n\">link</span><span class=\"bp\">.</span><span class=\"n\">e</span> <span class=\"o\">(</span><span class=\"n\">links</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>This is surprisingly nice to work with.  The <code>links</code> field is essentially a function <code>V G → V G → E G → Prop</code> (which is equivalent to <code>V G → V G → set (E G)</code>), but having it as a tuple seems to let you rewrite fewer things in proofs.</p>\n<p>It's not too hard to define functions that go between each of these representations.</p>",
        "id": 204606085,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595367705
    },
    {
        "content": "<p>@Kyle Miller There are many examples in category theory where you have the same vertex \"set\" but different kinds of morphisms between them. One very common example of this is the category of complexes, its homotopy category, or its derived category. Another example is that of the Kleisli category of a monad. </p>\n<p>Thanks a lot for your different possible implementations of multigraphs. What you call the \"dual version\" is definitely the most common representation in the area of mathematics I am working in (representation theory of finite dimensional algebras), where such a thing is called a quiver. </p>\n<p>I also saw a comment by <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> in <a href=\"https://github.com/leanprover-community/mathlib/pull/613\">https://github.com/leanprover-community/mathlib/pull/613</a> describing that has_hom was introduced to talk more easily about the free category on a graph, so I was wondering whether the two notions should be connected (or one removed and pointing to the other). I don't know enough about lean yet to answer this question, so I thought I ask here.</p>",
        "id": 204636613,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1595402326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> A common trick that we use when we have the same \"underlying set\" is a so-called type wrapper (which is just the identity function).</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">derived_category</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">C</span>\n</code></pre></div>\n\n\n<p>And then you can have different typeclasses on <code>C</code> and on <code>derived_category C</code>. In particular, their morphisms can be different.</p>",
        "id": 204637873,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595403717
    },
    {
        "content": "<p>Just to be clear: here I'm already thinking of <code>C</code> as the category of chain complexes. Not some sort of abelian category. So maybe I shouldn't have called it <code>derived_category</code>, but more something like <code>localisation_category</code>, or something like that.</p>",
        "id": 204640672,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595406263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> Yeah, I sort of had path algebras in the back of my mind when I was writing the second (and third) definitions.</p>\n<p>Since you asked, here's how you might connect the second definition to <code>has_hom</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Give the terms of a type the structure of a directed graph.</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">class</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">digraphs</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">Associate a `has_hom` structure to the digraph&#39;s vertex type.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">digraphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">has_hom</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">G</span> <span class=\"bp\">//</span> <span class=\"n\">source</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">target</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">-</span>\n<span class=\"cm\">A concrete directed graph on a given vertex and edge set.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">digraph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">):=</span>\n<span class=\"o\">(</span><span class=\"n\">source</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">digraph</span> <span class=\"n\">V</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n  <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"n\">digraph</span><span class=\"bp\">.</span><span class=\"n\">source</span><span class=\"o\">,</span>\n  <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"n\">digraph</span><span class=\"bp\">.</span><span class=\"n\">target</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">subdigraph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">digraphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">has_sources</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">source</span> <span class=\"err\">⊆</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">has_targets</span> <span class=\"o\">:</span> <span class=\"n\">E&#39;</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">target</span> <span class=\"err\">⊆</span> <span class=\"n\">V&#39;</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">digraphs</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">digraphs</span> <span class=\"o\">(</span><span class=\"n\">subdigraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">V&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">E&#39;</span><span class=\"o\">,</span>\n  <span class=\"n\">source</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">source</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">has_sources</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">target</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">target</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">has_targets</span> <span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>I also give a concrete definition of a <code>digraph</code> and sub-digraphs for illustration of the possible interface.</p>\n<p>What I was talking about earlier is that in Lean, many algebraic and categorical objects are referred to by some sort of carrier type.  Then, class resolution is able to give you the tacit structure.  As you note, there are many categories that are defined on the same object set, but, as Johan explains, Lean's class resolution gives you a trick to have it give different tacit structures.</p>\n<p>With the above <code>has_hom</code> instance, even though different digraphs might have the same underlying vertex types, because they are referred to <code>V G</code> for a specific <code>G</code>, the class resolution will find the correct <code>has_hom</code> instance for that graph.  At least, that's my understanding -- I don't have much practical experience here.</p>",
        "id": 204640748,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595406323
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Oh sorry I misunderstood! But how about </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">derived_category</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">chain_complex</span> <span class=\"n\">C</span>\n</code></pre></div>\n\n\n<p>? One could imagine this line of code actually being written, right? <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> have I understood this correctly? It just looks like a cool definition.</p>",
        "id": 204641551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595406937
    },
    {
        "content": "<p>Of course derived categories will actually be a major pain when you try to formalise them.</p>",
        "id": 204641662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407008
    },
    {
        "content": "<p>Maybe that's the point where we should go infty-cats</p>",
        "id": 204641679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407020
    },
    {
        "content": "<p>Do we know this?</p>",
        "id": 204641708,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407041
    },
    {
        "content": "<p>Do we know what?</p>",
        "id": 204641721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407059
    },
    {
        "content": "<p>I spent a long time poo-pooing the category theory library, inspired by Mario, but it's just getting better and better. The universe issues have been solved, the notation is slowly sinking in, and the fact that mathematicians like <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> just seem to have learnt Scott's current API effortlessly makes me wonder how far Lean 3 can go.</p>",
        "id": 204641879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407171
    },
    {
        "content": "<p>The more we push Lean 3 in ways like this, the more we learn about what we want from Lean 4</p>",
        "id": 204641899,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407189
    },
    {
        "content": "<p>Sure... but derived categories are different right?</p>",
        "id": 204641990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407247
    },
    {
        "content": "<p>I don't understand why</p>",
        "id": 204642006,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407267
    },
    {
        "content": "<p>Well, maybe not the derived categories per se, but taking derived functors...</p>",
        "id": 204642021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407277
    },
    {
        "content": "<p>you need to make awful choices... and lots of stuff gets swept under the rug in informal math.</p>",
        "id": 204642035,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407299
    },
    {
        "content": "<p>Are you saying that at least one of derived categories and derived functors will be impossible in Lean 3?</p>",
        "id": 204642044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407307
    },
    {
        "content": "<p>Or just that they will be very difficult?</p>",
        "id": 204642058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407317
    },
    {
        "content": "<p>I fear that even though possible, getting a useful API will be really tricky.</p>",
        "id": 204642122,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407351
    },
    {
        "content": "<p>We've seen how tricky sheaves are.</p>",
        "id": 204642131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407360
    },
    {
        "content": "<p>Defining a sheaf is easy peasy lemon squeezy</p>",
        "id": 204642142,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407374
    },
    {
        "content": "<p>But making them usable...</p>",
        "id": 204642144,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407380
    },
    {
        "content": "<p>Kenny got good at them!</p>",
        "id": 204642145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407381
    },
    {
        "content": "<p>I guess \"an expert managed to do it\" is not a great response here</p>",
        "id": 204642165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407401
    },
    {
        "content": "<p>(Don't mind me as you're discussing formalizing derived categories <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span>)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"317890\">Julian Külshammer</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Graph.20Theory/near/204636613\">said</a>:</p>\n<blockquote>\n<p>There are many examples in category theory where you have the same vertex \"set\" but different kinds of morphisms between them.</p>\n</blockquote>\n<p>One more thought about this: For categories, there are a handful of different possibilities in use.  But for graphs, sort of the whole point is varying the edge sets.  This suggests, at least to me, that directed graphs need to be handled somewhat differently from the way categories are handled in Lean.  This informed, to some degree, the above proposed design of digraphs.</p>",
        "id": 204642272,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595407476
    },
    {
        "content": "<p>Ooh, sorry. We should move to another thread.</p>",
        "id": 204642367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595407549
    },
    {
        "content": "<p>Oh I'm sorry <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> :-) I'll move to another thread.</p>",
        "id": 204642505,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595407635
    },
    {
        "content": "<p>No problem! It's sort of related, and I didn't mean to interrupt you.</p>",
        "id": 204642868,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1595407824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for all the interesting comments. It seems there is much to learn and explore in that direction.</p>",
        "id": 204648130,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1595412015
    },
    {
        "content": "<p>So I'm a bit late to the party here, but I was wondering if I could join in on the graph theory project? I've been trying to do small projects here and there to learn Lean but graph theory is what I ultimately wanted to do</p>",
        "id": 205978199,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596588825
    },
    {
        "content": "<p>hmm are you asking a question like \"if I want to contribute to the development of graph theory in mathlib, where should I start\"?</p>",
        "id": 205978452,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589098
    },
    {
        "content": "<p>yes! thank you that's a better way of putting it haha</p>",
        "id": 205978463,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589125
    },
    {
        "content": "<p>we need more API</p>",
        "id": 205978478,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589146
    },
    {
        "content": "<p>I don't know how to prove anything about the cardinality of the edge set of a graph</p>",
        "id": 205978485,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589160
    },
    {
        "content": "<p>i was looking at stuff like subgraphs and connectivity - i didn't see it in the PR, are you guys working on that?</p>",
        "id": 205978501,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589186
    },
    {
        "content": "<p>noted!</p>",
        "id": 205978558,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"322118\">@Michael Hahn</span> and I are working with eulerian circuits in a separate repo</p>",
        "id": 205978569,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589246
    },
    {
        "content": "<p>i think at least our induction principle for graphs is ready to be PRed</p>",
        "id": 205978582,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589261
    },
    {
        "content": "<p><a href=\"https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael\">https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael</a></p>",
        "id": 205978660,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589357
    },
    {
        "content": "<p>gotcha. i wanted to try to define some basic stuff for trees, would you be able to link the repo?</p>",
        "id": 205978661,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589357
    },
    {
        "content": "<p>too fast. thanks!</p>",
        "id": 205978687,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589401
    },
    {
        "content": "<p>should i just fork it or something?</p>",
        "id": 205978746,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589478
    },
    {
        "content": "<p>hmm</p>",
        "id": 205978764,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589508
    },
    {
        "content": "<p>What I would do is work in a branch of mathlib, and if there are things from that project I wanted, I would copy-paste them</p>",
        "id": 205978776,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589539
    },
    {
        "content": "<p>okay cool, thank you!</p>",
        "id": 205978803,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589562
    },
    {
        "content": "<p>working in a branch of mathlib will make it easier to collaborate with people here, and also easier to spin off parts of your branch into a PR</p>",
        "id": 205978858,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589632
    },
    {
        "content": "<p>michael and I are working in a separate repo because this is a summer project for him and we want there to be a place where it lives when it's done, even if it doesn't make it to mathlib</p>",
        "id": 205978877,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596589681
    },
    {
        "content": "<p>makes sense</p>",
        "id": 205978988,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589808
    },
    {
        "content": "<p>speaking of summer projects, i did originally intend to do graph theory for that, i just initially didn't see much stuff done and felt intimidated, and then i didn't keep up with stuff here. ya live and you learn ig lol</p>",
        "id": 205978993,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596589828
    },
    {
        "content": "<p>it's still summer, I think</p>",
        "id": 205979100,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596590041
    },
    {
        "content": "<p>i mean yeah fair</p>",
        "id": 205979145,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596590061
    },
    {
        "content": "<p>wanna do a project with me lol</p>",
        "id": 205979148,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596590069
    },
    {
        "content": "<p>speedrun <span aria-label=\"racecar\" class=\"emoji emoji-1f3ce\" role=\"img\" title=\"racecar\">:racecar:</span></p>",
        "id": 205979153,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596590078
    },
    {
        "content": "<p>i stepped away at an inopportune time, sorry. I'm happy to follow / code review your graph work if it happens in either a mathlib branch or a repo that you tell me about.</p>",
        "id": 205979976,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596591525
    },
    {
        "content": "<p>you're fine! <a href=\"https://github.com/agusakov/graph_theory_2020\">https://github.com/agusakov/graph_theory_2020</a><br>\nit doesn't have anything yet, still gotta make my first commits</p>",
        "id": 205981970,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596594178
    },
    {
        "content": "<p>appreciate it!</p>",
        "id": 205981975,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596594183
    },
    {
        "content": "<p>do you know which commands to type to start up the repo with a lean project? (now i see some of your other GitHub projects; i'm guessing the answer is yes)</p>",
        "id": 205982886,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596595525
    },
    {
        "content": "<p>yep!</p>",
        "id": 205983633,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596596411
    },
    {
        "content": "<p>made my first commit, i only have some tiny definitions so far</p>",
        "id": 205984106,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596596956
    },
    {
        "content": "<p>paths can have repeated edges</p>",
        "id": 205984264,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596597165
    },
    {
        "content": "<p><code>p.is_tour</code> says that there are no repeated edges</p>",
        "id": 205984269,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596597176
    },
    {
        "content": "<p>oh gosh thanks haha</p>",
        "id": 205984596,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596597451
    },
    {
        "content": "<p>i'm having trouble figuring out how to use it - i keep getting errors and i can't really find it anywhere in the files</p>",
        "id": 205985071,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596598017
    },
    {
        "content": "<p>sorry, it's actually called <code>p.is_trail</code>, defined at the end of this file<br>\n<a href=\"https://github.com/apurvnakade/mc2020-projects/blob/mathlib_simple_graph/src/michael/path.lean\">https://github.com/apurvnakade/mc2020-projects/blob/mathlib_simple_graph/src/michael/path.lean</a></p>",
        "id": 205986470,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596600086
    },
    {
        "content": "<p>gotcha! i actually went ahead and defined an <code>is_tour</code> cause i saw that <code>is_trail</code> allows for repeated vertices, just not repeated edges so it all worked out lol</p>",
        "id": 205986559,
        "sender_full_name": "Alena Gusakov",
        "timestamp": 1596600202
    },
    {
        "content": "<p>some (most?) of our definitions are adapted from the <code>mathlib:hedetniemi</code> branch</p>",
        "id": 205987562,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596601906
    },
    {
        "content": "<p>Taking a look at this since I did some graph theory in lean a while back - are you working on the mathlib_simple_graph branch or master?</p>",
        "id": 206098823,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596680714
    },
    {
        "content": "<p>mathlib_simple_graph</p>",
        "id": 206102197,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596685807
    },
    {
        "content": "<p>alright, are you accepting PRs?</p>",
        "id": 206102206,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596685847
    },
    {
        "content": "<p>yes</p>",
        "id": 206102219,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596685915
    },
    {
        "content": "<p>and finally, what's the progress on the things listed here: <a href=\"https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael\">https://github.com/apurvnakade/mc2020-projects/tree/mathlib_simple_graph/src/michael</a>? I've done the fourth a while ago</p>",
        "id": 206102327,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596686059
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"322118\">@Michael Hahn</span> wrote that list. I guess we currently don't have a definition of the konigsberg graph, because we haven't yet allowed multiple edges</p>",
        "id": 206102509,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596686366
    },
    {
        "content": "<p>i find the current type of edges pretty awkward to work with</p>",
        "id": 206102694,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596686607
    },
    {
        "content": "<p>we need at least a coercion <code>H.E \\to G.E</code> when <code>H.is_subgraph G</code> before we can make a serious application of subgraph induction.</p>",
        "id": 206102861,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596686881
    },
    {
        "content": "<p>Is there a code for embedded graphs in the sphere in homotopy type theory in Lean4?</p>",
        "id": 287375487,
        "sender_full_name": "Mahdi Khaleghi",
        "timestamp": 1656099426
    },
    {
        "content": "<p>Just to be clear -- Lean 4 is not a homotopy type theory prover, its axioms are incompatible with the univalence axiom. So there's no anything in homotopy type theory in Lean 4.</p>",
        "id": 287375830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656099626
    },
    {
        "content": "<p>thanks. are there open topics related to combinatorial graph theory that we can participate to implement?</p>",
        "id": 287376329,
        "sender_full_name": "Mahdi Khaleghi",
        "timestamp": 1656099889
    },
    {
        "content": "<p>We have a <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> stream where you might want to ask</p>",
        "id": 287376743,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1656100116
    },
    {
        "content": "<p>I'll check them out. Thanks.</p>",
        "id": 287625661,
        "sender_full_name": "Mahdi Khaleghi",
        "timestamp": 1656357906
    }
]
[
    {
        "content": "<p>Metric space in Lean takes a single type as argument, for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.metric_space.basic</span>\n<span class=\"kd\">variable</span> <span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">metric_space</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>It tells me this:  \"Each metric space induces a canonical uniform_space and hence a canonical topological_space. This is enforced in the type class definition, by extending the uniform_space structure. When instantiating a metric_space structure, the uniformity fields are not necessary, they will be filled in by default. In the same way, each metric space induces an emetric space structure. It is included in the structure, but filled in by default.\"</p>\n<p>I would like to come at this from a different direction.  I want to supply <code>M</code> with a metric <code>d</code>, following the <a href=\"https://en.wikipedia.org/wiki/Metric_space#Definition\">Wikipedia</a> definition in which <code>M</code> is any set (or just <code>Type</code>), and <code>d:MxM→ ℝ</code> has 3 properties:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.metric_space.basic</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kd\">variable</span> <span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variable</span> <span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">metric_space</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"kd\">variable</span> <span class=\"n\">d</span><span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">identity_of_indiscernibles</span> <span class=\"o\">:=</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n<span class=\"kd\">def</span> <span class=\"n\">symmetry</span> <span class=\"o\">:=</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"n\">x</span>\n<span class=\"kd\">def</span> <span class=\"n\">subadditivity</span> <span class=\"o\">:=</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">d</span> <span class=\"n\">y</span> <span class=\"n\">z</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric</span> <span class=\"o\">:=</span>\n        <span class=\"n\">identity_of_indiscernibles</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">symmetry</span> <span class=\"bp\">∧</span>\n        <span class=\"n\">subadditivity</span>\n</code></pre></div>\n<p>So a couple of hopefully very basic questions:</p>\n<p>Q1.  Where is <code>metric</code> in <code>mathlib</code>?  <br>\nQ2. Suppose multiple distinct choices <code>d</code> of metric  are suitable for a given set <code>M</code>.  So in this case it is not sufficient to say </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">S</span><span class=\"o\">:</span> <span class=\"n\">metric_space</span><span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I need to be able to differentiate </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variable</span> <span class=\"n\">d1</span><span class=\"o\">:</span> <span class=\"n\">metric</span>\n<span class=\"kd\">variable</span> <span class=\"n\">d2</span><span class=\"o\">:</span> <span class=\"n\">metric</span>\n<span class=\"kd\">variable</span> <span class=\"n\">S1</span><span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">M</span> <span class=\"n\">d1</span>\n<span class=\"kd\">variable</span> <span class=\"n\">S2</span><span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">M</span> <span class=\"n\">d2</span>\n</code></pre></div>\n<p>Is there \"this kind\" of metric space in <code>mathlib</code>, or do I have to start from scratch or from some other direction?</p>",
        "id": 218515478,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606885078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> (Re Q1: I don't think we have that exact concept.) What do you mean with \"multiple distinct choices of <code>d</code>\"?<br>\nShould they induce the same topology? If not, you can write <code>S1 : metric_space M</code> and <code>S2 : metric_space M</code>, but using those will be annoying.<br>\nWhat people typically do, is introduce a so-called \"type synonym\". For example, if <code>X : Type</code> and <code>linear_order X</code>, then <code>order_dual X</code> is a type with the opposite order. By definition <code>order_dual X := X</code>, but because they are not syntactically equal, the can carry different instances of the same type class.</p>",
        "id": 218518045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606888378
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I mean in the practical sense that I could have <code>d1(x,y) = abs(x-y)</code>or <code>d2(x,y)=\\sqrt((x-y)^2)</code> and they are not quite the same.  <br>\n These are my multiple distinct choices.  You could call them L1 norm, L2 norm and so on.  So I want to distinguish two metric spaces, <code>S1=(d1,R)</code> and <code>S2=(d2,R)</code> and reason about them separately, but have both rely on the concept that a metric space is a set with a metric.  I am coming at this from a very basic perspective.  So for example my proof that d1 is a metric might differ slightly from my proof that d2 is a metric.</p>",
        "id": 218518210,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606888680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"364351\">@Lars Ericson</span> The short answer is that with the current setup in mathlib, you can use <code>metric_space</code> for what you want, but it might become painful. One option to alleviate the pain is to use type synonyms.</p>",
        "id": 218520498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606891692
    },
    {
        "content": "<p>People have been working on lp spaces recently, if I'm not mistaken.</p>",
        "id": 218520502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606891709
    },
    {
        "content": "<p>Lars, handling iterated conjunctions turns out to be painful. Having a structure with three fields is much more convenient than a definition like your <code>metric</code>. With your definition of metric, if you have <code>P : metric M d x y z</code>, you access symmetry as <code>P.2.1</code> (or <code>P.right.left</code>). With a structure having a second field names <code>symm</code> you could have <code>P.symm</code> for instance.</p>",
        "id": 218523939,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606895851
    },
    {
        "content": "<p>Did you watch all LFTCM2020 videos? One of them is about redoing metric spaces from scratch.</p>",
        "id": 218523953,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606895881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218518210\">said</a>:</p>\n<blockquote>\n<p>I mean in the practical sense that I could have <code>d1(x,y) = abs(x-y)</code>or <code>d2(x,y)=\\sqrt((x-y)^2)</code> and they are not quite the same.  </p>\n</blockquote>\n<p>What is the type of <code>x</code> and <code>y</code> in the above sentence? I have a hard time guessing an answer that would make <code>d1</code> and <code>d2</code> \"not quite the same\", unless you mean not defeq.</p>",
        "id": 218524290,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606896128
    },
    {
        "content": "<p>Note that if you don't like type aliases (which can be pretty tricky for the elaborator, hence for the user) then you always have the possibility to completely bypass type class resolution. For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">m1</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">)),</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">m2</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">real.sqrt</span> <span class=\"o\">((</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t1</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">m1.to_uniform_space.to_topological_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">m2.to_uniform_space.to_topological_space</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">cont</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">continuous</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">cont</span> <span class=\"n\">t1</span> <span class=\"n\">t2</span> <span class=\"n\">f</span>\n</code></pre></div>",
        "id": 218525720,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606897292
    },
    {
        "content": "<p>In the last line <code>cont t1 t2 f</code> means <code>f</code> is continuous from topology <code>t1</code> (induced by metric structure <code>m1</code>) to topology <code>t2</code> (induced by metric structure <code>m2</code>). Is this what you wanted (I still don't understand what you call \"having a Wikipedia-style metric space\" which wouldn't be covered by what you pointed out in mathlib).</p>",
        "id": 218525895,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606897416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, by \"Wikipedia style\", I mean the <a href=\"https://en.wikipedia.org/wiki/Metric_space#Definition\">definition</a> which is  \"A metric space is an ordered pair <code>(M,d)</code> where <code>M</code> is a set and <code>d</code> is a metric on <code>M</code>\".  The Wikipedia definition focuses on d and describes the properties that <code>d</code> must have, when supplied with <code>M</code>, so that the pair <code>(M,d)</code> -- two elements together, separate and distinct -- comprises a metric space.  </p>\n<p>When I first looked at <a href=\"https://leanprover-community.github.io/mathlib_docs/topology/metric_space/basic.html#metric_space\">topology.metric_space.basic</a>, the first line <code>structure metric_space (α : Type u) </code> confused me, as a beginner, because it looked like <code>M</code>, as <code>α</code>, was the only thing being described, and that <code>d</code> was implied from <code>M</code>.  So that would only give me one  <code>d</code>, the implied one.</p>\n<p>Looking at it again, I see that <code>α</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/topology/metric_space/basic.html#has_dist\">constrained to have a distance function</a>.  However, as a beginner, I don't see the mechanics of how I supply distinct <code>d</code> for a given <code>M</code> so I can build different metric spaces on the same <code>M</code>.  For example, suppose <code>M=ℝ × ℝ</code>, the real plane.  Now suppose I have three <a href=\"https://en.wikipedia.org/wiki/Norm_(mathematics)\">norms</a>, <code>AbsNorm(m)</code>, <code>EuclidNorm(m)</code> and <code>TaxiCabNorm(m)</code>, and I define <code>d1(x,y)=AbsNorm(x-y)</code>, <code>d2(x,y)=EuclidNorm(x-y)</code> and <code>d3(x,y)=TaxiCabNorm(x-y)</code>.  There are <code>x,y</code> such that <code>d1</code>, <code>d2</code> and <code>d3</code> take on different values, so that sense <code>S1=(M,d1)</code> and <code>S2=(M,d2)</code> will be different metric spaces.</p>\n<p>So in summary my happy place for this task is where I can state <code>M</code> and <code>d</code> separately and mechanically prove that <code>(M,d)</code> taken together comprise a metric space.</p>\n<p>Thank you for the reference to the <a href=\"https://youtu.be/8mVOIGW5US4\">LFTCM2020 videos</a>.  I will watch them and then come back to the chat afterwards if I am still confused.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8mVOIGW5US4\" href=\"https://youtu.be/8mVOIGW5US4\"><img src=\"https://i.ytimg.com/vi/8mVOIGW5US4/default.jpg\"></a></div>",
        "id": 218555015,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606915631
    },
    {
        "content": "<p>Lean (and math) is happiest with one instance per type, but you can write something like <code>def euclid_norm_metric_space : metric_space M := [...]</code>.</p>",
        "id": 218555917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606916053
    },
    {
        "content": "<p>In this setting it would be better to read <code>metric_space</code> as \"metric\".</p>",
        "id": 218555941,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606916071
    },
    {
        "content": "<p>When we write <code>variables {M : Type} [metric_space M]</code>, we read it as \"Let M be a metric space\", but the actual values of the type <code>metric_space M</code> are metrics on M (or \"metric space structures on M\").</p>",
        "id": 218556156,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606916166
    },
    {
        "content": "<p>Lars, when you write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(M, d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span> on paper, you are hiding the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> has to satisfy a bunch of conditions that appear nowhere in this notation. In mathlib we chose to package together <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">d</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span></span></span></span> and <em>proofs</em> of these condition in a term whose type is called <code>metric_space M</code>.</p>",
        "id": 218567003,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606920842
    },
    {
        "content": "<p>If you want to package things even more and get a type whose terms will look like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo separator=\"true\">,</mo><mi>d</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(M, d)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span></span></span></span> then you can write</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">MetricSpace</span> <span class=\"o\">:=</span> <span class=\"bp\">Σ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">metric_space</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">MetricSpace</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 218567173,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606920902
    },
    {
        "content": "<p>Here a term with type <code>MetricSpace</code> will be a (dependent) pair where the first component is a type and the second one is a metric structure (distance + conditions) on it.</p>",
        "id": 218567317,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606920956
    },
    {
        "content": "<p>Reid, we shouldn't hide the fact that those type aliases tend to very easily confuse the Lean 3 elaborator. Anyway, we don't have enough information about what Lars actually wants to do to provide good advice.</p>",
        "id": 218567503,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606921036
    },
    {
        "content": "<p>That's why I didn't suggest writing <code>instance</code>s but <code>def</code>s (although I guess it wasn't very clear because I assumed Lars already has a type <code>M</code> on which to define these metrics).</p>",
        "id": 218570658,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606922296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> , in the Wikipedia style definition, the focus is on <code>d</code>, and any type <code>M</code> for which <code>d: M × M→ ℝ</code> is defined and has the 3 desired properties will do.  So I don't need to define a particular <code>M</code>, I need to define the expectations of <code>d</code>, which I did above.  I may supply <code>ℝ × ℝ</code> as an <code>M</code> for a suitable metric <code>d</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> what I want to do in this case is what I said: Make two instances of metric space, one for Euclidean distance and one for Taxicab distance.  Just that.  It's the same as if I wanted to reason about 3+2 or 1+9, it's two separate things and I want to explore each one separately.</p>\n<p>My longer term goal is to fill out my \"Straw Man Answer\" to this StackExchange question: <a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009\">https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009</a></p>",
        "id": 218578142,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606925255
    },
    {
        "content": "<p>So in general if I have Normal distribution and Poisson distribution or Norm(1,3) or Norm(0,1), I want to be able to declare and reason about these distinct objects separately in a well-founded way.</p>",
        "id": 218578315,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606925318
    },
    {
        "content": "<p>The possibility that my goal may not fit with the design of <code>mathlib</code> is maybe hinted at in <a href=\"https://leanprover-community.github.io/theories/topology.html\">this comment</a>:  \"Note that there are two ways of formalising the axiom that an arbitrary union of open sets is open: one could either ask that given a set of open sets, their union is open, or one could ask that given a function from some index set I to the set of open sets, the union of the values of the function is open. Mathlib goes for the first one.\"</p>",
        "id": 218578716,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606925480
    },
    {
        "content": "<p>Just don't use the word <code>instance</code>, and instead write <code>def foo : metric_space (ℝ × ℝ) := ...</code>, <code>def bar : metric_space (ℝ × ℝ) := ...</code>, etc</p>",
        "id": 218578742,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606925496
    },
    {
        "content": "<p>In this case, \"make two instances of metric space\" means make the two separate <code>def</code>, and in later proofs, instead of saying</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">something_about_my_metric</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>you say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">something_about_my_metric</span> <span class=\"o\">(</span><span class=\"n\">my_metric</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and you provide explicitly one of your <code>def</code>s</p>",
        "id": 218578930,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606925562
    },
    {
        "content": "<p>Oh Reid said the same thing</p>",
        "id": 218578970,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606925571
    },
    {
        "content": "<p>And I already said it this morning, I even posted the corresponding code with only Prop sorries.</p>",
        "id": 218584376,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1606927635
    },
    {
        "content": "<p>And Patrick, your sigma type example is precisely what the \"any type <code>M</code>\" desiratum Lars is about. Thanks for sharing it -- it's helped me understand better how sigma types are useful and where they're appropriate.</p>",
        "id": 218585170,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606927941
    },
    {
        "content": "<p>Is there a category of metric spaces?</p>",
        "id": 218585967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606928286
    },
    {
        "content": "<p>Not in Lean as far as I know</p>",
        "id": 218586123,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1606928358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> thank you for the <code>def m1</code> and <code>m2</code> example.  I am trying it out:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">m1</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">)),</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span>            <span class=\"c1\">-- a : ℝ × ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">b</span>            <span class=\"c1\">-- b : ℝ × ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">m1.dist</span>      <span class=\"c1\">-- dist : ℝ × ℝ → ℝ × ℝ → ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">m1.dist</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n</code></pre></div>\n<p>At the bottom the first 3 <code>#check</code>s give me expected results.  The 3rd <code>#check</code>, to access and apply the metric, gives me the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">function</span> <span class=\"bp\">'</span><span class=\"n\">has_dist.dist'</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">explicit</span> <span class=\"n\">argument</span> <span class=\"k\">with</span> <span class=\"n\">type</span> <span class=\"o\">(</span><span class=\"n\">has_dist</span> <span class=\"bp\">...</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What do I need to fix to apply the function?</p>",
        "id": 218599575,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606933971
    },
    {
        "content": "<p>Actually it looks like I can fix this by defining <code>m1.dist</code> external to <code>m1</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">m1</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d1</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">a</span>            <span class=\"c1\">-- a : ℝ × ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">b</span>            <span class=\"c1\">-- b : ℝ × ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">m1.dist</span>      <span class=\"c1\">-- dist : ℝ × ℝ → ℝ × ℝ → ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">m1.dist</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"c1\">-- ERROR</span>\n<span class=\"k\">#check</span> <span class=\"n\">d1</span>          <span class=\"c1\">-- d1 : ℝ × ℝ → ℝ × ℝ → ℝ</span>\n<span class=\"k\">#check</span> <span class=\"n\">d1</span> <span class=\"n\">a</span> <span class=\"n\">b</span>   <span class=\"c1\">-- d1 a b : ℝ</span>\n</code></pre></div>",
        "id": 218605149,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606936561
    },
    {
        "content": "<p>You can write <code>@metric_space.dist</code>, some number of underscores, then <code>m1</code></p>",
        "id": 218605304,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606936629
    },
    {
        "content": "<p>I was going to say that, but <code>unknown identifier 'metric_space.dist'</code>.</p>",
        "id": 218605577,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606936783
    },
    {
        "content": "<p>oh rip</p>",
        "id": 218605681,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606936815
    },
    {
        "content": "<p>it's in a superclass, that makes it quite awkward</p>",
        "id": 218605704,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606936825
    },
    {
        "content": "<p>wait <del>no</del> yes</p>",
        "id": 218605728,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606936839
    },
    {
        "content": "<p>To make matters worse, there's an instance of <code>has_dist (ℝ × ℝ)</code> ;-)</p>",
        "id": 218605938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606936938
    },
    {
        "content": "<p>Anyways, I guess you already know that points in a metric space have a distance--so I'm not sure what you hope to gain from these <code>#check</code>s</p>",
        "id": 218606081,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606937010
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I would rewrite the above example as follows, but it's full of errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_signature</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span> <span class=\"c1\">-- ERROR</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">metric_signature</span> <span class=\"c1\">-- ERROR</span>\n\n<span class=\"kd\">constant</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"c1\">-- ERROR</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_space_instance</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>  <span class=\"c1\">-- just wrong starting with : metric_space(M)</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>In other words I want to make a version of <code>metric_space(M)</code> called <code>metric_space_instance M d</code>.  Is this possible?</p>",
        "id": 218611086,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606939361
    },
    {
        "content": "<p>I agree that it is full of errors</p>",
        "id": 218611165,
        "sender_full_name": "Reid Barton",
        "timestamp": 1606939402
    },
    {
        "content": "<p>Fixed.  This gives me the sense of the Wiki definition which is <code>(M,d)</code>.  I understand it's not <code>mathlib</code>-onic but at least it typechecks.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_signature</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_space_instance</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d_taxicab</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">abs</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d_euclid</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">real.sqrt</span> <span class=\"o\">((</span><span class=\"n\">x.1</span> <span class=\"bp\">-</span> <span class=\"n\">y.1</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">x.2</span> <span class=\"bp\">-</span> <span class=\"n\">y.2</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S_taxicab</span> <span class=\"o\">:=</span> <span class=\"n\">metric_space_instance</span> <span class=\"n\">M</span> <span class=\"n\">d_taxicab</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S_euclid</span><span class=\"o\">:=</span> <span class=\"n\">metric_space_instance</span> <span class=\"n\">M</span> <span class=\"n\">d_euclid</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S_taxicab</span> <span class=\"c1\">-- S_taxicab : metric_space M</span>\n<span class=\"k\">#check</span> <span class=\"n\">S_euclid</span>  <span class=\"c1\">-- S_euclid : metric_space M</span>\n</code></pre></div>",
        "id": 218636249,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606952524
    },
    {
        "content": "<p>How do you plan to use these? How do you know that they're valid? Because this also typechecks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span> <span class=\"n\">topology.metric_space.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_signature</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">metric_space_instance</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">dist</span> <span class=\"o\">:=</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_self</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_comm</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">dist_triangle</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">notation</span> <span class=\"bp\">`</span><span class=\"n\">M</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span> <span class=\"bp\">×</span> <span class=\"n\">ℝ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">d_nonsensical</span> <span class=\"o\">:</span> <span class=\"n\">metric_signature</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S_nonsensical</span> <span class=\"o\">:</span> <span class=\"n\">metric_space</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">metric_space_instance</span> <span class=\"n\">M</span> <span class=\"n\">d_nonsensical</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S_nonsensical</span>  <span class=\"c1\">-- S_nonsensical : metric_space M</span>\n\n<span class=\"k\">#exit</span>\n</code></pre></div>",
        "id": 218637237,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606953147
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> I  take your point.  The correctness of the <code>metric</code> is in the axioms of <code>metric_space</code>.  Wikipedia only lists 3 properties and focusses on <code>d</code>.  <code>metric_space</code> also focusses on <code>d</code> internally and lists more than 3 axioms:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">dist_self</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">eq_of_dist_eq_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dist_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">dist_triangle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">edist</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">ennreal.of_real</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">edist_dist</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">edist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ennreal.of_real</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">control_laws_tac</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_uniform_space</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">uniform_space_of_dist</span> <span class=\"n\">dist</span> <span class=\"n\">dist_self</span> <span class=\"n\">dist_comm</span> <span class=\"n\">dist_triangle</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">uniformity_dist</span> <span class=\"o\">:</span> <span class=\"bp\">𝓤</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"bp\">⨅</span> <span class=\"n\">ε</span><span class=\"bp\">&gt;</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">𝓟</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">α</span><span class=\"bp\">×</span><span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">dist</span> <span class=\"n\">p.1</span> <span class=\"n\">p.2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">ε</span><span class=\"o\">}</span> <span class=\"bp\">.</span> <span class=\"n\">control_laws_tac</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>There are a bunch of <code>sorry</code>s in <code>metric_space_instance</code> so it's not really usable as-is. I was really just trying to get at how Wikipedia presents the structure <code>(M,d)</code>, not just <code>M</code> with an assumed <code>d</code>.  There are a couple of directions I could go to Wikipedia-ify this more:</p>\n<ul>\n<li>Use <code>structure</code></li>\n<li>Make a <code>class</code> for <code>metric</code>, which <code>mathlib</code> doesn't, and put the focus on <code>d</code>.  </li>\n</ul>\n<p>In the long run for the project I am doing, I have a long stack of definitions I need to assemble, namely:</p>\n<ul>\n<li>Inhabited set</li>\n<li>Sample space: inhabited set</li>\n<li>Algebra</li>\n<li>σ-algebra</li>\n<li>Event space A</li>\n<li>Family of sets A</li>\n<li>Σ(A) the sigma algebra generated by a family of sets A</li>\n<li>σ-additive function</li>\n<li>Topological space</li>\n<li>Homeomorphism</li>\n<li>Separable topological space</li>\n<li>Metric</li>\n<li>Metric space</li>\n<li>Open set U on a metric space</li>\n<li>Open sets O(F) of a family F</li>\n<li>Closed set X on a metric space</li>\n<li>Clopen set</li>\n<li><code>ℝ</code></li>\n<li>Real closed/open intervals <code>[a,b]</code>, <code>(a,b)</code>, <code>[a,b)</code>, <code>(a,b]</code>, <code>(0,1)</code>, <code>[0,1]</code>, <code>[0,∞)</code>.</li>\n<li>Real metric <code>dR: ℝ × ℝ → [0,∞)</code></li>\n<li>Borel σ-algebra <code>B(M)</code> of metric space <code>(M,d)</code></li>\n<li>Borel σ-algebra <code>B(ℝ)</code></li>\n<li>Borel σ-algebra <code>B((a,b))</code> for <code>a b : ℝ</code></li>\n<li>Borel set <code>X ∈ B(M)</code> of metric space <code>(M,d)</code></li>\n<li>Finite Borel measure <code>μ: B(M) → [0,∞)</code> of metric space <code>(M,d)</code></li>\n<li>Borel probability measure <code>μ: B(M) → [0,1]</code></li>\n<li>Diameter <code>diam(X)</code> for <code>X ⊆ M</code> of metric space <code>(M,d)</code></li>\n<li>Cauchy-complete metric space</li>\n<li>Measure <code>μ: A→ [0,∞)</code></li>\n<li>Measurable space <code>(S,Σ)</code></li>\n<li>Measurable function <code>f</code></li>\n<li>Pullback <code>f⁻¹: Σ → A</code></li>\n<li>Push-forward measure <code>f(μ): T → [0,∞)</code></li>\n<li>Measure space <code>(S,Σ,μ)</code></li>\n<li>Finite measure <code>p: A→[0,∞)</code></li>\n<li>Lebesgue σ-algebra <code>L(ℝ)</code></li>\n<li>Lebesgue outer measure <code>λ⋆ : L(ℝ) → [0,∞)</code></li>\n<li>Lebesgue measure <code>λ : L(ℝ) → [0,∞)</code></li>\n<li>Polish measurable space</li>\n<li>Probability measure <code>p: Σ → [0,1]</code></li>\n<li>Probability space <code>(Ω,A,P)</code></li>\n<li>Random variable <code>(Ω,A,P)→(S,Σ)</code> from probability space to measure space</li>\n<li>Distribution <code>μ_X : Σ → [0,1]</code></li>\n<li>Distribution space <code>(S,Σ ,μ_X )</code></li>\n<li>Distribution function <code>F_X: ℝ→ [0,1]</code></li>\n<li>Quantile function <code>T-:[0,1]→ ereal</code> of function <code>T:ℝ→ [0,1]</code> maybe a/k/a inverse distribution function <code>F^-X</code> of distribution function <code>F_X</code></li>\n<li>Real distribution space <code>(ℝ, B(ℝ), μ_x, F_X)</code> from distribution <code>μ_x</code> on real-valued random variable on <code>(Ω,A,P)</code></li>\n<li>Steinhaus space</li>\n<li>Discrete random variable</li>\n<li>Continuous random variable</li>\n<li>Continuous random variable density function</li>\n<li>Uniform continuous random variable</li>\n<li>Exponential continuous random variable</li>\n<li>Normal continuous random variable</li>\n<li>Construction of i.i.d random sequences from individual numbers in <code>ℝ</code></li>\n<li>Stochastic kernel</li>\n<li>Almost surely</li>\n<li>Version</li>\n<li>Transition kernel</li>\n<li>Transition probability kernel</li>\n<li>Regular version</li>\n<li>Conditional expectation</li>\n<li>Stochastic process</li>\n</ul>",
        "id": 218640960,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606956282
    },
    {
        "content": "<p>You could try to build up your theory for <code>R^n</code> first</p>",
        "id": 218641350,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606956674
    },
    {
        "content": "<p>Are you looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/premetric_space\">docs#premetric_space</a>, which has fewer fields?</p>",
        "id": 218641748,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606956988
    },
    {
        "content": "<p>Also, mathlib has a some of what you indicated, like intervals, Borel measure</p>",
        "id": 218641979,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1606957195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I would like to use everything already defined in <code>mathlib</code> but where the literature I'm reading expresses a metric space as a structure <code>(M,d)</code> or a probability space as a structure <code>(Ω,A,P)</code>, I want to keep that style of definition.  I also want to learn how to make classes of functions.  In the case of <code>metric_space</code>, the class is \"about\" the<code>M</code> in the metric space structure <code>(M,d)</code>.  I want to understand how to, instead, make a class which is \"about\" the function <code>d</code>.  Similarly if I describe the Gaussian probability distribution, I want to be able to talk about Gaussian random variables, which are functions from probability space to measure space.  I want to be able to construct and talk about Gaussian RV, Normal RV and so on.</p>\n<p>I've got 3 higher-level goals:</p>\n<ol>\n<li>\n<p>Typically the notion of <code>(Ω,A,P)</code> is invoked and then forgotten about when talking about probability distributions.  I had a <a href=\"https://math.stackexchange.com/questions/3760724/what-is-the-probability-space-of-typical-real-univariate-probability-distributio\">long back and forth</a> about this on Stack Exchange.  I was looking for \"the\" canonical probability space underlying continuous distributions on the reals.  The feedback I got was that you can \"carry\" continuous RVs like uniform, Gaussian and so on a lot of different ways, the simplest one being the Steinhaus space.  Once you know you can carry them all with many or with that one, the topic becomes boring for most people, because the probability space just acts as a kind of index set into the event space.  One index set is as good as another as long as it spans the space.  Nevertheless, I wanted to make it more concrete in the Lean sense of having a correct stack of types and stating and supporting axioms and theorems about the construction.</p>\n</li>\n<li>\n<p>I noticed along the way that the idea of a distribution function, typically only defined for the reals, should probably extend to any measurable space.  So, <a href=\"https://math.stackexchange.com/questions/3780089/extending-the-concept-of-distribution-function-to-any-totally-or-partially-order/3782009\">another Stack Exchange question</a>.  Nobody cares about this.  I just thought it was interesting.  I thought it would be interesting to see if, building up the machinery in a provably correct way in Lean, I could show that indeed the idea of a distribution function naturally extends to any measurable space, it doesn't just have to be on the reals.</p>\n</li>\n<li>\n<p>The bigger challenge is to formalize the definitions leading up to a Wiener stochastic process and the definition of Ito and Stratonovich integrals.  This is probably a lot harder.  However the answers to my Stack Exchange question on probability space went there and sketched it out.  So maybe it's not that hard.  That would also be interesting to do.</p>\n</li>\n</ol>",
        "id": 218642670,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606957825
    },
    {
        "content": "<p><code>premetric_space</code> has 3 axioms but it's a different 3 axioms from the Wikipedia presentation for metric space. <a href=\"https://en.wikipedia.org/wiki/Metric_(mathematics)#Premetrics\">https://en.wikipedia.org/wiki/Metric_(mathematics)#Premetrics</a></p>",
        "id": 218642853,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606958005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218642670\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> I would like to use everything already defined in <code>mathlib</code> but where the literature I'm reading expresses a metric space as a structure <code>(M,d)</code> or a probability space as a structure <code>(Ω,A,P)</code>, I want to keep that style of definition.</p>\n</blockquote>\n<p>I think you might be making your life very hard. Sometimes there are very good reasons for formal libraries to deviate from the standard definitions in maths literature. The reason that mathlib includes the topology/uniformity in the definition of a metric space, is because otherwise you'll infer two topologies on a product metric space, and Lean can't tell they are equal. These are the kind of implementation details where you have to \"be like water\" (as Bruce Lee said). If you start fighting the system, life will become very hard.</p>",
        "id": 218655330,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606973529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I'm not trying to fight the system.  At my beginner skill level, I find it easier to understand axiomatic definitions that say X is a thing comprised of these specific parts which follow this list of axioms.  In that spirit, if you look at this <a href=\"https://github.com/formalabstracts/formalabstracts/issues/54\">old definition of σ-algebra from 2017</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">sigma_algebra</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">univ_mem</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">closed_under_comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">univ</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">closed_under_countable_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">countable_union</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>it is more like that.  Today, if I look for σ-algebra in <code>mathlib</code>, what I find is that <code>σ-algebra</code> exists <a href=\"https://github.com/leanprover-community/mathlib/blob/61e76c42054a081ee5e8d58500eab948c3c3ac33/src/measure_theory/measurable_space.lean\">19 times in the comments,  and 0 times in the code</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">...</span>\n<span class=\"n\">σ</span><span class=\"bp\">-</span><span class=\"n\">algebras</span> <span class=\"n\">on</span> <span class=\"n\">a</span> <span class=\"n\">fixed</span> <span class=\"n\">set</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"bp\">`</span> <span class=\"n\">form</span> <span class=\"n\">a</span> <span class=\"n\">complete</span> <span class=\"n\">lattice.</span> <span class=\"n\">Here</span> <span class=\"n\">we</span> <span class=\"n\">order</span>\n<span class=\"n\">σ</span><span class=\"bp\">-</span><span class=\"n\">algebras</span> <span class=\"kd\">by</span> <span class=\"n\">writing</span> <span class=\"bp\">`</span><span class=\"n\">m₁</span> <span class=\"bp\">≤</span> <span class=\"n\">m₂</span><span class=\"bp\">`</span> <span class=\"k\">if</span> <span class=\"n\">every</span> <span class=\"n\">set</span> <span class=\"n\">which</span> <span class=\"n\">is</span> <span class=\"bp\">`</span><span class=\"n\">m₁</span><span class=\"bp\">`-</span><span class=\"n\">measurable</span> <span class=\"n\">is</span>\n<span class=\"n\">also</span> <span class=\"bp\">`</span><span class=\"n\">m₂</span><span class=\"bp\">`-</span><span class=\"n\">measurable</span> <span class=\"o\">(</span><span class=\"n\">that</span> <span class=\"n\">is</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">m₁</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">subset</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">m₂</span><span class=\"bp\">`</span><span class=\"o\">)</span><span class=\"bp\">.</span> <span class=\"n\">In</span> <span class=\"n\">particular</span><span class=\"o\">,</span> <span class=\"n\">any</span>\n<span class=\"n\">collection</span> <span class=\"n\">of</span> <span class=\"n\">subsets</span> <span class=\"n\">of</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"bp\">`</span> <span class=\"n\">generates</span> <span class=\"n\">a</span> <span class=\"n\">smallest</span> <span class=\"n\">σ</span><span class=\"bp\">-</span><span class=\"n\">algebra</span> <span class=\"n\">which</span>\n<span class=\"n\">contains</span> <span class=\"n\">all</span> <span class=\"n\">of</span> <span class=\"n\">them.</span> <span class=\"n\">A</span> <span class=\"n\">function</span> <span class=\"bp\">`</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"bp\">`</span> <span class=\"n\">induces</span> <span class=\"n\">a</span> <span class=\"n\">Galois</span> <span class=\"n\">connection</span>\n<span class=\"n\">between</span> <span class=\"n\">the</span> <span class=\"n\">lattices</span> <span class=\"n\">of</span> <span class=\"n\">σ</span><span class=\"bp\">-</span><span class=\"n\">algebras</span> <span class=\"n\">on</span> <span class=\"bp\">`</span><span class=\"n\">α</span><span class=\"bp\">`</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">β</span><span class=\"bp\">`.</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>I am a programmer, not a mathematician.  It is frustrating for me not to be able to be able to be able to build a specific object of type <code>σ-algebra</code>, when <code>σ-algebra</code> is one of the central building blocks of the theory I am trying to encode in Lean.  I find it a lot harder to learn or even apply a piece of code where the building blocks I want to pick up and put down exist only very implicitly in a structure which focuses at the top level on representing one major idea, like measurable space, while at the same time relegating explicit mention of a subsidiary idea like σ-algebra to the comments.</p>\n<p>I am happier when I can constructively engage with each of the components in the stack that I listed above in an individual sense on the component's own terms.  I want to be able to  play with σ-algebras explicitly on their own terms before seeing them subsumed as purely implicit features of larger structures.  That is, I want to be able to stop and understand each building block idea on it's own terms as I go along, and then see that building block idea explicitly expressed in the construction of the next idea.  However, based on the 2017/2020 comparison, it seems that as the code evolves, the major ideas get a lot more implicit structure packed into them and factored out in somewhat novel ways (compared to the Wikipedia presentation).  I guess this is to achieve higher levels of generality or categorization in the design.  However, that more general/categorical breakdown makes it harder to see the old trees from the old forest.</p>\n<p>I understand that in a sense you are discovering less ambiguous and more rigorous ways of presenting mathematical ideas than exist in the \"standard definitions\".   To that extent you should be maybe pushing for changes in the standard usage, so that the standard presentation conforms more to the way things are factored out in Lean than the way they have been presented in the past.</p>\n<p>One kind of \"activist\" way to do that would be to go into Wikipedia and simply change or augment the definitions you see in Wikipedia to fit the way ideas are newly presented in <code>mathlib</code>.  This is a reasonable suggestion because</p>\n<ul>\n<li>Anybody can edit Wikipedia</li>\n<li>You are a family member of Wikipedia in the sense that lines 53 to 57 of the <code>mathlib</code> code for<code>measurable_space</code> look like this:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">##</span> <span class=\"n\">References</span>\n<span class=\"bp\">*</span> <span class=\"bp\">&lt;</span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">en.wikipedia.org</span><span class=\"bp\">/</span><span class=\"n\">wiki</span><span class=\"bp\">/</span><span class=\"n\">Measurable_space</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">*</span> <span class=\"bp\">&lt;</span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">en.wikipedia.org</span><span class=\"bp\">/</span><span class=\"n\">wiki</span><span class=\"bp\">/</span><span class=\"n\">Sigma</span><span class=\"bp\">-</span><span class=\"n\">algebra</span><span class=\"bp\">&gt;</span>\n<span class=\"bp\">*</span> <span class=\"bp\">&lt;</span><span class=\"n\">https</span><span class=\"o\">:</span><span class=\"bp\">//</span><span class=\"n\">en.wikipedia.org</span><span class=\"bp\">/</span><span class=\"n\">wiki</span><span class=\"bp\">/</span><span class=\"n\">Dynkin_system</span><span class=\"bp\">&gt;</span>\n</code></pre></div>",
        "id": 218656856,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1606975789
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218656856\">said</a>:</p>\n<blockquote>\n<p>To that extent you should be maybe pushing for changes in the standard usage, so that the standard presentation conforms more to the way things are factored out in Lean than the way they have been presented in the past.</p>\n</blockquote>\n<p>I don't necessarily think so. Take the issue of filters for example. I'm not super familiar with Lean's real analysis library, but I think that a lot of stuff (e.g., limits) is done using filters. In the context of formalizing mathematics, filters are a great way to go. In the context of learning limits for the first time, filters are a terrible way to go. I think that a lot of freshmen calculus students would get very mad if we rewrote the Wikipedia limits page in terms of filters.</p>",
        "id": 218657979,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606977314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span> that's not what I'm saying.   I love simple axiomatic definitions like the ones you usually see for group, and ring.  However, while looking at probability space definitions in various course notes on the Internet, I discovered that those simple, clear cut, building block style definitions are the exception, not the rule, in mathematics and not just in <code>mathlib</code>.  So maybe 1% of math is presented that way, and the other 99% at the professional mathematician level is presented by a shifting and evolving set of alternative expressions.  For example, consider <a href=\"https://en.wikipedia.org/wiki/Stone_space\">Stone space</a> in Wikipedia.  It doesn't have one definition, it has 4:</p>\n<ul>\n<li>X is homeomorphic to the projective limit (in the category of topological spaces) of an inverse system of finite discrete spaces;</li>\n<li>X is compact and totally separated;</li>\n<li>X is compact, T0 , and zero-dimensional (in the sense of the small inductive dimension);</li>\n<li>X is coherent and Hausdorff.</li>\n</ul>\n<p>Also, if you look at the history of probability theory, it was a century long slug-fest where mathematicians constantly fought over how to express things and what to focus on.  You can see the blow-by-blow in <a href=\"https://arxiv.org/pdf/1802.06071.pdf\">The origins and legacy of Kolmogorov's Grundbegriffe</a>.  Math changes all the time.</p>\n<p>Regarding undergraduates getting annoyed if you changed a definition in Wikipedia: Don't worry about it.  I have gotten hammered in Zulip for making broad untestable assertions about large populations, but I will go ahead and do it again:  There is no undergraduate on the planet who is motivated to study metric spaces who will be bothered if you add an alternate presentation of metric spaces as a section in the Wikipedia page.  I have been a Wikipedia editor since 2008.  Wikipedia can also be quite contentious.  If you make an edit on the Metric Space page and you find that it leads to enormous controversy, I will come and defend you.  However, I will make another prediction: Nobody will notice.  On Wikipedia, the kind of page that will attract the most serious, sustained and concentrated attention is <a href=\"https://en.wikipedia.org/wiki/Joe_the_Plumber\">this one</a>.  Metric space, no so much.</p>",
        "id": 218700823,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607006307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218656856\">said</a>:</p>\n<blockquote>\n<p>In that spirit, if you look at this <a href=\"https://github.com/formalabstracts/formalabstracts/issues/54\">old definition of σ-algebra from 2017</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">sigma_algebra</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">univ_mem</span> <span class=\"o\">:</span> <span class=\"n\">univ</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">closed_under_comp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span> <span class=\"bp\">→</span> <span class=\"n\">univ</span> <span class=\"bp\">\\</span> <span class=\"n\">s</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">closed_under_countable_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">countable_union</span> <span class=\"n\">f</span> <span class=\"bp\">∈</span> <span class=\"n\">σ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>it is more like that.  Today, if I look for σ-algebra in <code>mathlib</code>, what I find is that <code>σ-algebra</code> exists <a href=\"https://github.com/leanprover-community/mathlib/blob/61e76c42054a081ee5e8d58500eab948c3c3ac33/src/measure_theory/measurable_space.lean\">19 times in the comments,  and 0 times in the code</a></p>\n</blockquote>\n<p>If you look at <code>measurable_space</code>, you'll see it's almost exactly this definition, just under a different name:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">measurable_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_measurable'</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_measurable'</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_measurable'</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Remember that in lean, <code>σ : set (set α)</code> and <code>is_measurable' : set α → Prop</code> are definitionally equal, and so are <code>s ∈ σ</code> and <code>is_measurable' s</code>.</p>",
        "id": 218702012,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607006819
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>.  Translating these <a href=\"https://en.wikipedia.org/wiki/Measurable_space#Example\">finite measurable space examples</a> using <code>mathlib</code> will really help me understand how to use the library:  Given <code>X={1,2,3}</code>, two instances of σ-algebra are <code>A1={X,∅}</code> and <code>A2=P(X)</code>.   I don't know how to make a particular finite set in Lean. This is not discussed in TPIL.  <a href=\"https://leanprover.github.io/logic_and_proof/sets_in_lean.html\">Logic and Proof</a> doesn't have a finite set example.  I need to do the following steps:</p>\n<ol>\n<li>Make <code>X = {1,2,3}</code></li>\n<li>Make <code>A1 = {X, ∅}</code></li>\n<li>Make <code>A2 = set.powerset(X)</code></li>\n<li>Prove that <code>measurable_space A1</code> and <code>measurable_space A2</code></li>\n</ol>\n<p>Is this possible?  I don't know how to do this.</p>",
        "id": 218750692,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607027755
    },
    {
        "content": "<p>Actually for <code>X={1,2,3}</code> I have a solution.</p>\n<p>I was concerned about getting a \"true <code>set</code>\" and not a \"set-like object\" that might not fit with <code>measurable_space</code>. </p>\n<p>I found <a href=\"https://leanprover-community.github.io/theories/sets.html\">the docs</a>.  This seems like a back door (only fits my example) but it gets me there:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218755298,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607030001
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218756457,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607030608
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> will <code>finset</code> unify with <code>set</code>?  This is needed to apply to <code>measurable_space</code>.  For example, this does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>  <span class=\"c1\">-- type error here and no automatic coercion</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>Also how do I prove set membership.  For example according to the <a href=\"https://leanprover-community.github.io/mathlib_docs/data/set/basic.html#set.mem_def\">definition of ∈ </a>, this should work, but does not:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">exact</span> <span class=\"n\">S</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It fails with error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">type</span> <span class=\"n\">ascription</span><span class=\"o\">,</span> <span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>I am a little fuzzy about the status of my definition <code>S</code>.</p>",
        "id": 218756848,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607030808
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">tactic.dec_trivial</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">set.left_mem_Icc.mpr</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"mi\">1</span> <span class=\"bp\">≤</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218757190,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607031053
    },
    {
        "content": "<p>I don't have a type error for your </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S</span>\n</code></pre></div>",
        "id": 218757358,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607031131
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">⊤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set.powerset</span> <span class=\"n\">X</span>\n\n<span class=\"k\">#reduce</span> <span class=\"n\">X</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">A1</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">A2</span>\n</code></pre></div>",
        "id": 218757848,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607031404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218750692\">said</a>:</p>\n<blockquote>\n<p>Thank you <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span>.  Translating these <a href=\"https://en.wikipedia.org/wiki/Measurable_space#Example\">finite measurable space examples</a> using <code>mathlib</code> will really help me understand how to use the library:  Given <code>X={1,2,3}</code>, two instances of σ-algebra are <code>A1={X,∅}</code> and <code>A2=P(X)</code>.   I don't know how to make a particular finite set in Lean. This is not discussed in TPIL.  <a href=\"https://leanprover.github.io/logic_and_proof/sets_in_lean.html\">Logic and Proof</a> doesn't have a finite set example.  I need to do the following steps:</p>\n<ol>\n<li>Make <code>X = {1,2,3}</code></li>\n<li>Make <code>A1 = {X, ∅}</code></li>\n<li>Make <code>A2 = set.powerset(X)</code></li>\n<li>Prove that <code>measurable_space A1</code> and <code>measurable_space A2</code></li>\n</ol>\n<p>Is this possible?  I don't know how to do this.</p>\n</blockquote>\n<p>The easiest way to prove specific theorems is to generalize them to something that doesn't have the \"example\" flavor. Under what assumptions does this theorem hold?</p>",
        "id": 218757894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607031437
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> !  This works on Lean Community Web Editor:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">S</span>\n<span class=\"k\">#check</span> <span class=\"n\">measurable_space</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>When I try it on my local VS Code copy of Lean, installed yesterday, I get this:<br>\n<a href=\"/user_uploads/3121/czfzqxWr8ZJUh_Ff1FkR0Tyh/Screenshot-from-2020-12-03-16-38-34.png\">Screenshot-from-2020-12-03-16-38-34.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/czfzqxWr8ZJUh_Ff1FkR0Tyh/Screenshot-from-2020-12-03-16-38-34.png\" title=\"Screenshot-from-2020-12-03-16-38-34.png\"><img src=\"/user_uploads/3121/czfzqxWr8ZJUh_Ff1FkR0Tyh/Screenshot-from-2020-12-03-16-38-34.png\"></a></div>",
        "id": 218758045,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607031532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is it correct to say that if #check doesn't complain, then A1 and A2 have been proven to be measurable spaces, just by passing the typecheck?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">({</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">⊤</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set.powerset</span> <span class=\"n\">X</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">measurable_space</span> <span class=\"n\">A1</span>\n<span class=\"k\">#check</span> <span class=\"n\">measurable_space</span> <span class=\"n\">A2</span>\n</code></pre></div>",
        "id": 218758285,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607031683
    },
    {
        "content": "<p>no</p>",
        "id": 218758297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607031691
    },
    {
        "content": "<p>a proof would be <code>#check (by apply_instance : measurable_space A1)</code></p>",
        "id": 218758350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607031723
    },
    {
        "content": "<p>all that typechecking the statement does is ensure that <code>A1</code> can be treated as a type</p>",
        "id": 218758422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607031750
    },
    {
        "content": "<p>Thanks.  Then not quite done yet because that yields</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">tactic.mk_instance</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">generate</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n  <span class=\"n\">measurable_space</span> <span class=\"bp\">↥</span><span class=\"n\">A1</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">measurable_space</span> <span class=\"bp\">↥</span><span class=\"n\">A1</span>\n</code></pre></div>\n<p>even though it passes the type check.</p>",
        "id": 218758495,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607031797
    },
    {
        "content": "<p>yes, there's a big difference between stating a theorem and proving it!</p>",
        "id": 218758546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607031822
    },
    {
        "content": "<p>Oh btw I have a typo, I used <code>\\top</code>, which is <code>set.univ</code> instead of <code>\\bot</code>, which is the empty set</p>",
        "id": 218758685,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607031875
    },
    {
        "content": "<p>The last part requires a bit more proof, like mario says though, A1 and A2 giving the measurable sets of a measurable space doesn't really require the base type to be fin 3</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"n\">sorry</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 218758880,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607031961
    },
    {
        "content": "<p>The A2 version is easier</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">meas2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A2</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218759024,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607032027
    },
    {
        "content": "<p>it would be nice to prove these by proving roughly <code>(⊥ : measurable_space X) = A1</code></p>",
        "id": 218759073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607032059
    },
    {
        "content": "<p>These are not efficient proofs, I'm just using <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#finish\">tactic#finish</a> which can solve a lot of goals automatically to avoid thinking about what's needed too hard here.</p>",
        "id": 218759095,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607032071
    },
    {
        "content": "<p>there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_space.is_measurable_bot_iff\">docs#measurable_space.is_measurable_bot_iff</a> but there is still some unwrapping to get the pair formulation</p>",
        "id": 218759215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607032126
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> this now gives a very clear guide for how to use <code>mathlib</code>.</p>",
        "id": 218759483,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607032244
    },
    {
        "content": "<p>In looking at this today I found these slides by <a href=\"http://www.andrew.cmu.edu/user/avigad/meetings/fomm2020/slides/fomm_boldo.pdf\">Sylvie Boldo</a> on Lebesgue integration in Coq.  Is it fair to say that <code>mathlib</code>at a same level of development for Lebesgue integral?  In particular she proved a few theorems <code>Fatou_Lebesgue</code>, <code>LInt_p_plus</code> and <code>LInt_p_with_adapted_seq</code> and I was wondering if you have those defined in <a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/integration.html\">Lebesgue integral</a></p>",
        "id": 218760409,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607032698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253861\">@Thomas Browning</span>  on the changing story of math, I came across this picture today in Wikipedia: <a href=\"/user_uploads/3121/9wosnUlHRvTXRC1GqXPLM4cn/1024px-Magma_to_group4.svg.png\">1024px-Magma_to_group4.svg.png</a> <br>\n<code>mathlib</code> has <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/free.html#free_magma\"><code>magma</code></a>.  I'd never heard of it before today.  It's not in <a href=\"https://idoc.pub/download/saunders-mac-lane-garret-birkhoff-algebra-1999-6nq85q2pd9nw\">Mac Lane and Birkhoff</a>.   The term was <a href=\"https://en.wikipedia.org/wiki/Magma_(algebra)#History_and_terminology\">coined in 1965</a>.  Saunders Mac Lane did not take notice.  So that's a concrete example of terminology and methodology shifts in mathematics.  Which is evidence for the idea that if <code>mathlib</code> has a different factoring and terminology for the underlying \"state of nature\" which you think is a better way of presenting that state of nature, you should really feel free to go ahead and explain things that way in Wikipedia.</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/9wosnUlHRvTXRC1GqXPLM4cn/1024px-Magma_to_group4.svg.png\" title=\"1024px-Magma_to_group4.svg.png\"><img src=\"/user_uploads/3121/9wosnUlHRvTXRC1GqXPLM4cn/1024px-Magma_to_group4.svg.png\"></a></div>",
        "id": 218761731,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607033362
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/measurable+space\">https://ncatlab.org/nlab/show/measurable+space</a></p>",
        "id": 218762175,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607033537
    },
    {
        "content": "<p><code>magma</code> in mathlib would just be <code>has_mul</code> a binary operation with no axioms</p>",
        "id": 218762227,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607033575
    },
    {
        "content": "<p>Then the arrows in your picture are instances in lean like, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semigroup.to_has_mul\">docs#semigroup.to_has_mul</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid.to_semigroup\">docs#monoid.to_semigroup</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/group.to_monoid\">docs#group.to_monoid</a></p>",
        "id": 218762453,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607033710
    },
    {
        "content": "<p>Wikipedia is not the only place to find references and descriptions of terms, but is just meant to be an easy reference with links to more in-depth explanations. nLab is one such more in-depth reference.</p>",
        "id": 218762495,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607033737
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> it might be best practice to replace Wikipedia references in the <code>mathlib</code> source with nLab pages.</p>",
        "id": 218763392,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607034237
    },
    {
        "content": "<p>magmas are popular in France I believe, because Bourbaki liked it</p>",
        "id": 218764542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607034854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"364351\">Lars Ericson</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218763392\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> it might be best practice to replace Wikipedia references in the <code>mathlib</code> source with nLab pages.</p>\n</blockquote>\n<p>No, I don't think so. nLab has a tendency for being inscrutable to non-experts</p>",
        "id": 218764690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607034947
    },
    {
        "content": "<p>wikipedia is much more appropriate for linking to core concepts in an undergraduate curriculum</p>",
        "id": 218764755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607034975
    },
    {
        "content": "<p>Also all the constructive detours in nLab are quite irrelevant for mathlib</p>",
        "id": 218764955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607035090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/How.20do.20I.20make.20a.20Wikipedia-style.20metric.20space.20in.20Lean.3F/near/218764690\">said</a>:</p>\n<blockquote>\n<p>No, I don't think so. nLab has a tendency for being inscrutable to non-experts</p>\n</blockquote>\n<p>Sometimes also for experts...</p>",
        "id": 218765644,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607035541
    },
    {
        "content": "<p>Suppose that the proofs for A1 and A2 happened to be identical.  (I know that that may not be the case here, it is a hypothetical.)  If so, what is the proper Lean syntax and style to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ms_proof</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ms_proof</span> <span class=\"n\">X</span> <span class=\"n\">A1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ms_proof</span> <span class=\"n\">X</span> <span class=\"n\">A2</span>\n</code></pre></div>",
        "id": 218846703,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607095582
    },
    {
        "content": "<p>that depends on what kind of identical you mean</p>",
        "id": 218846872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095658
    },
    {
        "content": "<p>if they are defeq you can just reuse the proof</p>",
        "id": 218846902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095671
    },
    {
        "content": "<p>if they are textually the same but are actually proving different things you can usually use a tactic</p>",
        "id": 218847020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095710
    },
    {
        "content": "<p>but it's also possible for an example like this one that there is simply a generalization to be had, where you prove a general theorem and just instantiate it twice. This is preferable if you can do it, reserving the tactic approach for proofs that are very significantly different and only look similar because the same automation is used (e.g. there are many theorems about complexes proved <code>by ext; simp</code> which have nothing to do with one another despite sharing the same proof text)</p>",
        "id": 218847336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607095826
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm supposing that I have a general theorem and I'm instantiating it twice.   However, syntactically, I don't think I'm proving a theorem in this case, I am building a structure.  <code>measurable_space</code> is a <a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/measurable_space.html#measurable_space\">structure with 4 fields</a>.  I am guessing that the body of the instance assignment:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">body</span>\n</code></pre></div>\n<p>has to evaluate to a <code>measurable_space</code> structure with 4 fields.  I don't know if that is a correct understanding of the type of <code>body</code>.  If so, then I should be able to say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ms_proof</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span> <span class=\"o\">}</span> <span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>However Lean is throwing up a bunch of errors when I do this:<br>\n<a href=\"/user_uploads/3121/51mE1iTGVlT8ynauc1McGHGM/Screenshot-from-2020-12-04-10-41-44.png\">Screenshot-from-2020-12-04-10-41-44.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/51mE1iTGVlT8ynauc1McGHGM/Screenshot-from-2020-12-04-10-41-44.png\" title=\"Screenshot-from-2020-12-04-10-41-44.png\"><img src=\"/user_uploads/3121/51mE1iTGVlT8ynauc1McGHGM/Screenshot-from-2020-12-04-10-41-44.png\"></a></div><p>Hence the question, what is the right way to do this so that I get significant re-use of code but the purpose of the code is to instantiate a structure with 4 fields.</p>",
        "id": 218849263,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607096616
    },
    {
        "content": "<p>Shouldn't you be using <code>A</code> instead of <code>A1</code>? Lean is complaining that <code>A1</code> is a function on the wrong type, the <code>def X := fin 3</code> rather than the variable <code>(X : Type)</code> in the theorem</p>",
        "id": 218849800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607096834
    },
    {
        "content": "<p>there isn't a really big difference between theorems and definitions in lean, the syntax is exactly the same except for the initial keyword</p>",
        "id": 218849961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607096884
    },
    {
        "content": "<p>Your two instances <code>M1</code> and <code>M2</code> are a bad idea btw because instances are supposed to be unique per type</p>",
        "id": 218850198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607096987
    },
    {
        "content": "<p>you can make them a <code>def</code> instead if you want to prove the theorem without making it the canonical measurable space on <code>X</code></p>",
        "id": 218850317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097029
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> removing that typo this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ms_proof</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">sorry</span> <span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">sorry</span> <span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">sorry</span> <span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ms_proof</span> <span class=\"n\">X</span> <span class=\"n\">A1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ms_proof</span> <span class=\"n\">X</span> <span class=\"n\">A2</span>\n</code></pre></div>\n<p>If I change the <code>def</code> to <code>theorem</code> I get a message at the <code>instance</code> lines</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">generate</span> <span class=\"n\">bytecode</span> <span class=\"n\">for</span> <span class=\"bp\">'</span><span class=\"n\">M1'</span>\n<span class=\"n\">code</span> <span class=\"n\">generation</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">VM</span> <span class=\"n\">does</span> <span class=\"n\">not</span> <span class=\"k\">have</span> <span class=\"n\">code</span> <span class=\"n\">for</span> <span class=\"bp\">'</span><span class=\"n\">ms_proof'</span>\n</code></pre></div>",
        "id": 218850400,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607097075
    },
    {
        "content": "<p>For this particular example the proofs will probably end up being different.  I was just curious what the right way was in case the proofs were the same.  However, even if the proofs are the same, the underlying sigma algebras are different by construction, so I want to call them different instances of <code>measurable_space</code>, even if the proof happens to go the same for the different sigma algebras.  Either that or I'm misunderstanding what <code>instance</code> is supposed to represent, other than \"an instance\".</p>",
        "id": 218850746,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607097234
    },
    {
        "content": "<p>An instance should usually be a <code>def</code> rather than a <code>theorem</code>. The general rule is: if you are \"constructing data\", more specifically if the type that you are constructing is not a <code>Prop</code> (in this case <code>measurable_space X : Type</code>), then it should be <code>def</code>, otherwise <code>theorem</code></p>",
        "id": 218852038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097673
    },
    {
        "content": "<p>if you don't follow this rule you get the \"code generation failed\" error</p>",
        "id": 218852113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097706
    },
    {
        "content": "<p>What you are describing, that there are multiple non-equivalent members of <code>measurable_space X</code>, is what <code>def</code> is about</p>",
        "id": 218852377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097791
    },
    {
        "content": "<p><code>instance</code> is for when the type, even if it is not literally a singleton, nevertheless has a \"canonical element\": for example the collection of all field structures on the reals is very far from a singleton yet when people use the reals as a field they really only mean one field structure, and <code>instance</code> encodes that \"canonical choice\" of structure. You can't have two canonical choices for the same type</p>",
        "id": 218852644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097885
    },
    {
        "content": "<p>In the case of <code>measurable_space X</code>, there is no canonical measurable space in general, even though there are two generically definable measurable spaces, top and bottom</p>",
        "id": 218852874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607097966
    },
    {
        "content": "<p>Each of the components is actually a theorem that the given set satisfies the required properties.  So taken together it's 4 proofs.  If they happen to be the same proof for two different sets then it seems like I am defining a category.  Is that overstating the case?  Again, hypothetical on the proofs requiring the same set of tactics (even if the tactics like <code>finish</code> resolve to different sequences \"under the hood\").</p>",
        "id": 218852926,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607097988
    },
    {
        "content": "<p>For <code>measurable_space real</code>, you could take the set of lebesgue measurable sets as canonical, or perhaps the borel measurable sets</p>",
        "id": 218852961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607098005
    },
    {
        "content": "<p>It's not a category in the mathematical sense, it's just a general theorem</p>",
        "id": 218853042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607098039
    },
    {
        "content": "<p>or <code>def</code> I should say</p>",
        "id": 218853051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607098045
    },
    {
        "content": "<p><code>A1</code> and <code>A2</code> are different sets, so <code>ms_proof X A1</code> and <code>ms_proof X A2</code> are proofs about two different measurable spaces.   Even though <code>X</code> is the same, the sigma algebras are different.  In Wikipedia style, the measurable spaces are <code>(X,A1)</code> and <code>(X,A2)</code>.  This is two different spaces.  Maybe in NCat style, <code>X</code> is the measurable space and <code>A1</code> and <code>A2</code> are sigma algebras that it has.   However, if that were the case, then I should have a structure <code>sigma_algebra</code> so that I can distingiush <code>A1</code> and <code>A2</code> as instances of  <code>sigma_algebra</code>.  But that is not the <code>mathlib</code> design.  So given the design, I should really be comfortable using <code>instance</code> for <code>M1</code> and <code>M2</code>.</p>",
        "id": 218854151,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607098490
    },
    {
        "content": "<p>It's not clear how to plan to proceed without those <code>sorry</code>s filled out</p>",
        "id": 218854536,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607098639
    },
    {
        "content": "<p>Because right now, they're impossible to fill</p>",
        "id": 218854570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607098654
    },
    {
        "content": "<p>Your current statement is \"every set of sets on X is a measure\", but that's not true</p>",
        "id": 218855225,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607098970
    },
    {
        "content": "<blockquote>\n<p>I should have a structure sigma_algebra so that I can distingiush A1 and A2 as instances of sigma_algebra.</p>\n</blockquote>\n<p><code>sigma_algebra</code> in mathlib is spelled <code>measurable_space</code></p>",
        "id": 218855529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607099110
    },
    {
        "content": "<p>We already have proofs that <code>\\top : measurable_space X</code> and <code>\\bot : measurable_space X</code>, I think that covers your use cases already</p>",
        "id": 218855680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607099181
    },
    {
        "content": "<p>I think an issue here is one should not read <code>instance</code> as \"instance\" in the sense that \"this term is a single possible instance of this type\". Instead <code>instance</code> means \"infer this instantiation of this type for ALL mentions of this type\".</p>",
        "id": 218855902,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607099285
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> thanks I will use <code>def</code> in preference to <code>instance</code> wherever possible.</p>\n<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I stated that I was exploring the hypothetical of a situation where the proofs for A1 and A2 happened to be the same.  In which case I was looking for a way to factor code for identical structure proofs-of-correctness (each structure component is a proof).  I understand that these are not the same proof.  Also though there is the ambiguous case where a tactic like <code>simp</code> or <code>finish</code> works but if you looked at the expanded sequence, these tactics found different proofs at a fine-grained level.</p>\n<p>In the case of these A1 and A2, the proof of A2 has a <code>sorry</code> in <code>is_measurable_Union</code>.   Otherwise they would be textually the same proof.</p>",
        "id": 218858982,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607100590
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I get that <code>sigma_algebra</code> in <code>mathlib</code> is spelled <code>measurable_space</code>.  However <code>measurable_space</code> only takes the \"carrier set\" <code>X</code> as an explicit argument.  The sigma algebra that it verifies is there as the proof that <code>X</code> is <code>is_measurable'</code>.  If I were to look at two different objects <code>M</code> that had type <code>measurable_space X</code>, I would not know if they were \"about\" <code>A1</code> or \"about\" <code>A2</code>.   If the rest of what I do depends on whether I have <code>A1</code> or <code>A2</code> underneath, then I am going to want to know that I proved the <code>measurable_space</code> of <code>X</code> for that A1 or A2.</p>",
        "id": 218860136,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607101089
    },
    {
        "content": "<p>It is the type of all sigma algebras</p>",
        "id": 218860433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607101212
    },
    {
        "content": "<p>an element of that type is a sigma algebra. You can tell which one it is because you have an element of the type, in the same way that you can tell the difference between <code>1 : real</code> and <code>4 : real</code> even thoughthey have the same type</p>",
        "id": 218860582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607101271
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">something_about_A1</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">sigma</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">sigma.is_measurable'</span> <span class=\"bp\">=</span> <span class=\"n\">A1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">...</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>?</p>",
        "id": 218860658,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607101307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> in probability theory <code>A1</code> and <code>A2</code> would represent two different event spaces with different granularity.  Propositions about one event space may not be equally valid on a differently constructed event space.  So really <code>1: (X,A1)</code> and <code>1:(X,A2)</code> are not the same thing at all.</p>",
        "id": 218861424,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607101602
    },
    {
        "content": "<p>What does <code>1: (X,A1)</code> mean? <code>(X, A1)</code> is not a type, it is a sigma algebra. Is <code>1</code> supposed to represent a measurable set?</p>",
        "id": 218876328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607108119
    },
    {
        "content": "<p>The idea here is that the elements of <code>measurable_space X</code> are themselves objects that you can manipulate, like what you have written <code>(X, A1)</code>. For example you can prove <code>(\\bot : measurable_space X) &lt;= \\top</code>, or <code>@is_measurable X \\bot A -&gt; @is_measurable X \\top A</code> and other things like that</p>",
        "id": 218876625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607108261
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I was abusing notation there.  You were talking about <code>1: real</code> and <code>2: real</code> and real is real.  I am thinking of sigma algebras as event spaces for a probability space.  I was just trying to express, notationally, that X with A1 and X with A2 are not the same.  Depending on the granularity of the event space you can either discern or not discern more or less about the outcome.  This means that what you can assert and compute the probability of is different for different sigma algebras.  Clearly A1 and A2 are different sigma algebras .  I need to be able to talk about them individually.   That's not easy in the current setup.</p>\n<p>Also as it turns out the proof of X with A1 is different from the proof of X with A2.  We don't really have a proof of X with A1 in the sketch by <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> , there is a <code>sorry</code> in the <code>is_measurable_Union </code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>So the two spaces <code>X</code> with <code>A1</code> and <code>X</code> with <code>A2</code> are different both in how they are proven to be measurable spaces and in what, as event spaces, the sigma algebras <code>A1</code> and <code>A2</code> allow you to express.  </p>\n<p>Also, consider how <code>mathlib</code> describes the situation: \"A measurable space is a set equipped with a σ-algebra, a collection of subsets closed under complementation and countable union. \"  A set.  Equipped with a σ-algebra.  Two different things.  Taken together, they make a 3rd thing.  However, the way the \"API\" of <code>measurable_space</code> is presented, it is hard to distinguish the presence of the second thing.  It's like saying a pair <code>(a,b)</code> has two parts <code>a</code> and <code>b</code>, but all pairs starting with <code>a</code> are isomorphic in some sense, so we'll prioritize the <code>a</code> and bury the <code>b</code>, and whenever we print the pair <code>(a,b)</code>, we are only going to print <code>(a,...)</code>.   I'm sorry, I just don't get it.  Clearly it is elegant to people who have more insight and training than I do.  I accept that.  But for me, I just don't get it.  It's OK that I don't get it.  Don't worry about it.  But I don't get it.</p>",
        "id": 218881246,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607110641
    },
    {
        "content": "<p>The <code>b</code> is only buried if you want it to be</p>",
        "id": 218881361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607110708
    },
    {
        "content": "<p>like I've been saying, <code>measurable_space X</code> is a type, that has elements, that you can use in expressions</p>",
        "id": 218881394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607110733
    },
    {
        "content": "<p>you don't have to always use them as instances</p>",
        "id": 218881422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607110749
    },
    {
        "content": "<p>it's like this: <code>(a : Type) (b : measurable_space a)</code>, see no burying</p>",
        "id": 218881619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607110828
    },
    {
        "content": "<p>The reason <code>measurable_space</code> is a class is because it is <em>also</em> common to want to fix a measure space or probability space <code>X</code> when talking about this stuff</p>",
        "id": 218881738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607110910
    },
    {
        "content": "<p>The proof of the theorems you are talking about in mathlib are done like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">gi_generate_from.lift_complete_lattice</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_measurable_bot_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable</span> <span class=\"n\">α</span> <span class=\"bp\">⊥</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span>      <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">∨</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">or_imp_distrib</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">classical.by_cases</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">,</span>\n      <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"k\">in</span>\n      <span class=\"n\">or.inr</span> <span class=\"bp\">$</span> <span class=\"n\">eq_univ_of_univ_subset</span> <span class=\"bp\">$</span> <span class=\"n\">hi</span> <span class=\"bp\">▸</span> <span class=\"n\">le_supr</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">,</span>\n      <span class=\"n\">or.inl</span> <span class=\"bp\">$</span> <span class=\"n\">eq_empty_of_subset_empty</span> <span class=\"bp\">$</span> <span class=\"n\">Union_subset</span> <span class=\"bp\">$</span> <span class=\"k\">assume</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n        <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">{</span><span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">false.elim</span> <span class=\"bp\">$</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">⟩))</span> <span class=\"o\">}</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">bot_unique</span> <span class=\"bp\">$</span> <span class=\"k\">assume</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">hs.elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s.symm</span> <span class=\"bp\">▸</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable_empty</span> <span class=\"n\">_</span> <span class=\"bp\">⊥</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s.symm</span> <span class=\"bp\">▸</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable.univ</span> <span class=\"n\">_</span> <span class=\"bp\">⊥</span><span class=\"o\">),</span>\n<span class=\"n\">this</span> <span class=\"bp\">▸</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">theorem</span> <span class=\"n\">is_measurable_top</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable</span> <span class=\"n\">_</span> <span class=\"bp\">⊤</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 218881978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607111028
    },
    {
        "content": "<p>Here we are starting from a much more powerful fact, that the space of all sigma algebras is a complete lattice, which immediately gives us <code>Sup</code>, <code>Inf</code>, <code>sup</code>, <code>inf</code>, <code>top</code> and <code>bot</code></p>",
        "id": 218882123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607111100
    },
    {
        "content": "<p>and then we prove post hoc that the <code>top</code> and <code>bot</code> so defined are in fact <code>univ</code> and <code>{empty, univ}</code> respectively</p>",
        "id": 218882189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607111137
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_space.copy</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable</span> <span class=\"n\">_</span> <span class=\"n\">c</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">c.is_measurable'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">eq_P</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">abstract</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">casesI</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">measurable_space.copy</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.ext</span> <span class=\"n\">eq_P</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊥</span> <span class=\"n\">A1</span> <span class=\"bp\">$</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">measurable_space.is_measurable_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">or.comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊤</span> <span class=\"n\">A2</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">A2</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo1_eq</span> <span class=\"o\">:</span> <span class=\"n\">foo1</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo2_eq</span> <span class=\"o\">:</span> <span class=\"n\">foo2</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 218883301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607111730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> thank you for being patient with me.  </p>\n<p>To move to the next part, we have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">X</span><span class=\"o\">:</span><span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>How do I get the size of an element of A1 or A2?  Or even <code>X</code>?  When I look at the definition of <code>fin N</code>, it is not clear that <code>N</code> is retained:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I want to be able to define a <code>metric</code> on <code>A1</code> which is just the size of the finite set.  This is not correct but I'm trying to get here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">SubSet</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">size</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"o\">:</span> <span class=\"n\">SubSet</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finite_set_measure_of</span><span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">):</span> <span class=\"n\">SubSet</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">size</span> <span class=\"n\">X</span> <span class=\"n\">F</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M1_measure</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span> <span class=\"n\">finite_set_measure_of</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1_MS</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_measurable_space</span> <span class=\"o\">:=</span> <span class=\"n\">M1</span><span class=\"o\">,</span>\n  <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">M1_measure</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218885918,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607113026
    },
    {
        "content": "<p>That's not a metric, I guess you mean a measure</p>",
        "id": 218886061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113086
    },
    {
        "content": "<p>the measure is called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.count\">docs#measure_theory.measure.count</a> in mathlib</p>",
        "id": 218886213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113172
    },
    {
        "content": "<p>It is defined by (infinite) summing 1 over the set</p>",
        "id": 218886382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113253
    },
    {
        "content": "<p>If you happen to know the set is finite you can use <code>finset.card</code> to get the cardinality</p>",
        "id": 218886434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113280
    },
    {
        "content": "<p>You can also use <code>cardinal.mk</code> to get the cardinality of an infinite set but for measures you really just want this to cap out at infinity so the infinite sum on <code>ennreal</code> is the easiest thing to implement</p>",
        "id": 218886585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113348
    },
    {
        "content": "<p>the proof that <code>fin n</code> has size <code>n</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.card_fin\">docs#fintype.card_fin</a></p>",
        "id": 218886757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607113438
    },
    {
        "content": "<p>You can do this, but it doesn't yield a very fun goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊥</span> <span class=\"n\">A1</span> <span class=\"bp\">$</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">measurable_space.is_measurable_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">or.comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊤</span> <span class=\"n\">A2</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">A2</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">M1_eq</span> <span class=\"o\">:</span> <span class=\"n\">M1</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">M2_eq</span> <span class=\"o\">:</span> <span class=\"n\">M2</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">fin.fintype</span> <span class=\"n\">_</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">M1_measure</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measure_theory.measure</span> <span class=\"n\">X</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">measure_theory.measure.of_measurable</span> <span class=\"n\">_</span> <span class=\"n\">M1</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">finset.card</span> <span class=\"n\">s.to_finset</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218887992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607114077
    },
    {
        "content": "<p>you have to prove that finite cardinalities are countably additive</p>",
        "id": 218888053,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607114121
    },
    {
        "content": "<p>I added the <code>M1_MS</code> to declare the <code>measure_space</code> to go with the <code>measure</code>.  My copy of Lean, downloaded yesterday, doesn't know <code>measurable_space.copy</code>, <code>measurable_space.copy_eq</code> and <code>measure_space</code> itself, though that is declared <a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/measure_space.html#measure_theory.measure_space\">here</a>: <br>\n<a href=\"/user_uploads/3121/WsZHvITjhMG6IAaM2UUAAdyP/Screenshot-from-2020-12-04-15-57-45.png\">Screenshot-from-2020-12-04-15-57-45.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/WsZHvITjhMG6IAaM2UUAAdyP/Screenshot-from-2020-12-04-15-57-45.png\" title=\"Screenshot-from-2020-12-04-15-57-45.png\"><img src=\"/user_uploads/3121/WsZHvITjhMG6IAaM2UUAAdyP/Screenshot-from-2020-12-04-15-57-45.png\"></a></div>",
        "id": 218890680,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607115663
    },
    {
        "content": "<p>That's because Mario defined it above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_space.copy</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable</span> <span class=\"n\">_</span> <span class=\"n\">c</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">c.is_measurable'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">eq_P</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">abstract</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">casesI</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">measurable_space.copy</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.ext</span> <span class=\"n\">eq_P</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊥</span> <span class=\"n\">A1</span> <span class=\"bp\">$</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">measurable_space.is_measurable_bot_iff</span><span class=\"o\">,</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"n\">or.comm</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊤</span> <span class=\"n\">A2</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">A2</span><span class=\"o\">]</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo1_eq</span> <span class=\"o\">:</span> <span class=\"n\">foo1</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">foo2_eq</span> <span class=\"o\">:</span> <span class=\"n\">foo2</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 218891673,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607116181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> restricting to A1, that looks like this.   I haven't got the <code>measure_space</code> declaration quite right yet:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measurable_space.copy</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">@</span><span class=\"n\">is_measurable</span> <span class=\"n\">_</span> <span class=\"n\">c</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">replace</span> <span class=\"n\">eq_P</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"bp\">=</span> <span class=\"n\">c.is_measurable'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">eq_P</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"bp\">..</span> <span class=\"o\">},</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">abstract</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">casesI</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">measurable_space.copy</span> <span class=\"n\">α</span> <span class=\"n\">c</span> <span class=\"n\">P</span> <span class=\"n\">eq_P</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.ext</span> <span class=\"n\">eq_P</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"n\">measurable_space.copy</span> <span class=\"bp\">⊥</span> <span class=\"n\">A1</span> <span class=\"bp\">$</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">measurable_space.is_measurable_bot_iff</span><span class=\"o\">,</span>\n        <span class=\"n\">A1</span><span class=\"o\">,</span>\n        <span class=\"n\">eq_comm</span><span class=\"o\">,</span>\n        <span class=\"n\">or.comm</span><span class=\"o\">],</span>\n     <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">M1_eq</span> <span class=\"o\">:</span> <span class=\"n\">M1</span> <span class=\"bp\">=</span> <span class=\"bp\">⊥</span> <span class=\"o\">:=</span> <span class=\"n\">measurable_space.copy_eq</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">fin.fintype</span> <span class=\"n\">_</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">M1_measure</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measure_theory.measure</span> <span class=\"n\">X</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">measure_theory.measure.of_measurable</span> <span class=\"n\">_</span> <span class=\"n\">M1</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">finset.card</span> <span class=\"n\">s.to_finset</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1_MS</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_measurable_space</span> <span class=\"o\">:=</span> <span class=\"n\">M1_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">M1_measure</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 218893377,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607117310
    },
    {
        "content": "<p>The <a href=\"https://leanprover-community.github.io/mathlib_docs/measure_theory/measure_space.html#measure_theory.measure_space\">documentation</a> is confusing because at the top level it says this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">measure_theory.measure_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">to_measurable_space</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span>\n<span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">measure_theory.measure</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>I read this as meaning that I should supply an instance with two fields, <code>to_measurable_space</code> and <code>volume</code>.  However, if I look at <a href=\"https://github.com/leanprover-community/mathlib/blob/5f430798db36c627dffaf31c96aca7fabdd74650/src/measure_theory/measure_space.lean#L1905\">the source</a>, it says something different:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I read this as meaning that I have to do everything I did for a <code>measurable_space</code>, and also supply a <code>volume</code>.  In that case, based on example above in this thread:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n</code></pre></div>\n<p>I should be saying something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A1</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"o\">,</span>\n  <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">M1_measure</span>\n</code></pre></div>\n<p>On the third hand, if I look at the supplied instances in the docs:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">measure_theory.real.measure_space</span>\n<span class=\"n\">measure_theory.measure.prod.measure_space</span>\n</code></pre></div>\n<p>The first one is declared as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">real.measure_space</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨{</span><span class=\"n\">to_outer_measure</span> <span class=\"o\">:=</span> <span class=\"n\">lebesgue_outer</span><span class=\"o\">,</span>\n  <span class=\"n\">m_Union</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">lebesgue_outer.Union_eq_of_caratheodory</span> <span class=\"bp\">$</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">borel_le_lebesgue_measurable</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n  <span class=\"n\">trimmed</span> <span class=\"o\">:=</span> <span class=\"n\">lebesgue_outer_trim</span> <span class=\"o\">}⟩</span>\n</code></pre></div>\n<p>and the second one as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">prod.measure_space</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">measure_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">volume.prod</span> <span class=\"n\">volume</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>So <code>real.measure_space</code> supplies values for fields <code>to_outer_measure</code> and <code>m_Union</code> and <code>trimmed</code>, none of which are mentioned in the class definitions of <code>measurable_space</code> and subclass <code>measure</code>.  <code>prod.measure_space</code> supplies a value for <code>volume</code> but nothing for <br>\n<code>is_measurable' </code>, <code>  is_measurable_empty</code>, <code> is_measurable_compl</code> and <code>is_measurable_Union</code>.</p>",
        "id": 218902601,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607123127
    },
    {
        "content": "<p>Creating a field <code>to_measurable_space</code> is how <code>extends measurable_space</code> works. Ideally the documentation could detect this and turn it back into <code>extends</code> for display purposes, but I'm not sure how easy that is in general.</p>",
        "id": 218902790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607123277
    },
    {
        "content": "<p>In the end the following is what gets at what was bothering me best:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier_set</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">algebra</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">class</span><span class=\"o\">]</span> <span class=\"n\">σ_algebra</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">XA</span><span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier_set</span> <span class=\"o\">:=</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">algebra</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">XA</span> <span class=\"c1\">-- XA : σ_algebra X A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space</span> <span class=\"n\">X</span> <span class=\"n\">A</span> <span class=\"n\">XA</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M</span> <span class=\"c1\">-- M : measurable_space X</span>\n</code></pre></div>\n<p>I would like to take this a little bit further and be able to say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space1</span>  <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space1</span> <span class=\"n\">XA</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M1</span> <span class=\"c1\">-- M : measurable_space X</span>\n</code></pre></div>\n<p>Unfortunately this yields a host of errors.  To make this work I think I would need to utilize/adapt  <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> 's <code>measurable_space.copy</code>.  It seems to be textually rewriting the proof and then re-running the proof through the proof engine.  I don't understand it yet but I will study it now.</p>\n<p><a href=\"user_uploads/3121/RwjXX3rpqYeco4v31DWJ3OUf/Screenshot-from-2020-12-05-22-26-54.png\">Screenshot-from-2020-12-05-22-26-54.png</a></p>\n<div class=\"message_inline_image\"><a href=\"user_uploads/3121/RwjXX3rpqYeco4v31DWJ3OUf/Screenshot-from-2020-12-05-22-26-54.png\" title=\"Screenshot-from-2020-12-05-22-26-54.png\"><img src=\"user_uploads/3121/RwjXX3rpqYeco4v31DWJ3OUf/Screenshot-from-2020-12-05-22-26-54.png\"></a></div>",
        "id": 218966491,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607225168
    },
    {
        "content": "<p>Just for reference, Mario wrote the <code>measurable_space.copy</code> code. You're still using <code>instance</code> in places where <code>def</code> seems most appropriate. You're not relying on any typeclass inferring, so <code>attribute [class] ...</code> is also not doing anything. On top of that, you're mixing names of definitions and names of variables. In the <code>to_measurable_space1</code>, the error at <code>is_measurable_empty</code> says that it cannot understand that <code>XA.algebra</code> is the same as <code>A</code>. And for that particular definition that you're trying to make, that would not have to be the case, because you're supplying any possible <code>XA : σ_algebra X A</code>.  That variable could have been called anything else. If you want to just use the <code>XA</code> you defined above, you would really have to say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space1</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M1</span> <span class=\"c1\">-- M : measurable_space X</span>\n</code></pre></div>",
        "id": 218970243,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607232312
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> and <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> . </p>\n<p>In my example above, I put in the <code>attribute [class] ...</code> because if you take it out, you can an error from Lean in the example as stated.</p>\n<p>If I look at the <a href=\"https://leanprover.github.io/reference/lean_reference.pdf\">Lean reference manual, section 3.3</a>, there is no mathematical overload to the definition of <code>class</code>.  A <code>class</code> is just what we think of in Python or C++: It's a way of describing a record with fields.  So:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">)</span>\n<span class=\"kd\">instance</span> <span class=\"n\">cls_five</span> <span class=\"o\">:</span> <span class=\"n\">cls</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">5</span><span class=\"o\">⟩</span>\n<span class=\"k\">#reduce</span> <span class=\"n\">cls_five</span> <span class=\"c1\">--- {val := 5}</span>\n</code></pre></div>\n<p>Given that, if I have a definition of <code>σ_algebra </code> with 5 fields I don't know why I should be reluctant to make an instance of it and populate the fields.   I don't get why I should make that a <code>def</code>.</p>\n<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> , your version of <code>to_measurable_space1</code> is constant and depends on <code>XA</code>.  I want to define <code>XA</code> as a parameter to a function <code>to_measurable_space1</code>.    <code>XA</code> is an instance of a class.  So to some extent, it is a data object, not a definition.  Given that Lean understands every other field reference to <code>XA</code> than the first one, I don't know why it is complaining about the first field reference.  <code>A</code> is not mentioned on its own at all in the definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space1</span>  <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span> <span class=\"c1\">-- Not OK</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span> <span class=\"c1\">-- OK</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span> <span class=\"c1\">-- OK</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span> <span class=\"c1\">-- OK</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm not trying to be difficult, I just don't understand the mechanics here.  I know that if I (redundantly, as far as I can tell) present <code>X</code> and <code>X</code> along with <code>XA</code> which has <code>XA.carrier_set = X</code> and <code>XA.algebra = A</code>, then things are fine.  If I have to do that, I don't mind it.  I just don't understand exactly why it is failing.</p>",
        "id": 218988887,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607264601
    },
    {
        "content": "<blockquote>\n<p>If I look at the Lean reference manual, section 3.3, there is no mathematical overload to the definition of class. A class is just what we think of in Python or C++: It's a way of describing a record with fields.</p>\n</blockquote>\n<p>No, that would be <code>structure</code></p>",
        "id": 218988941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607264645
    },
    {
        "content": "<p>Lean's <code>class</code> is inherited from Haskell's use as \"type class\"</p>",
        "id": 218988952,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607264664
    },
    {
        "content": "<p>Recommended reading: <a href=\"http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102\">http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102</a></p>",
        "id": 218989132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607264969
    },
    {
        "content": "<blockquote>\n<p>Typeclasses have pretty much nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now.</p>\n</blockquote>",
        "id": 218989149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607265002
    },
    {
        "content": "<p>(we'd call them interfaces or protocols in Python if that's where you came from, and yeah it confused me too for a bit)</p>",
        "id": 218989362,
        "sender_full_name": "Julian Berman",
        "timestamp": 1607265286
    },
    {
        "content": "<p>OK...but my example (before you get to <code>to_measurable_space1</code>) does what I want (allows me to re-use my definition of sigma algebra) in measurable_space) where, for reasons of my own taste, I have pulled out the definition of sigma algebra from measurable_space.  And the example doesn't go through (Lean won't allow it), unless I bless the sigma algebra <code>structure</code> as a type class.</p>\n<p>Thank you for the Haskell reference, I will read it now.  I'm not sure that it will make me want to undo my pull-out of sigma algebra as a construction from measure_space, because I like that I can see X and A on the same line in the <code>#check XA -- XA : σ_algebra X A</code>.</p>",
        "id": 218989373,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607265315
    },
    {
        "content": "<p>I think it's actually reasonable to pull out <code>σ_algebra</code> (though by mathlib conventions we would call it <code>is_σ_algebra</code>; this linguistic viewpoint seems to confuse you repeatedly), but if you build more stuff on top of this you pretty quickly will want to work with the <code>measurable_space</code> version.</p>",
        "id": 218989585,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607265633
    },
    {
        "content": "<p>Actually I guess what you seem confused about is something else, namely the difference between writing down a type (or proposition) and writing down a term/proof of it</p>",
        "id": 218989685,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607265823
    },
    {
        "content": "<p>which is fair enough--a new user pleased to find that Lean accepts <code>#check 2 + 2 = 4</code> might be dismayed to learn it is equally accepting of <code>#check 2 + 2 = 5</code></p>",
        "id": 218990007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607266235
    },
    {
        "content": "<p>Reid watch out... Twitter might come after you...</p>",
        "id": 218990104,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607266377
    },
    {
        "content": "<p>\"but lean checked the proof! It says it right there in the name\"</p>",
        "id": 218990641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607267092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"321696\">@Julian Berman</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> thanks, I have read the Haskell and narrowed down my point of confusion.  This works, without type class attribute, and using <code>instance</code> instead of <code>def</code> and adding <code>is_</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier_set</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">algebra</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">XA</span><span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier_set</span> <span class=\"o\">:=</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">algebra</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">XA</span> <span class=\"c1\">-- XA : is_σ_algebra X A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space</span> <span class=\"n\">X</span> <span class=\"n\">A</span> <span class=\"n\">XA</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M</span> <span class=\"c1\">-- M : measurable_space X</span>\n</code></pre></div>\n<p>This doesn't work, because even though <code>X</code> and <code>A</code> are defined in the namespace of the declaration and could be seen as type-valued identifiers, they are not available in the signature for some scoping reason:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I wouldn't have expected it to work myself except that I didn't notice that X and A are free in <code>XA : is_σ_algebra X A</code>.  Now that I see they are free, it makes complete sense to have to include them in the signature of <code>to_measurable_space</code>.  However, what is a little confusing as a usage constraint is that while this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>even though it should be clear from the construction of <code>XA</code> that the value of <code>A</code> is the same as the value of <code>XA.algebra</code>.   That is expecting too much of Lean I guess, so I won't whinge about it, I will just stay with <code>is_measurable' := A</code>.  But, for the record, i was not confusing types and values.  What is getting assigned here is the <strong>value</strong> <code>A</code> of <strong>type</strong>  <code>set X → Prop</code> to <strong>field</strong> <code>is_measurable'</code>.  Since by construction the value of <code>A</code> and the value of <code>XA.algebra</code> are identical.  This should work.  It doesn't.  I don't completely understand why.  But it is not because I am confused about something at the level of <code>#check 2+2=5</code>.  Reading the error messages, Lean is trying to prove something which should be, in some sense, obvious \"by construction\":</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Display</span> <span class=\"n\">GoalDisplay</span> <span class=\"n\">Messages</span>\n<span class=\"mi\">25</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">is_measurable_empty</span><span class=\"o\">)</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">XA.algebra</span> <span class=\"bp\">∅</span>\n<span class=\"mi\">25</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">is_measurable_compl</span><span class=\"o\">)</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">XA.algebra</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">XA.algebra</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span>\n<span class=\"mi\">25</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"o\">:</span> <span class=\"n\">error</span><span class=\"o\">:</span>\n<span class=\"n\">don't</span> <span class=\"n\">know</span> <span class=\"n\">how</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">placeholder</span> <span class=\"o\">(</span><span class=\"bp\">?</span><span class=\"n\">is_measurable_Union</span><span class=\"o\">)</span>\n<span class=\"n\">context</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n<span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">XA.algebra</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">XA.algebra</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 218999224,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607281287
    },
    {
        "content": "<p>your pings are multiplying</p>",
        "id": 218999234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607281309
    },
    {
        "content": "<p>you don't need to ping everyone in the conversation every time you say something. People who are watching the chat will respond anyway</p>",
        "id": 218999298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607281370
    },
    {
        "content": "<p>OK I was trying to be polite.  I will skip pings going forward!</p>",
        "id": 218999311,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607281392
    },
    {
        "content": "<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">is_σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier_set</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">algebra</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>this should not have the <code>carrier_set</code> and <code>algebra</code> fields</p>",
        "id": 218999384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607281468
    },
    {
        "content": "<p>The main reason I declared the structure is to keep track of those two objects.  Do those fields come for free if I leave them out?  I.e. when I make an instance of a parameterized structure, are the values of the parameters that I used to create the structure available as an operation on the structure instance?  They are not available as fields, for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">foo</span> <span class=\"n\">ℕ</span>\n<span class=\"k\">#check</span> <span class=\"n\">bar.X</span> <span class=\"c1\">-- unknown identifier 'bar.X'</span>\n</code></pre></div>",
        "id": 219018155,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607288753
    },
    {
        "content": "<p>They are available by necessity because you have to pass them in</p>",
        "id": 219019714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607289376
    },
    {
        "content": "<p>You don't need <code>bar.X</code>, you just use <code>nat</code></p>",
        "id": 219019754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607289393
    },
    {
        "content": "<p>They are available but not encapsulated.  There are times in the life of a programmer when, even though the elements of a record are available on their own, it is convenient to pass around the record itself and then, at a later time, make use of its fields, without having to carry around the entire environment in which the record was created.</p>",
        "id": 219021360,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607290029
    },
    {
        "content": "<p>You can define your own helper function if you like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">7</span> <span class=\"bp\">×</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"kd\">def</span> <span class=\"n\">foo.X</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">foo</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"k\">#check</span> <span class=\"n\">bar.X</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">bar.X</span> <span class=\"bp\">=</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 219021591,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607290110
    },
    {
        "content": "<p>Note that in the original construction, there is no guarantee that <code>X</code> and <code>carrier_set</code> are equal.</p>",
        "id": 219022910,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607290642
    },
    {
        "content": "<p>OK</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">is_σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.carrier_set</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.algebra</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n</code></pre></div>",
        "id": 219023018,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607290682
    },
    {
        "content": "<p>Which makes <code>carrier_set</code> useless, because the other fields contain only proofs about X</p>",
        "id": 219023054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607290692
    },
    {
        "content": "<p>Your new version might work better with <code>abbreviation</code> instead of <code>def</code></p>",
        "id": 219023244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607290782
    },
    {
        "content": "<p>But as mentioned above, it's very hard to construct an example where those fields are useful</p>",
        "id": 219023394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607290832
    },
    {
        "content": "<p>You want a term <code>is_σ_algebra</code> to be an argument of those functions otherwise how will you ever call them?</p>",
        "id": 219023523,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607290886
    },
    {
        "content": "<p>Sorry working on it</p>",
        "id": 219023581,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607290913
    },
    {
        "content": "<p>Here we go:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.carrier_set</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">):=</span> <span class=\"n\">X</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.algebra</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- Example 1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">XA1</span><span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A1</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">XA1</span> <span class=\"c1\">-- XA : is_σ_algebra X A</span>\n<span class=\"k\">#check</span> <span class=\"n\">is_σ_algebra.carrier_set</span> <span class=\"n\">XA1</span> <span class=\"c1\">-- XA1.carrier_set : Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space</span> <span class=\"n\">XA1</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M1</span>\n\n<span class=\"c1\">-- Example 2</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">({</span><span class=\"bp\">⊤</span> <span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">XA2</span><span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A2</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A2</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M2</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space</span> <span class=\"n\">XA2</span>\n</code></pre></div>",
        "id": 219024038,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607291096
    },
    {
        "content": "<p>You are still referring to <code>A</code> in the body of <code>to_measurable_space</code>. Why not do this? (Apart from whether or not it will be useful downstream...)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>This uses the <code>def is_σ_algebra.algebra {X: Type*} {A : set X → Prop} (XA : is_σ_algebra X A) := A</code> that you just defined, using projection notation.</p>",
        "id": 219024495,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607291284
    },
    {
        "content": "<p>Thank you.  This is the definition I have wanted all along but, prior to declaring <code>is_σ_algebra.algebra</code>, it did not go through.</p>",
        "id": 219029708,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607297388
    },
    {
        "content": "<p>But now I can't get down to <code>measure_space</code>.  Here is the full example up to <code>measure_space</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.measurable_space</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.ennreal</span>\n<span class=\"kn\">import</span> <span class=\"n\">measure_theory.measure_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_σ_algebra</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_empty</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_compl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_measurable_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.carrier_set</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">):=</span> <span class=\"n\">X</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_σ_algebra.algebra</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">A</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_measurable_space</span>  <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">XA</span> <span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">measurable_space</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable'</span> <span class=\"o\">:=</span> <span class=\"n\">XA.algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_empty</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_compl</span><span class=\"o\">,</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"n\">XA.is_measurable_Union</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">A1</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"bp\">𝒫</span> <span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">XA1</span><span class=\"o\">:</span> <span class=\"n\">is_σ_algebra</span> <span class=\"n\">X</span> <span class=\"n\">A1</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_measurable_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_compl</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">finish</span><span class=\"o\">},</span>\n  <span class=\"n\">is_measurable_Union</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">A1</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">XA1</span> <span class=\"c1\">-- XA : is_σ_algebra X A</span>\n<span class=\"k\">#check</span> <span class=\"n\">is_σ_algebra.carrier_set</span> <span class=\"n\">XA1</span> <span class=\"c1\">-- XA1.carrier_set : Type</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M1</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">to_measurable_space</span> <span class=\"n\">XA1</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">XFT</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">fin.fintype</span> <span class=\"n\">_</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">classical</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">μ_M1</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">measure_theory.measure</span> <span class=\"n\">X</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">measure_theory.measure.of_measurable</span> <span class=\"n\">_</span> <span class=\"n\">M1</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">finset.card</span> <span class=\"n\">s.to_finset</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">sorry</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M1</span> <span class=\"c1\">-- M1 : measurable_space X</span>\n<span class=\"k\">#check</span> <span class=\"n\">μ_M1</span> <span class=\"c1\">-- μ_M1 : measure X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">M1_MS</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_measurable_space</span> <span class=\"o\">:=</span> <span class=\"n\">M1</span><span class=\"o\">,</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">μ_M1</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>This error is very confusing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">field</span> <span class=\"bp\">'</span><span class=\"n\">to_measurable_space'</span>\n  <span class=\"n\">M1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">measurable_space</span> <span class=\"bp\">⁇</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n</code></pre></div>\n<p>Similarly confusing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">field</span> <span class=\"bp\">'</span><span class=\"n\">volume'</span>\n  <span class=\"n\">μ_M1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">measure</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">measure</span> <span class=\"bp\">⁇</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n</code></pre></div>\n<p>The definition is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">measurable_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kn\">export</span> <span class=\"n\">measure_space</span> <span class=\"o\">(</span><span class=\"n\">volume</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If I leave out the <code>to_measurable_space</code> field in the hopes that it gets automatically derived since <code>measure_space</code> is an extension of <code>measurable_space</code>, I still get a problem with just</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">M1_MS</span> <span class=\"o\">:</span> <span class=\"n\">measure_space</span> <span class=\"n\">M1</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">volume</span> <span class=\"o\">:=</span> <span class=\"n\">μ_M1</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I still get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">measure_space</span> <span class=\"n\">M2</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">M2</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">measurable_space</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"bp\">?</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"bp\">?+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I am totally stumped here.</p>",
        "id": 219030687,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607298784
    },
    {
        "content": "<p>I think this is the part where I have to go back and undo removing the type class attribute, and maybe undo using instance versus def, because it worked before.</p>",
        "id": 219031840,
        "sender_full_name": "Lars Ericson",
        "timestamp": 1607300613
    }
]
[
    {
        "content": "<p>Is something like the following in the library somewhere?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_to_zmod_bijective</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 278478184,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649609787
    },
    {
        "content": "<p>We have something stronger, namely <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_congr\">docs#equiv.subtype_congr</a></p>",
        "id": 278478288,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649609910
    },
    {
        "content": "<p>That does not seem to give me what I want, at least not directly. How would I use it here?</p>",
        "id": 278478626,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649610286
    },
    {
        "content": "<p><code>↥(range n)</code> is the subtype <code>{m : ℕ // m ∈ range n}</code>. <code>zmod n</code> is <code>fin n</code>, which is <code>{m : ℕ // 0 &lt; m}</code>. Hence <code>equiv.subtype_congr mem_range : ↥(range n) ≃ zmod n</code>.</p>",
        "id": 278478768,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610468
    },
    {
        "content": "<p>If now you care about the fact that it's <code>coe</code> and not another function, you can try showing that it's equal to the <code>equiv.subtype_congr</code> above, which I believe is an API lemma already.</p>",
        "id": 278478837,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610542
    },
    {
        "content": "<p>You can also just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.nat_cast_zmod_val\">docs#zmod.nat_cast_zmod_val</a> along with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.val_lt\">docs#zmod.val_lt</a></p>",
        "id": 278478841,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649610549
    },
    {
        "content": "<p><code>equiv.subtype_congr mem_range</code> doesn't typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">equiv.subtype_congr</span> <span class=\"n\">mem_range</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">mem_range</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">↔</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">≃</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span>\n</code></pre></div>",
        "id": 278478846,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649610554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> does <code>equiv.subtype_congr</code> say what you think it says?</p>",
        "id": 278478865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649610593
    },
    {
        "content": "<p>Oh, I do not mean <code>equiv.subtype_congr</code> indeed...</p>",
        "id": 278478869,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610599
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.subtype_equiv_right\">docs#equiv.subtype_equiv_right</a></p>",
        "id": 278478916,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610623
    },
    {
        "content": "<p><code>equiv.subtype_equiv_right mem_range</code> also does not typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">equiv.subtype_equiv_right</span> <span class=\"n\">mem_range</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">mem_range</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">↔</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">),</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"bp\">?</span><span class=\"n\">m_3</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 278478951,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649610690
    },
    {
        "content": "<p>Remove one explicit argument: <code>equiv.subtype_equiv_right (λ _, mem_range)</code></p>",
        "id": 278479019,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610747
    },
    {
        "content": "<p><code>equiv.subtype_equiv_right (@mem_range _)</code> seems to look better.</p>",
        "id": 278479052,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649610819
    },
    {
        "content": "<p>Still, I don't see yet how to go from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"bp\">≃</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">m</span> <span class=\"bp\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">bijective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)),</span> <span class=\"bp\">↑</span><span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 278479115,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649610887
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.bijective\">docs#equiv.bijective</a></p>",
        "id": 278479127,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649610905
    },
    {
        "content": "<p>Try <code>convert (equiv.subtype_equiv_right $ λ _, mem_range).bijective</code>.</p>",
        "id": 278479139,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649610933
    },
    {
        "content": "<p>If you want a more mathlib-like lemma which you can't bash by the hacky approach I just gave you, here it is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.cast_zmod_inj_on</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">inj_on</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 278479307,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611137
    },
    {
        "content": "<p><code>convert (equiv.subtype_equiv_right (@mem_range n)).bijective</code> leaves me with two goals, <code>zmod n = {x // x &lt; n}</code> and <code>(λ (a : ↥(range n)), ↑a) == ⇑(equiv.subtype_equiv_right mem_range)</code>.<br>\nI'm already having problems with the first...</p>",
        "id": 278479340,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649611182
    },
    {
        "content": "<p>Oh, you must case on <code>n</code> first.</p>",
        "id": 278479407,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611224
    },
    {
        "content": "<p>Even then you will need to apply some <code>ext</code>s and prove that <code>x % (n+1) = x</code> when <code>x &lt; n+1</code>.</p>",
        "id": 278479532,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611333
    },
    {
        "content": "<p>This is likely very relevant: <a href=\"https://github.com/leanprover-community/mathlib/pull/10888\">#10888</a></p>",
        "id": 278479561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611382
    },
    {
        "content": "<p>In particular, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.mod_inj_on_Ico\">docs#nat.mod_inj_on_Ico</a></p>",
        "id": 278479572,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611397
    },
    {
        "content": "<p>What is <code>range</code> here? The original question isn't a mwe</p>",
        "id": 278479574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649611400
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/range\">docs#range</a></p>",
        "id": 278479590,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649611423
    },
    {
        "content": "<p>I assumed <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.range\">docs#finset.range</a></p>",
        "id": 278479642,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611449
    },
    {
        "content": "<p><code>range</code> is <code>finset.range</code></p>",
        "id": 278479645,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649611454
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.zmod.basic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">range_to_zmod_bijective</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">function.bijective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">contradiction</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"n\">zmod</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">equiv.subtype_equiv_right</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"o\">,</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">)),</span>\n  <span class=\"n\">convert</span> <span class=\"n\">e.bijective</span> <span class=\"n\">using</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">⟩,</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">fin.coe_of_nat_eq_mod</span><span class=\"o\">,</span> <span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">nat.succ_ne_zero</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_range</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">nat.mod_eq_of_lt</span> <span class=\"n\">x_property</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 278479653,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611465
    },
    {
        "content": "<p>But I think just proving this directly would be even shorterr</p>",
        "id": 278479664,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611481
    },
    {
        "content": "<p>What's the goal after the <code>convert</code> there?</p>",
        "id": 278479739,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649611563
    },
    {
        "content": "<p>Thanks.<br>\nWhat do you mean by \"this\" or by \"directly\"?</p>",
        "id": 278479743,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649611574
    },
    {
        "content": "<p>I mean proving this just by proving that the map is injective and surjective.</p>",
        "id": 278479764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611616
    },
    {
        "content": "<p>That's what I had in mind first (and would have tried had the answer just been \"no\") <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 278479819,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649611677
    },
    {
        "content": "<p>It might be worthwhile to have that equiv in mathlib in any case.</p>",
        "id": 278479879,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278479572\">said</a>:</p>\n<blockquote>\n<p>In particular, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.mod_inj_on_Ico\">docs#nat.mod_inj_on_Ico</a></p>\n</blockquote>\n<p>Let me insist on this.</p>",
        "id": 278479991,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611871
    },
    {
        "content": "<p>What's wrong with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.mod_eq_of_lt\">docs#nat.mod_eq_of_lt</a> ?</p>",
        "id": 278480058,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649611945
    },
    {
        "content": "<p>I believe Michael should first prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">nat.cast_zmod_inj_on</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">inj_on</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">nat.cast_zmod_bij_on</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Ico</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">bij_on</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">zmod</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 278480076,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649611983
    },
    {
        "content": "<p>Ah ok.</p>",
        "id": 278480088,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649612004
    },
    {
        "content": "<p>I'd rather get on with putting Legendre symbols right...</p>",
        "id": 278480145,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612069
    },
    {
        "content": "<p>Welcome to mathlib <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 278480155,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612090
    },
    {
        "content": "<p>Presumably these should be proved for <code>fin</code> too? (from which the zmod cases follow easily by a case split)</p>",
        "id": 278480181,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612136
    },
    {
        "content": "<p>BTW, what is preferred notation: <code>∑ (a : finset.range p), ...</code> vs. <code>∑ (a : Ico 0 p), ...</code>?</p>",
        "id": 278480188,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612151
    },
    {
        "content": "<p>Probably <code>∑ a in finset.range p</code></p>",
        "id": 278480235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612167
    },
    {
        "content": "<p>OK, that's what I did:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">legendre_sym_sum_zero</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">legendre_sym</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 278480270,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612229
    },
    {
        "content": "<p>... which does not mean the same but is what you want, unless you need to access the proof that <code>a &lt; p</code>.</p>",
        "id": 278480274,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612232
    },
    {
        "content": "<p>The \"old\" file has lots of <code>Ico</code>s...</p>",
        "id": 278480280,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612242
    },
    {
        "content": "<p><code>∑ (a : finset.range p)</code> is different to <code>∑ a in finset.range p</code></p>",
        "id": 278480298,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612270
    },
    {
        "content": "<p><code>∑ (a : finset.range p)</code> means <code>∑ a in (finset.univ : finset (finset.range p)),</code></p>",
        "id": 278480356,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612295
    },
    {
        "content": "<p>By now, <code>legendre_sym p a</code> reduces to <code>quadratic_char p (a : zmod p)</code>, so <code>a &lt; p</code> is not needed.</p>",
        "id": 278480378,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278480280\">said</a>:</p>\n<blockquote>\n<p>The \"old\" file has lots of <code>Ico</code>s...</p>\n</blockquote>\n<p>That's likely not a bad thing. How were they used?</p>",
        "id": 278480382,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612343
    },
    {
        "content": "<p>For stuff related to Gauss' Lemma and Eisenstein's Lemma, mostly.</p>",
        "id": 278480402,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612369
    },
    {
        "content": "<p>If I do <code>∑ (a ∈ finset.range p), legendre_sym p a = 0</code>, then I get an error message</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span>\n<span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n<span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">fintype</span> <span class=\"n\">ℤ</span>\n</code></pre></div>\n<p>Is that because somewhere <code>p ≠ 0</code> is needed?</p>",
        "id": 278480514,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612485
    },
    {
        "content": "<p>That's still not what I wrote</p>",
        "id": 278480522,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612495
    },
    {
        "content": "<p>You need to literally write <code>in</code></p>",
        "id": 278480570,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612523
    },
    {
        "content": "<p><code>∑ (a ∈ finset.range p),</code> is parsed by lean as <code>∑ a in (finset.univ : finset ℤ), ∑ a in (finset.univ : finset (a ∈ finset.range p)),</code></p>",
        "id": 278480604,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612571
    },
    {
        "content": "<p><code>∑ (a in finset.range p), legendre_sym p a = 0</code> gives <code>invalid expression starting at ...</code></p>",
        "id": 278480608,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612576
    },
    {
        "content": "<p>no parens</p>",
        "id": 278480613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649612584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278480235\">said</a>:</p>\n<blockquote>\n<p>Probably <code>∑ a in finset.range p</code></p>\n</blockquote>",
        "id": 278480618,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612599
    },
    {
        "content": "<p>Please copy what we write literally. Syntax is demanding.</p>",
        "id": 278480630,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612625
    },
    {
        "content": "<p>Now my proof breaks down... <span aria-label=\"disappointed\" class=\"emoji emoji-1f61e\" role=\"img\" title=\"disappointed\">:disappointed:</span></p>",
        "id": 278480635,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612642
    },
    {
        "content": "<p>I was using <code>fintype.sum_bijective</code> (to reduce to the similar sum when <code>a</code> runs through <code>zmod p</code>).</p>",
        "id": 278480689,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612689
    },
    {
        "content": "<p>That's okay. We have similar lemmas for the usual sums.</p>",
        "id": 278480701,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612707
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij\">docs#finset.sum_bij</a></p>",
        "id": 278480714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649612728
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_bij\">docs#finset.sum_bij</a> has lots of arguments; <a href=\"https://leanprover-community.github.io/mathlib_docs/find/fintype.sum_bijective\">docs#fintype.sum_bijective</a> uses <code>bijective</code> directly...</p>",
        "id": 278480800,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649612854
    },
    {
        "content": "<p>You can also use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype\">docs#finset.sum_subtype</a>` to get to a different form</p>",
        "id": 278480808,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649612870
    },
    {
        "content": "<p>I somehow find this difficult to use to get from the sum over <code>a in range p</code> to the original sum over <code>a : range p</code>.<br>\nSorry, I have not yet a lot of experience with how sums, sets, subtypes work.</p>",
        "id": 278481162,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649613253
    },
    {
        "content": "<p>One thing to keep in mind is that these finite sums are <em>always</em> sums over some finset (in fact, these are notation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a> ). That how I remember that <code>\\sum a : X, ...</code> is shorthand for the sum over <code>finset.univ : finset X</code>, and <code>\\sum a in S, ...</code> where <code>S</code> is a <code>finset X</code> is shorthand for the sum over the finset <code>S</code> itself.</p>",
        "id": 278481563,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649613791
    },
    {
        "content": "<p>In terms of what I am summing over, I don't really see a difference between <code>univ (range n)</code> and <code>range n</code>.</p>",
        "id": 278481721,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614001
    },
    {
        "content": "<p>Is the only difference that in the first case, <code>range n</code> (or rather, the corresponding subtype) is considered to be the universe, and in the second case, the universe is <code>nat</code>?</p>",
        "id": 278481756,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614064
    },
    {
        "content": "<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\\u</code> when using it in the body</p>",
        "id": 278481827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649614124
    },
    {
        "content": "<p>there is a theorem that says they are equal which you can use if you want to recover your old proof</p>",
        "id": 278481837,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649614154
    },
    {
        "content": "<p>Yes that's right, remember that a finset is a <em>term</em> not a type, and the type of the finset is different in each case</p>",
        "id": 278482078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649614469
    },
    {
        "content": "<p>Is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype\">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>",
        "id": 278482112,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278481827\">said</a>:</p>\n<blockquote>\n<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\\u</code> when using it in the body</p>\n</blockquote>\n<p>Is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype\">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>",
        "id": 278482136,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614553
    },
    {
        "content": "<p><code>univ (range n)</code> has type <code>finset (probably some term coerced to a type)</code> and <code>finset.range n</code> has type <code>finset nat</code></p>",
        "id": 278482137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649614560
    },
    {
        "content": "<p>There's this funny up-arrow which can coerce terms to types, so you can make a type out of a finset, but the question is whether it's a good idea!</p>",
        "id": 278482183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649614609
    },
    {
        "content": "<p>Anyway, I am still stuck at the proof. Right now, it looks like this.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">legendre_sym_sum_zero</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">legendre_sym</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">quadratic_char_sum_zero</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">],</span>\n  <span class=\"k\">let</span> <span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">he</span> <span class=\"o\">:=</span> <span class=\"n\">range_to_zmod_bijective</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nat.prime.ne_zero</span> <span class=\"n\">_inst_1.1</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">legendre_sym</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">quadratic_char</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"n\">finset.sum_bij</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">red</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span> <span class=\"o\">(</span><span class=\"n\">red</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">x'</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">he.injective</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">he.surjective</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">imp</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h.symm</span><span class=\"o\">⟩),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_coe</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 278482186,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614623
    },
    {
        "content": "<p>The stuff in the <code>have t := ...</code>was copied from the source of <code>fintype.sum_bijective</code> (or rather, <code>...prod...</code>); I would not claim I do really understand what it does.</p>",
        "id": 278482219,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614682
    },
    {
        "content": "<p>The goal I am left with at the last <code>sorry</code> is<br>\n<code>∑ (a : ℕ) in range p, legendre_sym p ↑a = ∑ (x : ↥(range p)), legendre_sym p ↑↑x</code></p>",
        "id": 278482273,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614709
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278482136\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278481827\">said</a>:</p>\n<blockquote>\n<p>yes, they are equal, except that the type of the variable in the two cases is different so you need a <code>.1</code> or <code>\\u</code> when using it in the body</p>\n</blockquote>\n<p>Is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_subtype\">docs#finset.sum_subtype</a> mentioned by Eric Wieser? It is not obvious to me how to use that.</p>\n</blockquote>\n<p>No, the most direct theorem stating this is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_finset_coe\">docs#finset.sum_finset_coe</a></p>",
        "id": 278482284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649614731
    },
    {
        "content": "<p>For some reason, a sum over something of the form <code>(x : &lt;type&gt;)</code> shows up again.</p>",
        "id": 278482295,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649614752
    },
    {
        "content": "<p>you can see from the number of up arrows involved in the theorem statement why we prefer the right hand side to the left side</p>",
        "id": 278482303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649614767
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum_coe_sort\">docs#finset.sum_coe_sort</a> is likely a better fit</p>",
        "id": 278482452,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649614946
    },
    {
        "content": "<p>Apart from the order of arguments, they look the same to me.</p>",
        "id": 278482491,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649615016
    },
    {
        "content": "<p>OK, now I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">legendre_sym_sum_zero</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"n\">a</span> <span class=\"k\">in</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">legendre_sym</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">quadratic_char_sum_zero</span> <span class=\"n\">p</span> <span class=\"n\">hp</span><span class=\"o\">],</span>\n  <span class=\"k\">let</span> <span class=\"n\">red</span> <span class=\"o\">:</span> <span class=\"n\">finset.range</span> <span class=\"n\">p</span> <span class=\"bp\">→</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">finset.sum_finset_coe</span> <span class=\"o\">((</span><span class=\"n\">legendre_sym</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">coe</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">p</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">fintype.sum_bijective</span> <span class=\"n\">red</span> <span class=\"o\">(</span><span class=\"n\">range_to_zmod_bijective</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">nat.prime.ne_zero</span> <span class=\"n\">_inst_1.1</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">legendre_sym</span><span class=\"o\">,</span> <span class=\"n\">red</span><span class=\"o\">,</span> <span class=\"n\">coe_coe</span><span class=\"o\">,</span> <span class=\"n\">int.cast_coe_nat</span><span class=\"o\">,</span> <span class=\"n\">comp_app</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>which looks reasonable to me.</p>",
        "id": 278482561,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649615079
    },
    {
        "content": "<p>What's the statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_sum_zero\">docs#quadratic_char_sum_zero</a>?</p>",
        "id": 278483896,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649617072
    },
    {
        "content": "<p>The above is not an MWE.</p>",
        "id": 278484023,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617210
    },
    {
        "content": "<p><code>quadratic_char_sum_zero</code> is a lemma further up in the file. The statement is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">quadratic_char_sum_zero</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∑</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">),</span> <span class=\"n\">quadratic_char</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>\n<p>and the definition of <code>quadratic_char</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">quadratic_char</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span>      <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>           <span class=\"k\">then</span>  <span class=\"mi\">0</span>\n<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span>  <span class=\"mi\">1</span>\n                        <span class=\"k\">else</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 278484094,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617294
    },
    {
        "content": "<p>I assume writing the sum over <code>(a : zmod p)</code> is less of an issue here, since <code>zmod p</code> is finite ?</p>",
        "id": 278484167,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617359
    },
    {
        "content": "<p>Yes, I just wonder if it would be easier to prove the fin.range version first</p>",
        "id": 278484242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649617444
    },
    {
        "content": "<p>The alternative being <code>a in univ (zmod p)</code> ?</p>",
        "id": 278484244,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617450
    },
    {
        "content": "<p>They're identical, one is syntax for the other</p>",
        "id": 278484252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649617462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484242\">said</a>:</p>\n<blockquote>\n<p>Yes, I just wonder if it would be easier to prove the fin.range version first</p>\n</blockquote>\n<p>I'm using the ring structure of <code>zmod p</code> in the proof.</p>",
        "id": 278484280,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617521
    },
    {
        "content": "<p>The idea is that there is some <code>b : zmod p</code> such that <code>quadratic_char p b = -1</code>; use multiplicativitiy of the character and the fact that multiplication by <code>b</code> is a permutation of <code>zmod p</code>.</p>",
        "id": 278484372,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649617608
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484094\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">quadratic_char</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span>      <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>           <span class=\"k\">then</span>  <span class=\"mi\">0</span>\n<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span>  <span class=\"mi\">1</span>\n                        <span class=\"k\">else</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>If I were to define this I would just do <code>a^(p/2)</code> which mathlib knows is a monoid_hom (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/pow_monoid_hom\">docs#pow_monoid_hom</a>), then show its image lies in the submonoid {0,1,-1} ⊆ zmod p, so I get a monoid_hom to the submonoid (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.mrange_restrict\">docs#monoid_hom.mrange_restrict</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion\">docs#submonoid.inclusion</a>), then compose with the monoid_hom {0,1,-1} →* ℤ (seems missing, but {0,1,-1} happens to be iso to sign_type and we have <a href=\"https://github.com/leanprover-community/mathlib/pull/12835/files#diff-2fa03f9bb4ca3adcc899c9a0e2eeb5413815e402ce17f64031939f84de58cce3R130\">cast_hom</a> there).</p>",
        "id": 278500064,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649640304
    },
    {
        "content": "<p>This would require <code>p</code> to be an odd prime to work, and I would like to avoid assuming this in the definition.</p>",
        "id": 278567016,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649689397
    },
    {
        "content": "<p>Would it, though?</p>",
        "id": 278567265,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649689481
    },
    {
        "content": "<p>Well, <code>a ^ (p /2)</code> would not in general be 0, 1, or -1. Consider, e.g., <code>p = 6</code>...</p>",
        "id": 278571432,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649691002
    },
    {
        "content": "<p>And if <code>p = 2</code>, there is no difference between 1 and -1 in <code>zmod p</code>.</p>",
        "id": 278571524,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649691029
    },
    {
        "content": "<p>But <code>p = 2</code> works as expected, right?</p>",
        "id": 278571527,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649691031
    },
    {
        "content": "<p>Maybe. The submonoid {0,1,-1} is the same as {0,1} in <code>zmod 2</code>; I don't know if this would cause problems.</p>",
        "id": 278571866,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649691145
    },
    {
        "content": "<p>I think you only intend to use it when p is a prime, right? Otherwise it's not a character (<code>if a ^ (p / 2) = 1 then  1</code> only do what you intend when p is a prime). So maybe just add <code>p.prime</code> as an argument of <code>quadratic_char</code>? I agree that <code>p=2</code> needs special treatment when defining the hom from the submonoid {0,1,-1} of zmod p to ℤ, but doing a if..else on <code>p</code> seems better than if..else on <code>a</code>.</p>",
        "id": 278575742,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649692750
    },
    {
        "content": "<p>My impression was that it is preferred to define total functions, so that adding <code>p.prime</code> as an argument should be avoided.</p>",
        "id": 278576272,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649692957
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278500064\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278484094\">said</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">quadratic_char</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span>      <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>           <span class=\"k\">then</span>  <span class=\"mi\">0</span>\n<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span>  <span class=\"mi\">1</span>\n                        <span class=\"k\">else</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n</code></pre></div>\n<p>If I were to define this I would just do <code>a^(p/2)</code> which mathlib knows is a monoid_hom (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/pow_monoid_hom\">docs#pow_monoid_hom</a>), then show its image lies in the submonoid {0,1,-1} ⊆ zmod p, so I get a monoid_hom to the submonoid (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_hom.mrange_restrict\">docs#monoid_hom.mrange_restrict</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.inclusion\">docs#submonoid.inclusion</a>), then compose with the monoid_hom {0,1,-1} →* ℤ (seems missing, but {0,1,-1} happens to be iso to sign_type and we have <a href=\"https://github.com/leanprover-community/mathlib/pull/12835/files#diff-2fa03f9bb4ca3adcc899c9a0e2eeb5413815e402ce17f64031939f84de58cce3R130\">cast_hom</a> there).</p>\n</blockquote>\n<p>(note that the sign stuff is merging today - we have <code>mul_equiv sign_type $ fin 3</code> but not the <code>zmod</code> version - this should be doable by composing the mul_equiv from zmod to fin, but I don't think that exists, especially with the right definitional equalities)</p>",
        "id": 278576396,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649693019
    },
    {
        "content": "<p>At some point, one will have to show that <code>a ^ (p / 2)</code> is 1 or -1 when <code>a \\ne 0</code> and <code>p</code> is a prime; the question is perhaps, when. I imagine it would be a bit awkward to do that within the definition...</p>",
        "id": 278576487,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649693048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278576272\">said</a>:</p>\n<blockquote>\n<p>My impression was that it is preferred to define total functions, so that adding <code>p.prime</code> as an argument should be avoided.</p>\n</blockquote>\n<p>this is usually if it's more convenient; it seems here that it's less so, especially as we get less bundling</p>",
        "id": 278576499,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649693053
    },
    {
        "content": "<p>\"mul_equiv from zmod to fin\" it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_equiv.refl\">docs#mul_equiv.refl</a></p>",
        "id": 278577578,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649693530
    },
    {
        "content": "<p>of course :)</p>",
        "id": 278577720,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649693617
    },
    {
        "content": "<p>It's not necessarily a character when p is not prime but I guess we are fine with junk values :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278576487\">said</a>:</p>\n<blockquote>\n<p>At some point, one will have to show that <code>a ^ (p / 2)</code> is 1 or -1 when <code>a \\ne 0</code> and <code>p</code> is a prime; the question is perhaps, when. I imagine it would be a bit awkward to do that within the definition...</p>\n</blockquote>\n<p>I would first define the {0,1,-1} submonoid (and the hom to ℤ), then prove the lemma saying <code>pow_monoid_hom (p/2) a ∈ the submonoid</code> under the assumptions,  then the proof of the submonoid inclusion should be short enough to fit in <code>submonoid.inclusion (by { ... })</code>.</p>",
        "id": 278578432,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649693938
    },
    {
        "content": "<p>Defining a monoid_hom from an arbitrary finite field F_q to ℂ would facilitate the definition of higher (cubic, etc.) characters, but it depends on the choice of a (q-1)th primitive root both in the finite field and in ℂ ...</p>",
        "id": 278583970,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649696237
    },
    {
        "content": "<p>In some way, I guess this is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut\">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... under our definition, <code>is_cyclotomic_extension \\C \\C S</code> for all S. We haven't made a <code>cyclotomic_extension</code> instance for either C or F_q (and I guess F_q is more work...)</p>",
        "id": 278584547,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649696454
    },
    {
        "content": "<p>oh, we only need the F_q instances, but I digress</p>",
        "id": 278584760,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649696543
    },
    {
        "content": "<p>What would be the advantage(s) of doing it the way Junyan Xu suggests over leaving the definition as is and proving suitable API lemmas (including</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">quadratic_char_hom</span> <span class=\"o\">:</span> <span class=\"n\">zmod</span> <span class=\"n\">p</span> <span class=\"bp\">→*</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">quadratic_char</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">quadratic_char_one</span>  <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">quadratic_char_mul</span> <span class=\"n\">p</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>)?</p>",
        "id": 278586254,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649697151
    },
    {
        "content": "<p>I think the main difference is that if I understand the above correctly, the latter (with suitable conditions) lets you pick a definitionally nicer <code>to_fun</code> that avoids the need for the <code>if</code>s</p>",
        "id": 278588160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649698049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278584547\">said</a>:</p>\n<blockquote>\n<p>... <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut\">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... </p>\n</blockquote>\n<p>I don't think there can be an algebra_map from char p to char 0 ...</p>\n<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's \"unique\" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>",
        "id": 278588305,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649698102
    },
    {
        "content": "<p>One could define <code>quadratic_char</code> for finite fields of odd characteristic (or maybe also define it as the indicator function of the nonzero elements when the characteristic is 2) as a <code>monoid_hom</code> into the integers. Maybe this is a suitable level of generality?</p>",
        "id": 278588620,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649698253
    },
    {
        "content": "<p>ah, d'ah, there is I think somewhere an induced map to the <code>roots_of_unity</code>, but there was some issues with +/* mixing.</p>",
        "id": 278588847,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649698342
    },
    {
        "content": "<p>I feel like I'm getting confused and talking about the wrong things right now, sorry. I feel like most of the glue is there, though.</p>",
        "id": 278590547,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649698928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305\">said</a>:</p>\n<blockquote>\n<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's \"unique\" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>\n</blockquote>\n<p>I think there should be multiplicative characters into any ring (or even monoid with zero). Why restrict to ℂ as the target?</p>",
        "id": 278590953,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649699131
    },
    {
        "content": "<p>As a side question, is there a way to exress that <code>ψ</code> is an <em>additive</em> character from a field <code>F</code> into some ring (or mutiplicative monoid) <code>R</code>? I.e., <code>ψ(x+y) = ψ(x)*ψ(y)</code> for all <code>x y : F</code>.</p>",
        "id": 278591274,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649699276
    },
    {
        "content": "<p>You have to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiplicative\">docs#multiplicative</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/additive\">docs#additive</a></p>",
        "id": 278591470,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649699343
    },
    {
        "content": "<p>That looks a bit painful. In particular, since there are two possibilities and no obvious reason to prefer one over the other...</p>",
        "id": 278591764,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649699450
    },
    {
        "content": "<p>Usually the choice is obvious, and we wrap the weaker of the two types in <code>multiplicative</code> or <code>additive</code></p>",
        "id": 278592521,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649699772
    },
    {
        "content": "<p>In practice we tend not to use the bundled version as the canonical API for those cases though; but it's still useful for golfing proofs</p>",
        "id": 278592650,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649699832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278584547\">said</a>:</p>\n<blockquote>\n<p>... <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.from_zeta_aut\">docs#is_cyclotomic_extension.from_zeta_aut</a> composed with an algebra map... </p>\n</blockquote>\n<p>I don't think there can be an algebra_map from char p to char 0 ...</p>\n<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's \"unique\" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>\n</blockquote>\n<p>the real answer to this is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.power_basis\">docs#is_primitive_root.power_basis</a> + <a href=\"https://leanprover-community.github.io/mathlib_docs/find/power_basis.lift\">docs#power_basis.lift</a>, sorry about all the nonsense I wrote before</p>",
        "id": 278598672,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649702298
    },
    {
        "content": "<p>I'm not sure if we ever figured out weaker conditions for <code>is_primitive_root.power_basis</code>, but I still need to write <code>power_basis.map_conjugate</code> (+ get back to flt regular...)</p>",
        "id": 278598782,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649702350
    },
    {
        "content": "<p>wait, no, still wrong. do we not have something that just sends the generator of a power-basis to something, and then just says \"yes that's good enough\"? maybe just for <code>basis</code></p>",
        "id": 278599006,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649702448
    },
    {
        "content": "<p>I am playing around with the following.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.finite.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">char</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">quadratic_char</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"k\">then</span> <span class=\"mi\">0</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"n\">a</span><span class=\"bp\">^</span><span class=\"o\">((</span><span class=\"n\">fintype.card</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"bp\">-</span><span class=\"mi\">1</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">char</span>\n</code></pre></div>\n<p>but get the complaint that Lean doesn't know how to deduce that <code>a^((fintype.card F) / 2) = 1</code> is decidable.<br>\nWhat is the best way to get around that?</p>",
        "id": 278601766,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649703742
    },
    {
        "content": "<p>... and even <code>decidable (a = 0)</code>.</p>",
        "id": 278602474,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649704136
    },
    {
        "content": "<p><code>decidable_eq F</code> or just <code>classical</code> or something</p>",
        "id": 278602719,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1649704268
    },
    {
        "content": "<p><code>[decidable_eq F]</code> seems to be working; thanks.</p>",
        "id": 278602998,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649704415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479359\">Michael Stoll</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278590953\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278588305\">said</a>:</p>\n<blockquote>\n<p>The current definition of <code>quadratic_char</code> may be fine if it's just a standalone thing, but it doesn't seem to fit in the big picture as a special case of multiplicative characters from (the multiplicative group) of a finite field to ℂ. With the current definition the proofs may be less reusable. I could see that quadratic character is indeed somewhat special though, as it's \"unique\" because {1,-1} has trivial automorphism group, and it fits in ℤ with no need of ℂ, so maybe it warrants special treatment.</p>\n</blockquote>\n<p>I think there should be multiplicative characters into any ring (or even monoid with zero). Why restrict to ℂ as the target?</p>\n</blockquote>\n<p>I guess this would just be a <code>monoid_with_zero_hom</code>?</p>",
        "id": 278611708,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649708674
    },
    {
        "content": "<p>Note Ashvni's work on Dirichlet characters here: <a href=\"https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean\">https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean</a> . I was telling her to PR it only today :-)</p>",
        "id": 278631312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649720671
    },
    {
        "content": "<p><code>monoid_with_zero_hom</code> would be the correct type; what I am concerned with (and I think Eric also) is how to construct terms of that type. I don't think it needs to involve power basis or cyclotomic extension; since the multiplicative group of F_q is cyclic of order (q-1) so given a generator of (F_q)ˣ and an element x of another monoid satisfying x^(q-1) = 1 there's a unique monoid_with_zero_hom sending the generator to x. In the quadratic case with q odd, x is -1, and it makes no difference which generator we choose. There are some API useful for constructing the hom from (F_q)ˣ (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.zmod_equiv_zpowers\">docs#is_primitive_root.zmod_equiv_zpowers</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod.lift\">docs#zmod.lift</a>), but they don't include the zero element, haven't been specialized to the case of cyclic groups, and necessitates going back and forth between multiplicative and additive monoids. Although this approach involves a superfluous generator, it can be relatively easily connected to the a^(q/2) definition: the character is of order n (here n = 2) iff the its image has order n, iff its kernel is the subgroup of order (q-1)/n; since a ↦ a^((q-1)/n) has the same kernel and image the nth roots of unity, the character factors as a ↦ a^((q-1)/n) composed with a hom from the nth roots of unity in the domain to the codomain (iso onto the image of the character). I admit this is maybe too complicated for the current purpose.</p>\n<p>Dirichlet characters have domain zmod n (n not necessarily prime) instead of a finite field, so that work seems complementary to the current discussion.</p>",
        "id": 278638616,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1649728072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/bijection.20.60range.20n.20.E2.86.92.20zmod.20n.60.3F/near/278631312\">said</a>:</p>\n<blockquote>\n<p>Note Ashvni's work on Dirichlet characters here: <a href=\"https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean\">https://github.com/leanprover-community/mathlib/blob/p-adic/src/number_theory/dirichlet_character.lean</a> . I was telling her to PR itI only today :-)</p>\n</blockquote>\n<p>Is this going in the direction of Dirichlet's theorem on primes in arithmetic progressions? That would be great!</p>",
        "id": 278667664,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649755428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"398581\">@Mantas Baksys</span>, you might be interested in this.</p>",
        "id": 278667980,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649755606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> it's going in the direction of defining generalised Bernoulli numbers and showing that they're values of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">p</span></span></span></span>-adic L-functions! Interestingly, I have seen with my own eyes a proof of Dirichlet's theorem in Lean; it was written by a computer program Metamath 0, which translated the proof which they have in metamath into a 30 megabyte unreadable but compiling Lean proof.</p>",
        "id": 278676763,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649761404
    },
    {
        "content": "<p>The relevant question is perhaps rather whether Dirichlet's theorem on primes in AP is in mathlib, so that one can use the statement in further work...</p>",
        "id": 278686151,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649767113
    },
    {
        "content": "<p>Nope, the closest we have is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.exists_prime_ge_modeq_one\">docs#nat.exists_prime_ge_modeq_one</a> right now in mathlib unfortunately</p>",
        "id": 278686933,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1649767536
    },
    {
        "content": "<p>Do we have (classical, not p-adic) L-functions?</p>",
        "id": 278687287,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649767734
    },
    {
        "content": "<p>Complex analysis didn't exist until a couple of months ago, so anything related to it is in very early stages</p>",
        "id": 278687587,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649767915
    },
    {
        "content": "<p>Michael -- the joke is that we are going to end up with p-adic zeta functions before the Riemann zeta function! Unfortunately recent progress in complex analysis has made me more worried about whether I can pull this joke off :-/</p>",
        "id": 278688025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649768139
    },
    {
        "content": "<p>That's a bad joke, as far as I am concerned... <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 278688098,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649768178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span>, you have to click on the topic you want to respond to. Else, your message will just be lost in the stream of messages.</p>",
        "id": 278688339,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649768313
    },
    {
        "content": "<p>I've moved the message.</p>",
        "id": 278688419,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1649768351
    },
    {
        "content": "<p>Sorry, I didn't notice I had another message in focus.</p>",
        "id": 278688778,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649768495
    },
    {
        "content": "<p>I'm struggling with additive characters on a (finite) field <code>F</code> with values in a commutative ring <code>R</code>, which I try to define as <code>ψ : (multiplicative F) →* R</code>.<br>\nNow, for <code>a : F</code> I would like to define the character that sends <code>x : F</code> to <code>ψ (a*x)</code> (where the multiplication is that of <code>F</code>).<br>\nI have got this far:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span> <span class=\"n\">field_theory.finite.basic</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mul_shift'</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">ψ</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_shift_one</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">mul_shift'</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_shift'</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₀</span><span class=\"o\">,</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">h₀</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ψ.map_one'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_shift_mul</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">mul_shift'</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul_shift'</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">mul_shift'</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mul_shift'</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">ψ.map_mul'</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Define the multiplicative shift of an additive character -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">mul_shift</span> <span class=\"o\">(</span><span class=\"n\">ψ</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">multiplicative</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→*</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">mul_shift'</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">mul_shift_one</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">mul_shift_mul</span> <span class=\"n\">F</span> <span class=\"n\">R</span> <span class=\"n\">ψ</span> <span class=\"n\">a</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I am having problems with getting the types in <code>h₂</code> right: all the \"outer\" multiplications should be the multiplication of <code>F</code>, whereas the \"inner\" one in the left should be that of <code>multiplicative F</code>. But it is very hard to do this, since Lean seems to convert very eagerly between the two -- I somehow cannot get it to interpret the inner multiplication correctly.<br>\nAny suggestions?</p>",
        "id": 278742205,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649791861
    },
    {
        "content": "<p>You should never cast between the two types, use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiplicative.to_add\">docs#multiplicative.to_add</a> (so <code>x.to_add</code> instead of <code>(x : F)</code>)</p>",
        "id": 278742552,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649792036
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiplicative.of_add\">docs#multiplicative.of_add</a> in the other direction</p>",
        "id": 278742703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649792102
    },
    {
        "content": "<p>I think in this case you just want <code>φ.comp (add_monoid_hom.mul_right a).to_multiplicative</code></p>",
        "id": 278743095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649792308
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.to_multiplicative\">docs#add_monoid_hom.to_multiplicative</a></p>",
        "id": 278743121,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649792329
    },
    {
        "content": "<p>Ah, that makes sense. I was doing things in an overly pedestrian way...</p>",
        "id": 278743356,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1649792462
    },
    {
        "content": "<p>It has taken people quite a while to figure out how to make these things work effectively. There are all sorts of issues in the background involving whether definitions should be irreducible etc, and of course figuring out how to make it all work in one theorem prover might not give you answers about how best to do it in another one. These things are often just learnt by people asking here about how to do it.</p>",
        "id": 278761121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649801856
    }
]
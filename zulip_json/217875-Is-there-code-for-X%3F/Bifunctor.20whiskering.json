[
    {
        "content": "<p>Do we have this bifunctor version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.whiskering_right\">docs#category_theory.whiskering_right</a>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span> <span class=\"bp\">⥤</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>This could probably even be functorial in <code>F</code>, though I don't think I need that for the application I have in mind.</p>",
        "id": 289835706,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1657988781
    },
    {
        "content": "<p>If we have the equivalence <code>(α ⥤ β × γ) ≅ ((α ⥤ β) × (α ⥤ γ))</code> then this should follow from uncurrying, applying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.whiskering_right\">docs#category_theory.whiskering_right</a>, applying this equivalence and then currying back.</p>",
        "id": 289836408,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1657989867
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.prod'\">docs#category_theory.functor.prod'</a> , but I don't think we know that it is functorial / is an equivalence.</p>",
        "id": 289836699,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657990242
    },
    {
        "content": "<p>We do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_trans.prod\">docs#category_theory.nat_trans.prod</a> though.</p>",
        "id": 289836780,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1657990339
    },
    {
        "content": "<p>I tried doing the equivalence <code>(α ⥤ β × γ) ≅ ((α ⥤ β) × (α ⥤ γ))</code> but I'm stuck at giving <code>unit_iso</code>. Here is my code if someone wants to give it a shot.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.products.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"n\">u₃</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">v₃</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n          <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n          <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₃</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₃</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">functor_prod_functor_equiv</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"bp\">≌</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">functor</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">F.1.prod'</span> <span class=\"n\">F.2</span><span class=\"o\">,</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f.1.app</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f.2.app</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"o\">(</span><span class=\"n\">category_theory.prod.fst</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"o\">(</span><span class=\"n\">category_theory.prod.snd</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)⟩,</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"o\">⟨{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n       <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">functor.comp_map</span><span class=\"o\">,</span> <span class=\"n\">prod.fst_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">prod_comp_fst</span><span class=\"o\">,</span> <span class=\"n\">α.naturality</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n     <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">α.app</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n       <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">functor.comp_map</span><span class=\"o\">,</span> <span class=\"n\">prod.snd_map</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">prod_comp_snd</span><span class=\"o\">,</span> <span class=\"n\">α.naturality</span><span class=\"o\">]</span> <span class=\"o\">}⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">unit_iso</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">counit_iso</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 289846557,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658003805
    },
    {
        "content": "<p>I tried doing <code>convert iso.refl (𝟭 ((A ⥤ B) × (A ⥤ C)))</code> for the <code>unit_iso</code> field and then proving equality of functors through <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext\">docs#category_theory.functor.ext</a>,  but I think that's probably a bad approach since the documentation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.functor.ext\">docs#category_theory.functor.ext</a> explicitly says that this isn't something that you usually want to use.</p>",
        "id": 289846635,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658003942
    },
    {
        "content": "<p>I would use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_iso.of_components\">docs#category_theory.nat_iso.of_components</a></p>",
        "id": 289847715,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658005571
    },
    {
        "content": "<p>You (almost) never want to use equality of functors.</p>",
        "id": 289847788,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658005715
    },
    {
        "content": "<p>Is equality of natural transformations OK? Where are these arcane rules written down?</p>",
        "id": 289849863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658009175
    },
    {
        "content": "<p>Yes those are okay! Because a natural transformation is just a family of morphisms satisfying some prop, and since it's okay to talk about equality of (a family of) morphisms, it's then okay to talk about equality of natural transformations.</p>",
        "id": 289849950,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658009348
    },
    {
        "content": "<p>If a functor didn't have some data related to objects then there would be no issue with equality of functors.</p>",
        "id": 289849963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658009381
    },
    {
        "content": "<p>I think the general story is that in an n-category you should only talk about equality of n-cells</p>",
        "id": 289850028,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658009460
    },
    {
        "content": "<p>So all bets are off in an infinity category</p>",
        "id": 289850039,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658009491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> How would construct the following equivalence without appealing to equality of functors?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.products.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"n\">u₃</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">v₃</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n          <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n          <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₃</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₃</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n          <span class=\"o\">{</span><span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₄</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₄</span><span class=\"o\">}</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">F.1</span><span class=\"o\">,</span> <span class=\"n\">F.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 289855447,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658018531
    },
    {
        "content": "<p>Oh nevermind I can just do <code>{ hom := (𝟙 F.1, 𝟙 F.2), inv := (𝟙 F.1, 𝟙 F.2) }</code></p>",
        "id": 289855606,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658018854
    },
    {
        "content": "<p>Actually I think the following should be added in <code>category_theory.products.basic</code>. What's a good name for it?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">X.1</span><span class=\"o\">,</span> <span class=\"n\">X.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 289855728,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658019094
    },
    {
        "content": "<p>I managed to complete this equivalence. <a href=\"https://github.com/leanprover-community/mathlib/pull/15445\">#15445</a></p>",
        "id": 289857938,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658022937
    },
    {
        "content": "<p>(x×y)^z is isomorphic to x^z×y^z in any <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.cartesian_closed\">docs#category_theory.cartesian_closed</a> category according to <a href=\"https://en.wikipedia.org/wiki/Cartesian_closed_category#Equational_theory\">Wikipedia</a>; maybe we should do it in this generality? And it would give an isomorphism (involving functor equality), not just an equivalence. However I can't find this fact in category_theory.closed.cartesian, and mathlib doesn't know <code>Cat</code> is an example apparently.</p>",
        "id": 289860357,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658026593
    },
    {
        "content": "<p>Here are two versions of <code>functor_prod_functor_equiv</code> inspired by the adjunction between <code>×</code> and <code>⟶</code> in general cartesian closed categories; one version uses <code>eq_to_iso</code> and another one is closer to <a href=\"https://github.com/leanprover-community/mathlib/pull/15445\">#15445</a>. I'm not sure which one is faster and whether <code>eq_to_iso</code> will cause problems downstream.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.currying</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"n\">u₃</span> <span class=\"n\">v₁</span> <span class=\"n\">v₂</span> <span class=\"n\">v₃</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n          <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n          <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₃</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₃</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"n\">curry_obj</span> <span class=\"bp\">$</span> <span class=\"n\">functor.prod'</span>\n  <span class=\"o\">(</span><span class=\"n\">uncurry.obj</span> <span class=\"bp\">$</span> <span class=\"n\">category_theory.prod.fst</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">uncurry.obj</span> <span class=\"bp\">$</span> <span class=\"n\">category_theory.prod.snd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">functor.prod'</span>\n  <span class=\"o\">(</span><span class=\"n\">curry_obj</span> <span class=\"bp\">$</span> <span class=\"n\">uncurry.obj</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">category_theory.prod.fst</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">curry_obj</span> <span class=\"bp\">$</span> <span class=\"n\">uncurry.obj</span> <span class=\"o\">(</span><span class=\"mi\">𝟭</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">category_theory.prod.snd</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">eq_to_hom_fst</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">eq_to_hom</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.fst</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_to_hom_map</span> <span class=\"o\">(</span><span class=\"n\">category_theory.prod.fst</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">eq_to_hom_snd</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">eq_to_hom</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">prod.snd</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_to_hom_map</span> <span class=\"o\">(</span><span class=\"n\">category_theory.prod.snd</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hom_inv_id'</span> <span class=\"o\">:</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">⋙</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟭</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">prod_functor_to_functor_prod</span><span class=\"o\">,</span> <span class=\"n\">functor_prod_to_prod_functor</span><span class=\"o\">,</span> <span class=\"n\">curry_obj</span><span class=\"o\">,</span> <span class=\"n\">uncurry</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">category_theory.functor.ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟨</span><span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩⟩,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inv_hom_id'</span> <span class=\"o\">:</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">⋙</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟭</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">prod_functor_to_functor_prod</span><span class=\"o\">,</span> <span class=\"n\">functor_prod_to_prod_functor</span><span class=\"o\">,</span> <span class=\"n\">curry_obj</span><span class=\"o\">,</span> <span class=\"n\">uncurry</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">category_theory.functor.ext</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩,</span> <span class=\"n\">dsimp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">functor_prod_functor_equiv</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≌</span> <span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">unit_iso</span> <span class=\"o\">:=</span> <span class=\"n\">eq_to_iso</span> <span class=\"o\">(</span><span class=\"n\">hom_inv_id'</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">counit_iso</span> <span class=\"o\">:=</span> <span class=\"n\">eq_to_iso</span> <span class=\"o\">(</span><span class=\"n\">inv_hom_id'</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">prod.eta_iso</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X.1</span><span class=\"o\">,</span> <span class=\"n\">X.2</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">unit_iso</span> <span class=\"o\">:</span>\n  <span class=\"mi\">𝟭</span> <span class=\"n\">_</span> <span class=\"bp\">≅</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">⋙</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_iso.of_components</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">prod.eta_iso</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">≪≫</span> <span class=\"n\">iso.prod</span>\n  <span class=\"o\">(</span><span class=\"n\">nat_iso.of_components</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">iso.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"n\">nat_iso.of_components</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">iso.refl</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">simp</span> <span class=\"o\">}))</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">@[simps]</span> <span class=\"kd\">def</span> <span class=\"n\">counit_iso</span> <span class=\"o\">:</span>\n  <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">⋙</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">≅</span> <span class=\"mi\">𝟭</span> <span class=\"n\">_</span> <span class=\"o\">:=</span>\n<span class=\"n\">nat_iso.of_components</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">nat_iso.of_components</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">prod.eta_iso</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">$</span>\n    <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intros</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">tidy</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">functor_prod_functor_equiv'</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"bp\">×</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">≌</span> <span class=\"n\">A</span> <span class=\"bp\">⥤</span> <span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">functor</span> <span class=\"o\">:=</span> <span class=\"n\">prod_functor_to_functor_prod</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">inverse</span> <span class=\"o\">:=</span> <span class=\"n\">functor_prod_to_prod_functor</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">unit_iso</span> <span class=\"o\">:=</span> <span class=\"n\">unit_iso</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">counit_iso</span> <span class=\"o\">:=</span> <span class=\"n\">counit_iso</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n  <span class=\"n\">functor_unit_iso_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">curry_obj</span><span class=\"o\">],</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 289872801,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658047317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Bifunctor.20whiskering/near/289855728\">said</a>:</p>\n<blockquote>\n<p>Actually I think the following should be added in <code>category_theory.products.basic</code>. What's a good name for it?</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">×</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">≅</span> <span class=\"o\">(</span><span class=\"n\">X.1</span><span class=\"o\">,</span> <span class=\"n\">X.2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>The corresponding non-category statement is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.mk.eta\">docs#prod.mk.eta</a>.</p>",
        "id": 289874780,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658050119
    },
    {
        "content": "<p>And the original desired construction can be achieved more directly as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.currying</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">δ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">δ</span><span class=\"o\">]</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span> <span class=\"bp\">⥤</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"bp\">⥤</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">⥤</span> <span class=\"n\">δ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">curry_obj</span> <span class=\"bp\">$</span> <span class=\"n\">curry_obj</span> <span class=\"bp\">$</span> <span class=\"n\">functor.prod'</span>\n  <span class=\"o\">(</span><span class=\"n\">uncurry.obj</span> <span class=\"bp\">$</span> <span class=\"n\">category_theory.prod.fst</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">uncurry.obj</span> <span class=\"bp\">$</span> <span class=\"n\">category_theory.prod.snd</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">⋙</span> <span class=\"n\">uncurry.obj</span> <span class=\"n\">F</span>\n</code></pre></div>",
        "id": 289902154,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1658088653
    },
    {
        "content": "<p>Nice! It would be great to have the full functorial version though.</p>",
        "id": 289912755,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658105107
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15504\">#15504</a></p>",
        "id": 290041392,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1658191672
    }
]
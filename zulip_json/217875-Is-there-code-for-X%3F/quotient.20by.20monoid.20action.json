[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/S1.20and.20other.20topological.20spaces/near/210912022\">said</a>:</p>\n<blockquote>\n<p>It's complicated to describe in this case. The best I can come up with is this: The forgetful functor from sets with a group action to sets with a monoid action has a left adjoint. (It's a souped up version of the groupification functor from monoids to groups.) The equivalence relation is \"essentially\" the equivalence relation induced by the group action via this left adjoint (by this I mean they have the same quotients, but there can be some analogues of zero divisors which will complicate things). I don't know if any of this makes sense.</p>\n</blockquote>\n<p>This was an educational exercise in universal algebra, and I think I've verified that it all works (formalized in Lean!) while also proving some universal properties along the way.  I defined the <em>universal enveloping group</em> of a monoid (the non-commutative version of the Grothendieck group; I found the nomenclature in Bergman's book \"An Invitation to General Algebra and Universal Constructions\"), showed it was the universal group that factors homomorphisms from a monoid to a group, defined a \"universal enveloping group action\" associated to a monoid action, which factors homomorphisms of monoid actions  to group actions, then defined two quotients.  The first was <code>quot (λ (x y : α), ∃ (a : M), x = a • y)</code> and the second was the quotient of the universal enveloping group action by the universal enveloping group.  Lastly, I showed there was an equivalence between these two quotients.</p>\n<p>The code is too big for posting here, so here's a link to a gist: <a href=\"https://gist.github.com/kmill/af2bbe856ea66e147ef699365a85b763\">https://gist.github.com/kmill/af2bbe856ea66e147ef699365a85b763</a></p>\n<p>I didn't show anything was functorial or explicitly adjoint.</p>",
        "id": 210973472,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600850423
    },
    {
        "content": "<p>After all this, it seems to me it's all just a fancy way of saying that equivalence relation you're quotienting by is the one generated by <code>(λ (x y : α), ∃ (a : M), x = a • y)</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 210973700,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600850559
    },
    {
        "content": "<p>Universal enveloping algebras are important in the theory of Lie algebras and associative algebras; there was a recent PR by Oliver Nash about them. The reason I mention this is that when we were starting on schemes I needed localisation of rings and Kenny Lau formalised it and got it into mathlib, and then later on we realised that localisation started earlier in the story and there should be a localisation theory for monoids, which Amelia Livingston wrote and it involved a major refactor of localisation of rings.</p>",
        "id": 210986871,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600859141
    },
    {
        "content": "<p>If there's some sort of analogous story here, where the universal enveloping group should be done before the universal enveloping algebra, or perhaps some more general theory of universal enveloping stuff should be developed, then now would be a good time to figure out how to formalise this stuff in a good generality as far as mathlib goes.</p>",
        "id": 210986958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600859211
    },
    {
        "content": "<p>Just thinking about it now, I was very enthusiastic when Oliver mentioned universal enveloping algebras to me (because I need them for the Langlands program in order to state the definition of an automorphic form) but now I'm worried we've \"started too far down the line\" like we did when localising rings instead of monoids. Note that Oliver's PR is still open (he's having a Lean break right now before he comes to work for me doing Lean full time in April :D)</p>",
        "id": 210987093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600859307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>'s PR (<a href=\"https://github.com/leanprover-community/mathlib/issues/4041\">#4041</a>) is still in progress --- we did a refactor of <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>'s construction of the tensor algebra as a quotient of the free algebra first. The universal enveloping algebra construction will then be done as a quotient of the tensor algebra, I guess.</p>",
        "id": 210987264,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1600859460
    },
    {
        "content": "<p>I actually had a go at rebasing that PR on top of the refactored <code>ring_quot</code> and <code>tensor_algebra</code> stuff yesterday evening and ran into annoying issues with typeclass inference.</p>",
        "id": 210987447,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600859622
    },
    {
        "content": "<p>The issue is that the tensor algebra only has the structure of a semiring but I need the actual ring structure on the quotient. This is theoretically fine because our scalars contain -1 and so we get the subtraction by multiplying by that. But there are then two semiring structures: the original one and the one provided by <code>ring.to_semiring</code>, and they're not definitionally equal.</p>",
        "id": 210987714,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600859849
    },
    {
        "content": "<p>And for the Lie algebra stuff to work, the algebra structure should use the semiring structure from <code>ring.to_semiring</code> but the algebra structure on <code>tensor_algebra</code> is the other one.</p>",
        "id": 210987801,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600859915
    },
    {
        "content": "<p>I'm fairly sure I can massage this all into a good form, especially as corresponding problems must arise anywhere in the linear algebra parts of the library where we use subtraction, but I couldn't quite get it to work yesterday</p>",
        "id": 210987937,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600860006
    },
    {
        "content": "<p>Finally, I take the point Kevin is making about the lessons learned from ring localisation (I am aware of this history though I didn't follow it in detail). I'll have a little time again this evening and will look again, bearing in mind that it might be worth holding off till some more basic universal enveloping structure is in place.</p>",
        "id": 210988112,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600860140
    },
    {
        "content": "<p>I'm definitely not saying \"we're doing it wrong\", I'm just saying \"let's check we're doing it right\".</p>",
        "id": 210988608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600860493
    },
    {
        "content": "<p>Understood, and agreed.</p>",
        "id": 210988632,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600860516
    },
    {
        "content": "<p>The Lie bracket uses both multiplication and subtraction, so I don't think the enveloping algebra of a Lie algebra is a special case of something for a \"Lie monoid\" the same way that localization for rings was a special case of localization for monoids.</p>",
        "id": 210998591,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600866334
    },
    {
        "content": "<p>On the other hand localization of commutative monoids and this \"universal enveloping group of a monoid\" are both instances of \"invert some elements of a monoid\". But the commutative localization is really a special case that has extra properties, so it's worth keeping even if we also have general noncommutative localizations.</p>",
        "id": 210999536,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600866705
    },
    {
        "content": "<p>One of my slow-moving side projects is to extend the commutative localization to Ore localizations in the noncommutative case, which have the same extra properties, and also extend it to localizations of modules--the construction for modules is the same as for the monoids themselves so I guess it should be possible to take the localization of modules as the starting point, and then equip it with a monoid structure.</p>",
        "id": 210999845,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600866820
    },
    {
        "content": "<p>I'm confused about the semiring vs ring issue... The only additional data is negation, which you define as scalar multiplication by -1. Presumably you would extend the existing semiring structure, right? So why are the two semiring instances not defeq?</p>",
        "id": 211008136,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600870060
    },
    {
        "content": "<p>A good analogous case of this, which I assume is in mathlib, is the fact that a semimodule over a ring is an add_comm_group, and not just an add_comm_monoid. How does mathlib handle this case? (Assuming it does at all!)</p>",
        "id": 211008876,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600870315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  I believe the problem is that <code>ring</code> does not extend <code>semiring</code>. I don't understand the details of Lean's unification well enough to know for sure but it might be down to the fact that <code>semiring</code> carries <code>zero_mul</code> and <code>mul_zero</code> around with it. Check out <code>ring.to_semiring</code>: <a href=\"https://github.com/leanprover-community/mathlib/blob/7cf8fa629b389ac6e6615f0361225c515272fe98/src/algebra/ring/basic.lean#L413\">https://github.com/leanprover-community/mathlib/blob/7cf8fa629b389ac6e6615f0361225c515272fe98/src/algebra/ring/basic.lean#L413</a></p>",
        "id": 211058878,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600893379
    },
    {
        "content": "<p>Anyway I've got 30 minutes to look at this again now so hopefully I'll be able to bottom out. I agree with Reid that there is no case to be made for a weird Lie monoid structure.</p>",
        "id": 211059282,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600893599
    },
    {
        "content": "<p>Though it occurs to me that a horrendous workaround for my semiring issue (which I don't seriously propose) would be to avoid having to define a ring structure on the tensor algebra by quotienting by the relation generated by: <code>i(⁅x, y⁆) + i(y)i(x) ∼ i(x)i(y)</code>.</p>",
        "id": 211059778,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600893780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211059778\">said</a>:</p>\n<blockquote>\n<p>Though it occurs to me that a horrendous workaround for my semiring issue (which I don't seriously propose) would be to avoid having to define a ring structure on the tensor algebra by quotienting by the relation generated by: <code>i(⁅x, y⁆) + i(y)i(x) ∼ i(x)i(y)</code>.</p>\n</blockquote>\n<p>This seems like a good solution to me! All the conditions for a Lie algebra can be written using addition only anyway :)</p>",
        "id": 211060921,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600894404
    },
    {
        "content": "<p>But the ring/semiring thing seems like a more serious problem, doesn't it? The same issue would pop up whenever you have a semiring which just so happens to be a ring with respect to negation defined somehow.</p>",
        "id": 211060973,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600894440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211060973\">said</a>:</p>\n<blockquote>\n<p>But the ring/semiring thing seems like a more serious problem, doesn't it? The same issue would pop up whenever you have a semiring which just so happens to be a ring with respect to negation defined somehow.</p>\n</blockquote>\n<p>It does indeed seem more serious. I'm currently working to make sure I have understood this correctly, and think about what to do if so.</p>",
        "id": 211061332,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600894657
    },
    {
        "content": "<p>Maybe I should mention that I originally defined the tensor algebra over rings, but then switched to semirings because it felt like \"a generalization\"...</p>",
        "id": 211061572,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600894791
    },
    {
        "content": "<p>I blame <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <a href=\"https://github.com/leanprover-community/mathlib/pull/3531#discussion_r460123649\">https://github.com/leanprover-community/mathlib/pull/3531#discussion_r460123649</a><br>\n<span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 211061791,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600894914
    },
    {
        "content": "<p>Ha! I agree with his sentiments.</p>",
        "id": 211061972,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600895006
    },
    {
        "content": "<p>(Regarding the code I wrote, I'm happy enough with it just being an exercise, but if mathlib doesn't already have the universal enveloping group of a monoid, which I couldn't easily find already, I'm willing to clean it up for a PR.  It would be cool if there were an automatic generator for this stuff [wasn't there a post a month ago about this?], but for now I suppose grad student labor suffices.)</p>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> Was there an abstract nonsense reason for the quotients being equal? Is it that in each case the quotient is the coinvariants, which is a colimit, so the group-action-ification functor, which is left adjoint, preserves it?</p>",
        "id": 211062935,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600895510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211062935\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> Was there an abstract nonsense reason for the quotients being equal? Is it that in each case the quotient is the coinvariants, which is a colimit, so the group-action-ification functor, which is left adjoint, preserves it?</p>\n</blockquote>\n<p>Mumble mumble mumble left adjoint mumble mumble.</p>",
        "id": 211063095,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600895592
    },
    {
        "content": "<p>I don't know, it seemed obvious that the construction should work.</p>",
        "id": 211063115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600895608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I for one think it would be worth turning that gist into a PR.</p>",
        "id": 211063241,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600895674
    },
    {
        "content": "<p>I guess in some sense <code>eqv_gen</code> is the left adjoint of the forgetful functor from equivalence relations to relations, groupification is the left adjoint of the forgetful functor from groups to monoids,.</p>",
        "id": 211063292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600895714
    },
    {
        "content": "<p>Oh, and I certainly agree that the groupification should be in mathlib :)</p>",
        "id": 211063458,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600895814
    },
    {
        "content": "<p>And yes, it would be cool if we had an automatic generator. This is a special case of a forgetful functor associated to a morphism of theories in the sense of universal algebra, and these always have left adjoints.</p>",
        "id": 211063631,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600895929
    },
    {
        "content": "<p>While working on this, it felt like I was doing one of your Math 250B assignments again, but perhaps a bit more satisfying since it's formally verified <img alt=\":lean:\" class=\"emoji\" src=\"https://zulip-avatars.s3.amazonaws.com/3121/emoji/images/17579.png\" title=\"lean\"> (though I don't remember us covering any universal algebra -- I'd just sat in for a couple of Prof. Bergman's lectures and glance at his book occasionally)</p>",
        "id": 211064076,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600896239
    },
    {
        "content": "<p>A tangential question I've had in the back of my mind for a while: could anyone point me toward the state-of-the-art in deriving a confluent rewrite system from a list of axioms?  I know a little about the Knuth-Bendix algorithm, though I haven't seen a version of it for tree rewriting, only monoid/group word rewriting.  For axiom sets for which the algorithm succeeds, it might be a nice way to generate simp lemmas.</p>",
        "id": 211064359,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1600896396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> I'm pretty sure the \"general nonsense\" argument you mentioned using the fact that the quotient can be seen as a colimit will work. I wonder how one might formalize this in lean? The first step is that it's the colimit of a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Type}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">T</span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">y</span><span class=\"mord mathrm\">p</span><span class=\"mord mathrm\">e</span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the category with one object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋆</mo></mrow><annotation encoding=\"application/x-tex\">\\star</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">⋆</span></span></span></span> and where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>⋆</mo><mo separator=\"true\">,</mo><mo>⋆</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(\\star,\\star) = M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span><span class=\"mopen\">(</span><span class=\"mord\">⋆</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">⋆</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> as a monoid. Does mathlib have the construction of such a category assocaited to a monoid?</p>",
        "id": 211068214,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600898905
    },
    {
        "content": "<p>(Note that there is a left adjoint from the 2-category of groupoids to the 2-category of categories, and the groupification is a special case of this <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 211068285,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600898958
    },
    {
        "content": "<p>How do adjoints work for 2-categories?</p>",
        "id": 211070442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211070442\">said</a>:</p>\n<blockquote>\n<p>How do adjoints work for 2-categories?</p>\n</blockquote>\n<p>There are various versions. <a href=\"https://ncatlab.org/nlab/show/2-adjunction\">https://ncatlab.org/nlab/show/2-adjunction</a></p>",
        "id": 211070548,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900373
    },
    {
        "content": "<p>I guess I'm thinking of a \"strict 2-adjunction\" in this case?</p>",
        "id": 211070566,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900393
    },
    {
        "content": "<p>Yeah the reason I asked was that I could naively imagine more than one definition -- and indeed there seems to be more than one definition :-)</p>",
        "id": 211070610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900442
    },
    {
        "content": "<p>I should probably open a PR for this: <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/cat_localization/src/category_theory/localization.lean\">https://github.com/leanprover-community/mathlib/blob/cat_localization/src/category_theory/localization.lean</a></p>",
        "id": 211070679,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900469
    },
    {
        "content": "<p>But it's already a month behind, so it might already be broken with up-to-date mathlib.</p>",
        "id": 211070719,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900521
    },
    {
        "content": "<p>TIL localisation of a category is naturally an infinity category</p>",
        "id": 211070725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900526
    },
    {
        "content": "<p>(was watching the MSRI lectures by Carlos Simpson)</p>",
        "id": 211070740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211070725\">said</a>:</p>\n<blockquote>\n<p>TIL localisation of a category is naturally an infinity category</p>\n</blockquote>\n<p>Oh, how does this work?</p>",
        "id": 211070858,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900617
    },
    {
        "content": "<p>And which lectures?</p>",
        "id": 211070865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900623
    },
    {
        "content": "<p>He gave a series of lectures on infinity categories at MSRI a few years ago, I'll dig out the link</p>",
        "id": 211070987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900691
    },
    {
        "content": "<p>Found it: <a href=\"https://docs.google.com/viewer?url=https://www.msri.org/workshops/862/schedules/25985/documents/50141/assets/85626\">https://docs.google.com/viewer?url=https://www.msri.org/workshops/862/schedules/25985/documents/50141/assets/85626</a></p>",
        "id": 211071014,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900719
    },
    {
        "content": "<p>section 2.</p>",
        "id": 211071022,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900728
    },
    {
        "content": "<p>Apparently what people like me who only know about categories think of as localisation of a category at a collection of morphisms is actually a composition of true localisation (an infinity category) followed by  1-truncation (replace Hom(X,Y) by the set of isom classes)</p>",
        "id": 211071099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900802
    },
    {
        "content": "<p>Yes that link is exactly it -- I was watching the videos whilst exercising :-)</p>",
        "id": 211071189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1600900866
    },
    {
        "content": "<p>In case anyone else is interested, here's the link to the video: <a href=\"https://www.msri.org/workshops/862/schedules/25985\">https://www.msri.org/workshops/862/schedules/25985</a></p>",
        "id": 211071205,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900890
    },
    {
        "content": "<p>So the groupification of a monoid is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>-groupoid?!</p>",
        "id": 211071292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1600900936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211061791\">said</a>:</p>\n<blockquote>\n<p>I blame <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"https://github.com/leanprover-community/mathlib/pull/3531#discussion_r460123649\">https://github.com/leanprover-community/mathlib/pull/3531#discussion_r460123649</a><br>\n<span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>\n</blockquote>\n<p>I'll take the blame <span aria-label=\"expressionless\" class=\"emoji emoji-1f611\" role=\"img\" title=\"expressionless\">:expressionless:</span> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 211092300,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600926519
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211068214\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> I'm pretty sure the \"general nonsense\" argument you mentioned using the fact that the quotient can be seen as a colimit will work. I wonder how one might formalize this in lean? The first step is that it's the colimit of a functor from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">T</mi><mi mathvariant=\"normal\">y</mi><mi mathvariant=\"normal\">p</mi><mi mathvariant=\"normal\">e</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Type}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">T</span><span class=\"mord mathrm\" style=\"margin-right:0.01389em;\">y</span><span class=\"mord mathrm\">p</span><span class=\"mord mathrm\">e</span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">C</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{C}_M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the category with one object <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⋆</mo></mrow><annotation encoding=\"application/x-tex\">\\star</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">⋆</span></span></span></span> and where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Hom</mi><mo>⁡</mo><mo stretchy=\"false\">(</mo><mo>⋆</mo><mo separator=\"true\">,</mo><mo>⋆</mo><mo stretchy=\"false\">)</mo><mo>=</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{Hom}(\\star,\\star) = M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mord mathrm\">H</span><span class=\"mord mathrm\">o</span><span class=\"mord mathrm\">m</span></span><span class=\"mopen\">(</span><span class=\"mord\">⋆</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">⋆</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> as a monoid. Does mathlib have the construction of such a category assocaited to a monoid?</p>\n</blockquote>\n<p>Yup we have this... <a href=\"https://leanprover-community.github.io/mathlib_docs/find/single_obj\">docs#single_obj</a></p>",
        "id": 211092471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1600926785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211071292\">said</a>:</p>\n<blockquote>\n<p>So the groupification of a monoid is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord\">∞</span></span></span></span>-groupoid?!</p>\n</blockquote>\n<p>In more classical language, this is the classifying space or nerve construction</p>",
        "id": 211129555,
        "sender_full_name": "Reid Barton",
        "timestamp": 1600953615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/quotient.20by.20monoid.20action/near/211060921\">said</a>:</p>\n<blockquote>\n<p>This seems like a good solution to me! All the conditions for a Lie algebra can be written using addition only anyway :)</p>\n</blockquote>\n<p>I decided to see how this would look and maybe it's OK after all: <a href=\"https://github.com/leanprover-community/mathlib/pull/4041\">https://github.com/leanprover-community/mathlib/pull/4041</a> I still want to spend some time to understand the inference issues I encountered a bit better, but I've warmed up to what I at first thought was a dirty hack.</p>",
        "id": 211161232,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1600967305
    }
]
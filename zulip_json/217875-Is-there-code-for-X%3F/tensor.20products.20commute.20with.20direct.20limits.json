[
    {
        "content": "<p>This may be another product of me being bad at searching for things, but does mathlib know that <code> ⊗ M</code> commutes with direct limits?  </p>\n<p>Also a small update, but I was able to finish the construction of the equivalence of a module with the direct limit of its finitely generated submodules! (hence why I'm looking for the above lemma haha)</p>",
        "id": 274733899,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1646851641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> The answer is \"yes and no\". Mathlib knows that the in the category <code>Module R</code>, the functor <code> ⊗ M</code> is a left adjoint, and hence preserves all colimits. With a bit of luck, there is also a lemma that says that the hands-on direct limit (which I'm assuming you have used) is an example of a colimit in the sense of the category theory library. Combining these facts should give your desired statement.<br>\nBut this means that you will probably need a bit of glue to repackage your statements in the language of <code>category_theory</code>.</p>",
        "id": 274735586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646852412
    },
    {
        "content": "<p>2 messages were moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/namespaces.2C.20and.20more\">#new members &gt; namespaces, and more</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 274735712,
        "sender_full_name": "Notification Bot",
        "timestamp": 1646852445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> I have moved your message to a new thread in a different stream. I think this location is more appropriate.</p>",
        "id": 274735804,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646852480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274735804\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"455674\">Matej Penciak</span> I have moved your message to a new thread in a different stream. I think this location is more appropriate.</p>\n</blockquote>\n<p>Gotcha! Thanks</p>",
        "id": 274736924,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1646852895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274735586\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"455674\">Matej Penciak</span> The answer is \"yes and no\". Mathlib knows that the in the category <code>Module R</code>, the functor <code> ⊗ M</code> is a left adjoint, and hence preserves all colimits. With a bit of luck, there is also a lemma that says that the hands-on direct limit (which I'm assuming you have used) is an example of a colimit in the sense of the category theory library. Combining these facts should give your desired statement.<br>\nBut this means that you will probably need a bit of glue to repackage your statements in the language of <code>category_theory</code>.</p>\n</blockquote>\n<p>I think I'll want to use the <code>Module R</code> language for different parts of the proof anyway, so I think I'll try to clean up what I have and try to provide some of that glue next. Thanks for your help!</p>",
        "id": 274737184,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1646852988
    },
    {
        "content": "<p>There's a <code>monoidal_closed</code> instance for <code>Module R</code>, and this shows tensoring with an object preserves all colimits.</p>",
        "id": 274740094,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1646854206
    },
    {
        "content": "<p>I've been using this just yesterday.</p>",
        "id": 274740134,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1646854228
    },
    {
        "content": "<p>Let me know if you need help identifying all the moving parts!</p>",
        "id": 274740174,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1646854248
    },
    {
        "content": "<p>Caution: in <code>Module R</code> any two modules lie in the same universe, so if you want to prove the fully universe polymorphic version of the result, you'll face universe issue when applying results in <code>Module R</code>.</p>",
        "id": 274784757,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646882319
    },
    {
        "content": "<p>That's a fair point. On the other hand, I don't think it makes sense to duplicate major parts of the <code>category_theory</code> library just to remain maximally universe polymorphic.</p>",
        "id": 274786435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646884335
    },
    {
        "content": "<p>There aren't many colimits where the modules are in different universes anyway...</p>",
        "id": 274786693,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646884703
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit\">docs#module.direct_limit</a> requires all modules lie in the same universe but possibly different from the ring's universe (of course, you can't define a function in Lean with values lie in different universes); it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product\">docs#tensor_product</a> that allows the two module (and the ring) to be in different universes. We don't seem to have a <code>is_direct_limit</code> predicate, so it seems the easiest way state the result in the OP is to use <code>is_colimit</code>/<code>preserves_colimit</code> (otherwise you need to say an isomorphism to the direct limit commuting with natural maps).</p>\n<p>It's interesting to observe that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit\">docs#module.direct_limit</a> doesn't include any commutativity conditions and there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/directed_system\">docs#directed_system</a> imposing the conditions, which isn't needed by many declarations in that file, but is used in <a href=\"https://github.com/eric-wieser/flatstuff/blob/265b4d82dc06220bba8e1941a7039e698ba2392a/src/finite_submodules.lean#L159\">flatstuff</a> and certainly is needed for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Module.direct_limit_is_colimit\">docs#Module.direct_limit_is_colimit</a>.</p>",
        "id": 274795643,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646893857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274786435\">said</a>:</p>\n<blockquote>\n<p>That's a fair point. On the other hand, I don't think it makes sense to duplicate major parts of the <code>category_theory</code> library just to remain maximally universe polymorphic.</p>\n</blockquote>\n<p>I think it's not duplication but refactoring that's required to achieve full universe polymorphism in this case. If <code>M : Type u</code> then <code>M ⊗</code> is a functor from <code>Module.{v} R</code> to <code>Module.{max u v} R</code> which mathlib doesn't have, of which <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.tensor_left\">docs#category_theory.monoidal_category.tensor_left</a> is a special case (u=v). We can show Hom is the right adjoint to this functor, which would specialize to the monoidal category case. Anyway, it's not a small effort and may be not worth it.</p>",
        "id": 274796320,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646894721
    },
    {
        "content": "<p>However, currently flatness is already defined allowing R and M be in different universes, so tensor product between modules in different universe (M with ideals of R) is present in the very definition! So you have to deal with it if you want to keep the generality.</p>",
        "id": 274796421,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646894836
    },
    {
        "content": "<p>But the Hom functor will have different universes, right? In the universe polymorphic setup, they aren't adjoint functors, I think.</p>",
        "id": 274796423,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646894838
    },
    {
        "content": "<p>I think it's easier to have a <code>ulift</code> functor, and show that it preserves limits and colimits.</p>",
        "id": 274796551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646894971
    },
    {
        "content": "<p>But I think it's also perfectly fine to put everything in the same universe for now.</p>",
        "id": 274796562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646894992
    },
    {
        "content": "<blockquote>\n<p>But the Hom functor will have different universes, right? In the universe polymorphic setup, they aren't adjoint functors, I think.</p>\n</blockquote>\n<p>Hmm you're right, Hom(N,P) for N : Type v and P : Type (max u v) would lie in Type (max u v) instead of Type u, so the right adjoint may not exist.</p>",
        "id": 274796786,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646895192
    },
    {
        "content": "<p>There are criteria for flatness which involve testing against tensoring with ideals, and you could imagine that these criteria become false if the module is in a larger universe than the ring because there are \"not enough ideals\" somehow. I can't imagine applications where the ring and module aren't in the same universe (especially now ulift works)</p>",
        "id": 274802214,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646899838
    },
    {
        "content": "<p>Actually I'm not sure whether the tensoring functor preserves colimits if the universe v of the indexing type ι of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.direct_limit\">docs#module.direct_limit</a> is smaller than the universes w of the module. In general, does the lifting functor from <code>Module.{u}</code> to <code>Module.{max u v}</code> preserves \"large\" (i.e. the indexing category J is in higher universe than u) (co)limits? I guess the answer is yes, because if the (co)limit is too large to fit in Module.{u} then the (co)limit would simply not exist in Module.{u}, because you can construct cones with larger and larger cone point? Or you may consider the category <code>Type</code>, for which this becomes a set-theoretic question. I'd be interested to see a counterexample in either case.</p>",
        "id": 274841649,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646922418
    },
    {
        "content": "<p>Anyway, preserves_limits is defined to be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.preserves_limits_of_size\">docs#category_theory.limits.preserves_limits_of_size</a> with J (both objects and morphisms) in the universe of the hom type of the domain of the functor, though, and it should suffice for the current application, since the type of f.g. submodules of a module lies in the same universe as the module.</p>",
        "id": 274842178,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646922685
    },
    {
        "content": "<p>The explicit construction of (co)limits in <code>Type u</code> doesn't really seem to care about universes, right?</p>",
        "id": 274845442,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646924094
    },
    {
        "content": "<p>I didn't check but I think that predates <a href=\"https://github.com/leanprover-community/mathlib/pull/10243\">#10243</a></p>",
        "id": 274847561,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646924932
    },
    {
        "content": "<p>Yes, but the construction is compatible with <code>ulift</code>, right? Or was that not your question?</p>",
        "id": 274847681,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646924994
    },
    {
        "content": "<p>before <a href=\"https://github.com/leanprover-community/mathlib/pull/10243\">#10243</a> you can't talk about limits with J is in not same universe as the morphisms, or functors between categories in different universes preserving limits. And certain (co)limits certainly shouldn't exist in the same universe, e.g. the disjoint union of #(Type u) many <code>unit</code> in Type u. The general construction would work but the result would like Type (u+1).</p>",
        "id": 274848370,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646925268
    },
    {
        "content": "<p>Right, so certain (co)limits don't exist for universe reasons. But apart from those obstructions, all (co)limits exists, and are compatible with making the universe of the ambient category larger by composing with <code>ulift</code>.</p>",
        "id": 274848587,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646925371
    },
    {
        "content": "<p>But I can't seem to rule out that the limit may exist in Type u but isn't isomorphic to the limit in Type (u+1), like a limit in RingedSpace isn't necessarily the same as that in LocallyRingedSpace...</p>",
        "id": 274848996,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646925554
    },
    {
        "content": "<p>Hmm, since <code>Type</code> has generator <code>unit</code> and cogenerator <code>bool</code> in any universe, I think I have proofs that indeed <code>ulift_functor</code> preserves arbitrary large limits and colimits. The comparison morphism from the limit in the lower universe to the limit in the higher universe would also be useful (and dually for colimits). <code>Module</code> also has a generator so limits would be preserved, but what about cogenerator? Maybe we can somehow utilize the concrete category structure on <code>Module</code> ...</p>",
        "id": 274910237,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646954491
    },
    {
        "content": "<p>For filtered colimits, you should be able to reduce to <code>Type*</code>.</p>",
        "id": 274910552,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646954717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/274848996\">said</a>:</p>\n<blockquote>\n<p>But I can't seem to rule out that the limit may exist in Type u but isn't isomorphic to the limit in Type (u+1), like a limit in RingedSpace isn't necessarily the same as that in LocallyRingedSpace...</p>\n</blockquote>\n<p>I don't know any of the category theory context so someone should catch me up, but this sounds wrong. It should be possible to prove that limits and colimits taken in <code>Type (u+1)</code> are isomorphic to the analogous limit in <code>Type u</code> if it exists</p>",
        "id": 274910601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646954761
    },
    {
        "content": "<p>Yes I just came up with proofs, but I don't think these are obvious from these categorical definitions <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.is_limit\">docs#category_theory.limits.is_limit</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.preserves_limits_of_size\">docs#category_theory.limits.preserves_limits_of_size</a> ...</p>",
        "id": 274911493,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646955394
    },
    {
        "content": "<p>You can see from the \"explicit\" definitions of limits and colimits in <code>Type*</code> that the ulift functor preserves (maybe even creates?) limits and colimit.</p>",
        "id": 274911581,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646955466
    },
    {
        "content": "<p>The explicit definition may give you something in a higher universe; when it's in the same universe then it's the categorical limit, and ulift would preserve the limit. What I was concerned with is when the construction gives a result in a higher universe, and at the same time there accidentally exists a limit in the original universe.</p>\n<p>Will be back in 1.5 hours and try to formalize the proofs.</p>",
        "id": 274912250,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646955907
    },
    {
        "content": "<p>If there is \"accidentally\" a limit in the original universe, then you can ulift it into the higher universe and it will still be a limit; you can then compare it with the categorical limit to derive isomorphism</p>",
        "id": 274913691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646956916
    },
    {
        "content": "<p>For the constructed limits (and constructed tensor products etc.) we usually immediately prove that it satisfies the universal property in any universe, but for the accidental limit, we only know its universal property in its universe. Indeed there's a comparison morphism after lifting but it requires proof to show it's an isomorphism. The comparison morphism being isomorphism is equivalent to ulift_functor preserving limit, which means exactly that \"ulift it into the higher universe and it will still be a limit\", and which I am trying to prove.</p>",
        "id": 274919511,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646960985
    },
    {
        "content": "<p>There are lots of full subcategory inclusions (~ fully faithful functors) that don't preserve (co)limits, so I'd argue that Type u ⥤ Type (u+1) is the exception rather than the rule.</p>\n<p>We do know <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.fully_faithful_reflects_limits\">docs#category_theory.limits.fully_faithful_reflects_limits</a> and the same for colimits, so (co)limits in the larger category that lie in the smaller category are automatically (co)limits in the smaller category.</p>",
        "id": 274920570,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646961960
    },
    {
        "content": "<blockquote>\n<p>There are lots of full subcategory inclusions (~ fully faithful functors) that don't preserve (co)limits, so I'd argue that Type u ⥤ Type (u+1) is the exception rather than the rule.</p>\n</blockquote>\n<p>This should be true for Type and for any category where the objects have an \"internal\" definition, including <code>Module</code> and most other categories I can think of. Do you have an example where things go wrong?</p>",
        "id": 274921688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646963105
    },
    {
        "content": "<p>The reason ulift_functor preserves limits is not because of abstract nonsense but by unpacking the definition of the morphisms and how they interact with <code>ulift</code> specifically. I would expect that the abstract nonsense does not give you enough to prove the theorem, because as you say there are other kinds of fully faithful functors that don't preserve limits</p>",
        "id": 274921838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646963227
    },
    {
        "content": "<p>I didn't quite propose to use abstract nonsense to prove it; <code>unit</code> being a generator means that Hom(unit, -) is faithful, which means that two functions are distinguished by their values on points; <code>bool</code> being a cogenerator means that Hom(-, bool) is faithful, which means that two functions are distinguished by considering preimages of subsets of the codomain. The key in this argument is that <code>unit</code> and <code>bool</code> already lie in the lowest universe.</p>\n<p>I don't know what \"internal\" means, but <a href=\"https://mathoverflow.net/a/370624/3332\">here</a> is an example showing the inclusion from abelian groups to groups where things go wrong (doesn't preserve colimits).</p>",
        "id": 274922926,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646964216
    },
    {
        "content": "<p>Here is a proof that ulift_functor preserves limits. I realized the colimit case is trickier than I thought; not every g : (Y -&gt; bool) -&gt; (X -&gt; bool) comes from some f : X -&gt; Y (Hom(-,bool) is faithful but not full, unlike Hom(unit,-) which is even an equivalence of categories), and I'm yet to write down a condition g should satisfy in order to recover f ...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.preserves.basic</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span> <span class=\"n\">opposite</span>\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">w'</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">w'</span><span class=\"o\">}</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cone_of_element</span> <span class=\"o\">{</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"bp\">⋙</span> <span class=\"n\">ulift_functor.</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">})}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">c.X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">punit</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">c.π.app</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"o\">,</span>\n    <span class=\"n\">naturality'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">c.w</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">preserves_limits</span> <span class=\"o\">:</span> <span class=\"n\">preserves_limits_of_size.</span><span class=\"o\">{</span><span class=\"n\">w'</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">ulift_functor.</span><span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">preserves_limits_of_shape</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">J</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span> <span class=\"o\">{</span> <span class=\"n\">preserves_limit</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">preserves</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">lift</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">lc</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h.lift</span> <span class=\"o\">(</span><span class=\"n\">cone_of_element</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">punit.star</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">fac'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">lc</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h.fac</span> <span class=\"n\">_</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">uniq'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">lc</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">h.uniq</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n      <span class=\"n\">intro</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"o\">⟨⟩,</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">ulift.down</span> <span class=\"n\">this</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 274937987,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646982233
    },
    {
        "content": "<p>Hmm, the condition should be that of boolean algebra hom, I guess.</p>",
        "id": 274938179,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1646982409
    },
    {
        "content": "<p>Boolean algebra homs? This is just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_lattice_hom\">docs#bounded_lattice_hom</a></p>",
        "id": 274947087,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1646988892
    },
    {
        "content": "<p>I now have a <a href=\"https://gist.github.com/alreadydone/ecf34077c0ca9250bfb6ab41e00d76e8\">complete proof</a> that ulift_functor preserves all colimits as well. I believe it contains all ingredients to construct the <a href=\"https://ncatlab.org/nlab/show/complete+Boolean+algebra#cabas\">contravariant equivalence</a> between <code>Type</code> and the category of <strong>complete</strong> atomic Boolean algebras, but I use a direct approach that need not mention these concepts.</p>\n<p>The same argument should work for limits in Group and AddCommGroup (because the generator Z already lies in the lowest universe), but for Module it would only apply if the lower universe contains the ring R, which also serves as a generator in the higher universe. In these arguments I do not assume the (co)limit exists in the higher universe so I do not have access to the comparison morphism. If you take advantage of that maybe you can prove more.</p>\n<p>For colimits it's a different story: ulifting groups doesn't actually preserve colimits! <a href=\"https://mathoverflow.net/q/353408/3332\">One can embed</a> any infinite group G canonically into a simple group of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi mathvariant=\"normal\">∣</mi><mi>G</mi><mi mathvariant=\"normal\">∣</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{|G|}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.888em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.888em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∣</span><span class=\"mord mathnormal mtight\">G</span><span class=\"mord mtight\">∣</span></span></span></span></span></span></span></span></span></span></span></span>, and we may transfinitely iterate this construction to obtain a direct system of groups indexed by ordinals in the universe, <a href=\"https://mathoverflow.net/a/348643/3332\">whose colimit G+ is again a simple group</a>, whose cardinality is too large to lie in the universe, but does live in the next higher universe. In the lower universe, the colimit exists and is the trivial group, because for any cocone over the direct system, there exists a homomorphism from G+ to the cone point, which can't be an isomorphism onto the image due to cardinality reason, so must be trivial as G+ is simple. Therefore, ulifting to the next higher universe doesn't preserve colimits in Group. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<p>It's also interesting to learn that certain free objects (small coproducts of free objects on one generator) don't exist in the same universe but only in the next higher one, like the free complete lattice on three generators, or the free complete Boolean algebra on countably many generators, but these don't provide examples because the colimits don't exist in the lower universe.</p>\n<p>There seems to exist other ways things can \"go wrong\": there are algebraic <a href=\"https://mathoverflow.net/q/1924/3332\">statements independent of ZFC</a>, like the <a href=\"https://encyclopediaofmath.org/wiki/Whitehead_problem\">Whitehead problem</a>. It looks plausible to me that there exists a model of Lean's type theory where <code>Type 0</code> \"is\" the constructible universe, so all Whitehead groups there are free, while <code>Type 1</code> \"satisfies\" Martin's axiom, and non-free Whitehead groups exists there. However, I haven't been able to connect such statements to limits.</p>",
        "id": 275178330,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1647210325
    },
    {
        "content": "<p>Fascinating! Well done!</p>",
        "id": 275178860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1647211121
    },
    {
        "content": "<p>Asking for a nontrivial exact endofunctor on Set is a pretty reasonable statement, and it's equivalent to the existence of a measurable cardinal, which certainly isn't implied by ZFC: <a href=\"https://ncatlab.org/nlab/show/measurable+cardinal#in_category_theory\">https://ncatlab.org/nlab/show/measurable+cardinal#in_category_theory</a>, maybe this is the sort of connection to limits you might be looking for?</p>",
        "id": 275180478,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1647213354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> That construction requires you to take a colimit over a large index set though. Hopefully the theorem should at least be true for small colimits of groups</p>",
        "id": 275189235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647226437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/tensor.20products.20commute.20with.20direct.20limits/near/275178330\">said</a>:</p>\n<blockquote>\n<p>There seems to exist other ways things can \"go wrong\": there are algebraic <a href=\"https://mathoverflow.net/q/1924/3332\">statements independent of ZFC</a>, like the <a href=\"https://encyclopediaofmath.org/wiki/Whitehead_problem\">Whitehead problem</a>. It looks plausible to me that there exists a model of Lean's type theory where <code>Type 0</code> \"is\" the constructible universe, so all Whitehead groups there are free, while <code>Type 1</code> \"satisfies\" Martin's axiom, and non-free Whitehead groups exists there. However, I haven't been able to connect such statements to limits.</p>\n</blockquote>\n<p>I don't believe it is possible for Martin's axiom or CH to be true in a higher universe and false in a lower one, because it is a statement about sets of bounded cardinality. Any \"internal\" property (i.e. not something like projectiveness that talks about the other types in the given universe) about small sets in a large universe can be reflected back down to the small universe.</p>",
        "id": 275189389,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647226676
    },
    {
        "content": "<p>In your example, if <code>Type 0</code> is the constructible universe, then all Whitehead groups of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> are free, but then any Whitehead group in <code>Type 1</code> is provably \"small\" because <code>aleph 1</code> is a small cardinal, and hence is isomorphic to a group in <code>Type 0</code>; and group isomorphism preserves the Whitehead property, so all Whitehead groups of cardinality <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℵ</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\aleph_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\">ℵ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in any universe are free.</p>",
        "id": 275189725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647227050
    },
    {
        "content": "<p>Another example of this kind of reasoning is that <code>Con(ZFC + 6 inaccessibles)</code> is a property of <code>nat</code> in <code>Type 0</code> but it is provable in lean because we can construct a model of ZFC + 6 inaccessibles in <code>Type 7</code></p>",
        "id": 275189822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647227219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> <span class=\"user-mention\" data-user-id=\"125393\">@Junyan Xu</span> definitely have a look at <a href=\"https://github.com/leanprover-community/mathlib/pull/11677\">#11677</a></p>",
        "id": 275363819,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647346286
    },
    {
        "content": "<p>Hello. I am new. I'd like to get an idea about the feasibility of formalizing a 159-page paper and approximate timescales. Thanks!</p>",
        "id": 275460857,
        "sender_full_name": "Yi Hu",
        "timestamp": 1647397740
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"485551\">@Yi Hu</span>, welcome!  It depends very much on the paper, can you say more about it?  But frankly, formalization is a long way from the research frontier in most fields of math, and you would have to build in the time to get to that research frontier as well as the time for formalizing the paper itself.</p>",
        "id": 275461118,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647398124
    },
    {
        "content": "<p>The paper is here <a href=\"https://arxiv.org/abs/2203.03842\">https://arxiv.org/abs/2203.03842</a><br>\nThe main components are about a family of polynomials and their proper transforms after (hugely numerous) simple blowups.</p>",
        "id": 275462970,
        "sender_full_name": "Yi Hu",
        "timestamp": 1647400529
    },
    {
        "content": "<p>We're a long way from this, unfortunately.  Although we do aspire to get there (in 5 years?  10?), and it would be great to have you join the effort :-).  </p>\n<p>Just looking at the first sentence, I'm not even sure that mathlib has the definition of a rational map between schemes.</p>",
        "id": 275463293,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647400967
    },
    {
        "content": "<p>If you could extract a (very complicated) result purely about commutative algebra or polynomials which you wanted checked, that might be more within reach.</p>",
        "id": 275463658,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1647401484
    },
    {
        "content": "<p>5 messages were moved from this topic to <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Introductions.3A.20Yi.20Hu\">#new members &gt; Introductions: Yi Hu</a> by <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span>.</p>",
        "id": 275473024,
        "sender_full_name": "Notification Bot",
        "timestamp": 1647413887
    }
]
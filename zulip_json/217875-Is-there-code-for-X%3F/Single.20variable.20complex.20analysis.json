[
    {
        "content": "<p>Hi, I am fourth year undergraduate studying Computer Science and Mathematics at the University of Edinburgh. As my final year project, I decided to contribute to mathlib and so far I've enjoyed learning how to use Lean. From the <a href=\"https://leanprover-community.github.io/undergrad_todo.html\">undergrad math not in mathlib</a> I see that barely any of the complex analysis undergraduate curriculum is formalized. I was wondering whether somebody has tried formalizing this before or, if not, why?</p>",
        "id": 214068545,
        "sender_full_name": "Adrián Doña Mateo",
        "timestamp": 1603294643
    },
    {
        "content": "<p>I think I've seen <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> mention the lack of complex analysis a few times, but I don't know any more than that</p>",
        "id": 214069203,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1603294891
    },
    {
        "content": "<p>Well, we have the complex numbers as a field, but I'm not sure that anyone has developed the theory of complex analysis. It is definitely worth talking about this. I used to understand the situation with one-variable real analysis well: the argument was that there was no point developing it directly because at some point one would have to do multivariable real analysis. A lot of stuff has since been done, including, I believe, the fundamental theorem of calculus, so one might naively feel that we are in some sense ready to start complex analysis. I might be wrong though.</p>",
        "id": 214069677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603295077
    },
    {
        "content": "<p>do any of the other math formalization languages have good complex analysis stuff? i wonder if it might be possible to automatically translate their code over</p>",
        "id": 214071855,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603295932
    },
    {
        "content": "<p>It will almost certainly not be possible to automatically translate any code over, because if this were a thing then it would have been done way before now to translate other stuff over. The filter stuff from topology was I think all taken from Isabelle, but all ported manually.</p>",
        "id": 214072209,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603296049
    },
    {
        "content": "<p>i don't really see why it wouldn't be possible. at least to have it work in conjunction with a human programmer. a lot of the computer language translation stuff will be like, the computer does 95% of the work, but some structures don't quite map and you have to deal with that manually</p>",
        "id": 214073278,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296399
    },
    {
        "content": "<p>would it be useful to translate code from, say, isabelle to lean, if that was possible?</p>",
        "id": 214073316,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296421
    },
    {
        "content": "<p>There was some recent discussion of translating proofs in <a href=\"#narrow/stream/113489-new-members/topic/Translating.20proofs.20between.20proof.20systems\">this thread</a>.</p>",
        "id": 214073953,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603296651
    },
    {
        "content": "<p>If it produces code that can be integrated well into other parts that want to use it... such a translation tool would be awesome. I have no idea how to write such a tool though.</p>",
        "id": 214074043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603296683
    },
    {
        "content": "<p>it sounds like everyone in that thread is mathematicians rather than programmers</p>",
        "id": 214074200,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296734
    },
    {
        "content": "<p>It's no good to have a complex analysis library in mathlib that uses its own definition of the complex numbers, and its own polynomials, etc...</p>",
        "id": 214074204,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603296736
    },
    {
        "content": "<p>that's right</p>",
        "id": 214074235,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296751
    },
    {
        "content": "<p>you're never going to get live importing of isabelle code into lean working</p>",
        "id": 214074254,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296760
    },
    {
        "content": "<p>It needs to be integrated and reusable. Afaik, this is a major challenge that hasn't really been solved before</p>",
        "id": 214074258,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603296763
    },
    {
        "content": "<p>the best tools are things like <a href=\"https://github.com/natural/java2python\">https://github.com/natural/java2python</a></p>",
        "id": 214074328,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296793
    },
    {
        "content": "<p>(for this sort of translation)</p>",
        "id": 214074351,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238605\">Kevin Lacker</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214074200\">said</a>:</p>\n<blockquote>\n<p>it sounds like everyone in that thread is mathematicians rather than programmers</p>\n</blockquote>\n<p>Everyone in that thread includes Mario and Jasmin. Two bigshots in formalization-world. Both of them don't know how not to program.</p>",
        "id": 214074359,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603296805
    },
    {
        "content": "<p>well, i just mean nobody brought up the existing tools to translate programmign languages. no offense to anyone intended</p>",
        "id": 214074417,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296832
    },
    {
        "content": "<p>Feel free to experiment. It would be extremely cool if we could get such a tool to work.</p>",
        "id": 214074507,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603296862
    },
    {
        "content": "<p>OK - i'll take a look at some of the other languages here. perhaps some of the formalizations linked from <a href=\"http://www.cs.ru.nl/~freek/100/\">http://www.cs.ru.nl/~freek/100/</a> would be useful translation targets</p>",
        "id": 214074797,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603296973
    },
    {
        "content": "<p>The argument given when this comes up is usually of the form \"it's not even clear whether one wants to do this because the resulting stuff will not be idiomatic\". I am proudly a mathematician though :-)</p>",
        "id": 214074886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603297004
    },
    {
        "content": "<p>It might be worth digging more into <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's <a href=\"https://github.com/digama0/mm0/blob/master/mm0-lean/README.md\"><code>metamath-mm0-lean</code> stuff</a>.</p>",
        "id": 214075125,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603297083
    },
    {
        "content": "<p>Talking of translations and Freek 100, one could argue that once we have uniqueness of the reals proved we could in theory translate the metamath proof of PNT (that's a Freek question, right?) into Lean -- but of course the code would be unreadable and not appropriate for mathlib.</p>",
        "id": 214075242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603297125
    },
    {
        "content": "<p>if you have an unreadable proof for something, and that's the only proof, why not put it in mathlib until you have a better proof for it</p>",
        "id": 214075492,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603297209
    },
    {
        "content": "<p>I thought Mario already did an automatic translation of the metamath proof of PNT into Lean using mm0.</p>",
        "id": 214075510,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603297219
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/Prime.20number.20theorem.20in.20lean\">See this thread</a>.</p>",
        "id": 214075601,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603297255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> Yes, but it uses a version of <code>log</code> that isn't the one in mathlib. Crucially, it uses a version of <code>real</code> that isn't the one in mathlib. So to get the correct statement, we need to merge Alex's PR on uniqueness of <code>real</code>.</p>",
        "id": 214076348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603297534
    },
    {
        "content": "<p>I asked an IC undergraduate to revive the branch. I'm less busy than I was but still more busy than I'll be after a week on Friday, when I can go back to this if the UG hasn't done it.</p>",
        "id": 214076898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603297727
    },
    {
        "content": "<p>Java2python and similar tools rely on the existence of an AST representation of the underlying language, and a specifically built translation mechanism. Both java and python are similar in that they're bytecode based languages too, and have very mature interpreters, and many variants (jvm languages for java, ironpython, pypy etc for python)</p>",
        "id": 214078573,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298503
    },
    {
        "content": "<p>So a lot of work of python-to-python or java-to-java has also been done</p>",
        "id": 214078600,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298518
    },
    {
        "content": "<p>And then one can bring in discussion of compiler generation -- so many actual implementations of C around! gcc, clang, etc</p>",
        "id": 214078674,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298544
    },
    {
        "content": "<p>With Lean 3, we have... Lean 3. And as Mario remarked on a separate thread, it's not very clear how Lean can be represented in AST</p>",
        "id": 214078736,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298573
    },
    {
        "content": "<p>i'm sure there are more complications than that -- just some thoughts contrasting traditional PLs from theorem PLs</p>",
        "id": 214078925,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298645
    },
    {
        "content": "<p>(Jython exists =) )</p>",
        "id": 214079262,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603298779
    },
    {
        "content": "<p>Independent of this issue (for which the answer is surely ultimately going to be \"if you want complex analysis from Isabelle then feel free to manually port\") there's the question of whether we're ready to start on this at all. I was trying to say that 2 years ago I had a clear understanding of why I shouldn't be persuading undergraduates to formalise their 1st year real analysis course for mathlib (\"it's not general enough\"), but now I have a far poorer understanding of whether I should be persuading undergraduates to formalise their 2nd year complex analysis course.</p>",
        "id": 214079280,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603298789
    },
    {
        "content": "<p>Mathematically I think the issue is the following. One needs to have a good theory of polynomials in one variable to develop some of the theory of polynomials in a finite set of variables, because several of the foundational proofs use induction in the number of variables. Apparently it is less clear that one needs to have a good theory of one variable real analysis before one develops a multivariable theory, because that kind of interaction is perhaps not there so much. What is the story for complex analysis? Certainly a multivariable theory exists, but is it built on top of the one-variable theory or is the one-variable theory just a special case?</p>",
        "id": 214079665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603298953
    },
    {
        "content": "<p>Of course there needs to be a specialised theory of integration etc in one dimension. But does it come next, or is there a ton of other stuff which ideally should be done first?</p>\n<p>While we're here, someone might want to start thinking about the Jordan curve theorem I guess? Do we have enough to make this a feasible project? Or is the argument that we will only need it for e.g. rectifiable curves, which might be easier? I don't know the foundations of this stuff.</p>",
        "id": 214079967,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603299082
    },
    {
        "content": "<p>Note that analytic functions already exist in great generality thanks to <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> <br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/analytic_at\">docs#analytic_at</a><br>\nAnd <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> has been busy lately with the \"glue\" from formal power series to functions with domain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>E</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">E^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> where E is a Banach algebra. <a href=\"https://github.com/leanprover-community/mathlib/issues/4316\">#4316</a></p>",
        "id": 214079985,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> and I have actually been planning to try Goursat's theorem about contours around triangles, basically as a test case.  Here's a stub: <br>\n<a href=\"https://github.com/leanprover-community/mathlib/tree/triangles\">https://github.com/leanprover-community/mathlib/tree/triangles</a></p>",
        "id": 214080210,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299176
    },
    {
        "content": "<p>Thanks Heather! My instinct is that the first key missing definition is that of an integral of a holomorphic function along a path, and a goal might be Cauchy's integral formula. I have no feeling for how close we are on this.</p>",
        "id": 214080293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603299211
    },
    {
        "content": "<p>Aah! Triangles would be an even better first goal :-)</p>",
        "id": 214080408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603299247
    },
    {
        "content": "<p>But I say \"test case\" because of precisely the issue that Kevin mentions:  this would eventually lead to holomorphic -&gt; analytic in one variable, but I don't know if there's a more general, non-Goursat argument that does this directly in several variables.</p>",
        "id": 214080517,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299292
    },
    {
        "content": "<p>Looking at the code I guess one question that springs to mind is whether we can prove that reparametrising a curve still gives the same integral -- you go along the sides of the triangle at constant speed</p>",
        "id": 214080592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603299326
    },
    {
        "content": "<p>One other useful link: mathlib has the definition of a holomorphic function, it's just <a href=\"https://leanprover-community.github.io/mathlib_docs/find/differentiable\">docs#differentiable</a> but with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> as the field!</p>",
        "id": 214080598,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299328
    },
    {
        "content": "<p>One thing that is independent of all of this, and could be fun for <span class=\"user-mention\" data-user-id=\"345682\">@Adrián Doña Mateo</span> -- checking that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/differentiable\">docs#differentiable</a> is equivalent to the Cauchy-Riemann equations.</p>",
        "id": 214080764,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299386
    },
    {
        "content": "<p>And Alex and I can check in in a few days with some thoughts about whether the Goursat stuff is going to go anywhere.</p>",
        "id": 214080827,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603299412
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214080764\">said</a>:</p>\n<blockquote>\n<p>One thing that is independent of all of this, and could be fun for <span class=\"user-mention silent\" data-user-id=\"345682\">Adrián Doña Mateo</span> -- checking that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/differentiable\">docs#differentiable</a> is equivalent to the Cauchy-Riemann equations.</p>\n</blockquote>\n<p>That sounds like a very nice first milestone.</p>",
        "id": 214082401,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603299986
    },
    {
        "content": "<p>I still think we should first do differential forms and Stokes, and deduce Cauchy from that.</p>",
        "id": 214084458,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603300813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214078736\">said</a>:</p>\n<blockquote>\n<p>With Lean 3, we have... Lean 3. And as Mario remarked on a separate thread, it's not very clear how Lean can be represented in AST</p>\n</blockquote>\n<p>you don't need a Lean AST for this though - you really just need an AST for the other language. because you are free to generate Lean a much more restricted subset of Lean. i think the hardest thing though is that AFAICT some of the fundamental underlying datatypes are handled differently - like in metamath e.g. <a href=\"http://us.metamath.org/mpeuni/areacirc.html\">http://us.metamath.org/mpeuni/areacirc.html</a> you have statements like <code>(𝑡 ∈ ℝ → 𝑡 ∈ ℂ)</code>. in Lean IIUC you can't represent that directly because the type system works differently. fundamental datatypes in e.g. java and python aren't compatible with each other either, but you at least have a mapping between the type hierarchy even if they don't quite work the same.</p>",
        "id": 214084706,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603300922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214084458\">said</a>:</p>\n<blockquote>\n<p>I still think we should first do differential forms and Stokes, and deduce Cauchy from that.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I was hoping you would express an opinion :). Regarding this idea, how would you plan to do Stokes to allow for piecewise-continuous boundary?  Would this involve developing the theory of manifolds for the piecewise-linear structure groupoid?</p>",
        "id": 214104012,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309306
    },
    {
        "content": "<p>Why piece-wise continuous? How do you integrate on such a path? I think we only need manifolds with boundaries and corners here (this certainly covers triangles).</p>",
        "id": 214104270,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309419
    },
    {
        "content": "<p>Sorry, I meant piecewise-smooth.</p>",
        "id": 214104429,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309476
    },
    {
        "content": "<p>Ok. What is the issue then? \"concave corners\"? I guess we can get them after the fact but it will be messy.</p>",
        "id": 214104673,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309566
    },
    {
        "content": "<p>I think my concerns were unfounded. I was initially worried about whether one would need a manifold-like structure on the boundary itself (here a piecewise-smooth curve).  But I suppose what you are saying is that for a manifold with corners, one has stratification of the boundary into pieces which are genuine smooth manifolds, and so integration over the boundary can be defined neatly as a sum of integration over the pieces.</p>",
        "id": 214104839,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309641
    },
    {
        "content": "<p>Yes.</p>",
        "id": 214104885,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214080517\">said</a>:</p>\n<blockquote>\n<p>But I say \"test case\" because of precisely the issue that Kevin mentions:  this would eventually lead to holomorphic -&gt; analytic in one variable, but I don't know if there's a more general, non-Goursat argument that does this directly in several variables.</p>\n</blockquote>\n<p>In another direction -- do you know any answer to this?</p>",
        "id": 214104908,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309679
    },
    {
        "content": "<p>i.e., an argument \"holomorphic implies analytic\" that naturally works in several variables (without a prior one-variable argument)?</p>",
        "id": 214105033,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309718
    },
    {
        "content": "<p>I don't see the point of going through Goursat even in dimension 1.</p>",
        "id": 214105257,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309830
    },
    {
        "content": "<p>Well, it is a nice argument for a novice, which is the point for <span class=\"user-mention\" data-user-id=\"252920\">@Alex Kontorovich</span> :)</p>",
        "id": 214105346,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603309888
    },
    {
        "content": "<p>People usually do that because they have a version of Stokes with too strong assumptions and they insist on defining holomorphic functions as complex-differentiable without assuming C¹ in the real sense.</p>",
        "id": 214105351,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309890
    },
    {
        "content": "<p>Sure, I'm only talking from the mathlib point of view. Doing nice exercises is a different question.</p>",
        "id": 214105463,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603309927
    },
    {
        "content": "<p>But so, do you know any argument for several variables that does not involve reducing to the dimension-1 case?</p>",
        "id": 214105689,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603310031
    },
    {
        "content": "<p>By the way, <span class=\"user-mention\" data-user-id=\"345682\">@Adrián Doña Mateo</span> (or others), if you are interested in joining an attempt to do Goursat, it will be <time datetime=\"2020-10-23T19:00:00Z\">2020-10-23T15:00:00-04:00</time> at this link:<br>\n<a href=\"https://rutgers.zoom.us/j/95310486457?pwd=QW55SzU4NklMeFd6Y3hjKzc3bU1XZz09\">https://rutgers.zoom.us/j/95310486457?pwd=QW55SzU4NklMeFd6Y3hjKzc3bU1XZz09</a></p>",
        "id": 214106169,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603310222
    },
    {
        "content": "<p>I know almost nothing about complex analysis in several variables, but I think I always saw things deduced from the one-dimensional case.</p>",
        "id": 214106398,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603310314
    },
    {
        "content": "<p>Yes, I think the standard requirement is that the function be continuous, and individually holomorphic in each variable.  But this has always seemed odd to me (although I am sure there are good reasons).</p>",
        "id": 214106520,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603310372
    },
    {
        "content": "<p>Is this definition the same as being complex-differentiable?  Or am I overlooking something?</p>",
        "id": 214106646,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603310407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214084458\">said</a>:</p>\n<blockquote>\n<p>I still think we should first do differential forms and Stokes, and deduce Cauchy from that.</p>\n</blockquote>\n<p>Another point about this:  One still needs an independent definition of contour integral -- sometimes one wants to integrate around non-closed contours, or self-crossing contours, and so it would be a pain to be restricted only to integrating only over contours of the form \"boundary of a domain in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> with boundary and corners\".</p>",
        "id": 214109935,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603311917
    },
    {
        "content": "<p>Sure.</p>",
        "id": 214110000,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603311949
    },
    {
        "content": "<p>But this has nothing to do with the elementary setup. In differential geometry we want to integrate differential forms on chains that are not boundaries.</p>",
        "id": 214110091,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603311980
    },
    {
        "content": "<p>The approach in introductory texts, eg., Stein-Shakarchi, is to start with the very basic, like integrals over triangles, and see how much mileage one can get from that idea; amazingly, that little lemma can be whittled rather quickly (at least on the human level; we'll see about Lean) all the way up to Cauchy integral representations, analytic functions, etc. So the hope is to take Step 1, and do so now, without waiting for fancier things to be built...? (And also for me to learn more about how this all works...)</p>",
        "id": 214115655,
        "sender_full_name": "Alex Kontorovich",
        "timestamp": 1603314790
    },
    {
        "content": "<p>Sure, go for it!</p>",
        "id": 214116140,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603315086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238605\">Kevin Lacker</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214084706\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214078736\">said</a>:</p>\n<blockquote>\n<p>With Lean 3, we have... Lean 3. And as Mario remarked on a separate thread, it's not very clear how Lean can be represented in AST</p>\n</blockquote>\n<p>you don't need a Lean AST for this though - you really just need an AST for the other language. because you are free to generate Lean a much more restricted subset of Lean. i think the hardest thing though is that AFAICT some of the fundamental underlying datatypes are handled differently - like in metamath e.g. <a href=\"http://us.metamath.org/mpeuni/areacirc.html\">http://us.metamath.org/mpeuni/areacirc.html</a> you have statements like <code>(𝑡 ∈ ℝ → 𝑡 ∈ ℂ)</code>. in Lean IIUC you can't represent that directly because the type system works differently. fundamental datatypes in e.g. java and python aren't compatible with each other either, but you at least have a mapping between the type hierarchy even if they don't quite work the same.</p>\n</blockquote>\n<p>Translation from metamath is a \"solved problem\" at the technical level at this point. You can easily represent <code>(𝑡 ∈ ℝ → 𝑡 ∈ ℂ)</code> in lean, because lean knows about ZFC. It just says <code>t ∈ Real -&gt; t ∈ Complex</code> where <code>Real</code> and <code>Complex</code> have type <code>set Set</code>, that is, classes of ZFC</p>",
        "id": 214122339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603318830
    },
    {
        "content": "<p>Also, lean has a logical representation of the kind necessary for this kind of translation, and I have been planning (/long delaying) a translation from lean to MM0 along these lines, using the axiomatization of lean defined <a href=\"https://github.com/digama0/mm0/blob/master/examples/lean.mm1\">here</a></p>",
        "id": 214122500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603318933
    },
    {
        "content": "<p>translation between programming languages is much simpler than translating between proof languages, because you don't have to care if your translation is correct</p>",
        "id": 214122561,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603318993
    },
    {
        "content": "<p>I was imagining a workflow like, step 1 manually translate some metamath into 500 lines of lean. it 95% works. then you manually go fix up the 25 bugs</p>",
        "id": 214122670,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319046
    },
    {
        "content": "<p>I have that, except it's 100% not 95%</p>",
        "id": 214122685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319062
    },
    {
        "content": "<p>and it's 1 step to 1 line actually</p>",
        "id": 214122715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319085
    },
    {
        "content": "<p>i saw <a href=\"https://github.com/digama0/mm0\">https://github.com/digama0/mm0</a> and the name \"mario carneiro\" in about a zillion places, but i didnt see specifically a metamath to lean converter</p>",
        "id": 214122763,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319119
    },
    {
        "content": "<p>why not run this to generate a lean proof of all the rando stuff that's in metamath and not in lean, then? because it would use a wacky definition of \"real\" instead of the Lean one?</p>",
        "id": 214122787,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319146
    },
    {
        "content": "<blockquote>\n<p>mm0-hs from-mm performs wholescale translations from Metamath to MM0 + MMU or MM0 + MMB. This is the best way to obtain a large test set, because <a href=\"http://set.mm\">set.mm</a> is quite large and advanced.</p>\n</blockquote>",
        "id": 214122842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319168
    },
    {
        "content": "<blockquote>\n<p>mm0-hs to-lean translates MM0 into Lean source files compatible with mm0-lean. [WIP]</p>\n</blockquote>",
        "id": 214122860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319181
    },
    {
        "content": "<p>actually I should take off the WIP there, it works</p>",
        "id": 214122875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319193
    },
    {
        "content": "<blockquote>\n<p>why not run this to generate a lean proof of all the rando stuff that's in metamath and not in lean, then? because it would use a wacky definition of \"real\" instead of the Lean one?</p>\n</blockquote>\n<p>I did that</p>",
        "id": 214122916,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319230
    },
    {
        "content": "<p>The entire <a href=\"http://set.mm\">set.mm</a> library has been verified using the lean kernel</p>",
        "id": 214122944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319261
    },
    {
        "content": "<p>I have used this to fully verify a lean proof of dirichlet's theorem using the metamath library</p>",
        "id": 214123009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319303
    },
    {
        "content": "<p>but for example, <a href=\"http://us.metamath.org/mpeuni/basel.html\">http://us.metamath.org/mpeuni/basel.html</a> is not in mathlib. (to pick an example that you yourself wrote ;-) )</p>",
        "id": 214123020,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319313
    },
    {
        "content": "<p>the main limitation for higher level theorems like PNT is to prove the universality of the types involved, which is needed to prove that metamath's reals are isomorphic to lean's reals</p>",
        "id": 214123067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319359
    },
    {
        "content": "<p>It's not in mathlib because it's 500000 lines of unreadable stuff and the community doesn't know what to do with it yet</p>",
        "id": 214123115,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319401
    },
    {
        "content": "<p>it's kind of an all or nothing proposition, if you want the basel problem in lean to be proven using metamath you will need to bring half of the metamath library along with it</p>",
        "id": 214123217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319459
    },
    {
        "content": "<p>current plans revolve somehow with having a separate repo that folks can depend on</p>",
        "id": 214123255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319498
    },
    {
        "content": "<p>this automatically generated proof, does it use the Metamath types, like the metamath real number definition, all the way through? or if you look at like the top level of the proof, is that using lean style types</p>",
        "id": 214123328,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319528
    },
    {
        "content": "<p>What's missing before we could set up a separate <code>set-mm-lean</code> repo that anyone could import next to mathlib?</p>",
        "id": 214123410,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603319598
    },
    {
        "content": "<p>Mostly a nice CI script, I guess</p>",
        "id": 214123438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319623
    },
    {
        "content": "<p>you would need to download <a href=\"http://set.mm\">set.mm</a> from the git repo, get <code>mm0-hs</code> and run <code>mm0-hs from-mm</code> and <code>mm0-hs to-lean</code>, and then commit the lean files, where they will coexist with a manually curated set of files providing lean shims</p>",
        "id": 214123581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319703
    },
    {
        "content": "<p>what would someone do if they wrote some cool new formalization, but it depended on one of the ugly proofs in <code>set-mm-lean</code> - put it in their own repository?</p>",
        "id": 214123611,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603319735
    },
    {
        "content": "<p>leanproject is designed for that, you know</p>",
        "id": 214123634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319759
    },
    {
        "content": "<p>despite appearances not all extant lean code is in mathlib</p>",
        "id": 214123722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319804
    },
    {
        "content": "<p>Setting that project up hasn't been a high priority for me because I've been busy with completing other parts of the MM0 project but if someone is interested we can get that started</p>",
        "id": 214123951,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603319959
    },
    {
        "content": "<p>I'd be happy to help set the CI scripts up. What you've said above might be enough to get me started.</p>",
        "id": 214123982,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1603319987
    },
    {
        "content": "<p>There are a lot of low hanging fruit in the shims too. That is all simple but manual work</p>",
        "id": 214123991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603320000
    },
    {
        "content": "<p>I'll go set up a repo then</p>",
        "id": 214124123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603320084
    },
    {
        "content": "<p>Also, regarding isabelle to lean: I've been looking into it. The hard part is proof export from isabelle, because it wasn't designed for it and there are no proof objects</p>",
        "id": 214124219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603320148
    },
    {
        "content": "<p>i'm interested in doing some amount of \"simple but manual work\" here <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span> I think it would be handy to have a repo for essentially autogenerated and terrible-looking but still valid lean code</p>",
        "id": 214124484,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603320366
    },
    {
        "content": "<p>The basic procedure is to locate a metamath definition, locate the analogous lean definition (or define it), and then prove the isomorphism</p>",
        "id": 214126253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603321754
    },
    {
        "content": "<p>See <a href=\"https://github.com/digama0/mm0/blob/master/mm0-lean/mm0/set/post.lean\">https://github.com/digama0/mm0/blob/master/mm0-lean/mm0/set/post.lean</a>, which sets up the basic infrastructure enough to align the concepts of dirichlet's theorem</p>",
        "id": 214126281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603321785
    },
    {
        "content": "<p>Like this one:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nn0.rel_class</span> <span class=\"o\">:</span> <span class=\"n\">rel_class</span> <span class=\"n\">cℕ₀</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">aset</span> <span class=\"o\">:=</span> <span class=\"n\">nn0ex</span><span class=\"o\">,</span>\n  <span class=\"n\">to</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">cℕ₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">to_mem</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">cℕ₀</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">to_inj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">nat.cast_inj.1</span> <span class=\"o\">(</span><span class=\"n\">subtype.eq</span> <span class=\"n\">e</span><span class=\"o\">),</span>\n  <span class=\"n\">to_surj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"n\">nn0ind'</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n<p>This is proving that <code>cℕ₀</code>, which is notation for metamath's <code>NN0</code> (natural numbers with zero), is isomorphic to <code>ℕ</code> (lean's <code>nat</code>), using metamath theorems <code>nn0ex</code> which says <code>cℕ₀</code> is a set, and <code>nn0ind'</code> which is one version of an induction theorem for nn0</p>",
        "id": 214126466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603321966
    },
    {
        "content": "<p>it also declares it as an instance so that later proofs can use the isomorphism to prove for example that metamath's <code>c0</code> is mapped to lean's <code>0 : nat</code> by this isomorphism</p>",
        "id": 214126546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322045
    },
    {
        "content": "<p>hmm, interesting. i was imagining pushing down the mapping so that the formulas would be using Lean nat in a bunch of places, and then maybe some axioms would be missing</p>",
        "id": 214126605,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603322127
    },
    {
        "content": "<p>that part happens mostly automatically using the typeclasses, this is the setup</p>",
        "id": 214126619,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322152
    },
    {
        "content": "<p>But you can't use lean nat directly and get 100% coverage</p>",
        "id": 214126690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322192
    },
    {
        "content": "<p>or at least, not without more complex translation</p>",
        "id": 214126705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322206
    },
    {
        "content": "<p>However it does use lean's forall, exists, and, or directly, which makes a lot of things easier since you can just definitionally reduce things to see the lean versions</p>",
        "id": 214126725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322249
    },
    {
        "content": "<p>But keep in mind that the lean file exporter has no actual knowledge or integration with the lean executable, so its ability to produce nice lean files is extremely limited</p>",
        "id": 214126791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322313
    },
    {
        "content": "<p>remember that even lean doesn't know how to print lean terms in a completely 100% faithful way</p>",
        "id": 214126818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322356
    },
    {
        "content": "<p>I have empathy for lean's difficulties here, there are like dozens of unicode arrows that mean different things</p>",
        "id": 214126893,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1603322416
    },
    {
        "content": "<p>so the role of these shim files is to put notations on things, unfold definitions as required, and basically make the library more human accessible</p>",
        "id": 214126954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603322502
    },
    {
        "content": "<p>AFAIR, triangles allow us to prove that a complex differentiable is analytic while the general Stokes formula needs continuous differentiability.</p>",
        "id": 214203271,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603380378
    },
    {
        "content": "<p>Indeed, I think Patrick was addressing that point here:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214105257\">said</a>:</p>\n<blockquote>\n<p>I don't see the point of going through Goursat even in dimension 1.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Single.20variable.20complex.20analysis/near/214105351\">said</a>:</p>\n<blockquote>\n<p>People usually do that because they have a version of Stokes with too strong assumptions and they insist on defining holomorphic functions as complex-differentiable without assuming C¹ in the real sense.</p>\n</blockquote>",
        "id": 214216981,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603386272
    },
    {
        "content": "<p>(But I didn't quite understand what he was proposing -- is there a version of Stokes requiring less regularity?)</p>",
        "id": 214217035,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603386301
    },
    {
        "content": "<p>I learnt last year that there is an old book by Whitney that has extremely general versions of Stokes. But that's all I know.</p>",
        "id": 214217467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386498
    },
    {
        "content": "<p>I'm very far from an expert.</p>",
        "id": 214217484,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386503
    },
    {
        "content": "<p>With extremely general, I mean: very weak conditions on how differentiable you are, and your manifold is also allowed to be pretty wild.</p>",
        "id": 214217577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603386550
    },
    {
        "content": "<p>I can integrate <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">dx</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">x</span></span></span></span> along any path <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi><mo>:</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>→</mo><msup><mi mathvariant=\"double-struck\">R</mi><mn mathvariant=\"double-struck\">2</mn></msup></mrow><annotation encoding=\"application/x-tex\">\\gamma : [0, 1] \\to \\mathbb{R^2}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>. Doesn't even have to be continuous <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 214217770,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603386623
    },
    {
        "content": "<p>I think that if Goursat gives us, e.g., the maximum principle before we define differential forms etc, then it's worth it.</p>",
        "id": 214230665,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603392262
    },
    {
        "content": "<p>Yes I meant there are versions of Stokes that assume only stuff you get for complex differentiable functions.</p>",
        "id": 214237436,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603395246
    },
    {
        "content": "<p>See <a href=\"https://link.springer.com/article/10.1007/BF03024304\">https://link.springer.com/article/10.1007/BF03024304</a></p>",
        "id": 214237803,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1603395428
    },
    {
        "content": "<p>Thanks a lot for the link!</p>",
        "id": 214247205,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603400229
    }
]
[
    {
        "content": "<p><code>example {ι : Type*} {β : ι → Type*} [Π i, add_monoid (β i)] {i j : ι} (h : i = j) : β i ≃+ β j := sorry</code> do we have anything like that (and similar for other structures) ? I see <code>equiv.cast</code> but it doesn't preserve structure</p>",
        "id": 277132743,
        "sender_full_name": "Pierre-Alexandre Bazin",
        "timestamp": 1648641849
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">≃+</span> <span class=\"n\">β</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.rec</span> <span class=\"o\">(</span><span class=\"n\">add_equiv.refl</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n</code></pre></div>\n<p>No idea if it's usable</p>",
        "id": 277135339,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648642995
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add_equiv_of_eq</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">≃+</span> <span class=\"n\">β</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq.rec</span> <span class=\"o\">(</span><span class=\"n\">add_equiv.refl</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- go to j and then back again</span>\n<span class=\"kd\">def</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">≃+</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">add_equiv_of_eq</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">add_equiv_of_eq</span> <span class=\"n\">h.symm</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">test</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">test</span><span class=\"o\">,</span> <span class=\"n\">add_equiv_of_eq</span><span class=\"o\">],</span>\n  <span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">  ⊢ ⇑(eq.rec (add_equiv.refl (β j)) _) (⇑(eq.rec (add_equiv.refl (β i)) h) x) = x</span>\n<span class=\"cm\">  -/</span>\n  <span class=\"gr\">sorry</span> <span class=\"c1\">-- no idea how to proceed</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I can't use it, at least. Are you in a situation where all you care about is the isomorphism and you never need to \"evaluate\" it?</p>",
        "id": 277135836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648643234
    },
    {
        "content": "<p>Trying to do it using <code>equiv.cast</code>, I ended up with this : </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_monoid</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span> <span class=\"bp\">≃+</span> <span class=\"n\">β</span> <span class=\"n\">j</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">equiv.cast_eq_iff_heq</span> <span class=\"bp\">$</span> <span class=\"n\">congr_arg</span> <span class=\"n\">β</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">heq.rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h.symm</span> <span class=\"o\">},</span> <span class=\"n\">repeat</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">cast_heq</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">equiv.cast</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">β</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>I don't know if it's more usable</p>",
        "id": 277136170,
        "sender_full_name": "Pierre-Alexandre Bazin",
        "timestamp": 1648643398
    },
    {
        "content": "<p>Why do you need it? Just to make statements of the form \"these things are isomorphic\", or do you ever need to \"compute\" the isomorphism?</p>",
        "id": 277140497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648645352
    },
    {
        "content": "<p>If you are in a situation where you can use <code>subst</code> then it seems that you can reduce computations to <code>heq</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">==</span> <span class=\"n\">add_equiv_of_eq</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">heq_of_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 277140925,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648645491
    },
    {
        "content": "<p>Indeed this works well (and from there you should be able to prove your <code>test h x = x</code>, by proving first <code>test h x == x</code>by transitivity)</p>\n<p>My goal was to be able to reindex a direct sum, so I have an equiv <code>h</code> between the indices and at some point I needed the equiv between <code>β i</code> and <code>β (h (h.symm i))</code></p>",
        "id": 277146260,
        "sender_full_name": "Pierre-Alexandre Bazin",
        "timestamp": 1648647832
    },
    {
        "content": "<p>I see. Yes this is exactly the situation where you need something like the construction above.</p>",
        "id": 277169317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1648657221
    }
]
[
    {
        "content": "<p><del>I'm pretty sure this lemma is true modulo typos:</del> (proven)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_reverse</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">l.reverse.prod</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"bp\">⁻¹</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">prod_reverse</span> <span class=\"n\">xs</span><span class=\"o\">]</span>\n</code></pre></div>\n\n<p>Does this exist anywhere?</p>",
        "id": 214159820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603357089
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4738\">#4738</a></p>",
        "id": 214173788,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603366405
    },
    {
        "content": "<p>That PR adds</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prod_inv_reverse</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">L.prod</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">reverse.prod</span>\n</code></pre></div>\n\n<p>However, I've realized I still want the original in this thread,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">what</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">l.reverse.prod</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">l.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"bp\">⁻¹</span>\n</code></pre></div>\n\n<p>What should this second lemma be called?</p>",
        "id": 214194787,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603376903
    },
    {
        "content": "<p>I think <code>prod_reverse</code> is a fine name</p>",
        "id": 214195107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603377042
    },
    {
        "content": "<p>Is there another right hand side that a lemma of that name could have?</p>",
        "id": 214195174,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603377072
    },
    {
        "content": "<p>prod_reverse could be for a version with <code>comm_group</code> that says <code>l.prod = l.reverse.prod</code></p>",
        "id": 214196724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603377691
    },
    {
        "content": "<p><code>prod_reverse_noncomm</code>?</p>",
        "id": 214196785,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603377719
    },
    {
        "content": "<p>or it could also be <code>prod_reverse_eq_inv_prod_inv</code> or something</p>",
        "id": 214196878,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603377744
    },
    {
        "content": "<p>For my <code>what</code> lemma, you mean?</p>",
        "id": 214196887,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603377748
    },
    {
        "content": "<p>Yes</p>",
        "id": 214196927,
        "sender_full_name": "Reid Barton",
        "timestamp": 1603377764
    },
    {
        "content": "<p><code>prod_reverse_noncomm</code> seems reasonable, and I could add <code>prod_reverse</code> in the same PR</p>",
        "id": 214197005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603377798
    },
    {
        "content": "<p>What about <code>prod_inv</code> (for a name). cf. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_inv\">docs#mul_inv</a></p>",
        "id": 214198961,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378577
    },
    {
        "content": "<p><del>Or <code>list_mul_inv</code> if there's a concern about name conflicts when the list namespace is open.</del></p>",
        "id": 214199056,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378629
    },
    {
        "content": "<p>Wait, I thought there was a version of <code>mul_inv</code>for noncommutative groups.</p>",
        "id": 214199400,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378787
    },
    {
        "content": "<p>Oh, it's called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_inv_rev\">docs#mul_inv_rev</a></p>",
        "id": 214199506,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378823
    },
    {
        "content": "<p>So I think <code>prod_inv_reverse</code> should be called <code>prod_inv_rev</code>.</p>",
        "id": 214199600,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378870
    },
    {
        "content": "<p>Is there an analogue of <code>what</code> for a product of two elements?</p>",
        "id": 214199904,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603378988
    },
    {
        "content": "<p>In Leiden it would be called <code>socks_and_shoes</code></p>",
        "id": 214200338,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603379157
    },
    {
        "content": "<p>Because, well, if you first put on your socks, and then your shoes, you should remove them in the reverse order.</p>",
        "id": 214200432,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603379185
    },
    {
        "content": "<blockquote>\n<p>So I think prod_inv_reverse should be called prod_inv_rev.</p>\n</blockquote>\n<p>I went for <code>reverse</code> so it contained the function name - but I made sure to include <code>mul_inv_rev</code> in the docstring</p>",
        "id": 214200453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603379196
    },
    {
        "content": "<blockquote>\n<p>Is there an analogue of what for a product of two elements?</p>\n</blockquote>\n<p>No, which surprised me - we don't seem to have <code>(a⁻¹ * b⁻¹)⁻¹ = b * a</code> or the reverse</p>",
        "id": 214200495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603379219
    },
    {
        "content": "<p>So in the first year algebra course the lemma <code>(x * y) \\inv = y \\inv * x \\inv</code> has this funny name <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 214200531,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603379236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Product.20of.20a.20reversed.20list.20is.20inverse.20of.20product.20of.20inverses/near/214200495\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is there an analogue of what for a product of two elements?</p>\n</blockquote>\n<p>No, which surprised me - we don't seem to have <code>(a⁻¹ * b⁻¹)⁻¹ = b * a</code></p>\n</blockquote>\n<p>I think <code>by simp</code> would solve this.</p>",
        "id": 214200597,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379275
    },
    {
        "content": "<p>Yes, it would</p>",
        "id": 214200674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603379295
    },
    {
        "content": "<p>because of the <code>mul_inv_rev</code> and <code>inv_inv</code> lemmas</p>",
        "id": 214200681,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379298
    },
    {
        "content": "<p>But perhaps a lemma is still useful so it can be referred to by name?</p>",
        "id": 214200721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603379318
    },
    {
        "content": "<p>Maybe, but surely it shouldn't be a simp lemma.</p>",
        "id": 214200765,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379336
    },
    {
        "content": "<p>Oh for sure it shouldn't be <code>simp</code></p>",
        "id": 214200798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603379345
    },
    {
        "content": "<p>I'm just thinking of how I would actually use it in a proof, and I would always solve such things by simp, so I'm not sure I would ever actually use a lemma which says <code>(a⁻¹ * b⁻¹)⁻¹ = b * a</code>.</p>",
        "id": 214200895,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379391
    },
    {
        "content": "<p><code>socks_and_shoes</code> or <code>underwear_and_pants</code>?</p>",
        "id": 214201190,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379475
    },
    {
        "content": "<p>It's a little silly that simp doesn't solve the following </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- by simp doesn't solve this.</span>\n</code></pre></div>",
        "id": 214202006,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379802
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 214202111,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603379851
    },
    {
        "content": "<p>Sure, but I would like to be able to make <code>prod_inv_reverse</code> into a simp lemma, and be able to solve <code>what</code> with <code>by simp</code>.</p>",
        "id": 214202266,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603379915
    },
    {
        "content": "<p>there should be a <code>map_id'</code> lemma that helps simp solve statements like that</p>",
        "id": 214202840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380200
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">),</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">bar</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 214202865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603380220
    },
    {
        "content": "<p>I don't think <code>bar</code> can work as a simp lemma itself, it would cause too many other problems</p>",
        "id": 214203033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380290
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹⁻¹</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">tidy</span>\n</code></pre></div>",
        "id": 214203050,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603380298
    },
    {
        "content": "<p><code>map_id'</code> just says <code>L.map (\\lam x, x) = L</code></p>",
        "id": 214203069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380308
    },
    {
        "content": "<p>Oh okay.</p>",
        "id": 214203093,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603380319
    },
    {
        "content": "<p>Is there a tactic that's weaker than <code>tidy</code> which only does <code>ext</code> and <code>simp</code>?</p>",
        "id": 214203264,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603380374
    },
    {
        "content": "<p><code>ext; simp</code></p>",
        "id": 214203283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380385
    },
    {
        "content": "<p>What happens if you have to introduce more <code>ext</code> after a <code>simp</code>?</p>",
        "id": 214203333,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1603380411
    },
    {
        "content": "<p><code>ext; simp; ext</code></p>",
        "id": 214203360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380424
    },
    {
        "content": "<p>actually I don't find it that often</p>",
        "id": 214203429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380450
    },
    {
        "content": "<p>you can try using something like <code>simp [ext_iff]</code> but YMMV</p>",
        "id": 214203580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603380501
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4744\">#4744</a> helps a little with <code>example : L.map (λ x, x⁻¹⁻¹) = L := by simp</code>. At any rate, it suffices to solve <code>what</code> by <code>simp</code></p>",
        "id": 214204090,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603380709
    },
    {
        "content": "<p>Turns out <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.prod_reverse\">docs#list.prod_reverse</a> already exists!</p>",
        "id": 214315757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603461193
    },
    {
        "content": "<p>I think what's missing from that file, or from the general theory of permutations (which is somewhat scattered across mathlib across different areas of interest), is that a pairwise swap is a product of adjacent swaps.</p>",
        "id": 214316178,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1603461423
    },
    {
        "content": "<p>That's what I had originally set out to prove, and need this lemma for</p>",
        "id": 214316355,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603461506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is the master at this sort of thing -- if it's there he'll know where it is :-) (because he will have put it there!)</p>",
        "id": 214317840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603462150
    },
    {
        "content": "<p>I haven't done that one, but it sounds like it would fall out of the work needed for the alternating group</p>",
        "id": 214318015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603462225
    },
    {
        "content": "<p>plus there is the question of how to phrase \"adjacent\" in appropriately general way</p>",
        "id": 214318323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603462395
    },
    {
        "content": "<p>Maybe this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.sign</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">relation.refl_trans_gen</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">swap</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">l.prod</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">swap</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">_</span>\n</code></pre></div>",
        "id": 214319532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603462965
    },
    {
        "content": "<p>I think we already have that</p>",
        "id": 214319595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603462997
    },
    {
        "content": "<p>It's the _adjacent_ swap theorem we don't have</p>",
        "id": 214319620,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603463008
    },
    {
        "content": "<p>That's what that is</p>",
        "id": 214319629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603463014
    },
    {
        "content": "<p>Whoops, I missed <code>R a b</code> there. Is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/relation.refl_trans_gen\">docs#relation.refl_trans_gen</a> the magic there?</p>",
        "id": 214319723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603463045
    },
    {
        "content": "<p>To get the result for adjacent swaps you have to supply <code>\\lam x y, x = y + 1</code> as <code>R</code> and then prove that <code>refl_trans_gen R</code> holds for any two nats/fins or what have you</p>",
        "id": 214319794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603463079
    },
    {
        "content": "<p>Actually I guess it could use <code>eqv_gen</code>, since <code>swap</code> is commutative</p>",
        "id": 214319891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603463137
    },
    {
        "content": "<p>I suppose you could make that actually compute the list with <code>(next : α → α) (hr : relation.refl_trans_gen (fun x y, next x = y) x y)</code></p>",
        "id": 214320105,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603463233
    },
    {
        "content": "<p>that's just a special case</p>",
        "id": 214320618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603463452
    },
    {
        "content": "<p>It's an existential even then because of <code>refl_trans_gen</code> which is a prop</p>",
        "id": 214320725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603463505
    },
    {
        "content": "<p>I'm not sure I agree with that - I was able to computably obtain the list in <a href=\"https://github.com/leanprover-community/mathlib/issues/4379\">#4379</a> for when <code>α</code> is <code>nat</code>, and I think all I needed was <code>next</code> and a transitive relation</p>",
        "id": 214320964,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603463600
    },
    {
        "content": "<p>You also need to know the length of the sequence</p>",
        "id": 214323137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603464598
    },
    {
        "content": "<p>which is possible on <code>nat</code> and similar things but amounts to the <code>enum</code> class that <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> proposed in the other thread</p>",
        "id": 214323241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603464632
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.sign</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n<span class=\"kn\">section</span> <span class=\"n\">group</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- This is the `list.prod` version of `mul_inv_rev` -/</span>\n<span class=\"kd\">@[to_additive \"This is the `list.sum` version of `add_neg_rev`\"]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_inv_reverse</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">L.prod</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">L.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">reverse.prod</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">prod_inv_reverse</span> <span class=\"n\">xs</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">group</span>\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">eqv_gen</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">swap</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">l.prod</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">swap</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">Hrefl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">swap</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">l.prod</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">swap</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">⟨[],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">swap_self</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟩⟩,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">hr</span><span class=\"o\">,</span>\n  <span class=\"n\">case</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hr</span> <span class=\"o\">{</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨[</span><span class=\"n\">swap</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">],</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">forall_eq</span><span class=\"o\">,</span> <span class=\"n\">list.mem_singleton</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">Hrefl</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hr</span> <span class=\"n\">IH</span> <span class=\"o\">{</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨(</span><span class=\"n\">l.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">reverse</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">list.prod_inv_reverse</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">swap_inv</span><span class=\"o\">,</span> <span class=\"n\">swap_comm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">hp</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">case</span> <span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">hr₁</span> <span class=\"n\">hr₂</span> <span class=\"n\">IH₁</span> <span class=\"n\">IH₂</span> <span class=\"o\">{</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">H₁</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">l₂</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"o\">,</span> <span class=\"n\">H₂</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">IH₁</span><span class=\"o\">,</span> <span class=\"n\">IH₂</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">zy</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"n\">H₁</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">zx</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">Hrefl</span> <span class=\"o\">},</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span> <span class=\"bp\">++</span> <span class=\"n\">l₁</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">swap_comm</span> <span class=\"n\">at</span> <span class=\"n\">e₁</span> <span class=\"n\">e₂</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list.prod_append</span><span class=\"o\">,</span> <span class=\"n\">list.prod_append</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">e₁</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">e₂</span><span class=\"o\">,</span> <span class=\"n\">perm.swap_mul_swap_mul_swap</span> <span class=\"n\">zy</span> <span class=\"n\">zx</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">or.right_comm</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h.elim</span> <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₂</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 214323484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603464778
    },
    {
        "content": "<p>I was looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.swap_mul_swap_mul_swap\">docs#equiv.perm.swap_mul_swap_mul_swap</a>...</p>",
        "id": 214324409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603465229
    },
    {
        "content": "<p>it should be in <code>equiv.basic</code></p>",
        "id": 214324593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603465317
    },
    {
        "content": "<p>Or should <code>equiv.swap</code> be renamed to <code>equiv.perm.swap</code>?</p>",
        "id": 214324674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603465337
    },
    {
        "content": "<p>maybe? It is an equiv though</p>",
        "id": 214324908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603465470
    },
    {
        "content": "<p>Well, so are all perms</p>",
        "id": 214324984,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603465512
    },
    {
        "content": "<p>And it's defined as <code>def swap (a b : α) : perm α</code></p>",
        "id": 214325063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1603465560
    }
]
[
    {
        "content": "<p>Hey, i've got the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.nodup_of_to_finset_card_eq_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">l.length</span> <span class=\"bp\">→</span> <span class=\"n\">l.nodup</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.length</span><span class=\"o\">,</span> <span class=\"n\">list.to_finset_nil</span><span class=\"o\">,</span> <span class=\"n\">finset.card_empty</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">,</span>\n                <span class=\"n\">list.nodup_nil</span><span class=\"o\">,</span> <span class=\"n\">forall_true_left</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.length</span><span class=\"o\">,</span> <span class=\"n\">list.to_finset_cons</span><span class=\"o\">,</span> <span class=\"n\">list.nodup_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"n\">l_tl.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">l_tl.length</span><span class=\"o\">,</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">list.to_finset_card_le</span> <span class=\"n\">l_tl</span><span class=\"o\">),</span>\n      <span class=\"n\">by_contra'</span> <span class=\"n\">h'</span><span class=\"o\">,</span>\n      <span class=\"n\">linarith</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">finset.card_insert_le</span> <span class=\"n\">l_hd</span> <span class=\"n\">l_tl.to_finset</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">l_ih</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">h''</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">h''</span><span class=\"o\">,</span> <span class=\"n\">finset.insert_eq_of_mem</span><span class=\"o\">,</span> <span class=\"n\">list.mem_to_finset</span><span class=\"o\">,</span> <span class=\"n\">self_eq_add_right</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.nodup_iff_to_finset_card_eq_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.nodup</span> <span class=\"bp\">↔</span> <span class=\"n\">l.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">l.length</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">@</span><span class=\"n\">list.to_finset_card_of_nodup</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">list.nodup_of_to_finset_card_eq_length</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>and I think only one direction is covered by mathlib. Can someone confirm that this doesn't exist somewhere already?</p>",
        "id": 308237775,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667731246
    },
    {
        "content": "<p><code>l.dedup ~ l → l.nodup</code> feels like a more natural way to get to that proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.nodup_of_dedup_perm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.dedup</span> <span class=\"bp\">~</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">list.perm.nodup_iff</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">l.nodup_dedup</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.nodup_of_length_dedup_eq_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.dedup.length</span> <span class=\"bp\">=</span> <span class=\"n\">l.length</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l.nodup</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.nodup_of_dedup_perm</span> <span class=\"bp\">$</span> <span class=\"n\">l.dedup_sublist.subperm.perm_of_length_le</span> <span class=\"n\">h.ge</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">list.nodup_of_to_finset_card_eq_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">l.length</span> <span class=\"bp\">→</span> <span class=\"n\">l.nodup</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.nodup_of_length_dedup_eq_length</span>\n</code></pre></div>",
        "id": 308242501,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667734207
    },
    {
        "content": "<p>(<a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.perm.nodup_iff\">docs#list.perm.nodup_iff</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.subperm.perm_of_length_le\">docs#list.subperm.perm_of_length_le</a> are doing the heavy lifting there)</p>",
        "id": 308244064,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667735057
    },
    {
        "content": "<p>ah, indeed, that's nicer! does that deserve a PR?</p>",
        "id": 308250571,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667738844
    },
    {
        "content": "<p>The first lemma certainly seems PR worthy,  the second one probably is, and I think the last one probably isn't</p>",
        "id": 308251283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667739279
    },
    {
        "content": "<p>Maybe <code>list.nodup_of_dedup_perm </code> should be an <code>iff</code> or there should be a separate <code>iff</code> lemma</p>",
        "id": 308251353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1667739321
    },
    {
        "content": "<p>Ah, actually <code>dedup_eq_self</code> is a good alternative to what I originally had in mind!</p>",
        "id": 308252522,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667739967
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> I guess</p>",
        "id": 308252536,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1667739974
    }
]
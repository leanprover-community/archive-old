[
    {
        "content": "<p>Is there code anywhere for the disjoint union of partially ordered sets? Something that takes the disjoint union of their underlying types and keeps only the ordering relations that exist within each type? I've started to hack something together for my own purposes, but it would be great to know if there is already a robust API somewhere? </p>\n<p>I'm also interested in the sequential composition of posets A and B, where everything from A precedes everything from B in the composition, and all other relations are preserved.</p>",
        "id": 266984280,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641413268
    },
    {
        "content": "<p>You will be glad to know that I have a PR which does precisely this!</p>",
        "id": 266984370,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641413300
    },
    {
        "content": "<p>Does it do both things? I.e. \"parallel\" and \"sequential\" unions?</p>",
        "id": 266984508,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641413374
    },
    {
        "content": "<p>For some reason I don't understand, nobody needed it so far. But I thought it would be fun to use the disjoint/lexicographic sum of orders for more complicated order notions (locally finite orders, graded orders, incidence algebras...). So I wrote <a href=\"https://github.com/leanprover-community/mathlib/pull/11157\">#11157</a></p>",
        "id": 266984596,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641413411
    },
    {
        "content": "<p>Because there are two natural orders to put on <code>α ⊕ β</code>, my design is to equip <code>α ⊕ β</code> with the disjoint order and have <code>α ⊕ₗ β</code> a type synonym which is equipped with the linear sum.</p>",
        "id": 266984863,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641413531
    },
    {
        "content": "<p>I expect it be merged today or tomorrow at the latest.</p>",
        "id": 266984927,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641413566
    },
    {
        "content": "<p>Oh that's great! Where should I look and what should I look for to know when it is merged?</p>",
        "id": 266984987,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641413610
    },
    {
        "content": "<p>You can click here --&gt; <a href=\"https://github.com/leanprover-community/mathlib/pull/11157\">#11157</a> &lt;-- and later it will be in <a href=\"https://tqft.net/mathlib/data/sum/order\">file#data/sum/order</a></p>",
        "id": 266985441,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641413833
    },
    {
        "content": "<p>Got it. Thanks. I'm excited to check it out.</p>",
        "id": 266985710,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641413971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300396\">@Paul Rowe</span>, it's in!</p>",
        "id": 267286894,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641634739
    },
    {
        "content": "<p>Fantastic! I'll check it out today.</p>",
        "id": 267441947,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641823247
    },
    {
        "content": "<p>So, I'm trying to use the new material  by incorporating it into a structure that is basically a finite labeled partial order. I'm able to transfer <code>sum_comm</code> and <code>sum_assoc</code> to my new structure, but I hit a snag in transferring <code>sum_lex_assoc</code>. In the mwe below, the final <code>simp</code> tactic fails to solve the goal, when it does solve the equivalent goal of merge. I can probably power through, but I'm not sure if there's a good reason for this not to simplify?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sum.order</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">evt</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">poset</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">evt</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">evt</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fintype_evsys</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E.fin</span>\n<span class=\"kd\">instance</span> <span class=\"n\">poset_evsys</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E.poset</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">evsys_iso</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">order_iso</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">label</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">E1.l</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"o\">(</span><span class=\"n\">order.to_fun</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃ₑ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">evsys_iso</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">E1.evt</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"n\">E2.evt</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">E1.evt</span> <span class=\"bp\">⊕</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">fin</span> <span class=\"o\">:=</span> <span class=\"n\">sum.fintype</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">poset</span> <span class=\"o\">:=</span> <span class=\"n\">sum.partial_order</span><span class=\"o\">,</span>\n  <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">E1.l</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">E2.l</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span>  <span class=\"o\">}</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">⋈</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">merge</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">merge_label_inl</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">sum.inl</span> <span class=\"n\">e1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E1.l</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">merge_label_inr</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">sum.inr</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge.assoc</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">):</span>\n <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"bp\">⋈</span> <span class=\"n\">E3</span> <span class=\"bp\">≃ₑ</span> <span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">⋈</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge.comm</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span><span class=\"o\">):</span>\n<span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span> <span class=\"bp\">≃ₑ</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">⋈</span> <span class=\"n\">E1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_comm</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n  <span class=\"kd\">def</span> <span class=\"n\">before</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">E1.evt</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">fin</span> <span class=\"o\">:=</span> <span class=\"n\">sum.fintype</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">poset</span> <span class=\"o\">:=</span> <span class=\"n\">sum.lex.partial_order</span><span class=\"o\">,</span>\n  <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">E1.l</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">E2.l</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">▷</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">before</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">before_label_inl</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">sum.inl</span> <span class=\"n\">e1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E1.l</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">before_label_inr</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">sum.inr</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">before_assoc</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span> <span class=\"bp\">≃ₑ</span> <span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_lex_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 267477121,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641838027
    },
    {
        "content": "<p>This is because casing on <code>e : (E1 ▷ E2 ▷ E3).evt</code> breaks the type synonym.</p>",
        "id": 267489390,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641843746
    },
    {
        "content": "<p>I see. So would it work if I replaced the casing with a lemma that details the cases?</p>",
        "id": 267489537,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641843820
    },
    {
        "content": "<p>Or, rather, I can't figure out how to add back in the type synonym info into the right places.</p>",
        "id": 267489612,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641843856
    },
    {
        "content": "<p>Taking the first goal out of three before the <code>simp</code> in <code>before_assoc</code>, we get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">sum.inl</span> <span class=\"n\">sum.inl</span>\n<span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">:</span> <span class=\"n\">evsys</span>\n<span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">E1.evt</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">((</span><span class=\"n\">order_iso.sum_lex_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_equiv.to_fun</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but it should be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">case</span> <span class=\"n\">sum.inl</span> <span class=\"n\">sum.inl</span>\n<span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">:</span> <span class=\"n\">evsys</span>\n<span class=\"n\">e</span><span class=\"o\">:</span> <span class=\"n\">E1.evt</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">inlₗ</span> <span class=\"o\">(</span><span class=\"n\">inlₗ</span> <span class=\"n\">e</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">((</span><span class=\"n\">order_iso.sum_lex_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_equiv.to_fun</span> <span class=\"o\">(</span><span class=\"n\">inlₗ</span> <span class=\"o\">(</span><span class=\"n\">inlₗ</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 267489714,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641843920
    },
    {
        "content": "<p>This is a rather technical issue, I'm sorry <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span> <br>\nI didn't know how to do myself it until a week ago</p>",
        "id": 267489833,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641843978
    },
    {
        "content": "<p>One easy way is to use <code>change</code> to fix the goal exactly as it should be, but the goal is long enough for that to be a pain.</p>",
        "id": 267489907,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641844015
    },
    {
        "content": "<p>I see. No problem! I'll give that a shot.</p>",
        "id": 267490218,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641844167
    },
    {
        "content": "<p>Wait, I haven't given you the proper solution yet <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 267490257,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641844185
    },
    {
        "content": "<p>And yes, the type synonym stuff is basically all new to me, so I'm flying blind.</p>",
        "id": 267490275,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641844196
    },
    {
        "content": "<p>Yeah, I'm assuming that if I try to use <code>change</code> I can muddle through. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 267490365,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641844230
    },
    {
        "content": "<p>The idea is to define custom pattern-matching and then use it instead of casing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sum.order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">sum</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">fin</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">evt</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">poset</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">evt</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">evt</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">fintype_evsys</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E.fin</span>\n<span class=\"kd\">instance</span> <span class=\"n\">poset_evsys</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">E.poset</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">evsys_iso</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">order</span> <span class=\"o\">:</span> <span class=\"n\">order_iso</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">label</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">E1.l</span> <span class=\"n\">e</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"o\">(</span><span class=\"n\">order.to_fun</span> <span class=\"n\">e</span><span class=\"o\">))</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">≃ₑ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">evsys_iso</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">E1.evt</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"n\">E2.evt</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">E1.evt</span> <span class=\"bp\">⊕</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.elim</span> <span class=\"n\">E1.l</span> <span class=\"n\">E2.l</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">⋈</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">merge</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">merge_label_inl</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">inl</span> <span class=\"n\">e1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E1.l</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">merge_label_inr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">inr</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge.assoc</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"bp\">⋈</span> <span class=\"n\">E3</span> <span class=\"bp\">≃ₑ</span> <span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">⋈</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">merge.comm</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">E1</span> <span class=\"bp\">⋈</span> <span class=\"n\">E2</span> <span class=\"bp\">≃ₑ</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">⋈</span> <span class=\"n\">E1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_comm</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">before</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">E1.evt</span> <span class=\"bp\">⊕ₗ</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">fin</span> <span class=\"o\">:=</span> <span class=\"n\">sum.fintype</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">e.elim</span> <span class=\"n\">E1.l</span> <span class=\"n\">E2.l</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">▷</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">before</span>\n\n<span class=\"sd\">/-- Lexicographical `sum.inl`. Only used for pattern matching. -/</span>\n<span class=\"kd\">@[pattern]</span> <span class=\"kd\">abbreviation</span> <span class=\"n\">binl</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E1.evt</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">sum.inl</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- Lexicographical `sum.inr`. Only used for pattern matching. -/</span>\n<span class=\"kd\">@[pattern]</span> <span class=\"kd\">abbreviation</span> <span class=\"n\">binr</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E2.evt</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">evt</span> <span class=\"o\">:=</span> <span class=\"n\">to_lex</span> <span class=\"o\">(</span><span class=\"n\">sum.inr</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">before_label_inl</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">binl</span> <span class=\"n\">e1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E1.l</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">before_label_inr</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">binr</span> <span class=\"n\">e2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">E2.l</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">before_assoc</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"n\">E2</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"n\">E2</span><span class=\"o\">)</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span> <span class=\"bp\">≃ₑ</span> <span class=\"n\">E1</span> <span class=\"bp\">▷</span> <span class=\"o\">(</span><span class=\"n\">E2</span> <span class=\"bp\">▷</span> <span class=\"n\">E3</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">order</span> <span class=\"o\">:=</span> <span class=\"n\">order_iso.sum_lex_assoc</span> <span class=\"n\">E1.evt</span> <span class=\"n\">E2.evt</span> <span class=\"n\">E3.evt</span><span class=\"o\">,</span>\n  <span class=\"n\">label</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"k\">match</span> <span class=\"n\">e</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">binl</span> <span class=\"o\">(</span><span class=\"n\">binl</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">binl</span> <span class=\"o\">(</span><span class=\"n\">binr</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n    <span class=\"bp\">|</span> <span class=\"n\">binr</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 267490816,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641844444
    },
    {
        "content": "<p>Note that I made some changes to the rest of the file to show you mathlib style and some tricks. For example, you can use <code>[]</code> in the definition of <code>evsys</code> to make Lean automatically fill in <code>fintype evt</code> and <code>partial_order evt</code> through typeclass inference.</p>",
        "id": 267491178,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641844609
    },
    {
        "content": "<p>Also, what's your end goal? Do you have a reference I can look at?</p>",
        "id": 267491261,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641844656
    },
    {
        "content": "<p>Thanks for the tips and the style advice! I will try to run with what you gave me. I'm especially happy with the type class inference allowing one to elide those fields  when defining <code>merge</code>. I just had the linter generate the skeleton of the structure for me, so I dutifully filled in each field. I assume the type synonym makes type class inference fail for the <code>before</code> structure so the <code>fin</code> field is still required there?</p>\n<p>As for my end goal, I'm sort of just playing around. But one relevant reference is <a href=\"https://pauldavidrowe.github.io/papers/attacktrees-copland.pdf\">here</a>. The code above is mostly elaborating Definition 4 (with the observation that I assumed labeled DAGs in the paper, when I really want partial orders having a transitive edge relation).</p>",
        "id": 267503485,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641850397
    },
    {
        "content": "<p>The <code>fin</code> field shouldn't be required but we're missing the trivial instance <code>fintype α : fintype (lex α)</code> (you can try to provide it yourself! It's really not hard). <code>lex</code> is a newborn, so expect such holes.</p>",
        "id": 267503897,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641850581
    },
    {
        "content": "<p>Hmm... I think I don't understand. I tried <code>instance fintype_lex (h : fintype α) : fintype (lex α) := h</code> which doesn't complain, but that doesn't allow me to erase the <code>fin</code> field in <code>before</code>. Anyway, it doesn't really matter. I can clearly get by without type class inference doing it for me. I'm mostly just viewing this an opportunity to learn more about these more subtle (to me) points of style.</p>",
        "id": 267509666,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641853145
    },
    {
        "content": "<p>Ah of course, you used the wrong brackets. Here's what you should do:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">lex.fintype</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">lex</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">‹</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">›</span> <span class=\"c1\">-- \\fl and \\fr for French quotes</span>\n</code></pre></div>\n<p>Then it works.</p>",
        "id": 267514789,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641856040
    },
    {
        "content": "<p>Indeed it does! <code>\\fl \\fr</code> is new to me. But I should have thought of using <code>[]</code> in the context. Thanks again for all your help!</p>",
        "id": 267517098,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641857640
    },
    {
        "content": "<p>I'm reading your article. There's a typo in definition 2. <a href=\"/user_uploads/3121/udv5f4khpXywQsIq6sxXOmn6/image.png\">image.png</a> <br>\nShould be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"normal\">ℓ</mi><mi>G</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mi mathvariant=\"normal\">ℓ</mi><mi>H</mi></msub><mo stretchy=\"false\">(</mo><mi>η</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\ell_G(n) = \\ell_H(\\eta(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">ℓ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">η</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">))</span></span></span></span></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/udv5f4khpXywQsIq6sxXOmn6/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/udv5f4khpXywQsIq6sxXOmn6/image.png\"></a></div>",
        "id": 267610680,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641919980
    },
    {
        "content": "<blockquote>\n<p>If we only allow injective homomorphisms, then the preorder is actually a partial order (up to isomorphism) because injective homomorphisms in both directions between (finite) graphs G and H imply that G and H are isomorphic</p>\n</blockquote>\n<p>This is nontrivial, right? The injections don't have to cancel.</p>",
        "id": 267610983,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641920106
    },
    {
        "content": "<p>Maybe I've done too much type theory but this doesn't typecheck. What do you mean? <a href=\"/user_uploads/3121/Ickl61ueH94iNyHnFG03vYM4/image.png\">image.png</a> <br>\nAn illustration or two would clarify</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/Ickl61ueH94iNyHnFG03vYM4/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/Ickl61ueH94iNyHnFG03vYM4/image.png\"></a></div>",
        "id": 267612074,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641920527
    },
    {
        "content": "<p>I think that makes sense - take all the edges from E, and add in an edge from every vertex of G to every vertex of H, essentially unioning the complete bipartite graph's edges on</p>",
        "id": 267613042,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641920936
    },
    {
        "content": "<p>That's what I thought too but it's written <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>∪</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msub><mi>N</mi><mi>G</mi></msub><mo>×</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><msub><mi>N</mi><mi>H</mi></msub><mo>×</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E \\cup((N_G \\times \\{0\\}) \\times (N_H \\times \\{1\\}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">})</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}))</span></span></span></span> not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>∪</mo><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><msub><mi>N</mi><mi>G</mi></msub><mo>×</mo><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mo>∪</mo><mo stretchy=\"false\">(</mo><msub><mi>N</mi><mi>H</mi></msub><mo>×</mo><mo stretchy=\"false\">{</mo><mn>1</mn><mo stretchy=\"false\">}</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">E \\cup((N_G \\times \\{0\\}) \\cup (N_H \\times \\{1\\}))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">((</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">G</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">})</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:-0.109em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">1</span><span class=\"mclose\">}))</span></span></span></span>. Maybe a typo?</p>",
        "id": 267613588,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641921167
    },
    {
        "content": "<p>No, the product is needed there - it doesn't make sense with a union!</p>",
        "id": 267613691,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921222
    },
    {
        "content": "<p>How come? This doesn't make sense with</p>\n<blockquote>\n<p>E is the disjoint union of the edges of G and H</p>\n</blockquote>",
        "id": 267614582,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641921594
    },
    {
        "content": "<p>E should be a set of pairs of things from N, and N is a set of pairs. So (to put it in type theory terms like you mentioned) to make E' we need to have something which is a doubly nested pair, not a singly nested pair like in your example</p>",
        "id": 267614772,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921677
    },
    {
        "content": "<p>But <code>N_G</code> is already a set of pairs!</p>",
        "id": 267614847,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641921711
    },
    {
        "content": "<p>Not here it's not!</p>",
        "id": 267614980,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921754
    },
    {
        "content": "<p>Look at the definition of E in the paper, each element is a pair of pairs (where the innermost left thing is from N_G or N_H), so the thing we're unioning should also be of that form</p>",
        "id": 267615096,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921804
    },
    {
        "content": "<p>The set we're adding to E can also be written as <code>{((x, 0), (y, 1)) | x \\in N_G and y \\in N_H}</code></p>",
        "id": 267615256,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921848
    },
    {
        "content": "<p>I'm not convinced by the product, but it's the disjoint sum of graphs with all cross edges added, right?</p>",
        "id": 267615398,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641921907
    },
    {
        "content": "<p>Yeah</p>",
        "id": 267615514,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641921953
    },
    {
        "content": "<p>Just catching up here. Bhavik is right that <code>N_G</code> is not (necessarily) a set of pairs here. It's really just the elements of the underlying type of G. Pairing with <code>0</code> and <code>1</code> is essentially acting as <code>inl</code> and <code>inr</code>. So the pair <code>(e,0)</code> is akin to <code>inl e</code> and <code>(e,1)</code> is akin to <code>inr e</code>. It's a sort of ugly thing you have to do if you view the underlying universes of <code>G</code> and <code>H</code> as sets and not types. If they are sets, then it might happen that those sets intersect (which, of course, doesn't happen if they are distinct types).</p>",
        "id": 267617111,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641922606
    },
    {
        "content": "<p>Ultimately, your <code>sum.lex</code> is a much cleaner way to do things.</p>",
        "id": 267617250,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641922667
    },
    {
        "content": "<p>Ah I see! You're not actually after graphs, but rather orders.</p>",
        "id": 267617492,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641922771
    },
    {
        "content": "<p>Exactly. I didn't really have it clear in my mind when I wrote the paper.</p>",
        "id": 267617607,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641922812
    },
    {
        "content": "<p>The edges added to the graph will ensure that when you take the order defined by the transitive closure of the edge relation everything in <code>G</code> is less than everything in <code>H</code>.</p>",
        "id": 267617918,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641922938
    },
    {
        "content": "<p>Okay, so is there any reason you're defining <code>evsys</code> fully bundled? You could probably get away with using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">evsys</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 267618233,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641923064
    },
    {
        "content": "<p>Also, to your question above about it being a partial order when the maps are injective, you are right that it is non-trivial. I think it's essentially an instance of the Cantor-Schroeder-Bernstein theorem.</p>",
        "id": 267618243,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641923068
    },
    {
        "content": "<p>To be honest, I don't really know what I'm doing style-wise, so I'm trying things out in various ways. This also will fit into a larger structure that has additional constraints. (The codomain of <code>\\nat</code> is artificial, by the way. It's just there to have a mwe without a bunch of extra stuff.)</p>",
        "id": 267618788,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641923279
    },
    {
        "content": "<p>Ah okay! But the additional structures shouldn't stop you from using a less bundled approach.</p>",
        "id": 267619053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641923379
    },
    {
        "content": "<p>Just to give you a flavor of some of the extra content (definitely not enough to compile): </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">adversary_ordered</span> <span class=\"o\">{</span><span class=\"n\">event</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">event</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"o\">:</span> <span class=\"n\">event</span> <span class=\"bp\">→</span> <span class=\"n\">label</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">):</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">e1</span> <span class=\"n\">e2</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"n\">rel</span> <span class=\"n\">ℓ</span> <span class=\"n\">d</span> <span class=\"n\">c</span> <span class=\"n\">e1</span> <span class=\"bp\">→</span> <span class=\"n\">rel</span> <span class=\"n\">ℓ</span> <span class=\"n\">d</span> <span class=\"n\">c</span> <span class=\"n\">e2</span> <span class=\"bp\">→</span>\n  <span class=\"n\">adv_lab</span> <span class=\"o\">(</span><span class=\"n\">ℓ</span> <span class=\"n\">e1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">e1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">e2</span> <span class=\"bp\">∨</span> <span class=\"n\">e2</span> <span class=\"bp\">&lt;</span> <span class=\"n\">e1</span> <span class=\"bp\">∨</span> <span class=\"n\">e2</span> <span class=\"bp\">=</span> <span class=\"n\">e1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">exec</span> <span class=\"kd\">extends</span> <span class=\"n\">evsys</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adv_ord</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">adversary_ordered</span> <span class=\"n\">evt</span> <span class=\"n\">poset</span> <span class=\"n\">l</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 267619190,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641923417
    },
    {
        "content": "<p>Is there general advice on when to use bundled vs. not bundled? I'm really just feeling around in the dark until something works and doesn't get too much in the way when I am trying to prove what I want to prove.</p>",
        "id": 267619411,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641923500
    },
    {
        "content": "<p>Yes there is. Overbundled things are hard to use because there's too little info on the outside. Underbundling is bad too, but in subtler ways (like the size of the terms Lean comes up with). I'd advise you to not bundle <code>evt</code>. The rest can stay the same.</p>",
        "id": 267619671,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641923611
    },
    {
        "content": "<p>Ok, that's good to know. Thanks for the advice! </p>\n<p>Last night, I tried doing something more like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">evsys</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">partial_order</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"n\">fintype</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"n\">label</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">exec</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">evsys</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adv_ord</span> <span class=\"o\">:</span> <span class=\"n\">adversary_ordered</span> <span class=\"n\">E</span> <span class=\"n\">l</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and I got completely lost in figuring out how to get the type class inference stuff to just work. I'll try unbundling and see if it goes better.</p>",
        "id": 267620247,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641923822
    },
    {
        "content": "<p>Ah, you almost got it right! Exposing <code>E</code> is good, but you shouldn't use <code>extends</code> here.</p>",
        "id": 267620368,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641923866
    },
    {
        "content": "<p>I should be clearer. <code>evsys</code> shouldn't extend <code>partial_order</code> nor <code>fintype</code> (<code>evsys</code> can't be nicely inserted in the order hierarchy nor is a clear successor of <code>fintype</code>), but <code>exec</code> should extend <code>evsys</code> (they really are part of the same lineage).</p>",
        "id": 267620638,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641923968
    },
    {
        "content": "<p>Ok, so I should then include assumptions of the form <code>[partial_order E]</code> and <code>[fintype E]</code> when I need them?</p>",
        "id": 267620852,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641924021
    },
    {
        "content": "<p>Cool. Btw, I'm about to ghost you as I go into meeting. I'll circle back around later.</p>",
        "id": 267620947,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641924046
    },
    {
        "content": "<p>Yeah, and you might sometimes need to upgrade to <code>linear_order E</code>. Then you'll thank the mixin <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 267621016,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641924074
    },
    {
        "content": "<p>Maybe I misunderstood something, but Cantor-Schröder-Bernstein is usually trivial for finite things. If you have an injective graph homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>H</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">f : H \\to G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> has at least as many vertices and edges as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span>. If you also have an injective homomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">G \\to H</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> then they must have the same number of vertices and edges, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> must already be an isomorphism.</p>\n<p>(Usually Cantor-Schröder-Bernstein fails for infinite \"things with structure\". For example there are order embeddings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>→</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1] \\to (0, 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">(0, 1) \\to [0, 1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> but no isomorphism.)</p>",
        "id": 267630873,
        "sender_full_name": "David Wärn",
        "timestamp": 1641928431
    },
    {
        "content": "<p>Yes, you are correct. It is straightforward for finite things. I was never fully clear when I needed or wanted things to be a preorder or a partial order etc. I never ended up using the fact that the injective embeddings induces a partial order for the finite structures, so that particular comment is a bit of a dangling morsel with no follow up.</p>",
        "id": 267633219,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641929585
    },
    {
        "content": "<p>Ok, I'm still pretty confused. In the final definition below, I certainly need <code>Evt</code> to be an <code>exec</code> so that I have access to the <code>d</code> field. I can't figure out what to type so it doesn't complain. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Extract relevant things as constants for mwe</span>\n<span class=\"kd\">constant</span> <span class=\"n\">label</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">component</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">constant</span> <span class=\"n\">adversary_ordered</span> <span class=\"o\">(</span><span class=\"n\">Evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span> <span class=\"bp\">→</span> <span class=\"n\">label</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">constant</span> <span class=\"n\">rel</span> <span class=\"o\">{</span><span class=\"n\">Evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span> <span class=\"bp\">→</span> <span class=\"n\">label</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">component</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"kd\">constant</span> <span class=\"n\">adv_lab</span> <span class=\"o\">:</span> <span class=\"n\">label</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">evsys</span> <span class=\"o\">(</span><span class=\"n\">Evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span> <span class=\"bp\">→</span> <span class=\"n\">label</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">Evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">exec</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">evsys</span> <span class=\"n\">Evt</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"n\">component</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adv_ord</span> <span class=\"o\">:</span> <span class=\"n\">adversary_ordered</span> <span class=\"n\">Evt</span> <span class=\"n\">evsys.l</span> <span class=\"n\">d</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--These next two type check without error.</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">adv_evt</span> <span class=\"o\">[</span><span class=\"n\">evsys</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">adv_lab</span> <span class=\"o\">(</span><span class=\"n\">evsys.l</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">adv_evts</span> <span class=\"o\">(</span><span class=\"n\">Evt</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">evsys</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Evt</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">e</span> <span class=\"bp\">|</span> <span class=\"n\">adv_evt</span> <span class=\"n\">e</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- This gives an error: function expected at exec term has type Type</span>\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">relevant'</span> <span class=\"o\">[</span><span class=\"n\">exec</span> <span class=\"n\">Evt</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">component</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Evt</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 267645032,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641935240
    },
    {
        "content": "<p>So apparently the following will work for the last definition: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">relevant'</span> <span class=\"o\">[</span><span class=\"n\">po</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">@</span><span class=\"n\">exec</span> <span class=\"n\">E</span> <span class=\"n\">po</span><span class=\"o\">]</span>  <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">component</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">rel</span> <span class=\"n\">E</span> <span class=\"n\">po</span> <span class=\"n\">evsys.l</span> <span class=\"o\">(</span><span class=\"n\">exec.d</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">e</span>\n</code></pre></div>\n<p>Clearly I can't let <code>Evt</code> be implicit in the definition of <code>exec</code>. For some reason I thought making explicit caused a different set of problems, but it seems good now.</p>",
        "id": 267646861,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641936144
    },
    {
        "content": "<p><code>by sorry</code> -&gt; <code>sorry</code> btw</p>",
        "id": 267649080,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641937162
    },
    {
        "content": "<p>Sorry, I was too slow to help. But your diagnosis was correct.</p>",
        "id": 267649240,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641937247
    },
    {
        "content": "<p>No apology needed! But while I have your attention, I have another style question. I assume I should avoid writing <code>variables {Evt : Typ} [partial_order Evt]</code> unless I really want to require every declaration to require a partial_order instance in the scope. Is that right?</p>",
        "id": 267649450,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641937365
    },
    {
        "content": "<p>Or less obviously, if I'm willing to assume that <code>Evt</code> will always be an <code>evsys</code> in the current scope, but will sometimes be upgraded to <code>exec</code>, is it bad form to declare <code>variables {Evt : Type} [evsys Evt]</code>? The declarations requiring <code>exec Evt</code> end up with a redundant requirement for an <code>evsys Evt</code> instance. This seems like it would be bad form. On the other hand, it can get tedious typing in the <code>[evsys Evt]</code> argument to every definition and lemma.</p>",
        "id": 267650143,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641937736
    },
    {
        "content": "<p>Yes, this is pretty bad because <code>[evsys E] [exec E]</code> is declaring two unrelated <code>evsys</code> structures on <code>E</code>. My advice is to make</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">evsys</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">evsys</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span>\n<span class=\"kd\">end</span> <span class=\"n\">evsys</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">exec</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">exec</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span>\n<span class=\"kd\">end</span> <span class=\"n\">exec</span>\n</code></pre></div>\n<p>and you can do similarly for order instances</p>",
        "id": 267650522,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641937906
    },
    {
        "content": "<p>That makes sense. Thanks again! I've learned so much more about Lean in the last two days.</p>",
        "id": 267651092,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641938033
    },
    {
        "content": "<p>Reading some more, I think \"Minimum experts required\" and \"Minimum attack time\" are the width (minimum number of chains needed for a partition in chains) and height (length of the longest chain) of the order.</p>",
        "id": 267651773,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641938385
    },
    {
        "content": "<p>I don't exactly know about \"Guards needed to counter attack\" and \"Time required for all attacks\".</p>",
        "id": 267651945,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641938431
    },
    {
        "content": "<p>Also, your \"covariant\" and \"contravariant\" really are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monotone\">docs#monotone</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/antitone\">docs#antitone</a></p>",
        "id": 267651977,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641938449
    },
    {
        "content": "<p>Regarding the language around \"Minimum experts required\" etc. you are right. I don't love that language, but I was borrowing it from the main reference on which the paper is based. I agree that width and height are simpler concepts, but in papers on security, you'd be surprised by what ends up being more intuitive for reviewers with a bias towards the applications.</p>",
        "id": 267652756,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641938831
    },
    {
        "content": "<p>And thanks for pointers to monotone and antitone. Those will certainly be handy later.</p>",
        "id": 267652793,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641938855
    },
    {
        "content": "<p>Oh, and now that I go back and look, \"Minimum experts required\" is really the smallest width among the set of orders that form the semantics of a term, and \"Minimum attack time\" is the shortest height. The other two take the widest and the tallest among the set of orders in the semantics.</p>",
        "id": 267653375,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641939094
    },
    {
        "content": "<p>So for example, if you need one guard to counter an attack on every \"branch\" of an order, the widest order will result in requiring the most guards.</p>",
        "id": 267653797,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641939188
    },
    {
        "content": "<p>Okay, that's pretty cool!</p>",
        "id": 267653887,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641939233
    },
    {
        "content": "<p>We don't have partitions in chains/antichains, so we don't have the width and height of an order. Incidentally, <a href=\"https://github.com/leanprover-community/mathlib/pull/11308\">#11308</a> will allow talking about those in graded orders, but this isn't the greatest generality.</p>",
        "id": 267654073,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641939318
    },
    {
        "content": "<p>Dilworth would be a cool milestone</p>",
        "id": 267654106,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641939345
    },
    {
        "content": "<p>I'm glad you're reading through the paper. You may be the only one besides the reviewers to have read it!</p>",
        "id": 267654462,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641939501
    },
    {
        "content": "<p>I had to just look up Dilworth's theorem. That does sound like a good milestone. Of course, if width and height of an order do show up soon, it would be nice to characterize the attribute domains explicitly as above. I don't think Dilworth would be required for that.</p>",
        "id": 267654709,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641939631
    },
    {
        "content": "<p>I can cook up the definitions in a few days, but I think I've done already too many digressions in the past month to allow myself more non-uni work <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 267655207,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641939865
    },
    {
        "content": "<p>Yeah, I hear you. My efforts to formalize this stuff are not really on the main path of my projects at work, but it's often more fun.</p>",
        "id": 267655483,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641939993
    },
    {
        "content": "<p>Some people have written Lean formalization accompanying their maths paper. Maybe you could do something similar as an excuse for leaning? <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 267655762,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641940152
    },
    {
        "content": "<p>\"a notion of homomorphism on elements\" shouts category theory!</p>",
        "id": 267656374,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641940471
    },
    {
        "content": "<p>In an earlier paper (reference [11] in the paper you are reading) we did exactly that but with Coq. In fact, the reason I know any Lean at all is that I ported the Coq code to Lean code in the summer of 2020 as a personal project. That was pretty much a \"transliteration\" without trying to improve on things. But if this stuff works out, we might be able to use it for future papers. <em>fingers crossed</em></p>",
        "id": 267656455,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641940519
    },
    {
        "content": "<p>Yeah, do you know if the \"homomorphism order\" exists anywhere in mathlib? I'm scared to touch the category theory, but it does seem like the right level of abstraction.</p>",
        "id": 267656594,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641940586
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/preorder.small_category\">docs#preorder.small_category</a> is the category associated to a preorder. I don't know whether we have the other way around (which Propifies the arrows) but I expect you might want to work with a category rather than an order?</p>",
        "id": 267656804,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641940715
    },
    {
        "content": "<p>and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.sum\">docs#category_theory.sum</a> is the sum of two categories.</p>",
        "id": 267657190,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641940971
    },
    {
        "content": "<p>It's so hard finding the right level of generality. I'm happy enough when I can get to prove what I need it to prove. <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 267657192,
        "sender_full_name": "Paul Rowe",
        "timestamp": 1641940973
    },
    {
        "content": "<p>I don't know whether the lexicographic sum of categories is a thing however</p>",
        "id": 267657428,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1641941117
    },
    {
        "content": "<p><a href=\"http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/join+of+categories\">http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/join+of+categories</a></p>",
        "id": 267657620,
        "sender_full_name": "Reid Barton",
        "timestamp": 1641941239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Disjoint.20union.20of.20posets/near/267656804\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/preorder.small_category\">docs#preorder.small_category</a> is the category associated to a preorder. I don't know whether we have the other way around (which Propifies the arrows) but I expect you might want to work with a category rather than an order?</p>\n</blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/thin_skeleton\">docs#thin_skeleton</a> does something kind of similar to this? Given a category with homsets which are data but subsingleton, it makes them into Props and takes the quotient so you end up with a partial order</p>",
        "id": 267658203,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1641941534
    }
]
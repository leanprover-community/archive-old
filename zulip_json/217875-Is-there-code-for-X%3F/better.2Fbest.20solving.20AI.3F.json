[
    {
        "content": "<p>I was looking at the docs for simp and it said that the program can get stuck in replacement loops if one is not careful to put the simpler side on the left hand. This got me wondering - since the concept of automated provers (possibly with statistical approaches) is not new: How far is this integrated and how would one go about invoking it?</p>\n<p>EDIT<br>\nFor example, remembering already visited nodes in the reformulation-equivalence graph would get rid of loops. Since this graph is probably quite unending this is where the AI/statistics part would come in.</p>",
        "id": 231923433,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616742815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400229\">@Belisarius Cawl</span> Several things have been attempted. For example, there is <code>rewrite_search</code>.<br>\nOne thing that I've discovered since I started formalising is that there is a delicate balance between proof search, speed, and maintainability.<br>\nSo if you have a smart AI that takes some time to find a proof that isn't completely straightforward, it should be able to emit a fast (and maintainable) way to replicate the proof. This isn't always straightforward.</p>",
        "id": 231923856,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743199
    },
    {
        "content": "<p>But if you have 5000 lemmas in mathlib that are proven using <code>by smart_ai</code> and the ai takes 15 seconds to find the proof, then compile time is sky-rocketing.</p>",
        "id": 231923942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743234
    },
    {
        "content": "<p>On the other hand, if something in <code>logic.basic</code> changes, and <code>smart_ai</code> for some stupid reason can no longer find the proof of a certain lemma <code>X</code>, then it shouldn't require an author with domain specific knowledge to fix the proof of <code>X</code>. That is why <code>by smart_ai</code> should output a maintainable proof, and not just a fast but completely opaque proof term.</p>",
        "id": 231924073,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743331
    },
    {
        "content": "<p><code>simp</code> seems to find the middle ground, by asking from library authors to adhere to certain conventions (e.g., simpler side goes on the right, and make the simp-set as confluent as possible, etc...). If we stick to those conventions, in practice we seem to hit a nice balance between automation, speed, and maintainability.</p>",
        "id": 231924124,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743414
    },
    {
        "content": "<p>Speed is obtained by using <code>squeeze_simp</code> to output a certificate that uses <code>simp only [15, different, lemma, names]</code></p>",
        "id": 231924184,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743445
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I don't understand the last part. If I find a path why not just print it? Verifying it should be orders of magnitude faster.</p>",
        "id": 231924232,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743505
    },
    {
        "content": "<p>It depends on what <code>smart_ai</code> does... what do you mean with \"path\"?</p>",
        "id": 231924359,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743602
    },
    {
        "content": "<p>If <code>smart_ai</code> is only rewriting along lemmas of the form <code>A = B</code> that it finds in the library, then yes. This is <code>rewrite_search</code></p>",
        "id": 231924384,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743630
    },
    {
        "content": "<p>If you want it to also handle inequalities, or maybe other smart knowledge, then I don't know what \"path\" is.</p>",
        "id": 231924413,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743660
    },
    {
        "content": "<p>I visualize the problem as a graph, where each edge is a lemma application.</p>",
        "id": 231924416,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743664
    },
    {
        "content": "<p>Right, so if you print that \"path\", you are printing the proof term. Which is often larger and uglier than you expect. And quite opaque.</p>",
        "id": 231924485,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743709
    },
    {
        "content": "<p>ah yes, I did not register that as a problem.</p>",
        "id": 231924501,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743734
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">LCFP.map_comp_Tinv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_5</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r'</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">c₂</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_6</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">c₂</span> <span class=\"bp\">≤</span> <span class=\"n\">r'</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv</span> <span class=\"n\">r'</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">M₂</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">LCFP</span> <span class=\"n\">V</span> <span class=\"n\">r'</span> <span class=\"n\">c</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">Tinv</span> <span class=\"n\">V</span> <span class=\"n\">r'</span> <span class=\"n\">n</span> <span class=\"n\">c</span> <span class=\"n\">c₂</span> <span class=\"n\">M₂</span> <span class=\"bp\">=</span> <span class=\"n\">Tinv</span> <span class=\"n\">V</span> <span class=\"n\">r'</span> <span class=\"n\">n</span> <span class=\"n\">c</span> <span class=\"n\">c₂</span> <span class=\"n\">M₁</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">LCFP</span> <span class=\"n\">V</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r'</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">_inst_5</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r'</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"n\">c₂</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"bp\">≥</span><span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_6</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">c₂</span> <span class=\"bp\">≤</span> <span class=\"n\">r'</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)]</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv</span> <span class=\"n\">r'</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">M₂</span><span class=\"o\">),</span>\n  <span class=\"n\">id</span>\n    <span class=\"o\">((</span><span class=\"n\">id</span>\n        <span class=\"o\">((</span><span class=\"bp\">λ</span>\n          <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span>\n              <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span>\n            <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">))</span> <span class=\"bp\">⟶</span>\n              <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">e_2</span> <span class=\"o\">:</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">),</span>\n            <span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">eq</span> <span class=\"n\">e_1</span><span class=\"o\">)</span> <span class=\"n\">e_2</span><span class=\"o\">)</span>\n           <span class=\"o\">((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">≫</span>\n              <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n           <span class=\"o\">((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n           <span class=\"o\">(((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span> <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n               <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.trans</span>\n              <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">e_4</span> <span class=\"o\">:</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">),</span> <span class=\"n\">congr_arg</span> <span class=\"n\">c.map</span> <span class=\"n\">e_4</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n                 <span class=\"o\">(((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n                 <span class=\"n\">op_comp.symm</span><span class=\"o\">))</span>\n           <span class=\"o\">((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">≫</span>\n              <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n           <span class=\"o\">((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n              <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span> <span class=\"bp\">≫</span> <span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n           <span class=\"o\">(((</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span> <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n               <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm.trans</span>\n              <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">e_4</span> <span class=\"o\">:</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">),</span> <span class=\"n\">congr_arg</span> <span class=\"n\">c.map</span> <span class=\"n\">e_4</span><span class=\"o\">)</span>\n                 <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n                 <span class=\"o\">((</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">≫</span> <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">)</span>\n                 <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span> <span class=\"bp\">≫</span> <span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n                 <span class=\"n\">op_comp.symm</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n       <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">NormedGroup</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">Profinite</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ᾰ</span> <span class=\"n\">ᾰ_1</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_4</span> <span class=\"o\">:</span> <span class=\"n\">ᾰ</span> <span class=\"bp\">=</span> <span class=\"n\">ᾰ_1</span><span class=\"o\">),</span>\n           <span class=\"n\">congr_arg</span> <span class=\"n\">c.map</span> <span class=\"n\">e_4</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n          <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span> <span class=\"bp\">≫</span> <span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n          <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">f_1</span> <span class=\"o\">:</span> <span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"bp\">⟶</span> <span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f_1</span><span class=\"o\">),</span>\n              <span class=\"n\">congr_arg</span> <span class=\"n\">has_hom.hom.op</span> <span class=\"n\">e_1</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span> <span class=\"bp\">≫</span> <span class=\"o\">(</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span><span class=\"o\">)</span>\n             <span class=\"o\">((</span><span class=\"n\">ProFiltPseuNormGrpWithTinv.level</span> <span class=\"n\">r'</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.unop</span> <span class=\"bp\">≫</span> <span class=\"n\">Tinv₀_hom</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"n\">c₂</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n             <span class=\"o\">(</span><span class=\"n\">continuous_map.ext</span>\n                <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">((</span><span class=\"n\">filtration_obj</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_Top</span><span class=\"o\">)),</span>\n                   <span class=\"n\">subtype.cases_on</span> <span class=\"n\">x</span>\n                     <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">filtration</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">unop</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"n\">c₂</span><span class=\"o\">),</span>\n                        <span class=\"n\">subtype.ext</span> <span class=\"o\">(</span><span class=\"n\">profinitely_filtered_pseudo_normed_group_with_Tinv_hom.map_Tinv</span> <span class=\"n\">f.unop</span> <span class=\"n\">x</span><span class=\"o\">)))))))</span>\n</code></pre></div>",
        "id": 231924532,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743771
    },
    {
        "content": "<p>That's the proof term of the latest lemma that I just proved</p>",
        "id": 231924547,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743788
    },
    {
        "content": "<p>You can <code>#print lemma_name</code> to try this yourself</p>",
        "id": 231924556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743801
    },
    {
        "content": "<p>The proof script that generated the term is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">Tinv</span><span class=\"o\">,</span> <span class=\"n\">LCFP</span><span class=\"o\">],</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">LCP</span> <span class=\"n\">V</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">op_comp</span><span class=\"o\">],</span>\n  <span class=\"n\">congr'</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">f.unop.map_Tinv</span> <span class=\"n\">x</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231924619,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743824
    },
    {
        "content": "<p>Seems pretty obvious... haha :D</p>\n<p>Jokes aside, I treat that as machine code. I guess a real mathematician would want to be able to understand it though.</p>",
        "id": 231924664,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743859
    },
    {
        "content": "<p>And this is an \"easy\" lemma, that everyone who knows the maths would consider \"too easy to even state\"</p>",
        "id": 231924676,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743866
    },
    {
        "content": "<p>The important point is that this proof term will break very easily if some little detail in another place of the library is changed.</p>",
        "id": 231924719,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743907
    },
    {
        "content": "<p>But the tactic script is a lot more robust</p>",
        "id": 231924729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743916
    },
    {
        "content": "<p>It's a kind of philosophical topic it seems - If I proved my prover and my prover proves something with gibberish, does that count as understanding?</p>",
        "id": 231924733,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743919
    },
    {
        "content": "<p>you could solve the brittleness with version tags, no?</p>",
        "id": 231924812,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616743965
    },
    {
        "content": "<p>I appreciate the philosophical point. But my arguments are much more pragmatic.</p>",
        "id": 231924816,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616743972
    },
    {
        "content": "<p>so you could have recent versions tagged as buggy or just \"friendly\" updated (like expansion or equivalent rewrite)</p>",
        "id": 231924933,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616744047
    },
    {
        "content": "<p>We want the following features from mathlib:</p>\n<ol>\n<li>it should be able to grow (so we want some form of automation, because we don't want to keep stuck with low-level concepts and tools)</li>\n<li>it should be reasonably fast to compile mathlib (currently ~2 hrs on reasonable hardware)</li>\n<li>it should be maintainable (PR authors that edit file <code>X</code> shouldn't expect 100 other files to break, and if 3 files break that they don't know much about, they should still be able to fix the proofs easily)</li>\n</ol>",
        "id": 231924985,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616744086
    },
    {
        "content": "<p>So, any form of automation that helps with (1) forward, should take (2) and (3) into account</p>",
        "id": 231925142,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616744187
    },
    {
        "content": "<p>It's not clear to me how the version tags would help. It sounds like they will turn (3) into a nightmare.</p>",
        "id": 231925174,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616744220
    },
    {
        "content": "<p><code>tidy</code> is another tactic that will search for proofs, and <code>tidy?</code> will print a tactic script that uses lower-level tactics to produce the proof that <code>tidy</code> found</p>",
        "id": 231925221,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616744278
    },
    {
        "content": "<p>This model seems to scale well, but it's not easy to write a good <code>smart_ai?</code>. (At least it's not easy for <em>me</em>.)</p>",
        "id": 231925278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616744316
    },
    {
        "content": "<p>There is also the new <code>gptf</code>, with a very impressive trained neural net behind it. It definitely fits Johan's criterion, in that its job is solely to suggest what you might type in next! At the end of the process there's no sign that it was ever involved.</p>",
        "id": 231925333,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744395
    },
    {
        "content": "<p>Another example is <code>solve_by_elim</code>, which does backwards chaining from a specified set of lemmas, and <code>library_search</code> that tries to apply a single lemma from the entire library to close the goal.</p>",
        "id": 231925437,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744477
    },
    {
        "content": "<p><code>solve_by_elim</code> is usually robust enough to \"leave in place\", but <code>library_search</code> is sadly slow.</p>",
        "id": 231925455,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744497
    },
    {
        "content": "<p>I am thinking along the lines of - what are edits that cause a proof to break? Either the old version had a bug (in which case you need of course to discard everything relying on it) or you rewrite it because you have an equivalent but somehow \"better\" formulation (in which case you can keep your old proof, as long as you show that your rewrite is equivalent). Likely I don't really understand your problem though.</p>\n<p>I am thinking of something like Nix. Also I got a feeling that modularization could help. Again, as an outsider.</p>\n<p>Of course such an AI would be nontrivial which makes it exciting. There is a lot of art/subjectivity in (statistical) AI.</p>",
        "id": 231925459,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616744502
    },
    {
        "content": "<p>One of course wishes for the pushout of these two tactics. :-)</p>",
        "id": 231925469,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744511
    },
    {
        "content": "<p>Proofs break constantly in mathlib. :-) Make a few pull requests and you'll get a feel for what is going on.</p>",
        "id": 231925532,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744544
    },
    {
        "content": "<p>I really want to right now - but I have to constrain myself. Am already three rabbit holes down from my original task (which has nothing to do at all with proofs ;) )</p>",
        "id": 231925574,
        "sender_full_name": "Belisarius Cawl",
        "timestamp": 1616744595
    },
    {
        "content": "<p>mathlib definitely does not grow \"just from the top\". We are perpetually adding e.g. <code>simp</code> lemmas that make things work more smoothly, but that changes the behaviour of <code>simp</code> in every existing proof. It takes some care to only use tactics like this in ways that will break in predicable / manageable ways.</p>",
        "id": 231925591,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616744614
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400229\">Belisarius Cawl</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/better.2Fbest.20solving.20AI.3F/near/231924232\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> I don't understand the last part. If I find a path why not just print it? Verifying it should be orders of magnitude faster.</p>\n</blockquote>\n<p>A (related) technical term you might be interested in is a proof certificate, although that's more of a problem-specific concept. For example, to prove \"¬ linear_independent R v\" a proof certificate would be a list of coefficients <code>c i</code> such that <code>Σ i, c i * v i = 0</code>. So you could have a <code>find_linear_dependence</code> tactic outputting a definition of <code>c</code>, and a <code>check_linear_dependence c</code> tactic that verifies the linear combination adds up to 0. (You could say <code>squeeze_simp</code> outputs a proof certificate for the problem of determining whether two expressions are the same.)</p>",
        "id": 231933497,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1616749743
    }
]
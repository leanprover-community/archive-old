[
    {
        "content": "<p>It seems that <code>intro</code> (but not <code>rintro</code>) is able to unfold let bindings in goals:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.group</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.nat.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">some_def</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"bp\">$</span> <span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"bp\">$</span> <span class=\"n\">j</span> <span class=\"bp\">+</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span> <span class=\"n\">j</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">fin</span> <span class=\"n\">h1</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">h2.mp</span> <span class=\"n\">y</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_goal</span> <span class=\"o\">:</span> <span class=\"n\">some_def</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">some_def</span><span class=\"o\">,</span>\n  <span class=\"k\">assume</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">eq_mp_rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>However, the same does not seem to be true of hypotheses:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">as_hyp</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">some_def</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">some_def</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"o\">,,</span> <span class=\"n\">rest</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- `hs`, `h1`, and `h2` are gone?</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Is there a tactic that can do this?</p>",
        "id": 226456384,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613432663
    },
    {
        "content": "<p>I don't think any such tactic exists; most tactics just unfold lets or don't know what to do with them</p>",
        "id": 226456632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613432932
    },
    {
        "content": "<p>Presumably since <code>intro</code> can do it on goals, it should be possible to do it on hypotheses somehow too?</p>",
        "id": 226456661,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613432958
    },
    {
        "content": "<p>this needs a tactic that can \"hoist\" lets out of an expression</p>",
        "id": 226456662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613432960
    },
    {
        "content": "<p>no, there's a missing piece</p>",
        "id": 226456670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613432979
    },
    {
        "content": "<p>(although you used a really annoying example because of all the <code>_</code> in the goal)</p>",
        "id": 226456739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433027
    },
    {
        "content": "<p>(Pretend I used <code>let h1 := add_comm j i, h2 := (congr_arg fin h1) in x = h2.mp y</code>)</p>",
        "id": 226456766,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433075
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">as_hyp</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">some_def</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">some_def</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- before</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span> <span class=\"mi\">3</span> <span class=\"mi\">2</span> <span class=\"k\">in</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">some_def._proof_1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- after</span>\n  <span class=\"k\">show</span> <span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"mi\">3</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">+</span> <span class=\"mi\">3</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span> <span class=\"mi\">3</span> <span class=\"mi\">2</span> <span class=\"k\">in</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">some_def._proof_1</span> <span class=\"mi\">2</span> <span class=\"mi\">3</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now intro</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- put hs back</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hs</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226456787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433109
    },
    {
        "content": "<p>you need a tactic that will do the equivalent of the show lines</p>",
        "id": 226456841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433135
    },
    {
        "content": "<p>It's a little unrealistic to be using <code>let</code> with proofs anyway</p>",
        "id": 226456854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433163
    },
    {
        "content": "<p>these should be <code>have</code></p>",
        "id": 226456860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433172
    },
    {
        "content": "<p>My original idea behind the <code>let</code> was that <code>as_goal</code> could start <code>assume h1 h2</code>, <code>substs h1 h2</code> to eliminate <code>eq.mp</code> from the goal, but for reasons I don't understand that doesn't work</p>",
        "id": 226456943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433279
    },
    {
        "content": "<p>And <code>exact eq_mp_rfl</code> doesn't actually work for my real case</p>",
        "id": 226456956,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433306
    },
    {
        "content": "<p>This kind of looks like an <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> problem though</p>",
        "id": 226456967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433317
    },
    {
        "content": "<p><code>as_goal</code> can be proved by <code>rfl</code> straight off</p>",
        "id": 226456987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433352
    },
    {
        "content": "<p>The original problem is just exploring ways to express equalities between indexed types. I'm currently using something like <code>(a : A i) (b : A (i + 0)) : (⟨_, a⟩: Σ i, A i) = ⟨_, b⟩)</code>, but its ugly to work with, as both the caller and the prover need to supply the <code>zero_add</code> proof</p>",
        "id": 226457136,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433486
    },
    {
        "content": "<p>Evidently my mwe was enough for the original question but too reduced for the follow-up</p>",
        "id": 226457151,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433517
    },
    {
        "content": "<p>But a let-bindings introducing tactic would still be sane for data, right?</p>",
        "id": 226457168,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433541
    },
    {
        "content": "<p>well like I said there is a missing operation here, a let hoisting operation that can be performed by <code>change</code> if it is constructed appropriately</p>",
        "id": 226457201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433586
    },
    {
        "content": "<p>the only thing lean knows to do with lets is unfold them or put them in the context with <code>intro</code> when the goal happens to be a let (because this is a no-op internally)</p>",
        "id": 226457276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433635
    },
    {
        "content": "<p>it is a bit reminiscent of <code>generalize_proofs</code>, which does the same hoisting operation but for proofs instead of lets</p>",
        "id": 226457313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433687
    },
    {
        "content": "<p><code>generalize_proofs</code> gives me the proof that <code>fin (i + j) = fin (j + i)</code>, but not the proof that <code>i + j = j + i</code> - and for a general indexed type, the former does not imply the latter.</p>",
        "id": 226457435,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433797
    },
    {
        "content": "<p>True, but once the hypothesis is named it's easier to replace it by defeq with <code>congr_arg fin h'</code></p>",
        "id": 226457563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433891
    },
    {
        "content": "<p>In this particular case you should probably be using the <code>eq.mp</code> lemma specific to <code>fin</code></p>",
        "id": 226457616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433961
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fin.cast\">docs#fin.cast</a></p>",
        "id": 226457674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613433985
    },
    {
        "content": "<p><code>fin</code> was solely for the case of this mwe</p>",
        "id": 226457676,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613433992
    },
    {
        "content": "<p>then you should be using the <code>eq.mp</code> lemma specific to that type</p>",
        "id": 226457686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434013
    },
    {
        "content": "<p>It doesn't have a specific <code>eq.mp</code> lemma because the type is <code>A : ι → Type*</code> and <code>A i</code></p>",
        "id": 226457703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434048
    },
    {
        "content": "<p>I think <code>eq.rec A (h : i = j)</code> will work in that case</p>",
        "id": 226457778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434115
    },
    {
        "content": "<p>Yes, it does - I had in my head that <code>mp</code> was \"simpler\" and therefore might be easier to prove things about</p>",
        "id": 226457789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434139
    },
    {
        "content": "<p>No, it uses type equalities which are to be avoided</p>",
        "id": 226457802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434155
    },
    {
        "content": "<p>eq.rec makes the motive explicit and puts the equality in the type you actually want</p>",
        "id": 226457815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434183
    },
    {
        "content": "<p>Ultimately my thought was that if I had a goal of the form <code>h.rec a = b</code>, then I could use <code>subst h</code> in tactic mode to reduce it to <code>a = b</code></p>",
        "id": 226457817,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434186
    },
    {
        "content": "<p>you should</p>",
        "id": 226457824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434193
    },
    {
        "content": "<p>that doesn't work if <code>h</code> is a composite term though</p>",
        "id": 226457887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434228
    },
    {
        "content": "<p>in particular one side has to be a variable</p>",
        "id": 226457895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434238
    },
    {
        "content": "<p>Right, therein lies the problem, <code>0 + i = i</code> is apparently not a legal form for <code>h</code> in my case</p>",
        "id": 226457906,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434270
    },
    {
        "content": "<p>you have to generalize everything about <code>0 + i</code> to <code>j</code> first</p>",
        "id": 226457913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434288
    },
    {
        "content": "<p>once you can make your theorem typecheck with <code>j</code> in place of <code>0+i</code> you are done</p>",
        "id": 226457921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434317
    },
    {
        "content": "<p>I can't say more specifically without an MWE that has these features</p>",
        "id": 226457990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613434377
    },
    {
        "content": "<p>I don't have a super minimal example, but the head commit of <a href=\"https://github.com/leanprover-community/mathlib/tree/direct_sum_graded-mwe\">branch#direct_sum_graded-mwe</a> shows the tiny change that I was exploring (the previous commit has everything working, but is ugly)</p>",
        "id": 226458123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434512
    },
    {
        "content": "<p>(the branch only adds a single new file, so you should be able to just copy that file locally to try it out, if it's not too big to make that undesirable)</p>",
        "id": 226458222,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613434609
    },
    {
        "content": "<p>Not a complete fix, but this cleans up the statements using the sigma type approach a lot</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">! ### Typeclasses -/</span>\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n\n<span class=\"sd\">/-- A graded version of `has_one`, which must be of grade 0. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">ghas_one</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- A graded version of `has_one` that also subsumes `distrib` and `mul_zero_class` by requiring</span>\n<span class=\"sd\">the multiplication be an `add_monoid_hom`. Multiplication combines grades additively, like</span>\n<span class=\"sd\">`add_monoid_algebra`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">ghas_mul</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span> <span class=\"n\">j</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g_one</span> <span class=\"o\">[</span><span class=\"n\">has_zero</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ghas_one</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">ghas_one.one</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">g_mul</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">ghas_mul</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">ghas_mul.mul</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`ᵍ</span><span class=\"mi\">1</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">g_one</span> <span class=\"n\">_</span>\n<span class=\"kn\">local</span> <span class=\"kd\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">ᵍ*</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">:=</span> <span class=\"n\">g_mul</span> <span class=\"n\">_</span>\n<span class=\"kn\">local</span> <span class=\"kd\">prefix</span> <span class=\"bp\">`ᵍ↑`</span><span class=\"o\">:</span><span class=\"mi\">70</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">sigma.mk</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">→</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">defs</span>\n\n<span class=\"sd\">/-- A graded version of `monoid`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">gmonoid</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"kd\">extends</span> <span class=\"n\">ghas_mul</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">ghas_one</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ᵍ</span><span class=\"mi\">1</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">ᵍ*</span> <span class=\"bp\">ᵍ</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_assoc</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">b</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">ᵍ*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/-- A graded version of `comm_monoid`. -/</span>\n<span class=\"kd\">class</span> <span class=\"n\">gcomm_monoid</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"kd\">extends</span> <span class=\"n\">gmonoid</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_comm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">ᵍ*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">defs</span>\n</code></pre></div>",
        "id": 226460125,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613436761
    },
    {
        "content": "<p>I think the axioms are basically just the monoid axioms this way</p>",
        "id": 226460136,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613436783
    },
    {
        "content": "<p>Thanks, I'll see how the proofs further down the file deal with those changes tomorrow</p>",
        "id": 226460595,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613437344
    },
    {
        "content": "<p>This proof isn't perfect but it works</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Build a `gmonoid` instance for a collection of `add_submonoids`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">gmonoid.of_submonoids</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">carriers</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carriers</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">mul_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">gi</span> <span class=\"o\">:</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gj</span> <span class=\"o\">:</span> <span class=\"n\">carriers</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">gi</span> <span class=\"bp\">*</span> <span class=\"n\">gj</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carriers</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">gmonoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">zero_add</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">j</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">add_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"bp\">+</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">c</span><span class=\"o\">),</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">add_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">ghas_one.of_submonoids</span> <span class=\"n\">carriers</span> <span class=\"n\">one_mem</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">ghas_mul.of_submonoids</span> <span class=\"n\">carriers</span> <span class=\"n\">mul_mem</span> <span class=\"o\">}</span>\n\n<span class=\"sd\">/-- Build a `gcomm_monoid` instance for a collection of `add_submonoid`s. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">gcomm_monoid.of_submonoids</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">carriers</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">one_mem</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carriers</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">mul_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">⦄</span> <span class=\"o\">(</span><span class=\"n\">gi</span> <span class=\"o\">:</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">gj</span> <span class=\"o\">:</span> <span class=\"n\">carriers</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">gi</span> <span class=\"bp\">*</span> <span class=\"n\">gj</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">carriers</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"bp\">+</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">gcomm_monoid</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"o\">(⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">carriers</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"bp\">+</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"bp\">*</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">add_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">gmonoid.of_submonoids</span> <span class=\"n\">carriers</span> <span class=\"n\">one_mem</span> <span class=\"n\">mul_mem</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 226460860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613437693
    },
    {
        "content": "<p>The suffices step is probably not one I would have thought of, but I can see how it solves the problem nicely</p>",
        "id": 226461468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613438463
    },
    {
        "content": "<p>It's implementing what you said here<br>\n<span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226457817\">said</a>:</p>\n<blockquote>\n<p>Ultimately my thought was that if I had a goal of the form <code>h.rec a = b</code>, then I could use <code>subst h</code> in tactic mode to reduce it to <code>a = b</code></p>\n</blockquote>",
        "id": 226461999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613439069
    },
    {
        "content": "<p>except without getting to the point of having a <code>rec</code> in the goal</p>",
        "id": 226462006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613439099
    },
    {
        "content": "<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>",
        "id": 226462094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613439166
    },
    {
        "content": "<p>and then simp lemmas saying how the <code>.1</code> and <code>.2.1</code> components of your definitions unfold</p>",
        "id": 226462140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613439200
    },
    {
        "content": "<p>that way you never have to see a dependent type</p>",
        "id": 226462144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613439211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226462094\">said</a>:</p>\n<blockquote>\n<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>\n</blockquote>\n<p>How about an <code>ext</code> lemma?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sigma.subtype_ext</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)},</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">b.fst</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a.snd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b.snd</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">bi</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">change</span> <span class=\"n\">ai</span> <span class=\"bp\">=</span> <span class=\"n\">bi</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">subst</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 226495124,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613470580
    },
    {
        "content": "<p>Does that lemma not yet exist? <span aria-label=\"shock\" class=\"emoji emoji-1f628\" role=\"img\" title=\"shock\">:shock:</span></p>",
        "id": 226495300,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613470722
    },
    {
        "content": "<p>It probably follows from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.heq_iff_coe_eq\">docs#subtype.heq_iff_coe_eq</a> somehow, which was my previous attempt at solving this problem</p>",
        "id": 226495439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613470808
    },
    {
        "content": "<p>Yeah, here's the <code>heq_iff_coe_eq</code> proof:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sigma.subtype_ext'</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">b.fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a.snd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b.snd</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">heq_iff_coe_eq</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h₁.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">iff.rfl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I think the other one is nicer</p>",
        "id": 226495830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613471061
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6257\">#6257</a> for <code>sigma.subtype_ext</code> and three variants.</p>",
        "id": 226497383,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613471962
    },
    {
        "content": "<p>I don't think this can be a <code>@[ext]</code> lemma, it doesn't have a single key</p>",
        "id": 226557388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613501136
    },
    {
        "content": "<p>the proof is also simpler than that:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sigma.subtype_ext</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)},</span> <span class=\"n\">a.fst</span> <span class=\"bp\">=</span> <span class=\"n\">b.fst</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">a.snd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">b.snd</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">ai</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">bi</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 226557603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613501242
    },
    {
        "content": "<p>What do you mean by a single key?</p>",
        "id": 226557930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613501392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226557388\">said</a>:</p>\n<blockquote>\n<p>I don't think this can be a <code>@[ext]</code> lemma, it doesn't have a single key</p>\n</blockquote>\n<p>What does this mean? It's a criterion for deciding when two terms of a type are equal. Isn't that exactly an <code>ext</code> lemma?</p>",
        "id": 226558020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613501417
    },
    {
        "content": "<p>snap</p>",
        "id": 226558049,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1613501432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, I tried to iterate towards that short proof, but the equation compiler would give an error while I still had a sorry</p>",
        "id": 226558286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613501539
    },
    {
        "content": "<p>An <code>ext</code> lemma needs to actually be found when you use <code>ext</code>, it's not just an arbitrary collection of lemmas, it's a lookup table</p>",
        "id": 226560269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502453
    },
    {
        "content": "<p>the key of that lookup table is the constant name of the type, and the constant here is <code>Sigma</code> which already has an ext lemma</p>",
        "id": 226560319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502481
    },
    {
        "content": "<p>Why does the PR not break anything then?</p>",
        "id": 226560477,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502543
    },
    {
        "content": "<p>When you put multiple ext lemmas it will just try a random one, maybe you got lucky</p>",
        "id": 226560553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502576
    },
    {
        "content": "<p>And then why are lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.prod_ext\">docs#linear_map.prod_ext</a> fine, as they overlay another ext lemma on <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.ext\">docs#linear_map.ext</a></p>",
        "id": 226560567,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502584
    },
    {
        "content": "<p>there isn't any priority system so I expect this will not work robustly</p>",
        "id": 226560598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502597
    },
    {
        "content": "<p>Doesn't it try all of them until it finds one that applies?</p>",
        "id": 226560600,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502597
    },
    {
        "content": "<p>yes, if it fails</p>",
        "id": 226560688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502629
    },
    {
        "content": "<p>but <code>Sigma.ext</code> would succeed on goals that your new ext lemma work on</p>",
        "id": 226560730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502648
    },
    {
        "content": "<p>Also, I remember a PR where <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> put <code>@[priority]</code> on a bunch of ext lemmas, and we concluded that the default priority was declaration order (and thus removed all the <code>priority</code> attributes again)</p>",
        "id": 226560747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502658
    },
    {
        "content": "<p>in that case you can get different behavior depending on the order of imports, which is bad</p>",
        "id": 226560821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502703
    },
    {
        "content": "<p>Not if file B imports file A anyway</p>",
        "id": 226560932,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502751
    },
    {
        "content": "<p>Which in all the cases that came up, it does</p>",
        "id": 226560950,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502760
    },
    {
        "content": "<p>Yes. Now do we want to rely on this or not?</p>",
        "id": 226560963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502768
    },
    {
        "content": "<p>Any bug can be considered a feature if you look at it in the right way</p>",
        "id": 226561030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613502797
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5200\">#5200</a> is the PR I'm referring to</p>",
        "id": 226561139,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502838
    },
    {
        "content": "<p>And I think we declared it a feature when writing <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#partially-applied%20ext%20lemmas\">https://leanprover-community.github.io/mathlib_docs/notes.html#partially-applied%20ext%20lemmas</a></p>",
        "id": 226561439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1613502939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Unfolding.20let.20bindings.20in.20hypotheses/near/226462094\">said</a>:</p>\n<blockquote>\n<p>It would be maybe better in this case to have a (simp) lemma that reduces equalities on <code>\\Sigma i, {x // p i x}</code>  to equalities of the first two components</p>\n</blockquote>\n<p>I've finally updated <a href=\"https://github.com/leanprover-community/mathlib/issues/6053\">#6053</a> to use this approach, thanks for the suggestions <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, that definitely ended up cleaner</p>",
        "id": 227312592,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614017832
    }
]
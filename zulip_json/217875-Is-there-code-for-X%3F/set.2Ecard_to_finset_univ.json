[
    {
        "content": "<p>I've found I've wanted this lemma before for direct conversion between <code>fintype.card</code> and <code>set.univ.to_finset.card</code>. Does it already exist somewhere? Any reason for it not to exist?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">set.card_to_finset_univ</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset.card</span> <span class=\"bp\">=</span> <span class=\"n\">fintype.card</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.to_finset_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.card_univ</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(I ask because it's currently in <a href=\"https://github.com/leanprover-community/mathlib/pull/5698\">#5698</a>.)</p>",
        "id": 266439576,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640881156
    },
    {
        "content": "<p>Not every pair of lemmas chained together is worthy of its own lemma (otherwise this strategy for adding lemmas recurses forever!). When do you need this combination?</p>",
        "id": 266468941,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640909642
    },
    {
        "content": "<p>Yeah, that's the motivation for asking about this. It would be a counterpart to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.to_finset_card\">docs#set.to_finset_card</a> for <code>set.univ</code>, and you can use these two lemmas in reverse to turn all the <code>fintype.card</code>s in an expression into <code>to_finset.card</code>, which then you manipulate using the <code>set.finite</code> module.</p>\n<p>It's not essential to have this shortcut lemma, but I usually forget which pair of lemmas are needed to do the transformation.</p>",
        "id": 266470932,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640912133
    },
    {
        "content": "<p>Can this be <code>simp</code>? If so that would be a good reason to have it.</p>",
        "id": 266504096,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1640958018
    },
    {
        "content": "<p>I wonder if there's a reason <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card_univ\">docs#finset.card_univ</a> isn't a <code>simp</code> lemma already.</p>",
        "id": 266504268,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640958240
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/7230\">#7230</a></p>",
        "id": 266504410,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640958435
    },
    {
        "content": "<p>I think that might be worth reviving</p>",
        "id": 266506762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1640961496
    },
    {
        "content": "<p>Maybe if you're mostly dealing with fintype.card then you want it as a simp lemma and if you're mostly dealing with finset.card then you don't. This sort of thing can happen, right? For example when making an API for the complex numbers you really want <code>complex.ext_iff</code> as a <code>simp</code> lemma because when checking the axioms to show C is a ring you want to prove all equalities by equating real and imaginary parts and then using <code>ring</code> for the corresponding real equations. But in general when working with complex numbers as more conceptual objects e.g. when doing complex analysis you probably don't want this.</p>",
        "id": 266508818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1640963906
    },
    {
        "content": "<p>It's still running through CI, but I've made a PR (<a href=\"https://github.com/leanprover-community/mathlib/pull/11174\">#11174</a>) that addresses what is probably the underlying issue that made we want <code>set.card_to_finset_univ</code>, which is that <code>set.to_finset_univ</code> does not have fully general <code>fintype</code> arguments.</p>",
        "id": 266524332,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640985403
    },
    {
        "content": "<p>(A way I've used things like <code>set.card_to_finset_univ</code> in the past is to close goals by <code>convert</code>.)</p>",
        "id": 266524344,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640985476
    },
    {
        "content": "<p>It still doesn't seem like it's properly general -- it would be nice if a lemma could take implicit arguments that are elaborated as typeclass arguments if they don't end up being solved for via unification.</p>\n<p>To do things \"right\" without that, it seems like we need variants of each lemma where instances for the left-hand side of an expression come from implicit arguments, and instances on the right-hand side come from typeclasses. That way when rewriting the left-hand side has greater freedom to match, but the right-hand side still is able to use typeclass search to fill in instances that the implicit argument system can't determine.</p>",
        "id": 266524511,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1640985737
    },
    {
        "content": "<p>To illustrate the issue that <a href=\"https://github.com/leanprover-community/mathlib/pull/11174\">#11174</a> is solving more clearly:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- fails</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"c1\">--fails</span>\n<span class=\"c1\">-- `set.univ.to_finset = finset.univ` and `set.univ.to_finset = finset.univ` have different types</span>\n<span class=\"c1\">-- due to different instance arguments.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">convert</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"c1\">-- OK</span>\n\n<span class=\"c1\">-- New lemma:</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ'</span> <span class=\"o\">{</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">hu</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"c1\">-- OK</span>\n</code></pre></div>",
        "id": 266595410,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641100638
    },
    {
        "content": "<p>The PR leaves the original version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.to_finset_univ\">docs#set.to_finset_univ</a> because it's still useful if you want to <code>rw ← set.to_finset_univ</code>, since it will synthesize the <code>fintype set.univ</code> instance.</p>",
        "id": 266595519,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641100804
    },
    {
        "content": "<p>What's the conflicting pair of instances?</p>",
        "id": 266604999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641116257
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> <code>subtype.fintype</code> and <code>set.fintype_univ</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span><span class=\"o\">,</span> <span class=\"n\">term</span>\n  <span class=\"n\">set.to_finset_univ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n    <span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.fintype_univ</span> <span class=\"n\">α</span> <span class=\"n\">hα</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"n\">α</span> <span class=\"n\">hα</span>\n</code></pre></div>",
        "id": 266614654,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641130653
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.fintype_univ/src\">src#set.fintype_univ</a></p>",
        "id": 266614918,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641131065
    },
    {
        "content": "<p>That instance seems pointless if the other one matches it</p>",
        "id": 266614985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641131163
    },
    {
        "content": "<p>Also, I believe I've misunderstood how <code>simp</code> interacts with instance arguments. It seems to already treat them as implicit arguments first? Otherwise, these examples wouldn't all work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ'</span> <span class=\"o\">[</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">hu</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">set.fintype_univ</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">hu</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"n\">_</span> <span class=\"n\">hα</span><span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">set.fintype_univ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ.card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">)</span>  <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">hu</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">finset.univ</span> <span class=\"n\">_</span> <span class=\"n\">hα</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>",
        "id": 266615276,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641131688
    },
    {
        "content": "<p>Indeed, after matching with the goal, <code>simp</code> processes arguments to its lemmas left-to-right, if the value of the argument derives from the unification it uses that, otherwise it will use typeclass inference, or if it's a <code>Prop</code>, recursively call <code>simp</code> on that argument. (Notably, this means <code>out_param</code>s of instances do not get inferred correctly by <code>simp</code>.)</p>",
        "id": 266670695,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1641205337
    },
    {
        "content": "<p>Does any of the interesting discussion above deserve being added to this page: <a href=\"https://leanprover-community.github.io/extras/simp.html\">https://leanprover-community.github.io/extras/simp.html</a> ?</p>",
        "id": 266671043,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1641205563
    },
    {
        "content": "<p>I'm hoping to fix the <code>out_param</code> issue soon, so let's wait a bit before we do so :)</p>",
        "id": 266672053,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1641206280
    },
    {
        "content": "<p>There seems to be an elaboration bug with this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Here's the full error using <code>set_option pp.implicit true</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"mi\">1303</span><span class=\"o\">:</span><span class=\"mi\">35</span><span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">type</span> <span class=\"n\">check</span> <span class=\"n\">declaration</span> <span class=\"bp\">'</span><span class=\"n\">set.to_finset_univ'</span> <span class=\"n\">this</span> <span class=\"n\">is</span> <span class=\"n\">usually</span> <span class=\"n\">due</span> <span class=\"n\">to</span> <span class=\"n\">a</span> <span class=\"n\">buggy</span> <span class=\"n\">tactic</span> <span class=\"n\">or</span> <span class=\"n\">a</span> <span class=\"n\">bug</span> <span class=\"k\">in</span> <span class=\"n\">the</span> <span class=\"n\">builtin</span> <span class=\"n\">elaborator</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">type</span><span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">],</span>\n    <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n      <span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span>\n<span class=\"n\">elaborated</span> <span class=\"n\">value</span><span class=\"o\">:</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">],</span>\n    <span class=\"bp\">@</span><span class=\"n\">ext</span> <span class=\"n\">α</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n         <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">_inst_2</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n         <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">id</span>\n            <span class=\"o\">((</span><span class=\"n\">a</span> <span class=\"bp\">∈</span>\n                    <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n                      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                         <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n                  <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n               <span class=\"o\">(</span><span class=\"n\">true</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span><span class=\"o\">))</span>\n            <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_1</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">b_1</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e_2</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b_1</span><span class=\"o\">),</span>\n                <span class=\"bp\">@</span><span class=\"n\">congr</span> <span class=\"kt\">Prop</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"n\">iff</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">iff</span> <span class=\"n\">a_1</span><span class=\"o\">)</span> <span class=\"n\">b</span> <span class=\"n\">b_1</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">congr_arg</span> <span class=\"kt\">Prop</span> <span class=\"o\">(</span><span class=\"kt\">Prop</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span> <span class=\"n\">iff</span> <span class=\"n\">e_1</span><span class=\"o\">)</span> <span class=\"n\">e_2</span><span class=\"o\">)</span>\n               <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span>\n                  <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n                    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                       <span class=\"n\">_inst_2</span><span class=\"o\">))</span>\n               <span class=\"n\">true</span>\n               <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">propext</span>\n                   <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span>\n                      <span class=\"bp\">@</span><span class=\"n\">set.to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n                        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                           <span class=\"n\">_inst_2</span><span class=\"o\">))</span>\n                   <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n                   <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.mem_to_finset</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n                      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">subtype.fintype</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">set.univ_decidable</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n                         <span class=\"n\">_inst_2</span><span class=\"o\">)</span>\n                      <span class=\"n\">a</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n                     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">@</span><span class=\"n\">iff_true_intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.mem_univ</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">α</span> <span class=\"n\">a</span><span class=\"o\">)))</span>\n               <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span>\n               <span class=\"n\">true</span>\n               <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">propext</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_2</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n                  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n                      <span class=\"bp\">@</span><span class=\"n\">iff_true_intro</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">@</span><span class=\"n\">univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mem_univ</span> <span class=\"n\">α</span> <span class=\"n\">_inst_1</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n                     <span class=\"n\">α</span>\n                     <span class=\"n\">_inst_2</span>\n                     <span class=\"n\">a</span><span class=\"o\">))))</span><span class=\"bp\">.</span><span class=\"n\">mpr</span>\n           <span class=\"o\">(</span><span class=\"n\">iff.refl</span> <span class=\"n\">true</span><span class=\"o\">))</span>\n<span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">message</span><span class=\"o\">:</span>\n<span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">fintype</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"kt\">Type</span> <span class=\"n\">u_2</span>\n</code></pre></div>",
        "id": 266836489,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641316453
    },
    {
        "content": "<p>I'm not sure whether I'd expect it or not, but it also chooses the <code>subtype.fintype</code> instance for <code>set.to_finset</code> rather than the one given as an argument.</p>",
        "id": 266836553,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641316490
    },
    {
        "content": "<p>You need to add a coe_sort arrow I think</p>",
        "id": 266845564,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641320912
    },
    {
        "content": "<p>That does fix it here, but what's going on exactly? The error message shows that Lean's inserting the <code>coe_sort</code> automatically -- my only guess is that somehow it causes the elaborator to fail to unify some universe (meta)variables, so when metavariables are replaced by variables, once the kernel gets ahold of it they're accidentally different.</p>\n<p>I think this explains also why typeclass inference isn't picking up on the instance, since it seems to be <code>fintype.{u_2} (↥(@set.univ α) : Type u_1)</code>.</p>",
        "id": 266850863,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641323874
    },
    {
        "content": "<p>Indeed, explicit universes fixes it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">((</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p><em>Edit:</em> Hmm, even this is enough to get it to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">((</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266850908,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641323884
    },
    {
        "content": "<p>But this does fix it, too:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">set.to_finset_univ</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_finset</span> <span class=\"bp\">=</span> <span class=\"n\">finset.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.mem_to_finset</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 266854435,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641325880
    },
    {
        "content": "<p>Anyway, assuming this is a bug, <a href=\"https://github.com/leanprover-community/mathlib/pull/11247\">#11247</a> puts the lemma into this last form while adding a TODO.</p>",
        "id": 266873447,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641335442
    },
    {
        "content": "<p>Does it seem like a bug? Should I submit a lean issue?</p>\n<p>Here's a mathlib-free mwe:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}⟩</span>\n\n<span class=\"c1\">-- OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex1</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n\n<span class=\"c1\">-- Not OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex2</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">kernel failed to type check declaration 'ex2' this is usually due to a buggy tactic or a bug in the builtin elaborator</span>\n<span class=\"cm\">elaborated type:</span>\n<span class=\"cm\">  ∀ {α : Type u} [_inst_1 : inhabited ↥set.univ], true</span>\n<span class=\"cm\">elaborated value:</span>\n<span class=\"cm\">  λ {α : Type u} [_inst_1 : inhabited ↥set.univ], trivial</span>\n<span class=\"cm\">nested exception message:</span>\n<span class=\"cm\">type mismatch at application</span>\n<span class=\"cm\">  inhabited ↥set.univ</span>\n<span class=\"cm\">term</span>\n<span class=\"cm\">  ↥set.univ</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  Type u</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  Sort u_1</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex3</span> <span class=\"o\">[</span><span class=\"n\">inhabited.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n\n<span class=\"c1\">-- OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex4</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n\n<span class=\"c1\">-- OK</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">ex5</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">s</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span>\n</code></pre></div>",
        "id": 266873513,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641335478
    },
    {
        "content": "<p>This definitely seems like an elaborator bug.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>fails,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>works</p>",
        "id": 266874384,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1641336041
    },
    {
        "content": "<p>Definitely open a lean issue, because then you can reference it from a comment.</p>",
        "id": 266877746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1641338252
    },
    {
        "content": "<p>I wonder if it's the same underlying issue as <a href=\"https://github.com/leanprover-community/lean/pull/474\">lean#474</a></p>",
        "id": 266879951,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1641339810
    }
]
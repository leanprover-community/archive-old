[
    {
        "content": "<p>I'm idly trying to prove angle at centre is twice angle at circumference and I realise that I can't prove angle AOB plus angle BOC = angle AOC with undirected angles, indeed I am having real trouble adding hypotheses which make this statement true. Do I have to make a new definition before I can correctly state this theorem? I want to say something like \"any line though O which has A and B on the same side of it, also has C on that same side\".</p>",
        "id": 243832374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624561682
    },
    {
        "content": "<p>what's the theorem statement?</p>",
        "id": 243832840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624561920
    },
    {
        "content": "<p>An example of an informal statement is that B is in triangle OAC then AOB+BOC=AOC, which we could probably say right now. But more generally B could be in the \"infinite triangle\" with vertex O and sides extending OA and OC and I don't know how to say this in lean right now -- the question is if we have this definition</p>",
        "id": 243834254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624562640
    },
    {
        "content": "<p>I'm asking mostly what actual imports are you working with. Is this a theorem about R^2? Inner product spaces? Hilbert axioms for geometry?</p>",
        "id": 243835667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563331
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.triangle</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùîº</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"bp\">ùîº</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_add_torsor</span> <span class=\"n\">V</span> <span class=\"bp\">ùîº</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span>\n\n<span class=\"kn\">include</span> <span class=\"n\">V</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">euclidean_geometry</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">real</span>\n<span class=\"kn\">open</span> <span class=\"n\">finite_dimensional</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">angles_add</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">‚à†</span> <span class=\"n\">B</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Can't be proved but under some hypotheses which I can't yet express in Lean without making new definitions, it's true</p>",
        "id": 243836104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563515
    },
    {
        "content": "<p>We don't have convex hull for affine spaces :-(</p>",
        "id": 243836138,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563530
    },
    {
        "content": "<p>One way to describe that infinite triangle is as the sum of the rays OA and OC</p>",
        "id": 243836150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563537
    },
    {
        "content": "<p>there's no sum in an affine space</p>",
        "id": 243836228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563578
    },
    {
        "content": "<p>well, sum of the relative vectors with O as base point</p>",
        "id": 243836271,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563599
    },
    {
        "content": "<p>oh my goodness, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle\">docs#norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle</a></p>",
        "id": 243836457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563682
    },
    {
        "content": "<p>which is clearly the law of cosines</p>",
        "id": 243836496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563706
    },
    {
        "content": "<p>you mean <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle\">docs#inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle</a></p>",
        "id": 243836518,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563720
    },
    {
        "content": "<p>Not as long as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset'\">docs#eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset'</a> according to someone on the discord</p>",
        "id": 243836604,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563752
    },
    {
        "content": "<p>it's not even possible to <code>#print</code> that without going over the line length limit</p>",
        "id": 243836605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624563752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/adding.20angles/near/243836604\">said</a>:</p>\n<blockquote>\n<p>Not as long as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset'\">docs#eventually_closure_subset_of_is_compact_absorbing_of_is_open_of_omega_limit_subset'</a> according to someone on the discord</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"364484\">@Deniz Aydin</span> for the sake of credit!</p>",
        "id": 243836659,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1624563783
    },
    {
        "content": "<p>I think this is true</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">angle_at_center_equals_twice_angle_at_circumference</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOA</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOB</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOC</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">&lt;</span> <span class=\"n\">œÄ</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>but I can't write down the proof because there are two cases depending on whether BAC is &lt; 90 or &gt; 90.</p>",
        "id": 243836839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563884
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚â†</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">angle_eq_left</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hAO</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚â†</span> <span class=\"n\">O</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">dist_self</span> <span class=\"n\">at</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hAB</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">zero_eq_dist.mp</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">hOB</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">dist_pos.2</span> <span class=\"n\">hAO.symm</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">angle_eq_angle_of_dist_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hOA</span><span class=\"o\">,</span> <span class=\"n\">hOB</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">angle_eq_angle_of_dist_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hOB</span><span class=\"o\">,</span> <span class=\"n\">hOC</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">‚à†</span> <span class=\"n\">B</span> <span class=\"n\">O</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- this is not in general true</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243836870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624563909
    },
    {
        "content": "<p>(That needs <code>open euclidean_geometry</code>)</p>",
        "id": 243837119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564038
    },
    {
        "content": "<p>I think the theorem is false, you haven't said that O,A,B,C are coplanar</p>",
        "id": 243837257,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564104
    },
    {
        "content": "<p>and in particular reasoning about that comes up when you want to add angles</p>",
        "id": 243837345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564162
    },
    {
        "content": "<p>also do you want <code>h4</code> to say <code>have h4 : ‚à† A O C = ‚à† A O B + ‚à† B O C,</code>?</p>",
        "id": 243837751,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564376
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.triangle</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùîº</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"bp\">ùîº</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_add_torsor</span> <span class=\"n\">V</span> <span class=\"bp\">ùîº</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span>\n\n<span class=\"kn\">include</span> <span class=\"n\">V</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">euclidean_geometry</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">real</span>\n<span class=\"kn\">open</span> <span class=\"n\">finite_dimensional</span>\n<span class=\"kn\">open</span> <span class=\"n\">euclidean_geometry</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">              B</span>\n<span class=\"cm\">                  A'</span>\n<span class=\"cm\">              O</span>\n<span class=\"cm\">          A</span>\n<span class=\"cm\">                  C</span>\n\n<span class=\"cm\">hypothesis `h : ABC&lt;pi/2` means `AOC&lt;pi`.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">theorem</span> <span class=\"n\">angle_at_center_equals_twice_angle_at_circumference</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñù</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOA</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOB</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hOC</span> <span class=\"o\">:</span> <span class=\"n\">dist</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">&lt;</span> <span class=\"n\">œÄ</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚â†</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">angle_eq_left</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">linarith</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hAO</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚â†</span> <span class=\"n\">O</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">dist_self</span> <span class=\"n\">at</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">subst</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">hAB</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">zero_eq_dist.mp</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">hOB</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">hOA</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">dist_pos.2</span> <span class=\"n\">hAO.symm</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">angle_eq_angle_of_dist_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hOA</span><span class=\"o\">,</span> <span class=\"n\">hOB</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">angle_eq_angle_of_dist_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hOB</span><span class=\"o\">,</span> <span class=\"n\">hOC</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">‚à†</span> <span class=\"n\">B</span> <span class=\"n\">O</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- this is not in general true</span>\n    <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 243838043,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624564523
    },
    {
        "content": "<p>In the case when it's true, this is part of the proof. The other possibility is that it's the difference of these two angles.</p>",
        "id": 243838169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624564574
    },
    {
        "content": "<p>Is the finrank assumption used elsewhere as a way to say that V is 2 dimensional?</p>",
        "id": 243838377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564684
    },
    {
        "content": "<p>I'm interested in theorems you can't prove without making more definitions. You can state FLT in NNG but you have to define modular forms to prove it. After defining nat, succ_inj and zero_ne_succ are theorems which seem to be only provable after making more definitions (i.e. using the recursor and eliminating into type, rather than induction). Here also I can't write down my proof without making some more definitions.</p>",
        "id": 243838387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624564692
    },
    {
        "content": "<p>I have no idea whether the finrank hypothesis is the way to go. It makes the theorem true but there might be other ways to do it (e.g. you can demand that there exist three affine independent points but not four).</p>",
        "id": 243838456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624564735
    },
    {
        "content": "<p>either way, there needs to be some set of theorems that follow from the dimensionality assumption, which are likely to be crucial in the proof</p>",
        "id": 243838549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564790
    },
    {
        "content": "<p>The <code>finrank</code> hypothesis doesn't look ideal to me, as it would make it awkward to talk about angles within a plane in 3D space</p>",
        "id": 243838601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624564804
    },
    {
        "content": "<p>the only thing that I found which looks helpful is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_finrank_eq_two\">docs#euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_finrank_eq_two</a></p>",
        "id": 243838648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564825
    },
    {
        "content": "<p>but I think you want a theorem more along the lines of your adding angles lemma</p>",
        "id": 243838701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564861
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two\">docs#euclidean_geometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two</a>  is the subspace lemma</p>",
        "id": 243838798,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624564921
    },
    {
        "content": "<p>Which uses <code>finrank ‚Ñù s.direction = 2</code> instead of <code>finrank ‚Ñù V = 2</code></p>",
        "id": 243838857,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624564935
    },
    {
        "content": "<p>A simpler version of <code>angles_add</code> which doesn't need new definitions is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">angles_add</span> <span class=\"o\">(</span><span class=\"n\">O</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ùîº</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"n\">‚Ñù</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">‚à†</span> <span class=\"n\">B</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">‚à®</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">B</span> <span class=\"bp\">+</span> <span class=\"bp\">‚à†</span> <span class=\"n\">B</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à†</span> <span class=\"n\">A</span> <span class=\"n\">O</span> <span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">œÄ</span>\n</code></pre></div>",
        "id": 243838911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624564974
    },
    {
        "content": "<p>Maybe the fact that the lemma Mario links to is proved via that one suggests that working in a 2D subspace is easier than working in an ambient 2D space?</p>",
        "id": 243838922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624564977
    },
    {
        "content": "<p>I agree that asking for the whole space to be 2d is a bit overspecific. It might be possible to lift theorems about 2d space to 2d subspaces though using metric embedding</p>",
        "id": 243839019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1624565041
    },
    {
        "content": "<p>That version of <code>angles_add</code> isn't true because they might subtract</p>",
        "id": 243854070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624573386
    },
    {
        "content": "<p>I have a feeling that the right way to prove that is to go through oriented angles, but I think we don't have these</p>",
        "id": 243855395,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1624574407
    },
    {
        "content": "<p>Indeed, we don't have oriented <em>anything</em>.  But now that we have determinants of endomorphisms (thanks <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>!), it might be time to start building it.</p>",
        "id": 243855812,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624574801
    },
    {
        "content": "<p>Am I right in thinking for that we need oriented 2d affine spaces which generalizes to needing oriented submodules to put in <code>affine_subspace.direction</code> (aka the exterior powers)? Or are there better representations?</p>",
        "id": 243856236,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624575152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The path you describe is the ideal one, but I think that in the short term, you can use <del>docs#multilinear_map</del> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alternating_map\">docs#alternating_map</a> for a definition of orientation.</p>",
        "id": 243856414,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575306
    },
    {
        "content": "<p>The space of topdimensional alternating maps from a real vector space is 1-dimensional, and under the natural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> action it has two equivalence classes.</p>",
        "id": 243856511,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575363
    },
    {
        "content": "<p>Define an orientation to be a choice of equivalence class.</p>",
        "id": 243856522,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575376
    },
    {
        "content": "<p>Is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alternating_map\">docs#alternating_map</a> a closer approximation, since that's equivalent to linear maps from the exterior powers?</p>",
        "id": 243856574,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624575422
    },
    {
        "content": "<p>Yes thanks, fixed!  (that's what I meant to say)</p>",
        "id": 243856607,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575451
    },
    {
        "content": "<p>Also, it would be nice to define a density on a real vector space as an orbit of the natural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mord\">/2</span></span></span></span>-action (by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>¬±</mo></mrow><annotation encoding=\"application/x-tex\">\\pm</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">¬±</span></span></span></span>) on this 1-dimensional space of topdimensional alternating maps, and then prove that a density determines a measure.</p>",
        "id": 243856942,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575672
    },
    {
        "content": "<p>Finally (perhaps useful for <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>) there is a hack for defining oriented angles in dimension 2:  work with a real affine space modelled on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> considered as a real vector space!</p>",
        "id": 243857148,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624575830
    },
    {
        "content": "<p>I think working in <code>(exterior_algebra.Œπ R V).range ^ 2</code> gives you a poor mans exterior power?</p>",
        "id": 243857420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1624576013
    },
    {
        "content": "<p>I don't know that syntax.</p>",
        "id": 243857606,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624576143
    },
    {
        "content": "<p>I think working in a two-dimensional subspace is appropriate for two-dimensional geometry results going in mathlib, with the special case where the whole space is two-dimensional then being deduced from the subspace version. If you're doing some random olympiad geometry problem rather than proving a result that might be used in other proofs, then making the whole space two-dimensional seems appropriate.</p>",
        "id": 243860387,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624578209
    },
    {
        "content": "<p>Yes, we need orientations of finite-dimensional real vector spaces (or whatever wider class of modules orientations make sense for) before defining oriented angles. I'm not sure offhand if orientations should be defined for submodules, or only for modules with the coercion from submodule to subtype and the module instance on that subtype then being used to get orientations for submodules. Also, I don't know if we have all the instances needed to get a Euclidean affine space structure on an affine subspace of a Euclidean affine space (which we'd need if only modules get orientations), but if we're missing any, they should be easy to add.</p>",
        "id": 243860844,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624578581
    },
    {
        "content": "<p>Then you need to decide if oriented angles are real numbers, or use the <code>angle</code> type from <code>analysis.special_functions.trigonometric</code> (real numbers mod 2œÄ). And while oriented angles mod 2œÄ are certainly useful and meaningful, for many geometrical purposes you actually want oriented angles mod <code>œÄ</code> (the angle of a rotation from one undirected line to another) instead.</p>",
        "id": 243861279,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624578830
    },
    {
        "content": "<p>As noted above, until we have convexity for affine spaces, it's hard to talk about points being between other points, or on the same / different sides of a line (which is a major reason for not being able to state most olympiad geometry problems yet, as they tend to include such conditions to reduce configuration-dependence). Once we do have convexity for affine spaces (<a href=\"https://github.com/leanprover-community/mathlib/issues/2910\">#2910</a>), then I think we should define strict and weak versions of \"between\" in terms of it - both for a point being strictly or weakly between two points, and for an affine subspace being strictly or weakly between two points.</p>",
        "id": 243861793,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624579237
    },
    {
        "content": "<p>I think one could get quite far with the complex-geometry hack:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">geometry.euclidean.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">metric_space</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_add_torsor</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">oriented_angle</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">real.angle</span> <span class=\"o\">:=</span>\n<span class=\"n\">complex.arg</span> <span class=\"o\">((</span><span class=\"n\">p1</span> <span class=\"bp\">-·µ•</span> <span class=\"n\">p2</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"o\">(</span><span class=\"n\">p3</span> <span class=\"bp\">-·µ•</span> <span class=\"n\">p2</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 243862196,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624579617
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/adding.20angles/near/243861279\">said</a>:</p>\n<blockquote>\n<p>Then you need to decide if oriented angles are real numbers, or use the <code>angle</code> type from <code>analysis.special_functions.trigonometric</code> (real numbers mod 2œÄ). And while oriented angles mod 2œÄ are certainly useful and meaningful, for many geometrical purposes you actually want oriented angles mod <code>œÄ</code> (the angle of a rotation from one undirected line to another) instead.</p>\n</blockquote>\n<p>Although it brings all these problems.</p>",
        "id": 243862289,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624579701
    },
    {
        "content": "<p>We should already have all the main pieces needed to construct an isometry between the complex plane and an arbitrary two-dimensional Euclidean affine (sub)space. But to actually use complex numbers to prove geometrical results stated in a more general context, we need a load of lemmas transporting all the geometrical definitions we have across isometries (and maybe an associated tactic to use those lemmas to reduce a general result to be proved to one for the complex plane). We don't have those lemmas at present, though I think they should be straightforward to add.</p>",
        "id": 243862649,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624579924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/adding.20angles/near/243862649\">said</a>:</p>\n<blockquote>\n<p>We should already have all the main pieces needed to construct an isometry between the complex plane and an arbitrary two-dimensional Euclidean affine (sub)space.</p>\n</blockquote>\n<p>Indeed: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.isometry_euclidean\">docs#complex.isometry_euclidean</a> plus <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_isometry_equiv.of_inner_product_space\">docs#linear_isometry_equiv.of_inner_product_space</a> for the linear version, so what's missing is just the linear-to-affine glue.</p>",
        "id": 243862775,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624580069
    },
    {
        "content": "<p>(and in particular, the definition of an affine isometry, as we were discussing the other day)</p>",
        "id": 243862791,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624580094
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/adding.20angles/near/243862649\">said</a>:</p>\n<blockquote>\n<p>But to actually use complex numbers to prove geometrical results stated in a more general context, we need a load of lemmas transporting all the geometrical definitions we have across isometries (and maybe an associated tactic to use those lemmas to reduce a general result to be proved to one for the complex plane). We don't have those lemmas at present, though I think they should be straightforward to add.</p>\n</blockquote>\n<p>But all this is certainly missing, and moreover, it seems like an ugly way to prove things!  I hope that in the \"ideal\" state of the library nothing is done this way :)</p>",
        "id": 243862878,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624580165
    },
    {
        "content": "<p>It's probably more for when someone wants to formalize a complex-bash solution to an olympiad problem.</p>",
        "id": 243862903,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624580224
    },
    {
        "content": "<p>I see ... I wonder if that will ever be necessary?  I think of complex numbers as being a way of doing geometry problems by brute force, in what is sometimes a slightly more human-comprehensible form than in real co-ordinates.  But in Lean, I would think you can jump straight to the brute-force non-human-comprehensible version.</p>",
        "id": 243863229,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624580441
    },
    {
        "content": "<p>(Transporting across isometries can be useful in non-bash cases - anything where the proof involves reflecting the diagram and looking at the reflected points, for example. Likewise, transporting across similarities.)</p>",
        "id": 243863240,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1624580464
    },
    {
        "content": "<p>Yup, no objection to that!</p>",
        "id": 243863250,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1624580492
    },
    {
        "content": "<p>This oriented angle definition is wonderful. I felt very uncomfortable with this random <code>finrank V = 2</code> assumption, and didn't have a clue how to use it. I played (on paper) with Joseph's idea of <em>defining</em> an ordered angle to be what he called \"direct isometries\" modulo translations (assuming \"direct isometry\" means \"orientation-preserving\" -- we're not choosing an orientation here, we're preserving all of them :-) ) but for dim(V)=n+1 these \"ordered angles\" now seemed to be rotations of the n-sphere, and I wasn't sure if that was what we wanted them to be in general (angle A + angle B != angle B + angle A in general!).</p>",
        "id": 243916536,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1624628385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/adding.20angles/near/243856511\">said</a>:</p>\n<blockquote>\n<p>The space of topdimensional alternating maps from a real vector space is 1-dimensional, and under the natural <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mo>+</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span></span></span></span> action it has two equivalence classes.</p>\n</blockquote>\n<p>I've now implemented this definition of orientations (up to showing that these alternating maps are all multiples of the determinant and thus there are exactly two orientations). I'll do a series of PRs and then attempt to build oriented angles on top of orientations.</p>",
        "id": 259820540,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1635732606
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span>  That's great!  By the way, <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> was asking about the status of related things just the other day:<br>\n<a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/determinant.20via.20exterior.20algebra\">https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/determinant.20via.20exterior.20algebra</a></p>",
        "id": 259863159,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1635773338
    },
    {
        "content": "<p>Incidentally, as Kevin pointed out to me, we can express the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>‚àß</mo><mi>n</mi></msup><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\wedge^n V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mbin\">‚àß</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is one-dimensional neatly by saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mo>‚àß</mo><mi>n</mi></msup><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">\\wedge^n V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mbin\">‚àß</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> is a multiplicative torsor for the non-zero scalars.</p>",
        "id": 259865594,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1635774647
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/pull/12106\">#12106</a> for my work so far on oriented angles. As well as lots of lemmas just to set up the API, this includes a few more substantive geometrical results, e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- Angle at center of a circle equals twice angle at circumference, oriented vector angle</span>\n<span class=\"sd\">form. -/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">oangle_eq_two_zsmul_oangle_sub_of_norm_eq</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hxyne</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚â†</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hxzne</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚â†</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hxy</span> <span class=\"o\">:</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">y</span><span class=\"bp\">‚à•</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hxz</span> <span class=\"o\">:</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">z</span><span class=\"bp\">‚à•</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">hb.oangle</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">norm_zero</span><span class=\"o\">,</span> <span class=\"n\">norm_eq_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hxy</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hxyne</span> <span class=\"n\">hxy</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">norm_ne_zero_iff.1</span> <span class=\"o\">(</span><span class=\"n\">hxy.symm</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">norm_ne_zero_iff.2</span> <span class=\"n\">hy</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">norm_ne_zero_iff.1</span> <span class=\"o\">(</span><span class=\"n\">hxz</span> <span class=\"bp\">‚ñ∏</span> <span class=\"n\">norm_ne_zero_iff.2</span> <span class=\"n\">hx</span><span class=\"o\">),</span>\n  <span class=\"k\">calc</span> <span class=\"n\">hb.oangle</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">hb.oangle</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">hb.oangle</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">hb.oangle_sub_left</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"n\">hz</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n       <span class=\"bp\">...</span>           <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">œÄ</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">-</span>\n                       <span class=\"o\">(</span><span class=\"n\">œÄ</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n         <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hb.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq</span> <span class=\"n\">hxzne.symm</span> <span class=\"n\">hxz.symm</span><span class=\"o\">,</span>\n                <span class=\"n\">hb.oangle_eq_pi_sub_two_zsmul_oangle_sub_of_norm_eq</span> <span class=\"n\">hxyne.symm</span> <span class=\"n\">hxy.symm</span><span class=\"o\">]</span>\n       <span class=\"bp\">...</span>           <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"o\">(</span><span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kd\">by</span> <span class=\"n\">abel</span>\n       <span class=\"bp\">...</span>           <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n         <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hb.oangle_sub_right</span> <span class=\"o\">(</span><span class=\"n\">sub_ne_zero_of_ne</span> <span class=\"n\">hxyne</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">sub_ne_zero_of_ne</span> <span class=\"n\">hxzne</span><span class=\"o\">)</span> <span class=\"n\">hx</span>\n       <span class=\"bp\">...</span>           <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñ§</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">hb.oangle</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n         <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span><span class=\"n\">oangle_neg_neg</span><span class=\"o\">,</span> <span class=\"n\">neg_sub</span><span class=\"o\">,</span> <span class=\"n\">neg_sub</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272321584,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1645131542
    },
    {
        "content": "<p>We finally have a theorem which my kids learnt at the age of 15 :-)</p>",
        "id": 272322848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645132167
    },
    {
        "content": "<p>Note that it took 50 preparatory PRs elsewhere in mathlib to get this far (though some of that is because I prefer to PR dependencies as I go along rather than mixing changes to lots of different bits of mathlib in the main PR).</p>",
        "id": 272324984,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1645133298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> Which is greatly appreciated! Your PRs are showcases of atomic PRs that do one thing and do it right!</p>",
        "id": 272364128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645164920
    },
    {
        "content": "<p>I've done a big refactor of oriented angles and 2d rotations which I am now tidying up for PR, and wanted to post about it to check that everyone is ok with the change.</p>\n<p>The setting is an oriented real inner product space <code>E</code> of dimension 2.  The existing constructions, by <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span>, first define oriented angles and 2d rotations with respect to an orthonormal basis, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthonormal.oangle\">docs#orthonormal.oangle</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthonormal.rotation\">docs#orthonormal.rotation</a>. Then these constructions are proved to be the same for any two orthonormal bases of the same orientation, giving <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orientation.oangle\">docs#orientation.oangle</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orientation.rotation\">docs#orientation.rotation</a>.</p>\n<p>Here is my branch for the new construction: <a href=\"https://github.com/leanprover-community/mathlib/compare/volume-form..almost-complex-2d\">https://github.com/leanprover-community/mathlib/compare/volume-form..almost-complex-2d</a><br>\n(I am giving the diff relative to <a href=\"https://github.com/leanprover-community/mathlib/pull/16487\">#16487</a> since that PR itself has a +869 ‚àí352 diff.)</p>\n<p>My proposed new construction gives a basis-free construction of <code>oangle</code> and <code>rotation</code>, which cuts 600 lines from the file.  These lines are mostly made up again by a body of new theory, a new file <a href=\"https://github.com/leanprover-community/mathlib/blob/284747e2b754fd52fde59f6f909af85a5ea1b80c/src/analysis/inner_product_space/area_form.lean\"><code>inner_product_space/area_form</code></a>.  You can read the module docstring of that file for more about the approach. Suffice it to say that one develops the theory of a \"rotation-by-90-degrees map\" <code>J</code> and an \"oriented-area-of-a-parallelogram\" map <code>œâ</code> -- we don't have oriented area yet but this map <code>œâ</code> will also be helpful when it comes to constructing that.</p>\n<p>Professional geometers (<span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> <span class=\"user-mention\" data-user-id=\"455674\">@Matej Penciak</span> ...) will notice that this is all basically a version of the inner-product/symplectic/almost-complex/Kahler triangle, although for simplicity I have done everything in two dimensions.  (I'd be glad of a naming idea for my construction <a href=\"https://github.com/leanprover-community/mathlib/blob/284747e2b754fd52fde59f6f909af85a5ea1b80c/src/analysis/inner_product_space/area_form.lean#L422\"><code>kahler</code></a>, which betrays its origin in a way which might be confusing for people expecting the more general version.)</p>\n<p>This came out of sphere eversion, in some sense.  I defined the three-dimensional analogue of all this (cross product, rotation by an angle about an axis) there, and then found the energy to redo the two-dimensional version on the same foundation (<a href=\"https://github.com/leanprover-community/mathlib/pull/16487\">#16487</a>).</p>",
        "id": 299839950,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663704518
    },
    {
        "content": "<p>Avoiding needing to develop the API for oriented angles twice, with respect to a basis and then a copy of that API with respect to an orientation (and <a href=\"https://github.com/leanprover-community/mathlib/pull/16279\">#16279</a> adds the corresponding affine development for angles between points), is certainly attractive. But I think lemmas should be provided that the two definitions are equivalent, both on general principles of proving that different definitions are equivalent and for use in cases where calculations are more convenient with expressions involving separate complex numbers corresponding to the two vectors. That means four such lemmas (for each of <code>oangle</code> and <code>rotation</code>, providing a general lemma for any orthonormal basis with the right orientation, and a special-case one using <code>fin_orthonormal_basis</code> as the basis). I'd also expect a lemma proving that <code>right_angle_rotation</code> is equal to <code>rotation</code> by <code>œÄ / 2</code>.</p>",
        "id": 299844440,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1663706225
    },
    {
        "content": "<p>(I just looked at <a href=\"https://github.com/leanprover-community/mathlib/pull/16487\">#16487</a> but couldn't see the titular feature for the trees of reasonable refactors / API lemmas)</p>",
        "id": 299844535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663706267
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span>, what would you think of providing a single lemma for each of <code>oangle</code> and <code>rotation</code>, explaining how they can be calculated in a particular oriented orthonormal basis?  It's not clear to me that we need to duplicate all the lemmas (but I am open to hearing a different point of view).</p>",
        "id": 299845116,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663706512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I don't understand your comment (is it a question?)</p>",
        "id": 299845256,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663706550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/adding.20angles/near/299845116\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span>, what would you think of providing a single lemma for each of <code>oangle</code> and <code>rotation</code>, explaining how they can be calculated in a particular oriented orthonormal basis?</p>\n</blockquote>\n<p>Oh, sorry, maybe I misread -- this is what you were proposing.</p>",
        "id": 299845381,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663706610
    },
    {
        "content": "<p>I suppose a single lemma for each would work; it would simply need to be used together with the lemma stating the orientation of <code>fin_orthonormal_basis</code> whenever a proof starts by rewriting into the complex number form but doesn't care more specifically about the choice of basis.</p>",
        "id": 299845434,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1663706635
    },
    {
        "content": "<p>Apologies, I missed that it had a large tree of dependencies due to being on mobile, you can ignore my comment!</p>",
        "id": 299845513,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663706653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> Sorry, of course I don't mind adding 4 lemmas rather than 2; I had misread and thought you wanted to keep duplicate versions of <em>all</em> the dozens of lemmas.</p>",
        "id": 299845600,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663706696
    },
    {
        "content": "<p>Now PR'd as <a href=\"https://github.com/leanprover-community/mathlib/pull/16596\">#16596</a>.</p>",
        "id": 300091576,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1663831601
    }
]
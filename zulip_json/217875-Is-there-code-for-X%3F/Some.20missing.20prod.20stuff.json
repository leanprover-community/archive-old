[
    {
        "content": "<p>I search around and I couldn't find these guys:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prod.dup</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prod.mk'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"n\">prod.map</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">prod.dup</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prod.mk'_fst_snd</span> <span class=\"o\">:</span> <span class=\"n\">prod.mk'</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">prod.fst</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">prod.snd</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">funext</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prod.mk'</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">prod.dup</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.prod_map_fst_snd_eq</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">filter.map</span> <span class=\"n\">prod.fst</span> <span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">map</span> <span class=\"n\">prod.snd</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">filter.prod</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">prod.fst</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">prod.fst</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">le_comap_map</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hle₂</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">prod.snd</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">prod.snd</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">le_comap_map</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">le_inf</span> <span class=\"n\">hle₁</span> <span class=\"n\">hle₂</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Would anyone be against adding these to mathlib?</p>",
        "id": 270832364,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644074846
    },
    {
        "content": "<p>So <code>mk' f g x = (f x, g x)</code>?</p>",
        "id": 270850780,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644097410
    },
    {
        "content": "<p>That's similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.prod\">docs#linear_map.prod</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.prod\">docs#add_monoid_hom.prod</a>, so should probably be called <code>function.prod</code> or <code>pi.prod</code></p>",
        "id": 270850845,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644097468
    },
    {
        "content": "<p>Do we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.lift\">docs#prod.lift</a> ?</p>",
        "id": 270850963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644097672
    },
    {
        "content": "<p>Your <code>prod.mk</code> is just <code>prod.lift f g x</code>, for a correctly defined <code>prod.lift</code>...</p>",
        "id": 270851012,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644097725
    },
    {
        "content": "<p>Doesn't lift usually go in the other direction? (in which case <code>lift</code> is just <code>prod.rec</code>)</p>",
        "id": 270851607,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644098509
    },
    {
        "content": "<p>No, look at e.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.prod.lift\">docs#category_theory.limits.prod.lift</a></p>",
        "id": 270851773,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644098713
    },
    {
        "content": "<p>Do we even have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.rec\">docs#prod.rec</a> ?</p>",
        "id": 270851796,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644098759
    },
    {
        "content": "<p>I think we want something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pi.prod</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">γ</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"n\">a</span> <span class=\"bp\">×</span> <span class=\"n\">γ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 270851797,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644098761
    },
    {
        "content": "<p><code>prod.rec</code> is built-in like most <code>.rec</code>s</p>",
        "id": 270851859,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644098794
    },
    {
        "content": "<p>I think <code>lift</code> goes the other way outside <code>category_theory</code>, eg <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quotient.lift\">docs#quotient.lift</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_algebra.lift\">docs#tensor_algebra.lift</a>.</p>",
        "id": 270851945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644098882
    },
    {
        "content": "<p>It is well know that <code>quotient.lift</code> should be called <code>quotient.desc</code>.</p>",
        "id": 270851973,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644098914
    },
    {
        "content": "<p><code>lift</code> is a general word used for limits, and products are limits.</p>",
        "id": 270851997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644098965
    },
    {
        "content": "<p>My understanding was that <code>foo.lift</code> was for building maps <em>out</em> of <code>foo</code> from \"simpler\" maps</p>",
        "id": 270852149,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644099142
    },
    {
        "content": "<p>But your proposed <code>prod.lift</code> builds a map <em>into</em> <code>prod</code></p>",
        "id": 270852160,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644099166
    },
    {
        "content": "<p>Maybe that naming convention is bad, but that was the pattern I recall us having right now</p>",
        "id": 270852174,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644099201
    },
    {
        "content": "<p>I think of <code>lift</code> outside of the CT library more as \"get the thing given by the universal property\"</p>",
        "id": 270852181,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644099210
    },
    {
        "content": "<p>Whatever that universal property might be.</p>",
        "id": 270852195,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644099223
    },
    {
        "content": "<p>What's the universal property of <code>prod</code>? Isn't it <code>prod.rec</code>?</p>",
        "id": 270852241,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644099251
    },
    {
        "content": "<p>Or are there multiple universal properties?</p>",
        "id": 270852265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644099296
    },
    {
        "content": "<p>This is some weird type theory thing about \"positive\" and \"negative\" types.</p>",
        "id": 270852346,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644099383
    },
    {
        "content": "<p>In category theory, the universal property of the product is that mapping into the product is the same as mapping into both factors.</p>",
        "id": 270852350,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644099400
    },
    {
        "content": "<p>The way I see it, since <code>prod</code> is a negative type, there should be a <code>prod.corec</code> that would be what I called <code>prod.mk'</code>.</p>",
        "id": 270880434,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644139856
    },
    {
        "content": "<p>I PR'd <code>prod.mk'</code> as <code>pi.prod</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/11877\">#11877</a>, and found some downstream <code>foo.prod</code>s that could be reimplemented using <code>pi.prod</code>.</p>",
        "id": 270888446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644151927
    },
    {
        "content": "<p>I will make a PR for <code>filter.prod_map_fst_snd_eq</code> then.</p>",
        "id": 270905357,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644173964
    },
    {
        "content": "<p>It should probably not have <code>eq</code> in the name since the statement is about <code>le</code>!</p>",
        "id": 270914433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644184930
    },
    {
        "content": "<p>Yes, you're right.</p>",
        "id": 270948376,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644224100
    },
    {
        "content": "<p>I think mathlib is also missing <code>α × (β × γ) ↔ (α × β) × γ</code>. Or maybe this exists for <code>pi</code>, and I just can't find it.</p>",
        "id": 271353205,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644443838
    },
    {
        "content": "<p>Does that even typecheck? Can you give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> ?</p>",
        "id": 271353330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644443896
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.prod_assoc\">docs#equiv.prod_assoc</a></p>",
        "id": 271353391,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644443936
    },
    {
        "content": "<p>Ah, nice. Thanks.</p>",
        "id": 271353621,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644444020
    },
    {
        "content": "<p>I was looking for this lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">filter.prod_map_rlassoc</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">equiv.prod_assoc</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I could not find it. Would someone confirm that mathlib does have this? Also, proving this is turning into a challenge.</p>",
        "id": 271697512,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644684797
    },
    {
        "content": "<p>The <code>set</code> version of this lemma is also missing and I need it to prove the filter version above.</p>",
        "id": 271698336,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644685750
    },
    {
        "content": "<p>I think we have neither.</p>",
        "id": 271698827,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644686433
    },
    {
        "content": "<p>Is this some kind of general result about monads?</p>",
        "id": 271698840,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644686473
    },
    {
        "content": "<p>I don't think so. In my mind, these are just \"lifted\" versions of prod_assoc.</p>",
        "id": 271701240,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644689317
    },
    {
        "content": "<p>It's probably possible to get the set and filter versions of prod_assoc via applicative.seq?</p>",
        "id": 271701691,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644689592
    },
    {
        "content": "<p>It's also true for <code>finset</code>. So I guess the criterion is a functor with a notion of product.</p>",
        "id": 271701813,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644689746
    },
    {
        "content": "<p>Monoidal functors perhaps? <a href=\"https://en.wikipedia.org/wiki/Monoidal_functor\">https://en.wikipedia.org/wiki/Monoidal_functor</a></p>",
        "id": 271702391,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644690268
    },
    {
        "content": "<p>Applicatives are basically what those are.</p>",
        "id": 271702446,
        "sender_full_name": "Bernd Losert",
        "timestamp": 1644690344
    },
    {
        "content": "<p>Sounds like it.</p>",
        "id": 271702516,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644690412
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416322\">@Bernd Losert</span> I did half of it, the other half is just mutatis mutandis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.prod_map_rlassoc</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">equiv.prod_assoc</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_map</span><span class=\"o\">,</span> <span class=\"n\">mem_prod_iff</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"c1\">-- can't see how to do it any other way</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">tα</span><span class=\"o\">,</span> <span class=\"n\">hα</span><span class=\"o\">,</span> <span class=\"n\">tβγ</span><span class=\"o\">,</span> <span class=\"n\">hβγ</span><span class=\"o\">,</span> <span class=\"n\">hαβγ</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_prod_iff</span> <span class=\"n\">at</span> <span class=\"n\">hβγ</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hβγ</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">tβ</span><span class=\"o\">,</span> <span class=\"n\">hβ</span><span class=\"o\">,</span> <span class=\"n\">tγ</span><span class=\"o\">,</span> <span class=\"n\">hγ</span><span class=\"o\">,</span> <span class=\"n\">hβγ</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">tα.prod</span> <span class=\"n\">tβ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">tγ</span><span class=\"o\">,</span> <span class=\"n\">hγ</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mem_prod_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">tα</span><span class=\"o\">,</span> <span class=\"n\">hα</span><span class=\"o\">,</span> <span class=\"n\">tβ</span><span class=\"o\">,</span> <span class=\"n\">hβ</span><span class=\"o\">,</span> <span class=\"n\">rfl.subset</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"n\">c</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">⟩,</span> <span class=\"n\">hc</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">exact</span> <span class=\"bp\">@</span><span class=\"n\">hαβγ</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hβγ</span> <span class=\"o\">(⟨</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">tβ.prod</span> <span class=\"n\">tγ</span><span class=\"o\">)⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- same again</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 271706021,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644694624
    },
    {
        "content": "<p>I would love to see a proof using all that monadery stuff.</p>",
        "id": 271706118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644694756
    },
    {
        "content": "<p>I fear that the answer to the monadic stuff is that \"It's what defines an associative functor\" or however it's called and that what you're proving is precisely that <code>set</code> and <code>filter</code> are associative functors or however they are called.</p>",
        "id": 271706222,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644694920
    },
    {
        "content": "<p>If you're talking about applicative functors and your claim is true then no doubt this is just the sort of thing which people like Johannes Hoelzl and <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> were doing years and years ago.</p>",
        "id": 271706459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644695277
    },
    {
        "content": "<p>If you're using <code>finset</code> with applicative functions, indeed you need associativity and commutativity in order to map an effect to every element of the set. If you're looking at <code>set</code> and not <code>finset</code>, you need the operator of your applicative functor to be a big operator, applicable to arbitrary sets. I've never seen something like that though</p>",
        "id": 271707366,
        "sender_full_name": "Simon Hudon",
        "timestamp": 1644696444
    },
    {
        "content": "<p>Ok, you succeeded again to trick me into playing with filters. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.bases</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span> <span class=\"n\">equiv</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.has_basis.equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.has_basis</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">≃</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.has_basis</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h.mem_iff</span><span class=\"o\">,</span> <span class=\"n\">e.exists_congr_left</span><span class=\"o\">]⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.prod_map_rlassoc</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">prod_assoc</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"bp\">×ᶠ</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">×ᶠ</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">map_eq_comap_of_inverse</span> <span class=\"o\">(</span><span class=\"n\">prod_assoc</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">self_comp_symm</span> <span class=\"o\">(</span><span class=\"n\">prod_assoc</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm_comp_self</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"o\">((((</span><span class=\"n\">basis_sets</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"bp\">$</span> <span class=\"n\">basis_sets</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"bp\">$</span> <span class=\"n\">basis_sets</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">eq_of_same_basis</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"o\">((</span><span class=\"n\">basis_sets</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(((</span><span class=\"n\">basis_sets</span> <span class=\"n\">g</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">basis_sets</span> <span class=\"n\">h</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">prod_assoc</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">;</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">and_assoc</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Note that I modified slightly the statement since I didn't see the point of going against <code>equiv.prod_assoc</code>.</p>",
        "id": 271708927,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644698796
    },
    {
        "content": "<p>Does that first lemma generalize to surjective e?</p>",
        "id": 271709002,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644698913
    },
    {
        "content": "<p>Sure</p>",
        "id": 271709188,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699220
    },
    {
        "content": "<p>I wrote this lemma very quickly since it's a complete tautology that is exactly what is needed here.</p>",
        "id": 271709242,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699248
    },
    {
        "content": "<p>Do you mean the surjective case is already there?</p>",
        "id": 271709249,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699274
    },
    {
        "content": "<p>Let's do it for Eric:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">filter.has_basis.comp_of_surjective</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.has_basis</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f.has_basis</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h.mem_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hg</span> <span class=\"n\">i</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">hi'</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">g</span> <span class=\"n\">i'</span><span class=\"o\">,</span> <span class=\"n\">hi'</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">filter.has_basis.equiv</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">ι'</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f.has_basis</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">≃</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f.has_basis</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">h.comp_of_surjective</span> <span class=\"n\">e.surjective</span>\n</code></pre></div>",
        "id": 271709316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699408
    },
    {
        "content": "<p>Now the required lemma has a more complicated proof, but it looks shorter on screen <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 271709326,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699433
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12002\">#12002</a></p>",
        "id": 271709665,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644699853
    },
    {
        "content": "<p>Well you didn't have to write it so long!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">has_basis.comp_of_surjective</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.has_basis</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ι'</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">function.surjective</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l.has_basis</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">h.mem_iff.trans</span> <span class=\"n\">hg.exists</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 271714117,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644706462
    },
    {
        "content": "<p>(apologies, it was unkind of me to trick you into proving the surjective case without telling you that I had <a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.surjective.exists\">docs#function.surjective.exists</a> in mind as the proof)</p>",
        "id": 271714482,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644707033
    },
    {
        "content": "<p>So in fact it's now a one-liner. I really like these kinds of questions, it's the community at its best.</p>",
        "id": 271715802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644709020
    }
]
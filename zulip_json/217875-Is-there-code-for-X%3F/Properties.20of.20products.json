[
    {
        "content": "<p>Is a version of the following in mathlib?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.big_operators</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_prop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">l.prod</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">l</span> <span class=\"k\">with</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prod_nil</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">prod_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mem_cons_self</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">h₂</span> <span class=\"n\">a</span> <span class=\"bp\">$</span> <span class=\"n\">mem_cons_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">)),</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.prod_hom_rel\">docs#list.prod_hom_rel</a>, which looks somewhat related, but is different...</p>",
        "id": 296224614,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661895102
    },
    {
        "content": "<p>I think it's easy enough to construct a submonoid from the hypotheses and apply <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.list_prod_mem\">docs#submonoid.list_prod_mem</a> .</p>",
        "id": 296226559,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661896085
    },
    {
        "content": "<p>Thanks. I'll look at this tomorrow.</p>",
        "id": 296226881,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661896256
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.list.basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">list</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prod_prop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">l.prod</span> <span class=\"o\">:=</span>\n<span class=\"n\">foldl_rec_on</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">‹</span><span class=\"n\">_</span><span class=\"o\">›</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">list</span>\n</code></pre></div>",
        "id": 296246976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661911429
    },
    {
        "content": "<p>Nice proof! I weakened the assumptions to [has_one] [has_mul] and filled in the ‹_›.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prod_prop</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">l.prod</span> <span class=\"o\">:=</span>\n<span class=\"n\">foldl_rec_on</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">h₃</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"n\">_</span> <span class=\"n\">hy</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Although it's just a trivial application of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.foldl_rec_on\">docs#list.foldl_rec_on</a>, I think it would be nice to have a specialization of it to <a href=\"http://list.prod\">list.prod</a> in mathlib. A direct specialization would be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prod_prop'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_one</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">l.prod</span> <span class=\"o\">:=</span> <span class=\"n\">foldl_rec_on</span> <span class=\"n\">l</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span>\n</code></pre></div>\n<p>Which one should we prefer?</p>",
        "id": 296258667,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661924118
    },
    {
        "content": "<p>Although <code>prod_prop</code> would be nice to have, for the purpose of the Jacobi symbol PR (which I think is the application <span class=\"user-mention\" data-user-id=\"479359\">@Michael Stoll</span> has in mind) the following is probably the easiest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">jacobi_sym_trichotomy</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"n\">submonoid.list_prod_mem</span>\n  <span class=\"o\">⟨({</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℤ</span><span class=\"o\">),</span>\n   <span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">;</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n   <span class=\"n\">or.inr</span> <span class=\"o\">(</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">)⟩</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">ha'</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">list.mem_pmap.mp</span> <span class=\"n\">ha'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">prime_of_mem_factors</span> <span class=\"n\">hp</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">quadratic_char_is_quadratic</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and I also think it's a good idea to extract the submonoid to a separate definition.</p>",
        "id": 296260422,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661925448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  Nice. I'm defining <code>int.sign_monoid</code> as the submonoid in question and use that in your proof.</p>",
        "id": 296359024,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661959965
    },
    {
        "content": "<p>Actually, do people think we should generalize <code>sign_monoid</code> to <code>non_assoc_ring</code>? (I think <code>dec_trivial</code> won't work then.) And should the name be <code>sign_submonoid</code>?</p>",
        "id": 296374309,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661961488
    },
    {
        "content": "<p><code>sign_submonoid</code> is better, I think. In which file should this go eventually?</p>",
        "id": 296381531,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661962113
    },
    {
        "content": "<p>Is this meant to be units + zero, or <code>{-1, 0, 1}</code>?</p>",
        "id": 296381873,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661962227
    },
    {
        "content": "<p>The latter.</p>",
        "id": 296382045,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661962276
    },
    {
        "content": "<p>I assume you cannot use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sign_type\">docs#sign_type</a> because you want a submonoid?</p>",
        "id": 296382416,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661962381
    },
    {
        "content": "<p>Yes, and you may want to compute with the values of the Jacobi symbol as integers (in particular, add them up or use them as coefficients of a linear combination).</p>",
        "id": 296387253,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661962476
    },
    {
        "content": "<p>I think there's a possibility of defining <code>quadratic_char</code>, <code>legendre_sym</code>, and <code>jacobi_sym</code> all taking values in <code>sign_type</code>, and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sign_type.cast_hom\">docs#sign_type.cast_hom</a> when we want to work in Z; I think we've considered something like that before, but I forgot about the reasoning that led to the current design.</p>",
        "id": 296402526,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661963558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> i used the French quote syntax as a shorthand for the assumption tactic</p>",
        "id": 296406369,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1661964739
    },
    {
        "content": "<p>Yes I know but why not pure term-mode when it can be easily achieved :)</p>",
        "id": 296406744,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661964854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Properties.20of.20products/near/296402526\">said</a>:</p>\n<blockquote>\n<p>I think there's a possibility of defining <code>quadratic_char</code>, <code>legendre_sym</code>, and <code>jacobi_sym</code> all taking values in <code>sign_type</code>, and use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sign_type.cast_hom\">docs#sign_type.cast_hom</a> when we want to work in Z; I think we've considered something like that before, but I forgot about the reasoning that led to the current design.</p>\n</blockquote>\n<p>You want to be able to work with more general multiplicative characters (e.g., for cubic reciprocity <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>), not just ones that take values in {0, 1, -1}. I think it makes sense to have quadratic characters as a special case of multiplicative characters (and avoid the cast from <code>sign_type</code> to the integers whenever you want to do some nontrivial computation with the values).</p>",
        "id": 296420412,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661969044
    },
    {
        "content": "<p>I think it would be nice to make definitions more polymorphic. For example, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_char.primitive_add_char\">docs#add_char.primitive_add_char</a> is defined with domain <code>cyclotomic_field n R'</code>, but it could be defined for any ring, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_char.primitive_zmod_char\">docs#add_char.primitive_zmod_char</a> could be defined for any ring with a primitive n-th root of unity. <del>If you make them polymorphic like this, I think you won't need to map the values from the cyclotomic field to a larger field in some of your Gauss sum proofs.</del> (Edit: seems I got it backwards, you're mapping something smaller into the cyclotomic field, not the other way.)<br>\nFor quadratic characters, I think defining a <code>sign_type</code> version and using cast to get to any ring will make it the most polymorphic, but some work may be needed to make it pleasant to work with casts.<br>\nMoreover, the cubic stuff doesn't take values in Z, so it seems to strengthen the point of being able to work with different domains.</p>",
        "id": 296430893,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661972641
    },
    {
        "content": "<p>You can already do the following, if you like.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">number_theory.legendre_symbol.mul_character</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sign</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">mul_char</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"mi\">3</span><span class=\"o\">)</span> <span class=\"n\">sign_type</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">is_square</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)),</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"n\">map_nonunit'</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 296433166,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661973524
    },
    {
        "content": "<p>But as soon as you want to do Gauss sums, say, you'll have to cast to a ring anyway (and ℤ is the universal ring, so it makes sense to have ℤ as the domain).</p>",
        "id": 296433303,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661973579
    },
    {
        "content": "<p>The only possible advantage I see right now is that the proof of the trichotomy gets simpler. I'm not sure this is worth it.</p>",
        "id": 296433791,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661973787
    },
    {
        "content": "<p>How would you prove <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_fun_eq_pow_of_char_ne_two\">docs#quadratic_char_fun_eq_pow_of_char_ne_two</a> in a setting where the character takes values in <code>sign_type</code>?</p>",
        "id": 296434260,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661973959
    },
    {
        "content": "<p>By using injectivity of <code>coe : sign_type → F</code>?</p>",
        "id": 296434448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661974017
    },
    {
        "content": "<p>Yes, but it will be more complicated. The point I'm trying to make is that there is a trade-off, and I am not convinced that the pros outweigh the cons.</p>",
        "id": 296434778,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661974129
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_eq_pow_of_char_ne_two'\">docs#quadratic_char_eq_pow_of_char_ne_two'</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_card_sqrts\">docs#quadratic_char_card_sqrts</a></p>",
        "id": 296434820,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661974147
    },
    {
        "content": "<p>You are about to define something isomorphic to <code>sign_type</code> for each ring. There are reasons to be worried!</p>",
        "id": 296434913,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661974186
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/quadratic_char_sum_zero\">docs#quadratic_char_sum_zero</a></p>",
        "id": 296435150,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661974251
    },
    {
        "content": "<p><code>sign_submonoid</code> is only defined for integers now, it's me who suggested non_assoc_ring.</p>",
        "id": 296435181,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1661974261
    },
    {
        "content": "<p>Michael, all lemmas you're linking to genuinely all seem fine with <code>sign_type</code> to me.</p>",
        "id": 296435323,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661974312
    },
    {
        "content": "<p>Is there a way to define <code>sign_submonoid</code> as the image of the monoid(_with_zero) homomorphism from <code>sign_type</code>into any (non_assoc_)ring? (And use it as easily!)</p>",
        "id": 296435351,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661974321
    },
    {
        "content": "<p>The last one uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_char.is_nontrivial.sum_eq_zero\">docs#mul_char.is_nontrivial.sum_eq_zero</a>, for which your target needs to be a domain.</p>",
        "id": 296435898,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661974472
    },
    {
        "content": "<p>In my example above, <code>#check χ 1 + 1</code> complains <code>failed to synthesize type class instance for ⊢ has_add sign_type</code>, so it looks like you have to cast to ℤ explicitly: <code>(χ 1 : ℤ) + 1</code> (<code>↑(χ 1) + 1</code> doesn't cut it; it wants to cast to ℕ).</p>",
        "id": 296441680,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661976686
    },
    {
        "content": "<p>Is that a problem?</p>",
        "id": 296441868,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661976763
    },
    {
        "content": "<p>It looks clumsy in the statements. I prefer the statements to look as similar as possible to the way you'd write the mathematics they represent.</p>",
        "id": 296442079,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661976862
    },
    {
        "content": "<p>Coercions are on the least clumsy end of the spectrum of things formalisation can introducate in a statement.</p>",
        "id": 296442579,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661977068
    },
    {
        "content": "<p>But why introduce them if they are not necessary?<br>\nIt is not clear to me what you are trying to optimize here. I don't think the mere fact that <code>sign_type</code> exists implies that it has to be used at all costs. As I said earlier, I think using it here would have more disadvantages than advantages.</p>",
        "id": 296442925,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661977205
    },
    {
        "content": "<p>Here it gives you a unique interface for all rings, rather than several submonoids you will need to connect with explicit maps (which might mess you up because submonoids have a coercion to <code>Type</code>).</p>",
        "id": 296443561,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661977483
    },
    {
        "content": "<p>Further, all the basic logic would shared between both types and that makes yet another pair of API that we have to keep in sync.</p>",
        "id": 296443672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1661977524
    },
    {
        "content": "<p>I just need the submonoid of the integers (the universal ring). As <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> said, generalizing this was his idea.</p>",
        "id": 296444018,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1661977629
    },
    {
        "content": "<p>The submonoid is <code>(⊤ : submonoid sign_type).map sign_type.cast_hom</code>, right?</p>",
        "id": 296519842,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662010739
    },
    {
        "content": "<p>Or even <code>monoid_hom.mrange sign_type.cast_hom</code></p>",
        "id": 296521437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662012003
    },
    {
        "content": "<p>In the concrete case, <code>monoid_hom.mrange $ @sign_type.cast_hom ℤ _ _</code> or so. But then the proof which uses it does not work anymore; I'll have to look into that.</p>",
        "id": 296529832,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662016799
    },
    {
        "content": "<p>It looks like it's hard to get a reasonably simple proof of the result I want (<code>jacobi_sym_trichotomy</code>) with the <code>monoid_hom.mrange sign_type.cast_hom</code> approach.<br>\nSince I need this submonoid <em>olny</em> for this one proof, I will just use it locally (as in <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>'s original suggestion).</p>",
        "id": 296546284,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662023620
    },
    {
        "content": "<p>What does \"doesn't work\" mean here?</p>",
        "id": 296619235,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662046528
    },
    {
        "content": "<p>The following works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">sign_type</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sign_type</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">pos</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">neg</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"bp\">|</span><span class=\"n\">s</span><span class=\"bp\">|</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">exacts</span> <span class=\"o\">[</span><span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"bp\">$</span> <span class=\"n\">or.inr</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"bp\">$</span> <span class=\"n\">or.inl</span> <span class=\"n\">rfl</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">))</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">set.mem_range_self</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">end</span> <span class=\"n\">sign_type</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">jacobi_sym_trichotomy</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">sign_type.cast_hom</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_hom.mrange.copy</span> <span class=\"n\">_</span>\n  <span class=\"o\">(</span><span class=\"n\">sign_type.range_eq</span> <span class=\"n\">sign_type.cast_hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">list_prod_mem</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">ha'</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">list.mem_pmap.mp</span> <span class=\"n\">ha'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">prime_of_mem_factors</span> <span class=\"n\">hp</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">quadratic_char_is_quadratic</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 296643351,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662047523
    },
    {
        "content": "<p>Yes, but I think your original proof is simpler (no need to introduce <code>sign_type.range_eq</code>).</p>",
        "id": 296647310,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662048043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/Properties.20of.20products/near/296619235\">said</a>:</p>\n<blockquote>\n<p>What does \"doesn't work\" mean here?</p>\n</blockquote>\n<p>\"Doesn't work\" means that one needs the additional step provided by <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>'s code above.</p>",
        "id": 296647426,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662048084
    },
    {
        "content": "<p>The original seems simpler but is slower (about 2s, while the one that uses sign_type takes ~0.25s), and <code>sign_type.range_eq</code> could be used elsewhere (it also takes about 0.25s). By the way should lemmas like <code>range_eq</code> be auto-generated? Though the auto-generated lemma would have {zero, neg, pos} instead of what we want ({zero, pos, neg}).</p>",
        "id": 296649158,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662048608
    },
    {
        "content": "<p>Yeah I feel like we should generate this change statement as a lemma automagically as part of derive fintype, then a proof could be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sign</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">sign_type</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">range_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sign_type</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">neg</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">pos</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">fintype.coe_image_univ</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">finset.univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">sign_type</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">{</span><span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">neg</span><span class=\"o\">,</span> <span class=\"n\">pos</span><span class=\"o\">},</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 296650110,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1662048918
    },
    {
        "content": "<p>This should work for any fintype:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">range_eq</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sign_type</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set.range</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">zero</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">neg</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">pos</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">finset.coe_singleton</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">finset.image_singleton</span><span class=\"o\">,</span>\n    <span class=\"bp\">←</span> <span class=\"n\">fintype.coe_image_univ</span><span class=\"o\">,</span> <span class=\"n\">finset.coe_image</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.image_insert_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 296663113,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662053063
    },
    {
        "content": "<p>So what should I do now?<br>\nAdd <code>sign_type.range_eq</code> (with <code>[fintype α]</code> added?) to <code>data.sign</code> and change the order in the definition of <code>mul_char.is_quadratic</code> (and everything that uses it) to <code>0, -1, 1</code>, so that it is compatible with the order given in <code>range_eq</code>?</p>",
        "id": 296664272,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662053419
    },
    {
        "content": "<p>(I would like to get on with getting the Jacobi symbol into mathlib without getting lost in too many rabbit holes...)</p>",
        "id": 296665428,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662053807
    },
    {
        "content": "<p>To me the order {0,1,-1} is more natural than {0,-1,1}, so if any definition is to be changed it should be <code>sign_type</code>. However you don't have to change any definition; you could just do a rewrite:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">jacobi_sym_trichotomy</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∨</span> <span class=\"o\">[</span><span class=\"n\">a</span> <span class=\"bp\">|</span> <span class=\"n\">b</span><span class=\"o\">]</span><span class=\"bp\">ⱼ</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">sign_type.cast_hom</span> <span class=\"n\">ℤ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_hom.mrange.copy</span> <span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">$</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">set.pair_comm</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">sign_type.range_eq</span> <span class=\"n\">sign_type.cast_hom</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">list_prod_mem</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">_</span> <span class=\"n\">ha'</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">list.mem_pmap.mp</span> <span class=\"n\">ha'</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">hp</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"n\">p.prime</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">prime_of_mem_factors</span> <span class=\"n\">hp</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">quadratic_char_is_quadratic</span> <span class=\"o\">(</span><span class=\"n\">zmod</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 296686248,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662060643
    },
    {
        "content": "<p>OK; then I'll do that (and add <code>eq_range</code>).</p>",
        "id": 296690847,
        "sender_full_name": "Michael Stoll",
        "timestamp": 1662062430
    },
    {
        "content": "<p>Just to check; is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/jacobi_sym\">docs#jacobi_sym</a> in master? I don't see the definition upthread</p>",
        "id": 296868242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662140956
    },
    {
        "content": "<p>It's not in master; it was in PR <a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a> but now removed from it, to be added in a later PR. (<a href=\"https://github.com/leanprover-community/mathlib/pull/16290\">#16290</a> now is preliminary lemmas only.) Discussions are in <a href=\"#narrow/stream/116395-maths/topic/Jacobi.20symbol\">this thread</a>.</p>",
        "id": 296868635,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1662141108
    }
]
[
    {
        "content": "<p>I'm not sure what the appropriate name for this would be, but in a normed space do we have a definition of the filter of co-bounded sets (those whose complement is bounded)? Or is this just <code>filter.comap norm at_top</code>?</p>",
        "id": 271664402,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644633898
    },
    {
        "content": "<p>All this co stuff makes me wonder whether we should just formalise ideals (in the sense of \"the complements of all these sets give you a filter\") and then have the finite ideal, the bounded ideal, the null measure ideal...</p>",
        "id": 271679906,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644658187
    },
    {
        "content": "<p>We have closed sets in topology after all</p>",
        "id": 271679953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644658212
    },
    {
        "content": "<p>AFAIK, we don't. You should define it in a <code>pseudo_metric_space</code> as <code>{ sets := {s | bounded sᶜ}, ... }</code></p>",
        "id": 271688002,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644670933
    },
    {
        "content": "<p>Currently we have</p>\n<ul>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.cofinite\">docs#filter.cofinite</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.cocompact\">docs#filter.cocompact</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.coclosed_compact\">docs#filter.coclosed_compact</a></li>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.coprod\">docs#filter.coprod</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.Coprod\">docs#filter.Coprod</a></li>\n</ul>",
        "id": 271688069,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644671057
    },
    {
        "content": "<p>Is this concrete definition better than Jireh's mathematically extremely satisfying comap definition?</p>",
        "id": 271688073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644671073
    },
    {
        "content": "<p>Ie is it somehow better to make the concrete definition and then prove it's the comap?</p>",
        "id": 271688101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644671152
    },
    {
        "content": "<p>The main advantage of my definition is that it works in any metric space.</p>",
        "id": 271688360,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644671551
    },
    {
        "content": "<p>You can use <code>comap (dist x) at_top</code> but it needs a base point.</p>",
        "id": 271688362,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644671567
    },
    {
        "content": "<p>I see. So make the def in full generality and then prove that in some special cases it's the comap. Sounds like a fine PR <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> !</p>",
        "id": 271688645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644672065
    },
    {
        "content": "<p>Clearly, we need <code>@[simp]</code> lemmas that simplify <code>comap norm at_top</code>, <code>comap (dist x) at_top</code>, and <code>comap (λ x, dist x y) at_top</code> to <code>cobounded</code>. BTW, we have a few lemmas about these <code>comap</code> filters in <code>metric_space.basic</code> that should be reformulated in terms of <code>cobounded</code>.</p>",
        "id": 271688653,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644672088
    },
    {
        "content": "<p>AFAIR, we prove <code>cobounded ≤ cocompact</code> and <code>cobounded = cocompact</code> in a proper space.</p>",
        "id": 271688663,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644672105
    },
    {
        "content": "<p>where should I put it? <code>topology/metric_space/basic</code>? or a new file?</p>",
        "id": 271692408,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644677792
    },
    {
        "content": "<p>yes, we have those results: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/comap_dist_right_at_top_le_cocompact\">docs#comap_dist_right_at_top_le_cocompact</a> and it's <code>left</code> and <code>eq</code> versions.</p>",
        "id": 271692563,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644678009
    },
    {
        "content": "<p>I think that <code>metric_space.basic</code> is already long enough. Could you please put it into a new file and move the existing lemmas to this file?</p>",
        "id": 271710595,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644701366
    },
    {
        "content": "<p>Of course, instead of the old lemmas we should have <code>cobounded_le_cocompact</code> and <code>comap_dist_left/right_eq_cobounded</code>/<code>comap_norm_eq_cobounded</code> (or <code>comap_dist_left/right_at_top</code>/<code>comap_norm_at_top</code>)</p>",
        "id": 271710650,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644701434
    },
    {
        "content": "<p>There is a notion of a bornology, which is a way to formalize the notion of \"boundedness\". Should we think about defining bornological spaces? <br>\n<a href=\"https://en.wikipedia.org/wiki/Bornological_space\">https://en.wikipedia.org/wiki/Bornological_space</a><br>\nPresumably this is the right context for such a co-bounded filter?</p>",
        "id": 271760754,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644779997
    },
    {
        "content": "<p>It's not obscure at all, it's in Bourbaki!</p>",
        "id": 271760814,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644780074
    },
    {
        "content": "<p>I'm speaking as an arithmetic geometer, sorry ;) Fixed</p>",
        "id": 271760822,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644780089
    },
    {
        "content": "<p>I certainly never used that in my life, but it's still there <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 271760880,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644780148
    },
    {
        "content": "<p>Wow, I love this Wikipedia page. \"bornivorous\"</p>",
        "id": 271761052,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644780401
    },
    {
        "content": "<p>It's genuinely quite related to what Moritz and I have been doing over at <a href=\"https://tqft.net/mathlib/analysis/seminorm\">file#analysis/seminorm</a></p>",
        "id": 271761147,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644780514
    },
    {
        "content": "<p>Sounds precisely like the kind of generalization mathlib enjoys. Who is volunteering?</p>",
        "id": 271761321,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644780777
    },
    {
        "content": "<p>Yeah, they had fun with the names there. I guess I'm volunteering, but I'm not promising it soon. It doesn't seem like there is any rush anyway.</p>",
        "id": 271765886,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644786896
    },
    {
        "content": "<p>Unless it actually is important for your seminorm stuff, in which case I can make it  a priority.</p>",
        "id": 271765898,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644786923
    },
    {
        "content": "<p>For the structure projections, I was considering <code>is_borne</code> (or <code>is_borné</code>) instead of <code>is_bounded</code> to potentially avoid confusion with other things in mathlib. Thoughts?</p>",
        "id": 271769087,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644791382
    },
    {
        "content": "<p>Oh btw I have quite an idea of what should be there. <code>bornological_space</code> should be based on <code>topological_space</code>, <code>bornological_module</code> should follow <code>normed_space</code>.</p>",
        "id": 271769842,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792371
    },
    {
        "content": "<p>The projection should supersede <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a> and you'll need <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric_space\">docs#metric_space</a> to extend <code>bornological_space</code> to avoid the diamond with <code>prod</code>, but both can (and indeed should) wait for another PR.</p>",
        "id": 271769880,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792455
    },
    {
        "content": "<p>In general, the API should closely follow <code>topological_space</code>.</p>",
        "id": 271769888,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792481
    },
    {
        "content": "<p>I'm taking care of <code>bornivore</code>. It is really orthogonal to the rest.</p>",
        "id": 271769937,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792534
    },
    {
        "content": "<p>One might hope that the existing instances of <code>is_bounded</code> are all cases where the ambient object can be given a natural bornology, so perhaps <code>is_bounded</code> should be the way to go?</p>",
        "id": 271769949,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644792569
    },
    {
        "content": "<p>What are you referring to, Adam? <code>is_bounded</code> isn't a thing. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a>?</p>",
        "id": 271770079,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792724
    },
    {
        "content": "<p>I'm responding to <span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> 's last comment</p>",
        "id": 271770122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644792810
    },
    {
        "content": "<p>But there's no instance of <code>is_bounded</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 271770197,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792881
    },
    {
        "content": "<p>Yes, I'm literally copying from <code>topological_space</code> and making the necessary modifications.</p>",
        "id": 271770202,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644792895
    },
    {
        "content": "<p>Perhaps there is no <code>is_bounded</code>, but for some reason I thought there was.</p>",
        "id": 271770213,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644792918
    },
    {
        "content": "<p>AFAIA, there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.bounded\">docs#set.bounded</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_bounded_linear_map\">docs#is_bounded_linear_map</a></p>",
        "id": 271770276,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644792979
    },
    {
        "content": "<p>(The definition of a bornology looks like an order ideal that contains the ideal of finite sets, but the Wikipedia page doesn't seem to mention anything about ideals -- am I missing something?)</p>",
        "id": 271770300,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644793033
    },
    {
        "content": "<p>Regardless of whether it exists, we have various conditions stipulating some sort of boundedness in different contexts. Metric spaces is one such example. The point I was making is that with the notion of bornologocal spaces, I am hoping that those various notions of boundedness actually define a bornology, so that we can indeed have a unified <code>is_bounded</code> prop which will encompass all of those ad hoc notions that we currently have.</p>",
        "id": 271770311,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644793066
    },
    {
        "content": "<p>Yes, the covering condition, Kyle.</p>",
        "id": 271770316,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644793078
    },
    {
        "content": "<p>And my answer is that this won't happen, Adam. The one thing I see it will generalize is <code>metric.bounded</code>.</p>",
        "id": 271770380,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644793121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/co-bounded.20filter/near/271770316\">said</a>:</p>\n<blockquote>\n<p>Yes, the covering condition, Kyle.</p>\n</blockquote>\n<p>If an ideal contains the ideal of finite sets, then the covering condition is satisfied (and conversely).</p>",
        "id": 271770558,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644793311
    },
    {
        "content": "<p>I haven't looked through the library, but if this really the case, then that's even more of a reason to just use <code>is_bounded</code> as opposed to <code>is_borne</code>...</p>",
        "id": 271770914,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644793646
    },
    {
        "content": "<p>I agree it's a nice <code>topological_space</code>-like name, <code>is_borne</code>is nice too, and more endemic.</p>",
        "id": 271771022,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644793721
    },
    {
        "content": "<p>Note bounded linear maps are linear maps which are also morphisms of bornological spaces (I think?)</p>",
        "id": 271771183,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644793895
    },
    {
        "content": "<p>Oh, I think you're right.</p>",
        "id": 271771247,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644793933
    },
    {
        "content": "<p>So, unlike topological spaces, where <code>∅</code> is automatically an element, the axioms for bornological spaces don't guarantee that the bornology is nonempty unless the type is itself nontrivial. Should I just add the condition <code>is_bounded ∅</code> as an axiom (my preference) so we never have to pass around needless <code>nontrivial</code> assumptions?</p>",
        "id": 271771620,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644794467
    },
    {
        "content": "<p>I think that's a reasonable assumption, but I don't have enough experience with these objects to say for sure.</p>",
        "id": 271771957,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795029
    },
    {
        "content": "<p>I suppose we want the poset of bornologies to have <code>\\top</code>, which should be the the set of finite subsets, right?</p>",
        "id": 271772031,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795153
    },
    {
        "content": "<p>And for this to work for the empty type, we need the empty set to be bounded.</p>",
        "id": 271772038,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795179
    },
    {
        "content": "<p>I mean, it is literally only an issue when the type is empty. Yes, I think this reasoning regarding <code>top</code> makes sense.</p>",
        "id": 271772117,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644795299
    },
    {
        "content": "<p>Actually it seems that the order on bornologies should be reversed from what we have in mathlib for the order on topological space structures.</p>",
        "id": 271772137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795339
    },
    {
        "content": "<p>Because a morphism is supposed to map a bounded set to a bounded set.</p>",
        "id": 271772140,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795356
    },
    {
        "content": "<p>So this might be <code>bot</code> :)</p>",
        "id": 271772186,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644795384
    },
    {
        "content": "<p>ah, okay</p>",
        "id": 271772189,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644795391
    },
    {
        "content": "<p>For what it's worth, this is equivalent to the definition of a bornology that includes the empty set:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">bornology</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">infty</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"c1\">-- the \"filter at infinity\"</span>\n<span class=\"o\">(</span><span class=\"n\">le_cofinite</span> <span class=\"o\">:</span> <span class=\"n\">infty</span> <span class=\"bp\">≤</span> <span class=\"n\">cofinite</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and this is the definition of a bounded function with respect to bornologies <code>b</code> and <code>b'</code> on <code>α</code> and <code>α'</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">is_bounded</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">b'.infty.comap</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">b.infty</span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>proof of equivalence to other definition</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.cofinite</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bornology</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">infty</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_cofinite</span> <span class=\"o\">:</span> <span class=\"n\">infty</span> <span class=\"bp\">≤</span> <span class=\"n\">cofinite</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">bornology</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b'</span> <span class=\"o\">:</span> <span class=\"n\">bornology</span> <span class=\"n\">α'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_bounded</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">b'.infty.comap</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">b.infty</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bornology.ideal</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">B</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"n\">b.infty</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bornology.covers</span> <span class=\"o\">:</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">b.ideal</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">},</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bornology.ideal</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">b.le_cofinite</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">le_def</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">set.finite_singleton</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">compl_mem_cofinite</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bornology.inclusion</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hA</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span> <span class=\"o\">:=</span>\n<span class=\"n\">mem_of_superset</span> <span class=\"n\">hB</span> <span class=\"o\">(</span><span class=\"n\">set.compl_subset_compl.mpr</span> <span class=\"n\">hA</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bornology.unions</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hB</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hB'</span> <span class=\"o\">:</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">bornology.ideal</span><span class=\"o\">,</span> <span class=\"n\">set.compl_union</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">inter_mem</span> <span class=\"n\">hB</span> <span class=\"n\">hB'</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_bounded_iff</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_bounded</span> <span class=\"n\">b</span> <span class=\"n\">b'</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">b.ideal</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">b'.ideal</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">is_bounded</span><span class=\"o\">,</span> <span class=\"n\">le_def</span><span class=\"o\">,</span> <span class=\"n\">bornology.ideal</span><span class=\"o\">],</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">B</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">B'</span><span class=\"o\">,</span> <span class=\"n\">hB'</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">B'</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rintros</span> <span class=\"n\">x'</span> <span class=\"n\">hx'</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x'</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">B'</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">this</span> <span class=\"n\">hx'</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">exact</span> <span class=\"n\">mem_of_superset</span> <span class=\"n\">hB'</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">h</span> <span class=\"n\">B</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">B</span><span class=\"bp\">ᶜ</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hB</span><span class=\"o\">),</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.not_not_mem.mp</span> <span class=\"o\">(</span><span class=\"n\">imp_not_comm.mp</span> <span class=\"n\">h</span> <span class=\"n\">rfl</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bornology.of</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">empty_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">covers</span> <span class=\"o\">:</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">ideal</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">),</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">bornology</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">infty</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">B</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">},</span>\n    <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">empty_mem</span><span class=\"o\">],</span>\n    <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">A'</span> <span class=\"n\">hA</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">set.compl_subset_compl</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">hA</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">incl</span> <span class=\"n\">_</span> <span class=\"n\">hA</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n      <span class=\"n\">intros</span> <span class=\"n\">A</span> <span class=\"n\">A'</span> <span class=\"n\">hA</span> <span class=\"n\">hA'</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set.mem_set_of_eq</span> <span class=\"n\">at</span> <span class=\"bp\">⊢</span> <span class=\"n\">hA</span> <span class=\"n\">hA'</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set.compl_inter</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">union</span> <span class=\"n\">_</span> <span class=\"n\">hA</span> <span class=\"n\">_</span> <span class=\"n\">hA'</span><span class=\"o\">,</span>\n    <span class=\"kd\">end</span> <span class=\"o\">},</span>\n  <span class=\"n\">le_cofinite</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">le_def</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"n\">A'</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">h.dinduction_on</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">hx</span> <span class=\"n\">hs</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">empty_mem</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">set.insert_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">union</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">set.mem_univ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">covers</span><span class=\"o\">,</span> <span class=\"n\">set.mem_sUnion</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">hB</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">incl</span> <span class=\"n\">_</span> <span class=\"n\">hB</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">empty_mem</span> <span class=\"o\">:</span> <span class=\"bp\">∅</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">covers</span> <span class=\"o\">:</span> <span class=\"bp\">⋃₀</span> <span class=\"n\">ideal</span> <span class=\"bp\">=</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">incl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"bp\">⊆</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">A</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">),</span> <span class=\"n\">B</span> <span class=\"bp\">∪</span> <span class=\"n\">B'</span> <span class=\"bp\">∈</span> <span class=\"n\">ideal</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bornology.ideal_of_eq</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">bornology.of</span> <span class=\"n\">ideal</span> <span class=\"n\">empty_mem</span> <span class=\"n\">covers</span> <span class=\"n\">incl</span> <span class=\"n\">union</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">ideal</span> <span class=\"bp\">=</span> <span class=\"n\">ideal</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">B</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bornology.of</span><span class=\"o\">,</span> <span class=\"n\">bornology.ideal</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>\n</div></div>",
        "id": 271774409,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644798521
    },
    {
        "content": "<p>Nice!</p>",
        "id": 271774789,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644799062
    },
    {
        "content": "<p>Shouldn't <code>infty</code> be called <code>co-bounded</code>, per the title of this thread? ;)</p>",
        "id": 271774856,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644799120
    },
    {
        "content": "<p>So, should we have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">bornology_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cobounded</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_cofinite</span> <span class=\"o\">:</span> <span class=\"n\">cobounded</span> <span class=\"bp\">≤</span> <span class=\"n\">cofinite</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>with an instance for a <code>pseudo_metric_space</code>?</p>",
        "id": 271781365,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644809156
    },
    {
        "content": "<p>And <code>bounded</code> (or whatever is the new name) defined as <code>sᶜ ∈ cobounded</code>.</p>",
        "id": 271781412,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644809212
    },
    {
        "content": "<p>That was my new plan. Then the morphisms are just <code>f</code> that satisfy <code>comap f cobounded ≤ cobounded</code>. I can then provide the necessary API for bounded sets, and the API for cobounded sets comes mostly for free from the API for filters.</p>",
        "id": 271782223,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644810530
    },
    {
        "content": "<p>What are the other instances?</p>",
        "id": 271782313,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644810679
    },
    {
        "content": "<p>I mean, are we going to have more than one instance for <code>bornology_space</code>?</p>",
        "id": 271782318,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644810715
    },
    {
        "content": "<p>We will eventually, certainly locally convex spaces, or even any topological vector space.</p>",
        "id": 271782614,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644811186
    },
    {
        "content": "<p>If you could let me define bounded maps, that'd be nice, so that we can follow the hom refactor right from the start.</p>",
        "id": 271836133,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644850250
    },
    {
        "content": "<p>We could then instantiate <code>bounded_map_class</code> for continuous linear maps.</p>",
        "id": 271836392,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644850374
    },
    {
        "content": "<p>oops, sorry,  I just saw your comment. See <a href=\"https://github.com/leanprover-community/mathlib/pull/12036\">#12036</a>. If you want I can remove the <code>bounded_hom</code> bits, but if possible I would prefer if you told me how to follow the hom refactor so I can learn about it more.</p>",
        "id": 271857578,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644858736
    },
    {
        "content": "<p>Even just pointing me to an example or the relevant documentation might be enough.</p>",
        "id": 271858194,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644858985
    },
    {
        "content": "<p>Sorry, don't have time anymore now, so I suggest you have a look at <a href=\"https://tqft.net/mathlib/order/hom/lattice\">file#order/hom/lattice</a> or <a href=\"https://tqft.net/mathlib/order/hom/bounded\">file#order/hom/bounded</a></p>",
        "id": 271858197,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644858986
    },
    {
        "content": "<p>But also if you leave that to me, I'll be done in 20min. Up to you.</p>",
        "id": 271858239,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644859011
    },
    {
        "content": "<p>Alright, I'll just pull out the homs and leave it to you and I'll just pay attention to how you did it.</p>",
        "id": 271858495,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644859125
    },
    {
        "content": "<p>Do you want them in the same PR or a different one? I'd be happy to defer.</p>",
        "id": 271858683,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644859213
    },
    {
        "content": "<p>Doesn't matter to me. You are welcome to stick them in that one if you want to push to that branch. Or defer, your choice.</p>",
        "id": 271859746,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644859736
    }
]
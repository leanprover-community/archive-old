[
    {
        "content": "<p>Dear All,</p>\n<p>is there a lemma extending the \"T_2 property\" of a topological space from two points to a <code>finset</code>?  I am thinking of something along the lines of the lemma below, but any essentially equivalent formulation would likely work!</p>\n<p>Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.separation</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finsupp</span>\n\n<span class=\"c1\">--instance (X : Type*) : has_zero (set X) := ⟨(∅ : set X)⟩</span>\n<span class=\"c1\">-- Lean complains:</span>\n<span class=\"c1\">-- invalid definition, a declaration named 'set.has_zero' has already been declared</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">disjoint_nhds_finset_of_t2</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">finsupp</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">⟩,</span>  <span class=\"c1\">-- awkward: I think that this instance should be there...</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n    <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">disjoint</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"> -- proof likely starting with</span>\n<span class=\"cm\">  generalize' hd : s.card = d,</span>\n<span class=\"cm\">  refine finset.induction_on s _ _,</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219576517,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607675585
    },
    {
        "content": "<p>Related to the above: is it possible define a function <code>f : X → X → set X × set X</code> with the property that, if <code>x ≠ y</code>, then <code>f x y = (U, V)</code> with <code>U</code> and <code>V</code> disjoint neighbourhoods of <code>x</code> and <code>y</code>?  In the sample below, <code>cases</code> complains:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">induction</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">recursor</span> <span class=\"bp\">'</span><span class=\"n\">Exists.dcases_on'</span> <span class=\"n\">can</span> <span class=\"n\">only</span> <span class=\"n\">eliminate</span> <span class=\"n\">into</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>I take this to mean that <code>cases</code> can only return stuff of Type <code>Prop</code>, but in this case would have to return something of Type <code>set X</code>?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">disjoint_opens_pairs_of_t2</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">xy</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">set.univ</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"n\">cases</span> <span class=\"n\">t2_space.t2</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">xy</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219579745,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607677805
    },
    {
        "content": "<p>(I realize that, depending on how <code>t2_space</code> is implemented, this might require the axiom of choice: I am happy to assume it!)</p>",
        "id": 219580072,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607678030
    },
    {
        "content": "<p>yes, it is possible. Start by proving <code>\\forall x y, \\exists (UV : set X × set X), &lt;disjoint yada yada&gt;</code></p>",
        "id": 219580538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607678352
    },
    {
        "content": "<p>and then use <code>classical.some</code> on this proof to get the function</p>",
        "id": 219580558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607678369
    },
    {
        "content": "<p>Thanks for the suggestion: I will try!</p>",
        "id": 219580684,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607678452
    },
    {
        "content": "<p>oh, actually I see there is a case disjunction, so I guess you want the proof to be <code>\\forall x y, x != y -&gt; \\exists (UV : set X × set X), &lt;disjoint yada yada&gt;</code>, and then the function is <code>\\lam x y, if h : x = y then (univ, univ) else classical.some (proof x y h)</code></p>",
        "id": 219580844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607678569
    },
    {
        "content": "<p>The definition of <code>t2_space</code> seems to be exactly what I should prove, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">t2_space</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">t2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">u</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">u</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">v</span> <span class=\"bp\">∧</span> <span class=\"n\">u</span> <span class=\"bp\">∩</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219581465,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607678957
    },
    {
        "content": "<p>Thank you, Mario!  The code below compiles and I think that it does what I want!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">pre_choice_opens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n  <span class=\"n\">is_open</span> <span class=\"n\">U.1</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">U.2</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">U.1</span> <span class=\"bp\">∧</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">U.2</span> <span class=\"bp\">∧</span> <span class=\"n\">U.1</span> <span class=\"bp\">∩</span> <span class=\"n\">U.2</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">xy</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">xy</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">Z</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨(</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">Z</span><span class=\"o\">⟩,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t2_choice</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">set.univ</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">classical.some</span> <span class=\"o\">(</span><span class=\"n\">pre_choice_opens</span> <span class=\"n\">X</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">t2_choice</span>\n  <span class=\"c1\">--  t2_choice : Π (X : Type u_2) [_inst_4 : topological_space X] [_inst_5 : t2_space X], X → X → set X × set X</span>\n</code></pre></div>",
        "id": 219582901,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607680010
    },
    {
        "content": "<p>I suggest actually making two definitions, for the two sets, and then three lemmas about the properties of the two sets (all unpacked from the <code>pre_choice_opens</code> proof)</p>",
        "id": 219583068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607680130
    },
    {
        "content": "<p>I think that I am misunderstanding: the two sets need to be disjoint: how can I define them separately?</p>",
        "id": 219583132,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607680198
    },
    {
        "content": "<p>Mario, this kind of trick is really difficult for beginners (or even intermediate users like Damiano).</p>",
        "id": 219589968,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684209
    },
    {
        "content": "<p>Damanio, here are the definitions and statements. You need to understand <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.some\">docs#classical.some</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/classical.some_spec\">docs#classical.some_spec</a>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.separation</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">set</span> <span class=\"n\">classical</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">univ</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"k\">then</span> <span class=\"n\">univ</span> <span class=\"k\">else</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">$</span> <span class=\"n\">some_spec</span> <span class=\"bp\">$</span> <span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">disjoint_t2_open₁_t2_open₂</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∩</span> <span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 219590035,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684267
    },
    {
        "content": "<p>And it misses two lemmas saying both sets are open.</p>",
        "id": 219590095,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684288
    },
    {
        "content": "<p>I can give you the proofs if you get stuck, but this is an important exercise.</p>",
        "id": 219590142,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684314
    },
    {
        "content": "<p>The missing statements are</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_open_t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_open_t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 219590327,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684454
    },
    {
        "content": "<p>Let me give it a try!  Thanks!</p>",
        "id": 219590343,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607684462
    },
    {
        "content": "<p>Note that all proofs are two to four lines long.</p>",
        "id": 219590352,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684470
    },
    {
        "content": "<p>Note also where is the \"precondition\" <code>x ≠ y</code>. You don't need it to talk about the open sets, and you don't need it in 4 lemmas out of 5.</p>",
        "id": 219590658,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684528
    },
    {
        "content": "<p>That's the key: you don't want to pass around proofs to talk about objects only when proving the crucial property.</p>",
        "id": 219590748,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684560
    },
    {
        "content": "<p>Ok, this concept is slowly creeping its way in me, although it is not easy for me to spot where I am making this error...</p>",
        "id": 219590904,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607684615
    },
    {
        "content": "<p>I know it feels weird but only because you're usually lying to yourself. When you write computations on paper, it's not true that for each division you write a proof next to the division symbol. So you're doing the same thing as we do here: write first, apologize later.</p>",
        "id": 219591318,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684720
    },
    {
        "content": "<p>Note also the trick that junk values (this is how we call values returned when the precondition is not met) are not random, although Kevin loves to joke about returning 37. They are carefully chosen to maximize the number of lemmas that are unconditionnaly true. For instance here, returning the empty set would be a bad choice because <code>mem_t2_open₁</code> would need the precondition. Again we don't really care those lemmas are true in junk cases, but it does save some typing when applying them.</p>",
        "id": 219591740,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607684998
    },
    {
        "content": "<p>This is my attempt with the first of the lemmas above: I am not even sure if I made progress or not...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">t2_open₁</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n<span class=\"c1\">--  obtain ⟨U, V, oU, oV, xU, yV, UV⟩ := (t2_separation h),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_def</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>For me, the <code>some</code> is a wall that I cannot climb...</p>",
        "id": 219594293,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607686362
    },
    {
        "content": "<p>I did identify the <code>_</code> in the underscore as <code>F</code>, though!  This is the only use that I have for the <code>obtain</code> line...</p>",
        "id": 219594370,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607686408
    },
    {
        "content": "<p>Whenever you see a <code>some</code>, use <code>some_spec</code> with the same hypothesis given to <code>some</code></p>",
        "id": 219594371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607686409
    },
    {
        "content": "<p>Ah, I will try!  Thanks!</p>",
        "id": 219594385,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607686421
    },
    {
        "content": "<p>This is a proof of the first lemma!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">t2_open₁</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Any comments are very welcome!  Especially since I do not really understand this proof (or rather, what it is that I am supposed to prove)!</p>",
        "id": 219596882,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607688041
    },
    {
        "content": "<p>That's right. You can probably write it as something like <code>(some_spec (t2_separation h)).snd.2.2.1</code></p>",
        "id": 219596959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607688113
    },
    {
        "content": "<p>Basically, <code>some_spec (t2_separation h)</code> is a theorem that says <code>some (t2_separation h)</code> satisfies the property in the existential of <code>t2_separation h</code></p>",
        "id": 219597054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607688176
    },
    {
        "content": "<p>in this case, <code>some (t2_separation h)</code> is <code>t2_open₁ x y</code>, so <code>some_spec (t2_separation h)</code> says that <code>∃v : set α, is_open (t2_open₁ x y) ∧ is_open v ∧ x ∈ t2_open₁ x y ∧ y ∈ v ∧ t2_open₁ x y ∩ v = ∅)</code></p>",
        "id": 219597216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607688254
    },
    {
        "content": "<p>Ok, so it is giving a name to the \"variable\" open set that contains x and [properties involving y], without referring to y.  Is this a correct way of thinking about this?</p>",
        "id": 219597430,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607688394
    },
    {
        "content": "<p>I find it a bit easier to understand if there is only one existential; Patrick's version uses <code>some</code> twice on the two existentials. If you use <code>some</code> on your <code>pre_choice_opens</code> proof instead of <code>t2_separation h</code> directly, the property you get out is something like <code>is_open (foo x y).1 ∧ is_open (foo x y).2 ∧ x ∈ (foo x y).1 ∧ y ∈ (foo x y).2 ∧ (foo x y).1 ∩ (foo x y).2 = ∅)</code>, where <code>foo x y</code> is a definition abbreviating <code>some (pre_choice_opens x y h)</code>. If you then define <code>t2_open₁ x y := (foo x y).1</code> and <code>t2_open₂ x y := (foo x y).2</code>, then you can simply observe that this is a conjunction of all the lemmas you want</p>",
        "id": 219597499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607688462
    },
    {
        "content": "<p>I think that the \"nested\" <code>some</code>s are now what I am trying to undo in the second lemma.  I will try to fill in the proofs with both approaches: I may learn <code>some</code>thing</p>",
        "id": 219597828,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607688683
    },
    {
        "content": "<p>It took me a while, but here is a proof of lemma 2:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">t2_open₂</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219600884,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607690601
    },
    {
        "content": "<p>The fact there are two existentials is indeed a bit unfortunate for a first exercise in using these ideas. The reason I did that is the existing lemma <code>t2_separation</code> is stated like that.</p>",
        "id": 219602553,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607691670
    },
    {
        "content": "<p>My proofs were:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₁</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">t2_open₁</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">op₁</span><span class=\"o\">,</span> <span class=\"n\">op₂</span><span class=\"o\">,</span> <span class=\"n\">x_in</span><span class=\"o\">,</span> <span class=\"n\">y_in</span><span class=\"o\">,</span> <span class=\"n\">hinter</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">t2_open₁</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">T</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">by_cases</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">t2_open₂</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">some_spec</span> <span class=\"bp\">$</span> <span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">y_in</span><span class=\"o\">,</span> <span class=\"bp\">-</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">t2_open₂</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">y_in</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>In the first proof I named every pieces in the <code>rcases</code> for clarity, and in the second lemma I illustrate how to throw away unneeded pieces.</p>",
        "id": 219602727,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607691772
    },
    {
        "content": "<p>Thanks for your proofs!  I also had all the terms in the <code>rcases ... ⟨_, _, _, D, _⟩</code> labeled, but then I dropped them, for obscurity!</p>",
        "id": 219602982,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607691948
    },
    {
        "content": "<p>Underscores do not drop them, it gives them awful names. Dashes drop them.</p>",
        "id": 219603077,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607691981
    },
    {
        "content": "<p>here is a proof of the next lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">disjoint_t2_open₁_t2_open₂</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">t2_open₁</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∩</span> <span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">t2_open₂</span><span class=\"o\">,</span>\n  <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">h_1</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">unfold</span> <span class=\"n\">t2_open₁</span><span class=\"o\">,</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">))</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">E</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219603130,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/219603077\">said</a>:</p>\n<blockquote>\n<p>Underscores do not drop them, it gives them awful names. Dashes drop them.</p>\n</blockquote>\n<p>Ah, I learned that</p>\n<ol>\n<li>I should pay more attention to the difference between <code>-</code> and <code>_</code>;</li>\n<li>there <em>is</em> a difference between them!</li>\n</ol>",
        "id": 219603222,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692063
    },
    {
        "content": "<p>Ok, now try to prove that next lemma in two lines (one <code>rcases</code> and one more line).</p>",
        "id": 219603298,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692092
    },
    {
        "content": "<p>Seeing your proofs, I could probably avoid <code>unfold</code>ing and separate the cases presciently...</p>",
        "id": 219603300,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692093
    },
    {
        "content": "<p>I mean <code>disjoint_t2_open₁_t2_open₂</code></p>",
        "id": 219603332,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692111
    },
    {
        "content": "<p>Yes, it is the next one in your/my list!</p>\n<p>Except it is almost lunch time: I might do it in a bit!</p>\n<p>Thanks for the exercises and the help!</p>",
        "id": 219603383,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692144
    },
    {
        "content": "<p>No, it's what you called the next one, but you just pasted a proof that is 8 lines long.</p>",
        "id": 219603551,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692222
    },
    {
        "content": "<p>I say make it 2 lines long now.</p>",
        "id": 219603573,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692239
    },
    {
        "content": "<p>Ah, ok!</p>",
        "id": 219603583,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692248
    },
    {
        "content": "<p>(sorry, I was still processing the <code>_</code> and <code>-</code>)</p>",
        "id": 219603622,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607692269
    },
    {
        "content": "<p>Actually you can make it one line long (without cheating by putting two tactics on the same line) if you go to 106 columns.</p>",
        "id": 219603762,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692348
    },
    {
        "content": "<p>Oh, I can bring it down to 89 columns, but this is borderline obfuscation.</p>",
        "id": 219603875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692414
    },
    {
        "content": "<p>I should really work now instead of playing with Lean.</p>",
        "id": 219603957,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692449
    },
    {
        "content": "<p>Admittedly, all this is trivial after seeing the definition of T2, so obfuscation is allowed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_open_t2_open₂</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">t2_open₂</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">classical.em</span> <span class=\"bp\">$</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">t2_open₂</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">])</span>\n<span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">t2_open₂</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">some_spec</span> <span class=\"bp\">$</span> <span class=\"n\">some_spec</span> <span class=\"bp\">$</span> <span class=\"n\">t2_separation</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Ok, I'll go to work.</p>",
        "id": 219604704,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1607692842
    },
    {
        "content": "<p>I'll need time to process these two lines: for the moment, I will absorb the satisfaction that I could find <em>one</em> proof!</p>",
        "id": 219605557,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607693347
    },
    {
        "content": "<p>I feel at the same time proud and ashamed: I managed to prove the statement about disjoint <code>finset</code>s having disjoint neighbourhoods... but not using <code>some</code>s...  sorry!  Below is the argument, in case people are interested!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.separation</span>\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">set</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset_disjoint_point_opens_of_t2</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span>\n    <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">disjoint</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">generalize'</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">s.card</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"n\">is_open_empty</span><span class=\"o\">,</span> <span class=\"n\">is_open_univ</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.disjoint_univ.mpr</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">ta</span> <span class=\"n\">xxt</span> <span class=\"n\">x</span> <span class=\"n\">xt</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">xU</span><span class=\"o\">,</span> <span class=\"n\">aV</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">t2_separation</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">t</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">xt</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Ui</span><span class=\"o\">,</span> <span class=\"n\">Vi</span><span class=\"o\">,</span> <span class=\"n\">oUi</span><span class=\"o\">,</span> <span class=\"n\">oVi</span><span class=\"o\">,</span> <span class=\"n\">xUi</span><span class=\"o\">,</span> <span class=\"n\">aVi</span><span class=\"o\">,</span> <span class=\"n\">UVi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">xxt</span> <span class=\"n\">x</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">V</span> <span class=\"bp\">∪</span> <span class=\"n\">Ui</span><span class=\"o\">,</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">Vi</span><span class=\"o\">,</span> <span class=\"n\">is_open_union</span> <span class=\"n\">oV</span> <span class=\"n\">oUi</span><span class=\"o\">,</span> <span class=\"n\">is_open_inter</span> <span class=\"n\">oU</span> <span class=\"n\">oVi</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">xU</span><span class=\"o\">,</span> <span class=\"n\">aVi</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">fi</span><span class=\"o\">,</span>\n    <span class=\"n\">by_cases</span> <span class=\"n\">fa</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">set.mem_union_left</span> <span class=\"n\">_</span> <span class=\"n\">aV</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.mem_union_right</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">xUi</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"n\">fi</span> <span class=\"n\">fa</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">disjoint.union_left</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">set.disjoint_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">set.inter_subset_right</span> <span class=\"n\">U</span> <span class=\"n\">Vi</span><span class=\"o\">)</span> <span class=\"n\">UVi</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">set.disjoint_of_subset_right</span> <span class=\"n\">_</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">Vi</span><span class=\"o\">)</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">set.inter_subset_left</span> <span class=\"n\">U</span> <span class=\"n\">Vi</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"n\">set.inter_comm</span> <span class=\"n\">at</span> <span class=\"n\">UV</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">set.disjoint_iff_inter_eq_empty.mpr</span> <span class=\"n\">UV</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">ne_of_mem_of_not_mem</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">xt</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset_disjoint_finset_opens_of_t2</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n  <span class=\"bp\">∧</span> <span class=\"n\">disjoint</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">generalize'</span> <span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">t.card</span> <span class=\"bp\">=</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">t</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">set.univ</span><span class=\"o\">,</span> <span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">is_open_univ</span><span class=\"o\">,</span> <span class=\"n\">is_open_empty</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.mem_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">set.univ_disjoint.mpr</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">S</span> <span class=\"n\">xS</span> <span class=\"n\">hi</span> <span class=\"n\">sxS</span><span class=\"o\">,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">xU</span><span class=\"o\">,</span> <span class=\"n\">yV</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hi</span> <span class=\"o\">(</span><span class=\"n\">finset.disjoint_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">subset_insert</span> <span class=\"n\">x</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"n\">sxS</span><span class=\"o\">),</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Ui</span><span class=\"o\">,</span> <span class=\"n\">Vi</span><span class=\"o\">,</span> <span class=\"n\">oUi</span><span class=\"o\">,</span> <span class=\"n\">oVi</span><span class=\"o\">,</span> <span class=\"n\">xUi</span><span class=\"o\">,</span> <span class=\"n\">aVi</span><span class=\"o\">,</span> <span class=\"n\">UiVi</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finset_disjoint_point_opens_of_t2</span> <span class=\"n\">s</span> <span class=\"n\">x</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">Ui</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"bp\">∪</span> <span class=\"n\">Vi</span><span class=\"o\">,</span> <span class=\"n\">is_open_inter</span> <span class=\"n\">oU</span> <span class=\"n\">oUi</span><span class=\"o\">,</span> <span class=\"n\">is_open_union</span> <span class=\"n\">oV</span> <span class=\"n\">oVi</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">xU</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span> <span class=\"n\">xUi</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">fi</span><span class=\"o\">,</span>\n        <span class=\"n\">by_cases</span> <span class=\"n\">fx</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">fx</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">set.mem_union_right</span> <span class=\"n\">_</span> <span class=\"n\">aVi</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">Vi.mem_union_left</span> <span class=\"o\">(</span><span class=\"n\">yV</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">mem_of_mem_insert_of_ne</span> <span class=\"n\">fi</span> <span class=\"n\">fx</span><span class=\"o\">))</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">disjoint.union_right</span><span class=\"o\">,</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">set.disjoint_of_subset_left</span> <span class=\"o\">(</span><span class=\"n\">set.inter_subset_left</span> <span class=\"n\">U</span> <span class=\"n\">Ui</span><span class=\"o\">)</span> <span class=\"n\">UV</span> <span class=\"o\">},</span>\n        <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">set.disjoint_of_subset_left</span> <span class=\"o\">(</span><span class=\"n\">set.inter_subset_right</span> <span class=\"n\">U</span> <span class=\"n\">Ui</span><span class=\"o\">)</span> <span class=\"n\">UiVi</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">disjoint_insert_right.mp</span> <span class=\"n\">sxS</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219634141,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607707292
    },
    {
        "content": "<p>.</p>",
        "id": 219651382,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607715128
    },
    {
        "content": "<p>In case this is not already in mathlib and people think that this is a useful addition, I can make a PR with this proof!<br>\n<span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 219691963,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607751910
    },
    {
        "content": "<p>I guess there's al ultrafilter-centric analogue of this statement too... (analogous to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/t2_iff_ultrafilter\">docs#t2_iff_ultrafilter</a> )</p>",
        "id": 219692149,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607752296
    },
    {
        "content": "<p>I did not learn about ultrafilters yet: I will make this PR and see if there is interest in more!</p>",
        "id": 219692215,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607752389
    },
    {
        "content": "<p>But maybe it's not that interesting... I guess it would say, approximately, that given any two disjoint finite sets <code>S</code> and <code>T</code>, any ultrafilter which converges to a point in <code>S</code> cannot converge to any point in <code>T</code>.</p>",
        "id": 219692283,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607752444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I didn't like ultrafilters at first, but then I realized that one should think of them like algebraic geometers think of valuation rings, and now I love them!</p>",
        "id": 219692354,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607752577
    },
    {
        "content": "<p>Ah, as I am not familiar with filters/ultrafilters, I unconsciously try to avoid them.  Your comment makes me want to dive into them, though!  Thanks!</p>",
        "id": 219692373,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607752648
    },
    {
        "content": "<p>(The analogy breaks down after a while, but it's a good approximation <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 219692586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607752984
    },
    {
        "content": "<p>Done!<br>\n<a href=\"https://github.com/leanprover-community/mathlib/issues/5332\">#5332</a></p>\n<p>Let's see if Lean also likes it!</p>",
        "id": 219693597,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607754810
    },
    {
        "content": "<p>The code below proves the same existence of disjoint open sets containing disjoint finsets.  It is slightly longer than the other proof, however it seems more streamlined: should I update the previous PR or, by proof-irrelevance, the shorter the proof, the better?</p>\n<p>Here, short is only measured in terms of lines, not of anything more objective.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.separation</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset_ind_card_empty</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">basea0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">base11</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">})</span>\n  <span class=\"o\">(</span><span class=\"n\">indu</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∪</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">b</span> <span class=\"n\">basea0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">xs</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">symm</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.insert_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">indu</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"n\">hi</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">a</span> <span class=\"n\">basea0</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">ta</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">symm</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">finset.insert_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">indu</span> <span class=\"n\">base11</span> <span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"n\">hi</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">dis</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">is_open</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">disjoint</span> <span class=\"n\">U</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dis_symm</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">dis</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">dis</span> <span class=\"n\">t</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n <span class=\"n\">unfold</span> <span class=\"n\">dis</span> <span class=\"n\">at</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">aU</span><span class=\"o\">,</span> <span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"n\">disjoint.symm</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">aU</span><span class=\"o\">,</span> <span class=\"n\">disjoint.symm</span> <span class=\"n\">UV</span><span class=\"o\">⟩</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dis_basea0</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">dis</span> <span class=\"n\">a</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">is_open_univ</span><span class=\"o\">,</span> <span class=\"n\">is_open_empty</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">disjoint_empty</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dis_base11</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">dis</span> <span class=\"o\">({</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">forall_eq</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_singleton</span><span class=\"o\">,</span> <span class=\"n\">disjoint_iff_inter_eq_empty</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">t2_separation</span> <span class=\"o\">(</span><span class=\"n\">finset.not_mem_singleton.mp</span> <span class=\"o\">(</span><span class=\"n\">finset.disjoint_singleton.mp</span> <span class=\"o\">(</span><span class=\"n\">disjoint.comm.mp</span> <span class=\"n\">d</span><span class=\"o\">))),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">dis_indu</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">dis</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">dis</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">dis</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∪</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">ac</span> <span class=\"n\">bc</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U1</span><span class=\"o\">,</span> <span class=\"n\">V1</span><span class=\"o\">,</span> <span class=\"n\">oU1</span><span class=\"o\">,</span> <span class=\"n\">oV1</span><span class=\"o\">,</span> <span class=\"n\">aU1</span><span class=\"o\">,</span> <span class=\"n\">bV1</span><span class=\"o\">,</span> <span class=\"n\">UV1</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ac</span> <span class=\"o\">(</span><span class=\"n\">finset.disjoint_of_subset_left</span> <span class=\"o\">(</span><span class=\"n\">finset.subset_union_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">U2</span><span class=\"o\">,</span> <span class=\"n\">V2</span><span class=\"o\">,</span> <span class=\"n\">oU2</span><span class=\"o\">,</span> <span class=\"n\">oV2</span><span class=\"o\">,</span> <span class=\"n\">aU2</span><span class=\"o\">,</span> <span class=\"n\">bV2</span><span class=\"o\">,</span> <span class=\"n\">UV2</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">bc</span> <span class=\"o\">(</span><span class=\"n\">finset.disjoint_of_subset_left</span> <span class=\"o\">(</span><span class=\"n\">finset.subset_union_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">d</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U1</span> <span class=\"bp\">∪</span> <span class=\"n\">U2</span><span class=\"o\">,</span> <span class=\"n\">V1</span> <span class=\"bp\">∩</span> <span class=\"n\">V2</span><span class=\"o\">,</span> <span class=\"n\">is_open_union</span> <span class=\"n\">oU1</span> <span class=\"n\">oU2</span><span class=\"o\">,</span> <span class=\"n\">is_open_inter</span> <span class=\"n\">oV1</span> <span class=\"n\">oV2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">xab</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">xc</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">bV1</span> <span class=\"n\">_</span> <span class=\"n\">xc</span><span class=\"o\">,</span> <span class=\"n\">bV2</span> <span class=\"n\">_</span> <span class=\"n\">xc</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">finset.mem_union.mp</span> <span class=\"n\">xab</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">mem_union_left</span> <span class=\"n\">U2</span> <span class=\"o\">(</span><span class=\"n\">aU1</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">mem_union_right</span> <span class=\"n\">U1</span> <span class=\"o\">(</span><span class=\"n\">aU2</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">disjoint_union_left.mpr</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">disjoint_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">UV1</span><span class=\"o\">,</span> <span class=\"n\">disjoint_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">inter_subset_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">UV2</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">disjoint_finset_t2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">dis</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset_ind_card_empty</span> <span class=\"n\">dis</span> <span class=\"n\">dis_symm</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">dis_basea0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">dis_base11</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">dis_indu</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219721782,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607799047
    },
    {
        "content": "<p><del>Also, why in the last proof, I need to use the underscores?  I would have wanted to use <code>dis_basea0</code> and the others, just like I did <code>dis_symm</code>, but I cannot understand why Lean does not like it.</del></p>",
        "id": 219722018,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607799374
    },
    {
        "content": "<p>Probably <code>dis_basea0</code> takes some extra arguments which <code>apply</code> automatically figures out - similarly if you change the <code>apply dis_basea0</code> to <code>refine disbasea0</code>, it'll probably fail</p>",
        "id": 219722038,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607799419
    },
    {
        "content": "<p>You can use <code>show_term {apply dis_basea0}</code> to see what you could use in place of that refine, and then put that instead of the underscore</p>",
        "id": 219722067,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607799479
    },
    {
        "content": "<p>Thanks!  I fixed the first two: I am still not entirely sure what it is, but the new version works!</p>",
        "id": 219722110,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607799517
    },
    {
        "content": "<p>I had tried <code>show_term</code> but it gives something that does not work.  If I remember correctly, it said <code>exact dis_basea0</code>.</p>",
        "id": 219722469,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607800067
    },
    {
        "content": "<p>I pushed a more conceptual argument.</p>\n<ol>\n<li>On pairs <code>finset</code>s, I added an explicit induction.</li>\n<li>On <code>topological_space</code>, I added a general lemma that to show separation of <code>finset</code>s it suffices to show separation of singletons.</li>\n<li>Finally, the <code>t2_space</code> assumption is all that is needed to show the required separation!</li>\n</ol>",
        "id": 219744719,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607836150
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span>  I don't even see <code>disjoint_finsets_opens_of_t2</code> in the current state of the PR.</p>",
        "id": 220093635,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608110975
    },
    {
        "content": "<p>As pointed out by Johan, I think the definition <code>separate</code> doesn't make sense. You should have removed the disjointness assumption from there and move it to the main lemma. And if we need that definition at all then it should be about any sets, not only finite ones. That said I don't think we need it now. You can state your end goal as </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">t2_separation_finsets</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span>\n</code></pre></div>",
        "id": 220105693,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119235
    },
    {
        "content": "<p>And I think it's worth the trouble of also stating the intermediate lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">t2_separation_point_finset</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>since it makes sense to know it independently.</p>",
        "id": 220105742,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119274
    },
    {
        "content": "<p>I think you are right that they key is to have relevant induction lemmas for finsets. But I think the one you chose is not the most relevant one.</p>",
        "id": 220105813,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119322
    },
    {
        "content": "<p>The key feature of these topological lemmas is they are about disjoint points and finsets. So I propose to prove:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finset.induction_disjoint_point</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">y</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">s</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset.induction_disjoint</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"n\">t</span>\n</code></pre></div>\n<p>which should be straightforward applications of <code>finset.induction_on</code>.</p>",
        "id": 220105885,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119395
    },
    {
        "content": "<p>and then use them to prove the two topological lemmas (the second topological lemma using the first one of course).</p>",
        "id": 220105959,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119435
    },
    {
        "content": "<p>Do you want help or are you still happy to learn stuff using this example?</p>",
        "id": 220106169,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608119588
    },
    {
        "content": "<p>Ah, I found out now your comments here, but I just pushed a new version.  I will now read and merge your comments!</p>",
        "id": 220115665,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608125911
    },
    {
        "content": "<p>I am happy to try your suggestion out.  Should you find that pointing me in the right direction becomes more work for you than to simply do it yourself, please say so!</p>",
        "id": 220115944,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608126101
    },
    {
        "content": "<p>One quick question: I am happy to go with either <code>disjoint a b</code> or <code>a ∩ b = ∅</code>.<br>\nIs there any particular reason to prefer one over the other?</p>",
        "id": 220116252,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608126251
    },
    {
        "content": "<p>One should prefer the version which shows up more in mathlib -- this will be the version deemed \"canonical\", so the one which the simp lemmas will mention etc</p>",
        "id": 220116353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608126340
    },
    {
        "content": "<p>a regexp search for <code>.* ∩ .* = ∅</code> gives only three hits, and <code>disjoint</code> has 99 hits</p>",
        "id": 220116661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608126493
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">library_search</span> <span class=\"c1\">-- works</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">library_search</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I would use <code>disjoint</code>.</p>",
        "id": 220116903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608126612
    },
    {
        "content": "<p>Ok, I will keep <code>disjoint</code>, then!</p>",
        "id": 220117067,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608126710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/220115944\">said</a>:</p>\n<blockquote>\n<p>Should you find that pointing me in the right direction becomes more work for you than to simply do it yourself, please say so!</p>\n</blockquote>\n<p>This is not at all how I see it. I claim it's important that many mathematicians learn how to use a proof assistant, with the distant goal that one day proof assistants will be useful tools for mathematics. Hence I'm happy to spend some time helping other mathematicians to learn. My goal here isn't to get more lemmas about T2 spaces into mathlib as quickly as possible.</p>",
        "id": 220127731,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608131680
    },
    {
        "content": "<p>Looking at the latest version of the PR, I see that using your union induction principle is actually quite efficient, so maybe I was wrong about the most relevant induction lemmas here. I still claim:</p>\n<ul>\n<li>my two induction principles for finsets could be useful, so it would be nice to have them</li>\n<li>you should define <code>separate</code> for arbitrary sets, and maybe rename it to <code>separated</code>, the current version sounds grammatically weird (but I'm not a native speaker)</li>\n</ul>",
        "id": 220128126,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608131870
    },
    {
        "content": "<ul>\n<li>The version where one point is separated from a finset is also worth spelling out (you can deduce it from the version separating two finsets of course)</li>\n</ul>",
        "id": 220128261,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608131923
    },
    {
        "content": "<p>I have another exercise for you, related to your proof and a question you asked recently. I see from your proofs that we have a lemma <code>is_open_union</code>, that you use as <code>is_open_union oU oW</code>. This is a waste of typing. It should be <code>oU.union oW</code> which is shorter and looks nice. It means someone needs to rename <code>is_open_union</code> to <code>is_open.union</code> and then fix mathlib, enjoying all the shorten proofs on the way. The same holds for <code>is_open_inter</code>, <code>is_closed_union</code> and <code>is_closed_inter</code>. This can be a separate PR. The main goal here is to increase your understanding of the dot notation magic.</p>",
        "id": 220128772,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608132173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/disjoint_nhds_finite_of_t2/near/220116661\">said</a>:</p>\n<blockquote>\n<p>a regexp search for <code>.* ∩ .* = ∅</code> gives only three hits, and <code>disjoint</code> has 99 hits</p>\n</blockquote>\n<p>This means the definition of <code>t2_space</code> and surrounding lemmas should change.</p>",
        "id": 220129045,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1608132298
    },
    {
        "content": "<p>Dear Patrick,</p>\n<p>I have finished the earlier exercise, here is a solution (the <code>_1</code> in the names are an artifact, since I had them in the file <code>topology.separation</code> and for the purpose of posting here, I wanted to make sure that I avoided circularity):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.separation</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">classical.prop_decidable</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset.induction_disjoint_point_1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">y</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">t</span> <span class=\"n\">ta</span> <span class=\"n\">iP</span> <span class=\"n\">xat</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hrec</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">xat</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_insert_self</span> <span class=\"n\">_</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">iP</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">xat</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_insert_of_mem</span> <span class=\"n\">_x</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">finset.induction_disjoint_1</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hrec</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">x</span> <span class=\"n\">t</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">u</span> <span class=\"n\">au</span> <span class=\"n\">hP</span> <span class=\"n\">sau</span><span class=\"o\">,</span> <span class=\"n\">hrec</span> <span class=\"n\">a</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">finset.disjoint_insert_right.mp</span> <span class=\"n\">sau</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">hP</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finset.disjoint_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">finset.subset_insert</span> <span class=\"n\">a</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">sau</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">t2_separation_point_finset_1</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">revert</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_disjoint_point</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">s</span> <span class=\"n\">xy</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">is_open_empty</span><span class=\"o\">,</span> <span class=\"n\">is_open_univ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">mem_univ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">inter_univ</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">aU</span><span class=\"o\">,</span> <span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Uy</span><span class=\"o\">,</span> <span class=\"n\">Vx</span><span class=\"o\">,</span> <span class=\"n\">oUy</span><span class=\"o\">,</span> <span class=\"n\">oVx</span><span class=\"o\">,</span> <span class=\"n\">aUy</span><span class=\"o\">,</span> <span class=\"n\">bVx</span><span class=\"o\">,</span> <span class=\"n\">UyVx</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">t2_separation</span> <span class=\"n\">xy.symm</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">Uy</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">Vx</span><span class=\"o\">,</span> <span class=\"n\">is_open_union</span> <span class=\"n\">oU</span> <span class=\"n\">oUy</span><span class=\"o\">,</span> <span class=\"n\">is_open_inter</span> <span class=\"n\">oV</span> <span class=\"n\">oVx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">bVx</span><span class=\"o\">⟩,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_insert</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">union_singleton</span><span class=\"o\">,</span> <span class=\"n\">union_subset_iff</span><span class=\"o\">],</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">subset_union_of_subset_left</span> <span class=\"n\">aU</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">subset_union_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">set.singleton_subset_iff.mpr</span> <span class=\"n\">aUy</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">union_inter_distrib_right</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.inter_assoc</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">,</span> <span class=\"n\">set.empty_inter</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.empty_union</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.inter_comm</span> <span class=\"n\">V</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.inter_assoc</span><span class=\"o\">,</span> <span class=\"n\">UyVx</span><span class=\"o\">,</span> <span class=\"n\">set.empty_inter</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">t2_separation_finsets_1</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">∧</span> <span class=\"n\">U</span> <span class=\"bp\">∩</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">symmetry'</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction_disjoint</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">u</span> <span class=\"n\">yt</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">is_open_empty</span><span class=\"o\">,</span> <span class=\"n\">is_open_univ</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">subset_univ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">inter_univ</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">oU</span><span class=\"o\">,</span> <span class=\"n\">oV</span><span class=\"o\">,</span> <span class=\"n\">aU</span><span class=\"o\">,</span> <span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">Ut</span><span class=\"o\">,</span> <span class=\"n\">Vy</span><span class=\"o\">,</span> <span class=\"n\">oUt</span><span class=\"o\">,</span> <span class=\"n\">oVy</span><span class=\"o\">,</span> <span class=\"n\">aUt</span><span class=\"o\">,</span> <span class=\"n\">bVy</span><span class=\"o\">,</span> <span class=\"n\">UtVy</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">t2_separation_point_finset</span> <span class=\"n\">yt</span><span class=\"o\">,</span>\n      <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">U</span> <span class=\"bp\">∪</span> <span class=\"n\">Vy</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"bp\">∩</span> <span class=\"n\">Ut</span><span class=\"o\">,</span> <span class=\"n\">is_open_union</span> <span class=\"n\">oU</span> <span class=\"n\">oVy</span><span class=\"o\">,</span> <span class=\"n\">is_open_inter</span> <span class=\"n\">oV</span> <span class=\"n\">oUt</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n      <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">finset.coe_insert</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">union_singleton</span><span class=\"o\">,</span> <span class=\"n\">union_subset_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">subset_union_of_subset_left</span> <span class=\"n\">aU</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n          <span class=\"n\">subset_union_of_subset_right</span> <span class=\"o\">(</span><span class=\"n\">set.singleton_subset_iff.mpr</span> <span class=\"n\">bVy</span><span class=\"o\">)</span> <span class=\"n\">U</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">subset_inter_iff.mpr</span> <span class=\"o\">⟨</span><span class=\"n\">bV</span><span class=\"o\">,</span> <span class=\"n\">aUt</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">union_inter_distrib_right</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.inter_assoc</span><span class=\"o\">,</span> <span class=\"n\">UV</span><span class=\"o\">,</span> <span class=\"n\">set.empty_inter</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">set.empty_union</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">set.inter_comm</span> <span class=\"n\">V</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">set.inter_assoc</span><span class=\"o\">,</span> <span class=\"n\">set.inter_comm</span> <span class=\"n\">_</span> <span class=\"n\">Ut</span><span class=\"o\">,</span> <span class=\"n\">UtVy</span><span class=\"o\">,</span> <span class=\"n\">set.empty_inter</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220135235,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608135101
    },
    {
        "content": "<p>I was indeed going to say that this solution does not look prettier than what I had before, but I also have not polished it as much!  By \"proof irrelevance\", I am tempted to maintain the older version, if you agree!  Especially since it already develops a little API around <code>separate</code>.</p>\n<p>I will change the name <code>separate</code> to <code>separated</code> and make it take <code>set</code>s instead of <code>finsets</code> as inputs.</p>\n<p>After that, I will read again your comments and see what else I missed!</p>",
        "id": 220135735,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608135227
    },
    {
        "content": "<p>I do run into the issue of converting a <code>finset</code> into a <code>set</code>: is there a standard way?</p>",
        "id": 220136913,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608135673
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 220137285,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1608135833
    },
    {
        "content": "<p>This seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span>  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 220137498,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608135916
    },
    {
        "content": "<p>There seems to be a coercion:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">s</span>\n</code></pre></div>",
        "id": 220137800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608136051
    },
    {
        "content": "<p>I tried with the uparrow, but it did not seem to work for me...</p>",
        "id": 220137924,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136087
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"bp\">↑</span><span class=\"n\">s</span>\n</code></pre></div>",
        "id": 220138032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608136133
    },
    {
        "content": "<p>Ah, if I tell Lean what Type it should have, it works!  Thanks!</p>",
        "id": 220138112,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136163
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">disjoint</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">separated</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(Now separated takes <code>sets</code> as inputs)</p>",
        "id": 220138177,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136188
    },
    {
        "content": "<p>You could also state this as a theorem about <code>finite</code> sets</p>",
        "id": 220138502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136296
    },
    {
        "content": "<p>if you don't use anything about the finset besides the fact that it coerces to set</p>",
        "id": 220138542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136313
    },
    {
        "content": "<p>Ah, I have always glossed over the distinction between <code>finsets</code> and <code>finite</code>.  Maybe this is the time to correct this!</p>\n<p>I am doing an <code>finset.induction_on</code>, though: this feels like it will be a problem...</p>",
        "id": 220138812,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136419
    },
    {
        "content": "<p>you can probably use <code>finite.induction_on</code> then</p>",
        "id": 220138930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136464
    },
    {
        "content": "<p>Actually, it would be nice if you could prove this without induction, it will probably be a lot shorter</p>",
        "id": 220138965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136487
    },
    {
        "content": "<p>I initially wanted to directly define the intersections over all open sets given by the <code>t2_separation</code>, but I had bad memories of using the <code>big_operators</code> and opted for reducing everything to pairwise intersections/unions...</p>",
        "id": 220139138,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136570
    },
    {
        "content": "<p>I can very well see that if I knew how to use the <code>big_operators</code>, I could do this directly, instead of by induction...</p>",
        "id": 220139194,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136606
    },
    {
        "content": "<p>You don't need big ops here, this is a big union which uses the basic set library</p>",
        "id": 220139214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136616
    },
    {
        "content": "<p>in any case, with the coercion, it only occupies one more line than before!</p>",
        "id": 220139244,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136634
    },
    {
        "content": "<p>Ah, I remember now: my issue was getting the \"choice\" function for the t2_separation on all pairs of points.  That is what stumped me.</p>\n<p>And I confess that, while I proved the lemmas that Patrick suggested earlier, I did not really understand the <code>option/get/some</code> stuff...</p>",
        "id": 220139428,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608136721
    },
    {
        "content": "<p>It might also be nice to have a version of the separation axiom that says that given <code>x, y</code> distinct there is <code>x \\in U</code> such that <code>y \\notin closure U</code></p>",
        "id": 220139486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136751
    },
    {
        "content": "<p>that means one less set to deal with</p>",
        "id": 220139505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136761
    },
    {
        "content": "<p>You don't really need that here - since you are local to a single proof you can use the <code>choice</code> tactic to make the function on the spot</p>",
        "id": 220139653,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608136820
    },
    {
        "content": "<p>As usual, I like your suggestions!  However, I prefer to keep the PR as it is now and think about what else to add later.  Does this seem reasonable?</p>",
        "id": 220141061,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608137533
    },
    {
        "content": "<p>(Btw, I also pushed the latest version of <a href=\"https://github.com/leanprover-community/mathlib/issues/5332\">#5332</a>.  This version now has <code>separated</code> instead of <code>separate</code> and the inputs are two <code>sets</code> instead of two <code>finsets</code>.  Everything else is essentially the same!)</p>",
        "id": 220141211,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608137609
    },
    {
        "content": "<p>Todo (as per Patrick's comment):</p>\n<ol>\n<li>add the two induction principles (probably a separate PR);</li>\n<li>add lemma for separating one point from a <code>finset</code> (this should be easy, but I may not have time to do it now: it might appear in the next iteration of this PR);</li>\n<li>change <code>is_open_union</code> to <code>is_open.union</code> and compress using projection notation.  Similarly for <code>is_open_inter</code>, <code>is_closed_union</code>, <code>is_closed_inter</code> (again, this is probably a separate PR).</li>\n</ol>",
        "id": 220141693,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608137861
    },
    {
        "content": "<p>Which of these two version is \"better\"?  Does it make a difference?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">point_disjoint_finset_opens_of_t2</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">separated</span> <span class=\"o\">(({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">finset_disjoint_finset_opens_of_t2</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">singleton_disjoint.mpr</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">point_disjoint_finset_opens_of_t2</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">separated</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↑</span><span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">coe_singleton</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">finset_disjoint_finset_opens_of_t2</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">singleton_disjoint.mpr</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220142945,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608138379
    },
    {
        "content": "<p>Also consider</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">point_disjoint_finset_opens_of_t2</span> <span class=\"o\">[</span><span class=\"n\">t2_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">separated</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 220143298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138551
    },
    {
        "content": "<p>even better, prove that if <code>separated (s i) t</code> for all <code>i</code>, then <code>separated (\\bigcup i, s i) t</code>, and <code>separated</code> is symmetric, without a <code>t2_space</code> assumption</p>",
        "id": 220143583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138691
    },
    {
        "content": "<p>Then, you can apply those two facts (and <code>separated {x} {y}</code> in a <code>t2_space</code>) to directly prove that finite sets are separated in a <code>t2_space</code></p>",
        "id": 220143676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138732
    },
    {
        "content": "<p>actually you should follow the lead of these topology theorems in your statement of finite unions and intersections:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_open_bInter</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"bp\">∈</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"bp\">⋂</span><span class=\"n\">i</span><span class=\"bp\">∈</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite.induction_on</span> <span class=\"n\">hs</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">bInter_empty</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_open_univ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hs</span> <span class=\"n\">ih</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">bInter_insert</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n    <span class=\"n\">is_open_inter</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mem_insert</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">hi</span><span class=\"o\">))))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_closed_bUnion</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">finite</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">i</span><span class=\"bp\">∈</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">is_closed</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span><span class=\"n\">i</span><span class=\"bp\">∈</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">finite.induction_on</span> <span class=\"n\">hs</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">bUnion_empty</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_closed_empty</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hs</span> <span class=\"n\">ih</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">bUnion_insert</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n    <span class=\"n\">is_closed_union</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mem_insert</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">hi</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">mem_insert_of_mem</span> <span class=\"n\">_</span> <span class=\"n\">hi</span><span class=\"o\">))))</span>\n</code></pre></div>",
        "id": 220143827,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138822
    },
    {
        "content": "<p>These lemmas are already in the PR: mathematically, they seem equivalent to what you are saying, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[symm]</span> <span class=\"kd\">lemma</span> <span class=\"n\">symm</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">separated</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">separated</span> <span class=\"n\">t</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">union_left</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">separated</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">separated</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">separated</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∪</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 220144064,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608138927
    },
    {
        "content": "<p>the first one yes, the second one not quite</p>",
        "id": 220144102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138951
    },
    {
        "content": "<p>(the assumptions are that alpha is a topological space, no t2 assumption)</p>",
        "id": 220144166,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608138964
    },
    {
        "content": "<p>I mean the left side should be a finite union</p>",
        "id": 220144175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138967
    },
    {
        "content": "<p>not a binary union</p>",
        "id": 220144197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608138978
    },
    {
        "content": "<p>Ok, I replaced the finite union by the finset.induction part...</p>",
        "id": 220144215,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608138989
    },
    {
        "content": "<p>As the two topology proofs show, it should not be more than a few lines to get from the binary version to the finite union version</p>",
        "id": 220144289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608139023
    },
    {
        "content": "<p>In any case, it is now time for me to get to my \"life outside Lean\"!  I will take a look at what happens here later!</p>\n<p>Thank you very much!</p>",
        "id": 220144357,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1608139058
    },
    {
        "content": "<p>There is life outside Lean??</p>",
        "id": 220145982,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608139740
    }
]
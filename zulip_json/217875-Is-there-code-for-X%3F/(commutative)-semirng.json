[
    {
        "content": "<p>Is there already a definition of a type with two operations, addition and multiplication, that is just like a <code>semiring</code>, except that it does not need to have a unit for multiplication.  I do not mind if multiplication is commutative, although it is in my intended application.  I looked for <code>semirng</code> (as well as <code>semring</code> and <code>semrng</code>), but did not find anything.</p>",
        "id": 219768640,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877175
    },
    {
        "content": "<p>Nevermind, I think that <code>add_comm_monoid</code> is what I want.</p>",
        "id": 219768957,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877667
    },
    {
        "content": "<p>This doesn't have a multipication</p>",
        "id": 219768962,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607877684
    },
    {
        "content": "<p>Ah, so I am misunderstanding this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- An additive commutative monoid is an additive monoid with commutative `(+)`. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor add_monoid add_comm_semigroup]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">add_monoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">add_comm_semigroup</span> <span class=\"n\">M</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">comm_monoid</span>\n</code></pre></div>\n<p>I thought that the <code>add_monoid</code> and <code>add_comm_semigroup</code> implied different operations.  Is this not the case?</p>",
        "id": 219769025,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877778
    },
    {
        "content": "<p>(The doc_string seems contradicting what I think)</p>",
        "id": 219769032,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877796
    },
    {
        "content": "<p>So, I guess that I would like two <code>add_comm</code> structures, one of which is a monoid, and a distributive law.</p>",
        "id": 219769112,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877905
    },
    {
        "content": "<p>the <code>to_additive</code> thing is a metaprogramming trick that takes something like the class <code>comm_monoid</code> and automatically makes <code>add_comm_monoid</code>.</p>",
        "id": 219769114,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607877911
    },
    {
        "content": "<p>But a priori there is no relationship between <code>comm_monoid</code> and <code>add_comm_monoid</code>.</p>",
        "id": 219769115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607877911
    },
    {
        "content": "<p>ah, so I could build one like what i want by piling up two <code>add</code> structures and if I <em>do not</em> put the <code>to_additive</code> they would be a <code>+</code> and a <code>*</code>?</p>",
        "id": 219769181,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607877977
    },
    {
        "content": "<p>E.g. look at the source for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/comm_monoid/src\">src#comm_monoid</a></p>",
        "id": 219769183,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607877983
    },
    {
        "content": "<p>I think what you want is a class that extends <code>add_comm_monoid</code> and the (nonexistent, as far as I know) <code>semigroup_with_zero</code> and the class that ensures distributivity of <code>+</code> and <code>*</code> that I can't remember the name of right now...</p>",
        "id": 219769217,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878064
    },
    {
        "content": "<p><code>distrib</code> should be the distributive property:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A typeclass stating that multiplication is left and right distributive</span>\n<span class=\"sd\">over addition. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor has_mul has_add]</span>\n<span class=\"kd\">class</span> <span class=\"n\">distrib</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">has_add</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 219769276,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878124
    },
    {
        "content": "<p>I am happy to assume comm_semigroup_with_zero, but I <em>really</em> do not have a unit for multiplication: I want to put this structure on <code>finset</code>s.</p>",
        "id": 219769349,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878216
    },
    {
        "content": "<p>Oh, BTW my explanation of <code>to_additive</code> is probably not 100% correct. It looks like <code>add_comm_monoid</code> is actually declared explicitly with a <code>to_additive</code> declaration right after to connect it to <code>comm_monoid</code>. I guess <code>to_additive</code> makes some of the API for you.</p>",
        "id": 219769351,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878217
    },
    {
        "content": "<p>semigroups don't have units IIRC</p>",
        "id": 219769366,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878257
    },
    {
        "content": "<p>Ok, thanks for the correction: I know so little of this, at the moment, that I had filed it in my head as \"there is a system to keep track of whether you call it <code>+</code> or <code>*</code>\"!</p>",
        "id": 219769382,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878282
    },
    {
        "content": "<p>That's not <code>to_additive</code>, that's this <code>add_</code> stuff</p>",
        "id": 219769389,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878301
    },
    {
        "content": "<p>The classes with <code>add_</code> in their name are built on top of <code>+</code>, the ones without are built on <code>*</code></p>",
        "id": 219769441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878343
    },
    {
        "content": "<p>ok, so by default, an operation is <code>*</code>, unless is it declared with a <code>add_</code> and then it is a <code>+</code>, right?</p>",
        "id": 219769444,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878357
    },
    {
        "content": "<p>I think <code>to_additive</code> takes lemmas of the form <code>mul_foo</code> and automatically makes lemmas of the form <code>add_foo</code>, if I understand what Reid is saying here...</p>",
        "id": 219769459,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878384
    },
    {
        "content": "<p>I was typing my comment, while you were explaining yours, thanks!)</p>",
        "id": 219769460,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878384
    },
    {
        "content": "<p>right, <code>to_additive</code> is some automation which means we don't have to duplicate everything between the additive and multiplicative versions by hand</p>",
        "id": 219769479,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878435
    },
    {
        "content": "<p>so you have to tell lean that it should generate the <code>add_foo</code> lemmas for <code>add_comm_monoid</code> using the <code>mul_foo</code> lemmas for <code>comm_monoid</code>, and that's the <code>to_additive</code> declaration that we noticed above.</p>",
        "id": 219769518,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878443
    },
    {
        "content": "<p>So, I think you want to extend <code>add_comm_group</code>, <code>semigroup</code> and <code>distrib</code>... that will imply <code>0 * x = x * 0 = 0</code> already, right?</p>",
        "id": 219769533,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878484
    },
    {
        "content": "<p>I guess you can also add <code>monoid_with_zero</code> just in case</p>",
        "id": 219769542,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878503
    },
    {
        "content": "<p>Yes. but he doesn't have negation and that's not true for additive monoids</p>",
        "id": 219769552,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878516
    },
    {
        "content": "<p>oh I missed \"semi\"</p>",
        "id": 219769558,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878528
    },
    {
        "content": "<p>Yes, negation I also want to avoid.</p>",
        "id": 219769565,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878547
    },
    {
        "content": "<p>oh then there might not be any combination which does exactly what you want</p>",
        "id": 219769569,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878554
    },
    {
        "content": "<p>You can't actually use <code>monoid_with_zero</code> because it implies <code>monoid</code></p>",
        "id": 219769616,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878580
    },
    {
        "content": "<p>Yeah, this is why I was suggesting the <code>semigroup_with_zero</code> class <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 219769618,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607878581
    },
    {
        "content": "<p><code>semigroup</code> is such a hard name for category theorists <span aria-label=\"head bandage\" class=\"emoji emoji-1f915\" role=\"img\" title=\"head bandage\">:head_bandage:</span></p>",
        "id": 219769625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878601
    },
    {
        "content": "<p>well, if it is only the <code>with_zero</code> part that is missing, I can add the two axioms <code>zero_mul</code> and <code>mul_zero</code>, right?</p>",
        "id": 219769645,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878648
    },
    {
        "content": "<p>oh <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_zero_class\">docs#mul_zero_class</a></p>",
        "id": 219769652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878674
    },
    {
        "content": "<p>What goofy names... <code>mul_zero_class</code> and <code>distrib</code></p>",
        "id": 219769692,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607878685
    },
    {
        "content": "<p>so, <code>extends add_comm_monoid, semigroup, distrib, mul_zero_class</code>?</p>",
        "id": 219769697,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878697
    },
    {
        "content": "<p>I will try it and see if I can pull it off!</p>",
        "id": 219769713,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607878721
    },
    {
        "content": "<p>Just to avoid being stuck for silly reasons: proving the <code>instance</code> should simply be a matter of following my nose, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">semirng</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">semigroup</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">distrib</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_class</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">semirng</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 219769940,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879038
    },
    {
        "content": "<p>If all the other structures are on <code>finset</code> then it might be a matter of <code>by apply_instance</code>. If it isn't then you can make the other structures first. But this might be one of those places where some people don't want those instances, so maybe it should be a <code>def</code> instead.</p>",
        "id": 219770014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607879115
    },
    {
        "content": "<p>I assume this is the semiring structure given by the lattice structure?</p>",
        "id": 219770016,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879117
    },
    {
        "content": "<p>Yes, union=+ and intersection=*.</p>",
        "id": 219770018,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879147
    },
    {
        "content": "<p>Umm... addition is symmetric difference no?</p>",
        "id": 219770062,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879167
    },
    {
        "content": "<p>Ah, I had union in mind...</p>",
        "id": 219770067,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879191
    },
    {
        "content": "<p>It is not the boolean-ish algebra that I want</p>",
        "id": 219770073,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879208
    },
    {
        "content": "<p>If there are two natural choices for addition then probably you don't want anything to be an instance, because then everyone who wants the other one is stuck with it</p>",
        "id": 219770080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607879238
    },
    {
        "content": "<p>This is essentially a direct sum of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"bold\">Z</mi><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\mathbf{Z}/2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbf\">Z</span></span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span> indexed by the type</p>",
        "id": 219770081,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879240
    },
    {
        "content": "<p>where you identify a finite set with its indicator function.</p>",
        "id": 219770087,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879274
    },
    {
        "content": "<p>In what I want, once an element is in, it will never go out</p>",
        "id": 219770128,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879286
    },
    {
        "content": "<p>(with addition, you can remove it with intersections, of course)</p>",
        "id": 219770133,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879301
    },
    {
        "content": "<p>Is that distributive?</p>",
        "id": 219770136,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879315
    },
    {
        "content": "<p>I thought that it was distributive \"both ways\"</p>",
        "id": 219770149,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879350
    },
    {
        "content": "<p>Yeah you're probably right</p>",
        "id": 219770157,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879378
    },
    {
        "content": "<p>This already basically exists as <code>distrib_lattice</code></p>",
        "id": 219770158,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607879385
    },
    {
        "content": "<p>it is according to wikipedia:<br>\n<a href=\"https://en.wikipedia.org/wiki/Algebra_of_sets\">https://en.wikipedia.org/wiki/Algebra_of_sets</a></p>",
        "id": 219770163,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879394
    },
    {
        "content": "<p>Ah, I will look at distributive lattice then!</p>",
        "id": 219770207,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879417
    },
    {
        "content": "<p>(the name sounds good)</p>",
        "id": 219770210,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879425
    },
    {
        "content": "<p>Yeah it's clearly distribute. But I agree with what Kevin said above, because as far as I know the \"standard\" way to define a (semi)ring structure from a boolean algebra is by letting addition be the symmetric difference.</p>",
        "id": 219770231,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607879495
    },
    {
        "content": "<p>Ok, it is simply that for doing \"induction\", unions is what I need, rather than symmetric differences</p>",
        "id": 219770301,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879587
    },
    {
        "content": "<p>I will not make an instance, and I will check out <code>distrib_lattice</code></p>",
        "id": 219770317,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∪</mo></mrow><annotation encoding=\"application/x-tex\">\\cup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∪</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∩</mo></mrow><annotation encoding=\"application/x-tex\">\\cap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">∩</span></span></span></span> are \"builtin\" notation for mathematicians when using sets, but lattice theory is a generalisation of this stuff and the notation used is these square <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊓</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcap</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊓</span></span></span></span> stuff. It is actually a <strong>pain</strong> that set theory in Lean sticks to this set union and intersection notation. When ideals were defined and given a lattice structure, the lattice notation was used, and initially I was shocked that I was supposed to write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>≤</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I\\leq J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi><mo>⊆</mo><mi>J</mi></mrow><annotation encoding=\"application/x-tex\">I\\subseteq J</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span></span></span></span>, but now actually I see the benefits of this: we are using lots of different notations for lattice notation in various situations when we're dealing with lattices which we don't perceive as lattices, e.g. the subgroup generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>⊔</mo><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">H\\sqcup K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊔</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> in Lean. Sticking to lattice notation everywhere is a good convention, I think.</p>",
        "id": 219770506,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607879888
    },
    {
        "content": "<p>Good, I will follow the convention!  How do I type the square union and intersection?</p>",
        "id": 219770520,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879963
    },
    {
        "content": "<p>(hovering in VSCode answers my question \\lub)</p>",
        "id": 219770533,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607879996
    },
    {
        "content": "<p><del>So, I should define inclusion of sets, rather than union.  Have I understood correctly?</del>  I am slightly confused.</p>",
        "id": 219770591,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607880103
    },
    {
        "content": "<p>I agree with what Kevin said about the union intersection notation, but just one small comment. I would argue that addition being defined as symmetric difference is the only reasonable choice. For example if you work in a finite type, then the structure you get is a ring if you use symmetric difference, but not if you use union.</p>",
        "id": 219770680,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607880243
    },
    {
        "content": "<p>I thought that this would have worked, but Lean does not want me to use neither ⊔ nor ∪.  I suspect that you already told me what I should do, but I did not understand it...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">finset_lattice</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">distrib_lattice</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">⊔</span> <span class=\"n\">b</span><span class=\"o\">),</span>   <span class=\"c1\">-- failed to instantiate goal with fun (a : 4._.40) (b : 4._.41), ((frozen_name has_sup.sup) a b)</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219770793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607880430
    },
    {
        "content": "<p>ooh, what a fun error message</p>",
        "id": 219770808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607880478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219770680\">said</a>:</p>\n<blockquote>\n<p>I agree with what Kevin said about the union intersection notation, but just one small comment. I would argue that addition being defined as symmetric difference is the only reasonable choice. For example if you work in a finite type, then the structure you get is a ring if you use symmetric difference, but not if you use union.</p>\n</blockquote>\n<p>Ok, I will use this \"simple-minded union\" structure sparingly!</p>",
        "id": 219770846,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607880500
    },
    {
        "content": "<p>Don't we have this? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.distrib_lattice\">docs#finset.distrib_lattice</a></p>",
        "id": 219770931,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607880673
    },
    {
        "content": "<p>note the <code>decidable_eq</code> requirement</p>",
        "id": 219770937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607880701
    },
    {
        "content": "<p>Thanks!  I opened the classical locale and now Lean is having more <code>fun</code>: thanks!</p>",
        "id": 219770981,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607880740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219770931\">said</a>:</p>\n<blockquote>\n<p>Don't we have this? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.distrib_lattice\">docs#finset.distrib_lattice</a></p>\n</blockquote>\n<p>I will try to do it by hand first, and then compare with what is already in mathlib, just to get some practice.  Thanks for the pointer, though!</p>",
        "id": 219770994,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607880787
    },
    {
        "content": "<p>My only issue with lattice notation is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊔</mo></mrow><annotation encoding=\"application/x-tex\">\\sqcup</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.55556em;vertical-align:0em;\"></span><span class=\"mord\">⊔</span></span></span></span> is disjoint union in my mind. But I got used to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊕</mo></mrow><annotation encoding=\"application/x-tex\">\\oplus</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊕</span></span></span></span></p>",
        "id": 219771535,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607881633
    },
    {
        "content": "<p>Is it possible to see the name of each field that I am trying to prove?  For instance, the first one asks to produce something with type <code>finset X \\to finset X \\to finset X</code>.  I \"guessed\" that it was the union.  Others later on are similarly ambiguous.  Is there a way to know what name each property has?</p>",
        "id": 219774094,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607885247
    },
    {
        "content": "<p>(instead of type-checking myself and second guessing what I see that I will need to prove later on!)</p>",
        "id": 219774102,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607885269
    },
    {
        "content": "<p>If you type <code>{! }</code> where you are supposed to construct a structure, a little light bulb will show on. If you click on the light bulb and select <code>generate a skeleton for the structure under construction</code>, it will give you the name of the different fields.</p>",
        "id": 219774178,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1607885370
    },
    {
        "content": "<p>Wow: this is great!!!  Thank you <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> !</p>",
        "id": 219774336,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607885566
    },
    {
        "content": "<p>Actually you can just use <code>_</code></p>",
        "id": 219774569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607885911
    },
    {
        "content": "<p>I had never thought of clickling the yellow light-bulbs<br>\n<span aria-label=\"light bulb\" class=\"emoji emoji-1f4a1\" role=\"img\" title=\"light bulb\">:light_bulb:</span></p>",
        "id": 219774866,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607886285
    },
    {
        "content": "<p>To get some practice, I thought that I would define a new structure <code>sus</code> on subsets of a set, just like <code>topological_space</code>, except that I drop the requirement of arbitrary unions and only allow finite unions.  (The definition only involves pairwise unions, although, as a mathematician, I still feel a bit funny having to specify this!  As a consequence, for those who, like me, think often about the empty set, this implies that I need to add the hypothesis that <code>∅</code> is in my collection of sets, since I can no longer take the empty union.)</p>\n<p>Thus, <code>sus</code> with <code>+ = ∪</code> and <code>* = ∩</code> is a <code>comm_semiring</code>, which is where I am headed.  This <code>comm_semiring</code> structure is also the structure that I want to put on \"<code>finsets with univ</code>\".</p>\n<p>I copied the beginning of the <code>topology/basic</code> file and started changing as needed.  When I got to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">topological_space_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_open</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_open</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n<p>I got completely stuck.  I can understand the statement: if two instances of topological space on the same type have the same open sets, then they agree.  However, the proof in indecipherable to me.  Can anyone give me some guidance or even simply a proof?  Below is the code that I have so far.  Feel free to give more advice!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"sd\">/-- A `sus` on `α`. -/</span>\n<span class=\"kd\">@[protect_proj]</span> <span class=\"kd\">structure</span> <span class=\"n\">sus</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_su</span>       <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_univ</span>  <span class=\"o\">:</span> <span class=\"n\">is_su</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_su</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_inter</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_su</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_su</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">class</span><span class=\"o\">]</span> <span class=\"n\">sus</span>  <span class=\"c1\">--I do not know what this does, but it was there</span>\n\n<span class=\"sd\">/-- A constructor for `sus` using complements of the given `sus` structure. -/</span>\n<span class=\"c1\">-- this definition is not relevant to what I care about: I simply say that if I have a ```sus```, then the collection of complements also forms a ```sus```</span>\n<span class=\"kd\">def</span> <span class=\"n\">sus.comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_su</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f.is_su</span> <span class=\"n\">X</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n  <span class=\"n\">is_su_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sus.is_su_empty</span><span class=\"o\">],</span>\n  <span class=\"n\">is_su_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sus.is_su_univ</span><span class=\"o\">],</span>\n  <span class=\"n\">is_su_inter</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">compl_inter</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">sus.is_su_union</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n  <span class=\"n\">is_su_union</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">compl_union</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">sus.is_su_inter</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">sus</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- this was the proof for topological spaces</span>\n<span class=\"c1\">-- | ⟨a, _, _, _, _⟩ ⟨b, _, _, _, _⟩ rfl := rfl</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219810226,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607933601
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- this was the proof for topological spaces</span>\n<span class=\"c1\">-- | ⟨a, _, _, _, _⟩ ⟨b, _, _, _, _⟩ rfl := rfl</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">f_is_su</span><span class=\"o\">,</span> <span class=\"n\">f_is_su_univ</span><span class=\"o\">,</span> <span class=\"n\">f_is_su_empty</span><span class=\"o\">,</span> <span class=\"n\">f_is_su_inter</span><span class=\"o\">,</span> <span class=\"n\">f_is_su_union</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">g_is_su</span><span class=\"o\">,</span>\n <span class=\"n\">g_is_su_univ</span><span class=\"o\">,</span>\n <span class=\"n\">g_is_su_empty</span><span class=\"o\">,</span>\n <span class=\"n\">g_is_su_inter</span><span class=\"o\">,</span>\n <span class=\"n\">g_is_su_union</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟩,</span><span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219810917,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607934135
    },
    {
        "content": "<p>The first part was generated by <code>rintros?</code></p>",
        "id": 219810934,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607934161
    },
    {
        "content": "<p>Thanks!  I will try it!</p>",
        "id": 219810972,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607934206
    },
    {
        "content": "<p>I am not sure if this makes it clearer or opaquer, but also what is below works.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟩,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219811140,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607934333
    },
    {
        "content": "<p>If you do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[protect_proj, ext]</span> <span class=\"kd\">structure</span> <span class=\"n\">sus</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>lean will generate a lemma <code>sus.ext</code> and <code>sus.ext_iff</code> for you</p>",
        "id": 219811295,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607934482
    },
    {
        "content": "<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>",
        "id": 219811525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607934619
    },
    {
        "content": "<p>Thank you both!</p>\n<p>Indeed, with <br>\n<code>@[protect_proj, ext] structure sus (α : Type*) :=</code><br>\nthe proof is simply <code>sus.ext</code>.</p>\n<p>Otherwise, <code>cases</code> all the way reduces the proof to <code>refl</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219811830,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607934805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219811525\">said</a>:</p>\n<blockquote>\n<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>\n</blockquote>\n<p>What does \"equation compiler\" mean?  Is it what you see when you use <code>show_term</code>?</p>",
        "id": 219811953,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607934870
    },
    {
        "content": "<p>The equation compiler proof is the first one you mentioned:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">topological_space_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_open</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_open</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 219812534,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1607935257
    },
    {
        "content": "<p>Ah, thanks!  I am also seeing through this proof more.  However, now I do not understand why is what is below not a proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>  <span class=\"c1\">-- invalid expression\\\\ command expected</span>\n</code></pre></div>\n<p>While this one is?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨⟩,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 219813187,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607935685
    },
    {
        "content": "<p>you probably need <code>rfl</code> instead of <code>⟨⟩</code> in the first version</p>",
        "id": 219813591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607935965
    },
    {
        "content": "<p>you can also use <code>⟨_⟩</code></p>",
        "id": 219813724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936048
    },
    {
        "content": "<p>because the constructor of <code>eq</code> is <code>eq.refl</code> which has one explicit argument</p>",
        "id": 219813745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936066
    },
    {
        "content": "<p><code>rintro</code> doesn't really care if you don't give it enough arguments:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span> <span class=\"o\">⟨⟩</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n</code></pre></div>",
        "id": 219813809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936129
    },
    {
        "content": "<p>I tried with </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>  <span class=\"c1\">-- invalid expression \\\\ command expected</span>\n</code></pre></div>\n<p>and it does not work.  In any case, I have enough proofs of a completely trivial result that the computer can even figure out on its own!  I was just curious about the proof style with <code>|</code> that I had never seen before, hence my curiousity!</p>",
        "id": 219814287,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607936445
    },
    {
        "content": "<p>The following compiles for me with no errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">order.filter.ultrafilter</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.filter.partial</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span> <span class=\"n\">filter</span>\n\n<span class=\"sd\">/-- A `sus` on `α`. -/</span>\n<span class=\"kd\">@[protect_proj]</span> <span class=\"kd\">structure</span> <span class=\"n\">sus</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_su</span>       <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_univ</span>  <span class=\"o\">:</span> <span class=\"n\">is_su</span> <span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_empty</span> <span class=\"o\">:</span> <span class=\"n\">is_su</span> <span class=\"bp\">∅</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_inter</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_su</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∩</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">is_su_union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">is_su</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">is_su</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"n\">t</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">class</span><span class=\"o\">]</span> <span class=\"n\">sus</span>  <span class=\"c1\">--I do not know what this does, but it was there</span>\n\n<span class=\"sd\">/-- A constructor for `sus` using complements of the given `sus` structure. -/</span>\n<span class=\"c1\">-- this definition is not relevant to what I care about: I simply say that if I have a ```sus```, then the collection of complements also forms a ```sus```</span>\n<span class=\"kd\">def</span> <span class=\"n\">sus.comp</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_su</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f.is_su</span> <span class=\"n\">X</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span>\n  <span class=\"n\">is_su_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sus.is_su_empty</span><span class=\"o\">],</span>\n  <span class=\"n\">is_su_empty</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sus.is_su_univ</span><span class=\"o\">],</span>\n  <span class=\"n\">is_su_inter</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">compl_inter</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">sus.is_su_union</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n  <span class=\"n\">is_su_union</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">compl_union</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">sus.is_su_inter</span> <span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"n\">t</span><span class=\"bp\">ᶜ</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">sus</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">p₁</span> <span class=\"n\">p₂</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n\n<span class=\"kd\">@[ext]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">sus_eq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">sus</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">f.is_su</span> <span class=\"bp\">=</span> <span class=\"n\">g.is_su</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"n\">rfl</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 219814446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936534
    },
    {
        "content": "<p>Oh, you still have the <code>:=</code> on the first line</p>",
        "id": 219814490,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936574
    },
    {
        "content": "<p>when you use an equation compiler proof you have to take that off</p>",
        "id": 219814524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936594
    },
    {
        "content": "<p>Ah, I was puzzled by the fact that yours compiled, while mine did not.  I had taken no notice of the <code>:=</code></p>",
        "id": 219814567,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607936618
    },
    {
        "content": "<p>so then, why the <code>a</code> and <code>b</code>?</p>",
        "id": 219814642,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607936645
    },
    {
        "content": "<p>it makes the intermediate state display a little nicer</p>",
        "id": 219814656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936661
    },
    {
        "content": "<p>I see</p>",
        "id": 219814716,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607936705
    },
    {
        "content": "<p>it's totally optional here</p>",
        "id": 219814726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607936717
    },
    {
        "content": "<p>Ok, I am understanding this proof a little better now.  At first, it looked like non-sense, now it suggests that the statement is entirely trivial!</p>",
        "id": 219814869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607936831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/(commutative)-semirng/near/219811525\">said</a>:</p>\n<blockquote>\n<p>To prove two instances of a structure are equal, do cases on them. Look at how I prove the ext lemma for complex numbers in the complex number game. The equation compiler proof is just doing cases.</p>\n</blockquote>\n<p>I am doing the Complex Numbers Game.  If you are interested, I found a couple of typos in <code>Level_00_basic.lean</code>.</p>",
        "id": 219817808,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1607938691
    },
    {
        "content": "<p>Open an issue on github and I'll deal with it one day.</p>",
        "id": 219818268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607939018
    }
]
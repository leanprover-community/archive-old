[
    {
        "content": "<p>Hey! I have a set <code>S : set $ set X</code> and I know that all elements of <code>S</code> are <code>finite</code>. Is there an easy way to get a minimal element of <code>S</code>?<br>\nEquivalently (I believe), is there something along the lines of <code>is_well_founded_on ({s : set X | s.finite}) (ssubset)</code> ?</p>\n<p>Actually, let me ensure I'm not falling into <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> : I have the following code (trying to deal with <a href=\"#narrow/stream/116395-maths/topic/Properties.20on.20.60fintype_inverse_systems.60\">this</a> ) and I want to drop the <code>fintype</code> assumption in favour of the one in the docstring (last lemma).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.filtered</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.category.Top.limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.finset.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.category.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.full_subcategory</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.types</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">prop_decidable</span>\n\n\n<span class=\"kd\">def</span> <span class=\"n\">category_theory.functor.eventual_range</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"bp\">⋂</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">category_theory.functor.is_mittag_leffler</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n             <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">i'</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f'</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.functor.is_mittag_leffler_iff_eventual_range</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F.is_mittag_leffler</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">F.eventual_range</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">category_theory.functor.eventual_range</span><span class=\"o\">],</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">There is probably a nice general argument along the lines of:</span>\n<span class=\"sd\">* If J is cofiltered, then so is J/j (the comma category) for any j.</span>\n<span class=\"sd\">* The functor F : J ⥤ Type v defines a functor J/j ⥤ (F.obj j) by sending (f : i ⟶ j) to set.range $ F.map f</span>\n<span class=\"sd\">* The image of a cofiltered category is cofiltered</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.functor.ranges_directed_of_is_cofiltered</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">directed_on</span> <span class=\"o\">(</span><span class=\"bp\">⊇</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">ij</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">kj</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"n\">is_cofiltered.min</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">li</span> <span class=\"o\">:=</span> <span class=\"n\">is_cofiltered.min_to_left</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">lk</span> <span class=\"o\">:=</span> <span class=\"n\">is_cofiltered.min_to_right</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">is_cofiltered.eq</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"bp\">≫</span> <span class=\"n\">ij</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lk</span> <span class=\"bp\">≫</span> <span class=\"n\">kj</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">ml</span> <span class=\"o\">:=</span> <span class=\"n\">is_cofiltered.eq_hom</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"bp\">≫</span> <span class=\"n\">ij</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lk</span> <span class=\"bp\">≫</span> <span class=\"n\">kj</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"bp\">$</span> <span class=\"n\">ml</span> <span class=\"bp\">≫</span> <span class=\"n\">li</span> <span class=\"bp\">≫</span> <span class=\"n\">ij</span><span class=\"o\">),</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">ml</span> <span class=\"bp\">≫</span> <span class=\"n\">li</span> <span class=\"bp\">≫</span> <span class=\"n\">ij</span><span class=\"o\">⟩,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">superset</span><span class=\"o\">],</span> <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">functor.map_comp</span><span class=\"o\">,</span> <span class=\"n\">types_comp</span><span class=\"o\">],</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">ij</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">li</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">ml</span> <span class=\"k\">with</span> <span class=\"n\">F.map</span> <span class=\"n\">ij</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">li</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">ml</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.range_comp_subset_range</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">dsimp</span> <span class=\"o\">[</span><span class=\"n\">superset</span><span class=\"o\">],</span>\n    <span class=\"n\">simp_rw</span> <span class=\"o\">[</span><span class=\"n\">category_theory.is_cofiltered.eq_condition</span><span class=\"o\">,</span> <span class=\"n\">functor.map_comp</span><span class=\"o\">,</span> <span class=\"n\">types_comp</span><span class=\"o\">],</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_cofiltered.eq_hom</span> <span class=\"o\">(</span><span class=\"n\">li</span> <span class=\"bp\">≫</span> <span class=\"n\">ij</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">lk</span> <span class=\"bp\">≫</span> <span class=\"n\">kj</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">ml</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">kj</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">lk</span><span class=\"o\">)</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">ml</span> <span class=\"k\">with</span> <span class=\"n\">F.map</span> <span class=\"n\">kj</span> <span class=\"bp\">∘</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">lk</span> <span class=\"bp\">∘</span> <span class=\"n\">F.map</span> <span class=\"n\">ml</span><span class=\"o\">),</span>\n    <span class=\"n\">apply</span> <span class=\"n\">set.range_comp_subset_range</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- Probably exists somewhere</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">directed_on_min</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">J</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">preorder</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">directed_on</span> <span class=\"o\">(</span><span class=\"bp\">≥</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">m</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"n\">xm</span><span class=\"o\">,</span> <span class=\"n\">xa</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">m</span> <span class=\"n\">H</span> <span class=\"n\">a</span> <span class=\"n\">as</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"n\">x</span> <span class=\"n\">xs</span> <span class=\"n\">xm</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">xa</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/--</span>\n<span class=\"sd\">With enough `well_founded`-fu, one could probably weaken the `fintype` hypothesis to</span>\n<span class=\"sd\">\\```</span>\n<span class=\"sd\">  ∀ (j i : J) (f : i ⟶ j), (set.range $ F.map f).finite</span>\n<span class=\"sd\">\\```</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">category_theory.functor.is_mittag_leffler_of_fintype</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">j</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">F.is_mittag_leffler</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟨</span><span class=\"n\">j</span><span class=\"o\">,</span><span class=\"mi\">𝟙</span> <span class=\"n\">j</span><span class=\"o\">⟩⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">function.argmin</span>\n             <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">))</span>\n             <span class=\"o\">(</span><span class=\"n\">finite.well_founded_of_trans_of_irrefl</span> <span class=\"n\">has_ssubset.ssubset</span><span class=\"o\">),</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f.1</span><span class=\"o\">,</span> <span class=\"n\">f.2</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i'</span> <span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">directed_on_min</span> <span class=\"o\">(</span><span class=\"n\">F.ranges_directed_of_is_cofiltered</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n         <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">))</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">_</span>\n         <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f'</span><span class=\"o\">))</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span><span class=\"n\">f'</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">klef</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">lt_or_eq_of_le</span> <span class=\"n\">klef</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">function.not_lt_argmin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 315213888,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670768731
    },
    {
        "content": "<p>I assume by minimal you mean something weaker than \"in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lower_bounds\">docs#lower_bounds</a>\"? otherwise <code>S := {{1, 2}, {2,3}]</code> is a problem.</p>",
        "id": 315214710,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670769067
    },
    {
        "content": "<p>Or did you also mean \"every finite set is in <code>S</code>\"?</p>",
        "id": 315214860,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670769159
    },
    {
        "content": "<p>Indeed, I need an element of the set with nothing below it, essentially.</p>",
        "id": 315214887,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670769170
    },
    {
        "content": "<p>Probably you want <code>set (finset \\a)</code>, rather?</p>",
        "id": 315232240,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670778043
    },
    {
        "content": "<blockquote>\n<p>∀ (j i : J) (f : i ⟶ j), (set.range $ <a href=\"http://F.map\">F.map</a> f).finite</p>\n</blockquote>\n<p>Notice that if you take <code>f</code> to be the identity you'd be able to show all <code>F.obj j</code> are finite from this. Maybe you want to assume <code>∀ j, ∃ i (f : i ⟶ j), (set.range $ F.map f).finite</code> instead.</p>\n<p>Also, <code>category_theory.functor.is_mittag_leffler_of_fintype</code> should use <code>finite</code> instead of <code>fintype</code>.</p>",
        "id": 315238202,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670781222
    },
    {
        "content": "<p>You should be able to deduce well-foundedness of <code>finset α</code> from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multiset.well_founded_lt\">docs#multiset.well_founded_lt</a> and the order embedding from <code>finset α</code> to <code>multiset α</code> (does this exist?).</p>",
        "id": 315238970,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670781617
    },
    {
        "content": "<p>I would guess the order embedding is trivial to construct but doesn't exist</p>",
        "id": 315239528,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670781915
    },
    {
        "content": "<p>The fact that we have that result for <code>multiset</code> suggests we should have it in mathlib for finset, XY problems aside</p>",
        "id": 315239577,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670781950
    },
    {
        "content": "<p>I was about to write the same thing!</p>",
        "id": 315239588,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670781957
    },
    {
        "content": "<p>The proof of the multiset lemma is a single line, <code>subrelation.wf (λ _ _, multiset.card_lt_of_lt) (measure_wf multiset.card)</code></p>",
        "id": 315239721,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670782013
    },
    {
        "content": "<p>I would guess you can directly copy that using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card_lt_of_ssubset\">docs#finset.card_lt_of_ssubset</a></p>",
        "id": 315239762,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670782037
    },
    {
        "content": "<p>... if that existed</p>",
        "id": 315239824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670782065
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.card_lt_card\">docs#finset.card_lt_card</a></p>",
        "id": 315240216,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670782240
    },
    {
        "content": "<p>The naming is all over the place.</p>",
        "id": 315240222,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670782247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315232240\">said</a>:</p>\n<blockquote>\n<p>Probably you want <code>set (finset \\a)</code>, rather?</p>\n</blockquote>\n<p>Well, I really wanted the set of <code>finite</code> sets since it's a range, but Junyan's comment makes me reconsider the stupidity of what I asked for</p>",
        "id": 315241196,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670782749
    },
    {
        "content": "<p>Re <code>finite</code> vs <code>fintype</code>: does that mean that <code>nonempty_section_of_fintype_inverse_system</code> should be corrected too?</p>",
        "id": 315241259,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670782793
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315241196\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315232240\">said</a>:</p>\n<blockquote>\n<p>Probably you want <code>set (finset \\a)</code>, rather?</p>\n</blockquote>\n<p>Well, I really wanted the set of <code>finite</code> sets since it's a range, but Junyan's comment makes me reconsider the stupidity of what I asked for</p>\n</blockquote>\n<p>Mmh, I think the proof would indeed work with the <code>\\forall j \\exists i (f : i \\--&gt; j), …</code> version</p>",
        "id": 315241825,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670783105
    },
    {
        "content": "<blockquote>\n<p>Hey! I have a set S : set $ set X and I know that all elements of S are finite. Is there an easy way to get a minimal element of S?</p>\n</blockquote>\n<p>Take an element of minimal cardinality?</p>",
        "id": 315247117,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1670786111
    },
    {
        "content": "<p>Seems going through finset is still easier because we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.finite.to_finset_ssubset\">docs#set.finite.to_finset_ssubset</a>.<br>\nBut we don't seem to have the fact that a strict subset of a finite set has strictly less cardinality (neither <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nat.card\">docs#nat.card</a> nor <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal.mk\">docs#cardinal.mk</a>).</p>",
        "id": 315251558,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670789034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/The.20set.20of.20finite.20sets.20is.20well-founded.3F/near/315247117\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Hey! I have a set S : set $ set X and I know that all elements of S are finite. Is there an easy way to get a minimal element of S?</p>\n</blockquote>\n<p>Take an element of minimal cardinality?</p>\n</blockquote>\n<p>Yeah, I'm probably gonna take this approach</p>",
        "id": 315287096,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670819560
    },
    {
        "content": "<p>I went with the following, which is not too bad as far as I can tell:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">category_theory.functor.is_mittag_leffler_of_exists_finite_range</span>\n  <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cofiltered</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"bp\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F.is_mittag_leffler</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n               <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f'.2</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n                 <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f'.2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span> <span class=\"n\">fmin</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i'</span> <span class=\"n\">f'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">directed_on_min</span> <span class=\"o\">(</span><span class=\"n\">F.ranges_directed_of_is_cofiltered</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">⟨⟨</span><span class=\"n\">i'</span><span class=\"o\">,</span><span class=\"n\">f'</span><span class=\"o\">⟩,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_range</span><span class=\"o\">,</span> <span class=\"n\">psigma.exists</span><span class=\"o\">,</span> <span class=\"n\">forall_exists_index</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">_</span> <span class=\"n\">k</span> <span class=\"n\">g</span> <span class=\"n\">rfl</span> <span class=\"n\">gf</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">fmin</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">g</span><span class=\"o\">⟩</span> <span class=\"n\">gf</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n\n  <span class=\"k\">let</span> <span class=\"n\">fins</span> <span class=\"o\">:=</span> <span class=\"n\">subtype</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Σ'</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">j</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">f.2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">},</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">fins</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">fin</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨⟨⟨</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">f</span><span class=\"o\">⟩,</span><span class=\"n\">fin</span><span class=\"o\">⟩⟩,</span> <span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">fmin</span> <span class=\"o\">:=</span> <span class=\"n\">function.argmin</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fins</span><span class=\"o\">),</span> <span class=\"n\">f.prop.to_finset.card</span><span class=\"o\">)</span> <span class=\"n\">nat.lt_wf</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">fmin.val</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">g</span> <span class=\"n\">gf</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">lt_or_eq_of_le</span> <span class=\"n\">gf</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"n\">gfin</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">F.map</span> <span class=\"n\">g.2</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span> <span class=\"n\">fmin.prop.subset</span> <span class=\"n\">gf</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fins</span><span class=\"o\">),</span> <span class=\"n\">f.prop.to_finset.card</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">not_lt_argmin</span> <span class=\"n\">nat.lt_wf</span> <span class=\"o\">⟨</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">gfin</span><span class=\"o\">⟩</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset.card_lt_card</span> <span class=\"o\">(</span><span class=\"n\">set.finite.to_finset_ssubset.mpr</span> <span class=\"n\">h_1</span><span class=\"o\">),</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">assumption</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 315298487,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1670827598
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/17950\">#17950</a></p>",
        "id": 315914221,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1671051809
    }
]
[
    {
        "content": "<p>Before coming to my actual <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a>, the following seems like it should be trivial to do:</p>\n<p>How should one interpret a nonzero complex number as a continuous linear automorphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>? For example, do we have something that achieves the second of the following two? For comparison, the first one is found by <code>library_search</code>, but it only interprets a nonzero complex number as a linear automorphism of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> without bundled continuity.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.schwarz</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"bp\">À£</span> <span class=\"bp\">‚Üí*</span> <span class=\"o\">(</span><span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚âÉ‚Çó</span><span class=\"o\">[</span><span class=\"n\">‚ÑÇ</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_module_aut</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">‚ÑÇ</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"bp\">À£</span> <span class=\"bp\">‚Üí*</span> <span class=\"o\">(</span><span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚âÉ</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">‚ÑÇ</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 281317504,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1651765637
    },
    {
        "content": "<p>The first <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> step for the above is that I'd like to have the following easy special case of the open mapping theorem, and I have trouble feeding into the inverse function theorem (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_strict_fderiv_at.to_local_homeomorph\">docs#has_strict_fderiv_at.to_local_homeomorph</a>) the fact that a non-zero complex derivative is an invertible fderivative:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.schwarz</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">metric</span> <span class=\"n\">function</span> <span class=\"n\">set</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_nhds_of_deriv_nonzero</span>\n  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">dg_nonzero</span> <span class=\"o\">:</span> <span class=\"n\">deriv</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dg_strict</span> <span class=\"o\">:</span> <span class=\"n\">has_strict_deriv_at</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">deriv</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">W_nhd</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">''</span> <span class=\"n\">W</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">dg_strict'</span> <span class=\"o\">:=</span> <span class=\"n\">dg_strict.has_strict_fderiv_at</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:=</span> <span class=\"n\">has_strict_fderiv_at.to_local_homeomorph</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- I'd like the next argument in `key` to be `dg_strict'`, but that</span>\n  <span class=\"c1\">-- is not a coercion of a continuous linear equivalence.</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 281317768,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1651765742
    },
    {
        "content": "<p>The main <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> is: do we have the open mapping theorem for nonconstant holomorphic functions (on a connected open set, say)?</p>",
        "id": 281317959,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1651765808
    },
    {
        "content": "<p>I guess yet another way of phrasing the question is: is there a <code>deriv</code>-version (as opposed to the <code>fderiv</code> formulation) of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_strict_fderiv_at.to_local_homeomorph\">docs#has_strict_fderiv_at.to_local_homeomorph</a>?</p>",
        "id": 281319643,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1651766439
    },
    {
        "content": "<p>You can do it with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.schwarz</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">metric</span> <span class=\"n\">function</span> <span class=\"n\">set</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">image_nhds_of_deriv_nonzero</span>\n  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g'</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hg'</span> <span class=\"o\">:</span> <span class=\"n\">g'</span> <span class=\"bp\">‚â†</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dg_strict</span> <span class=\"o\">:</span> <span class=\"n\">has_strict_deriv_at</span> <span class=\"n\">g</span> <span class=\"n\">g'</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">W_nhd</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">g</span> <span class=\"bp\">''</span> <span class=\"n\">W</span> <span class=\"bp\">‚àà</span> <span class=\"bp\">ùìù</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚âÉ</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">‚ÑÇ</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span> <span class=\"o\">:=</span>\n    <span class=\"o\">(</span><span class=\"n\">linear_map.linear_equiv_of_injective</span> <span class=\"o\">(</span><span class=\"n\">algebra.lmul_left</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">g'</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">algebra.lmul_left_injective</span> <span class=\"n\">hg'</span><span class=\"o\">)</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_continuous_linear_equiv</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">has_strict_fderiv_at</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">‚ÑÇ</span> <span class=\"bp\">‚Üí</span><span class=\"n\">L</span><span class=\"o\">[</span><span class=\"n\">‚ÑÇ</span><span class=\"o\">]</span> <span class=\"n\">‚ÑÇ</span><span class=\"o\">)</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">dg_strict.has_strict_fderiv_at</span><span class=\"o\">,</span>\n    <span class=\"n\">ext1</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">continuous_linear_equiv.coe_coe</span><span class=\"o\">,</span> <span class=\"n\">linear_equiv.coe_to_continuous_linear_equiv'</span><span class=\"o\">,</span>\n      <span class=\"n\">linear_map.linear_equiv_of_injective_apply</span><span class=\"o\">,</span> <span class=\"n\">algebra.lmul_left_apply</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n      <span class=\"n\">continuous_linear_map.smul_right_apply</span><span class=\"o\">,</span> <span class=\"n\">continuous_linear_map.one_apply</span><span class=\"o\">,</span>\n      <span class=\"n\">algebra.id.smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">‚Üê</span> <span class=\"n\">A.map_nhds_eq_of_equiv</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">filter.image_mem_map</span> <span class=\"n\">W_nhd</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>(where the ugly <code>simp only</code> is just to make things fast, but a plain <code>simp</code> works as well).</p>",
        "id": 281437263,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651843241
    },
    {
        "content": "<p>(I didn't know the name of <code>algebra.lmul_left</code>, but it was found for me by <code>suggest</code>).<br>\nAnd probably we could add some more API to make this easier, but the current situation is already not too bad I think.</p>",
        "id": 281437486,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651843327
    },
    {
        "content": "<p>(And a better way to phrase the conclusion of the lemma is probably to say <code>filter.map g (ùìù w) = ùìù (g w)</code>).</p>",
        "id": 281437659,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1651843409
    }
]
[
    {
        "content": "<p>Is there anything in mathlib to handle binary relations that are transitive and symmetric but not necessarily reflexive? Specifically, I'd like to construct the collection of 'equivalence classes', with disjointness, properties of transversals, etc etc. Clearly it's not rocket science to just do it myself, or even to reduce it to the equivalence relation case; I just don't want to reinvent any wheels.</p>",
        "id": 227516517,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614119577
    },
    {
        "content": "<p>I believe one has the construction of \"equivalence classes\" built in for any relation, equivalence or not, as <code>quot</code>.  I've never used it so am not 100% sure that it does what I think :). But see<br>\n<a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#quotients</a></p>",
        "id": 227520813,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614121659
    },
    {
        "content": "<p>Doesn't transitivity and symmetry imply reflexivity?</p>",
        "id": 227521806,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614122169
    },
    {
        "content": "<p>At least, on a non-empty relation</p>",
        "id": 227521832,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614122191
    },
    {
        "content": "<p>No - you can have singletons not related to anything. That’s it, though</p>",
        "id": 227522561,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614122633
    },
    {
        "content": "<p>I suggest using <code>quot</code> like Heather mentioned. The API is fairly pleasant to use</p>",
        "id": 227529061,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614126455
    },
    {
        "content": "<p>I don't think <code>quot</code> will work - from what I can see, it forgets the difference between elements on which the relation is irreflexive and ones where it is reflexive. I don't want irreflexive elements to give 'quotient' elements at all.</p>",
        "id": 227538582,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614133762
    },
    {
        "content": "<p>Yes that's right. Quote is just the quotient by the equivalence relation generated by the given relation. I guess I'm confused about what you want the quotient to actually be...</p>",
        "id": 227542437,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614137197
    },
    {
        "content": "<p>I didn't say I want a quotient, just a notion of 'equivalence classes', which make sense in that they form a partition of the elements for which the relation is reflexive. Using a quotient on an appropriate subtype will work to prove all this, but maybe it makes more sense just do do the proofs directly.</p>",
        "id": 227545499,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614140035
    },
    {
        "content": "<p>Are you looking for this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ht</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">setoid</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x.prop</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">@@</span><span class=\"n\">ht</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 227587178,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614167897
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> perhaps this discussion would move forward more smoothly if you were to write down in Lean some type or term or structure which you want to have, or have an API for, with a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> and some sorried lemmas.</p>",
        "id": 227594678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614172036
    },
    {
        "content": "<p>I think my question is answered - what I want doesn't quite exist out of the box, but it's pretty close to <code>quot</code>. I'm writing a small API for what I need, which is all easy. I'm satisfied I'm not repeating anything already in mathlib, and this was the only point of my question.</p>",
        "id": 227595906,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1614172643
    }
]
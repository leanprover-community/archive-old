[
    {
        "content": "<p>Perfect! Thank you!</p>",
        "id": 271075875,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1644289948
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"373814\">Rish Vaishnav</span> has marked this topic as resolved.</p>",
        "id": 271075903,
        "sender_full_name": "Notification Bot",
        "timestamp": 1644289981
    },
    {
        "content": "<p>I think the general rule with heq is that either you're doing something wrong or you're intentionally doing something technical and are probably an expert. I've heard people who have had to battle with heq tell me that it's not as bad as everyone says though. To my surprise <span class=\"user-mention\" data-user-id=\"133584\">@Joseph Hua</span> 's first project in my course had a bunch of heqs in!</p>",
        "id": 271088380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644303622
    },
    {
        "content": "<p>I've never heard of <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#unify_equations\">tactic#unify_equations</a> before</p>",
        "id": 271090056,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1644305360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271088380\">said</a>:</p>\n<blockquote>\n<p>I think the general rule with heq is that either you're doing something wrong or you're intentionally doing something technical and are probably an expert. I've heard people who have had to battle with heq tell me that it's not as bad as everyone says though. To my surprise <span class=\"user-mention silent\" data-user-id=\"133584\">Joseph Hua</span> 's first project in my course had a bunch of heqs in!</p>\n</blockquote>\n<p>it made some very slick proofs for equality of functors, because it's not asking for definitional equality on types</p>",
        "id": 271115830,
        "sender_full_name": "Joseph Hua",
        "timestamp": 1644321038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271075788\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"373814\">Rish Vaishnav</span> That sort of lemma's not necessary because you can turn each heq into an eq step-by-step. There's a tactic for this, too, which is nice:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">heq_congr</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hAB</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">=</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hfg</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">==</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unify_equations</span> <span class=\"n\">hAB</span> <span class=\"n\">hfg</span> <span class=\"n\">hab</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I'm not sure this solves the issue. Yes, the general <code>heq_congr</code> lemma is easy to prove once you've stated it (you can also write <code>cases hAB, cases hfg, cases hab, refl</code>). The problem is when you are in a situation where <code>A</code> and <code>B</code> aren't local constants, so the same tactic invocation no longer works (but applying the general lemma would work).</p>\n<p>One way of avoiding <code>==</code> in this case is to change the type of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">marginal</span> <span class=\"o\">(</span><span class=\"n\">mv</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can you define it as <code>measure (Π i : ι, β i)</code> instead? This is mathematically less natural, but it should be easier to work with because now the type doesn't depend on <code>mv</code> (working with type families over a type like<code>set ι</code> which has lots of equalities that aren't definitional often leads to this kind of problem).</p>",
        "id": 271121249,
        "sender_full_name": "David Wärn",
        "timestamp": 1644324303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/.E2.9C.94.20heq_congr.3F/near/271121249\">said</a>:</p>\n<blockquote>\n<p>One way of avoiding <code>==</code> in this case is to change the type of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">marginal</span> <span class=\"o\">(</span><span class=\"n\">mv</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Can you define it as <code>measure (Π i : ι, β i)</code> instead? This is mathematically less natural, but it should be easier to work with because now the type doesn't depend on <code>mv</code> (working with type families over a type like<code>set ι</code> which has lots of equalities that aren't definitional often leads to this kind of problem).</p>\n</blockquote>\n<p>This is an interesting suggestion, I could \"extend\" this marginal distribution definition to the full index type, though this would slightly complicate the (very simple) definitions I currently have. If I run into any big issues with <code>heq</code> I'll give it a shot, but I feel that I'm starting to get used to it.</p>\n<p>As Joseph has suggested, I'm just using this for \"slickness\" in this proof. I had a version of it without <code>heq</code> but it was essentially a dumbed-down version of the proof above for conditional independence on random variables.</p>",
        "id": 271148125,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1644335674
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373814\">@Rish Vaishnav</span> Something <code>heq</code> wrangling can mean is missing lemmas about new definitions.  For example, the following one might be useful, since you can do <code>simp_rw [marginal_apply_copy μ f (set.union_empty B)]</code> in the <code>independent_iff_cond_irrel</code> theorem you pointed at. You'd still need to develop more lemmas around simplifying expressions involving <code>pi_set_equiv</code> though.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pi_set_equiv</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">mv</span> <span class=\"n\">mv'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hmv</span> <span class=\"o\">:</span> <span class=\"n\">mv</span> <span class=\"bp\">=</span> <span class=\"n\">mv'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≃</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">mv'</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">hmv</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">marginal_apply_copy</span> <span class=\"o\">{</span><span class=\"n\">mv</span> <span class=\"n\">mv'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hmv</span> <span class=\"o\">:</span> <span class=\"n\">mv</span> <span class=\"bp\">=</span> <span class=\"n\">mv'</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">mv</span><span class=\"o\">,</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">marginal</span> <span class=\"n\">μ</span> <span class=\"n\">f</span> <span class=\"n\">mv</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">marginal</span> <span class=\"n\">μ</span> <span class=\"n\">f</span> <span class=\"n\">mv'</span> <span class=\"o\">(</span><span class=\"n\">pi_set_equiv</span> <span class=\"n\">β</span> <span class=\"n\">hmv</span> <span class=\"bp\">''</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">subst</span> <span class=\"n\">hmv</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span><span class=\"o\">,</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">pi_set_equiv</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">set.image_id'</span><span class=\"o\">,</span> <span class=\"n\">equiv.coe_refl</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 271184676,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644351345
    },
    {
        "content": "<p>Some justification for <code>heq</code>-avoidance is from the following interpretation of what <code>heq</code> even is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">heq_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">==</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">cast</span> <span class=\"n\">h</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>It's that there's an equality <code>h : α = β</code> such that the canonical equivalence <code>cast h : α → β</code> carries <code>a</code> to <code>b</code>. That's it.</p>\n<p>Usually there's something more meaningful than <code>cast h</code> that you can use, and it's usually worth building out some additional definitions and lemmas to support that.</p>",
        "id": 271190060,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644353997
    },
    {
        "content": "<p>Thanks, will try using that instead.</p>",
        "id": 271235243,
        "sender_full_name": "Rish Vaishnav",
        "timestamp": 1644387183
    }
]
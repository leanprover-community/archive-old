[
    {
        "content": "<p>I would like to have an isomorphism between a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and its localization at one <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">R_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. More generally, the localization of a ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> at a submonoid consisting only of units, should be isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, because the identity is a localization map. Is there something approximating that in the library?</p>",
        "id": 237957500,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620481955
    },
    {
        "content": "<p>You should be able to create a <code>localization_map</code> between <code>R</code> and <code>R</code>, that exhibits the identity map as a localization at <code>{1}</code>.</p>",
        "id": 237964020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620487952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> the lowdown on localisation is that given R and S there is \"the explicit localisation R[1/S]\" in Lean (i.e. a model for the localisation) and there is also \"the predicate that an R-algebra A is isomorphic to R[1/S]\". So you can get what you want by first proving that the R-algebra R satisfies the predicate for S={1}, and then using the fact that everything which satisfies the predicate is isomorphic to the explicit localisation, if that is what your question is. If you formalised the question in Lean rather than just making a mathematical statement, it would be easier to see what you were after.</p>",
        "id": 237966019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620489634
    },
    {
        "content": "<p>PS if it's not in the library already that R satisfies the localisation predicate for S=1 or more generally <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mo>‚äÜ</mo><msup><mi>R</mi><mo>√ó</mo></msup></mrow><annotation encoding=\"application/x-tex\">S\\subseteq R^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.771331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">√ó</span></span></span></span></span></span></span></span></span></span></span> then it probably should be!</p>",
        "id": 237966166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620489726
    },
    {
        "content": "<p>Yeah that's exactly what I meant. Just wanted to make sure I'm not missing something obvious before I spend too much time working on the general problem. It's not in the library as far as I can see.</p>",
        "id": 237967325,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620490736
    },
    {
        "content": "<p>Here's a toy version I got to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.basic</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kn\">include</span> <span class=\"n\">hM</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">localization_at_units_iso</span> <span class=\"o\">:</span> <span class=\"n\">localization</span> <span class=\"n\">M</span> <span class=\"bp\">‚âÉ+*</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">localization.ring_equiv_of_quotient</span> <span class=\"bp\">$</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">CommRing.of</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_localization_map</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hM</span> <span class=\"n\">_</span> <span class=\"n\">y.2</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">‚ü©,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">‚ü©,},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]‚ü©,</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)‚ü©,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">‚ü©,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">is_unit_iff_exists_inv.mp</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"n\">_</span> <span class=\"n\">c.2</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"o\">‚ü®</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">‚ü©,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">hc</span> <span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 237967362,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620490795
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">localization_at_units_iso</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"bp\">‚àà</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">is_unit</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">localization</span> <span class=\"n\">M</span> <span class=\"bp\">‚âÉ+*</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">localization.ring_equiv_of_quotient</span>\n<span class=\"o\">{</span> <span class=\"n\">map_units'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">hM</span> <span class=\"n\">y.1</span> <span class=\"n\">y.2</span><span class=\"o\">,</span>\n  <span class=\"n\">surj'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">‚ü©,</span> <span class=\"n\">mul_one</span> <span class=\"n\">z</span><span class=\"o\">‚ü©,</span>\n  <span class=\"n\">eq_iff_exists'</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"bp\">Œª</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">‚ü®</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">‚ü©,</span>\n    <span class=\"bp\">Œª</span> <span class=\"o\">‚ü®‚ü®</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">‚ü©,</span> <span class=\"n\">h</span><span class=\"o\">‚ü©,</span> <span class=\"o\">(</span><span class=\"n\">is_unit.mul_left_inj</span> <span class=\"o\">(</span><span class=\"n\">hM</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span><span class=\"o\">‚ü©,</span>\n  <span class=\"bp\">..</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 237968659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620491946
    },
    {
        "content": "<p>It's just the same proof, but I never need to go into tactic mode (or use category theory)</p>",
        "id": 237969038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620492284
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 237969232,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620492461
    },
    {
        "content": "<p>Let's see if I can put something together here.</p>",
        "id": 237969296,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620492501
    },
    {
        "content": "<p>This doesn't actually need the additive structure of rings, so it might as well go into <code>group_theory/monoid_localization</code> I assume...</p>",
        "id": 237969352,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620492551
    },
    {
        "content": "<p>Why do we assume M is a submonoid here?</p>",
        "id": 237969471,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620492629
    },
    {
        "content": "<p>Localization is defined only at submonoids isn't it?<br>\nIf I can divide by <code>f</code> and by <code>g</code> I can also divide by <code>fg</code>.</p>",
        "id": 237969600,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620492743
    },
    {
        "content": "<p>I can see it is defined only at submonoids in Lean, but it isn't in the real world.</p>",
        "id": 237969633,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620492785
    },
    {
        "content": "<p>Of course localizing at a random subset will be the same thing as localizing at the submonoid generated by this subset.</p>",
        "id": 237969663,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620492832
    },
    {
        "content": "<p>But for formalization purposes I'm surprised we imposed that useless assumption.</p>",
        "id": 237969712,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620492856
    },
    {
        "content": "<p>If you define a localization by the obvious universal property then the submonoid condition is completely useless.</p>",
        "id": 237969736,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620492898
    },
    {
        "content": "<p>I'm not sure. I guess the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>R</mi><mo>‚Üí</mo><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">M\\times R\\to R_M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r,s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">r/s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span></span></span> wouldn't be surjective if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> wasn't a submonoid?</p>",
        "id": 237969991,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620493120
    },
    {
        "content": "<p>And this surjectivity is one of the defining properties of localization maps, as it's defined in Lean.</p>",
        "id": 237970033,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620493170
    },
    {
        "content": "<p>It's not defined by the universal property I think.</p>",
        "id": 237970048,
        "sender_full_name": "Justus Springer",
        "timestamp": 1620493201
    },
    {
        "content": "<p>Maybe we need to change the definition of <code>localization_map</code>?</p>",
        "id": 237970188,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620493267
    },
    {
        "content": "<p>This was done by Kenny in 2017 as one of the very first projects that either he or I had been involved in, that's why we localise at submonoids -- we were copying out of Atiyah--Macdonald and had no idea about Lean; indeed this project taught us a lot about it.</p>",
        "id": 237970229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620493319
    },
    {
        "content": "<p>I think <code>localization_map</code> should be refactored to be a predicate on ring homomorphisms, or maybe a mixin on top of <code>algebra</code>. But this is quite a massive refactor, and I haven't found time or energy to do it.</p>",
        "id": 237970588,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620493605
    },
    {
        "content": "<p>Currently we need to resort to some ugly hacks to make the codomain of a <code>localization_map</code> into an <code>algebra</code>.</p>",
        "id": 237970614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620493649
    },
    {
        "content": "<p>Also <code>f.to_map</code> isn't very nice to read.</p>",
        "id": 237970639,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620493680
    },
    {
        "content": "<p>I acctually really like <span class=\"user-mention\" data-user-id=\"130377\">@David W√§rn</span> 's definition of <code>is_free_group</code>. We could do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">localization_map</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">maps_to_unit</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">‚Üí</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">lift_comp</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">cond</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lift_unique</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h.comp</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"n\">cond</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 237970692,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620493700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384542\">Justus Springer</span> <a href=\"#narrow/stream/217875-Is-there.20code.20for.20X.3F/topic/Localization.20at.20units/near/237969991\">said</a>:</p>\n<blockquote>\n<p>I'm not sure. I guess the map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>√ó</mo><mi>R</mi><mo>‚Üí</mo><msub><mi>R</mi><mi>M</mi></msub></mrow><annotation encoding=\"application/x-tex\">M\\times R\\to R_M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">√ó</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>s</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(r,s)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">r/s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span></span></span> wouldn't be surjective if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> wasn't a submonoid?</p>\n</blockquote>\n<p>Of course you can't use this formula. You need to replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> by the generated submonoid.</p>",
        "id": 237970732,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620493732
    },
    {
        "content": "<p>This allow you do to thing like localizing at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>f</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{f\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">}</span></span></span></span> without introducing a special case notation for instance.</p>",
        "id": 237970771,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620493784
    },
    {
        "content": "<p>(queue the complaints about semirings in 3...2...1...)</p>",
        "id": 237970774,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620493789
    },
    {
        "content": "<p>We'll want eliminators for other universes as well, I guess.</p>",
        "id": 237970966,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620493975
    },
    {
        "content": "<p>Yeah I'm not sure what to do about universes...</p>",
        "id": 237970978,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620493992
    },
    {
        "content": "<p>And maybe a constructor for the current defn</p>",
        "id": 237970983,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620493998
    },
    {
        "content": "<p>Do we ever want a localization of a (semi)ring which is not in the same universe?</p>",
        "id": 237970995,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494022
    },
    {
        "content": "<p>Every time you \"construct\" a localization, it ends up in the same universe</p>",
        "id": 237971040,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494048
    },
    {
        "content": "<p>I can think of various ways of ending up with \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span>\" in arbitrary universes.</p>",
        "id": 237971106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620494126
    },
    {
        "content": "<p>If you have the rational functions on some proper variety or something.</p>",
        "id": 237971167,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620494171
    },
    {
        "content": "<p>Like the prime subfield of a field <code>K : Type LARGE</code>?</p>",
        "id": 237971184,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494177
    },
    {
        "content": "<p>I guess the solution is to have <code>is_function_field_of X rat</code> and <code>is_prime_subfield_of K rat</code>, etc...</p>",
        "id": 237971213,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620494213
    },
    {
        "content": "<p>Yeah good point, in this case we would want that the canonical map <code>int \\to K</code> is a localization to the prime subfield</p>",
        "id": 237971214,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494216
    },
    {
        "content": "<p>Damiano was also toying with the idea of having <code>prelocalization_map</code>s. So that <code>int -&gt; real</code> was an example. Half of the theory works for that notion.</p>",
        "id": 237971260,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620494282
    },
    {
        "content": "<p>Okay, here's a fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">localization_map</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">maps_to_unit</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">s</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">unique_lift</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"bp\">‚àà</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">)),</span> <span class=\"bp\">‚àÉ!</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">h.comp</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 237971302,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494291
    },
    {
        "content": "<p>Or perhaps we need <code>C : Type v</code>?</p>",
        "id": 237971381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494403
    },
    {
        "content": "<p>The easiest would be to have a defn that doesn't mention universes...</p>",
        "id": 237971503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620494486
    },
    {
        "content": "<p>I don't understand, I thought Kevin was always saying Neil's predicate did exactly that.</p>",
        "id": 237971568,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1620494526
    },
    {
        "content": "<p>Yeah, we could just use Neil's predicate with the submonoid generated by the set (in the commutative ring case!)</p>",
        "id": 237971592,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494555
    },
    {
        "content": "<p>But that's okay because all semirings are commutative rings</p>",
        "id": 237971621,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1620494598
    }
]
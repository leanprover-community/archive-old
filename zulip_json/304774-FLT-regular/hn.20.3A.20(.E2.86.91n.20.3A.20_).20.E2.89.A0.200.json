[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>  do you think all the various <code>hn : (↑n : _) ≠ 0</code> come from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a> or do we need somewhere else?</p>",
        "id": 265714830,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640109114
    },
    {
        "content": "<p>Assuming everything is a domain</p>",
        "id": 265714836,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640109118
    },
    {
        "content": "<p>Yeah, pretty much I think</p>",
        "id": 265716032,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640109636
    },
    {
        "content": "<p>OK, we can maybe look for volunteers  in the math stream, it seems a good small project for someone who is looking for something to do</p>",
        "id": 265716717,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640110024
    },
    {
        "content": "<p>I have some time before Christmas, I am trying to prove it myself</p>",
        "id": 265786484,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640167452
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/pull/10974\">#10974</a> I proved that, if <code>p ∣ n</code>, then <code>expand R p (cyclotomic n R) = cyclotomic (p * n) R</code>. I will prove tomorrow the analogous formula in the case <code>¬p ∣ n</code>.</p>",
        "id": 265845978,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640203247
    },
    {
        "content": "<p>The formula for <code>cyclotomic (p ^ s * m) R</code> in characteristic <code>p</code> should then be easy.</p>",
        "id": 265846370,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640203335
    },
    {
        "content": "<p>I see that <code>hn : (↑n : _) ≠ 0</code> is becoming really annoying (since sometimes is in <code>A</code>, sometimes in <code>K</code> etc). If you need it just use a <code>have :... := sorry</code>. I hope the assumption will disappear soon.</p>",
        "id": 265901588,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640254042
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/11005\">#11005</a> for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cyclotomic_epand_eq_cyclotomic_mul</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hdiv</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">expand</span> <span class=\"n\">R</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">*</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"n\">n</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 265925564,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640272681
    },
    {
        "content": "<p>In <code>src/ready_for_mathlib/cycl_poly.lean</code> I've proved</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">cyclotomic_mul_prime_pow_eq</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">m</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">nat.prime</span> <span class=\"n\">p</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">char_p</span> <span class=\"n\">R</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hk</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span><span class=\"n\">p</span> <span class=\"bp\">∣</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">cyclotomic</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">*</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"n\">m</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>that should the main step to remove the <code>↑n ≠ 0</code> assumption from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a>.</p>",
        "id": 265949113,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640289927
    },
    {
        "content": "<p>OMG I am stupid!!  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a> is false without <code>↑n ≠ 0</code>!</p>\n<p>Not completely, if <code>n = p ^ s * m</code> with <code>¬p ∣ m</code>, then <code>(polynomial.cyclotomic n R).is_root μ ↔ is_primitive_root μ m</code>.</p>",
        "id": 265953915,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640294030
    },
    {
        "content": "<p>The reason is easy, in characteristic <code>p</code>, the Frobenius is injective, so taking <code>p</code>-th power cannot kill anything, and the multiplicative order of anything is not divisible by <code>p</code>, so there are no primitive <code>p</code>-th roots of unity.</p>",
        "id": 265954031,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640294114
    },
    {
        "content": "<p>So what we get is that <code>zeta'</code> is always a primitive root of unity, but the order is complicated.</p>",
        "id": 265954124,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640294189
    },
    {
        "content": "<p>I think this still works for our purposes, though - we still get a cyclotomic extension, just not the \"obvious\" one. So we can make the <code>n ≠ 0</code> versions as lemmas, and then use this that you've proved to get cyclotomic extensions.</p>",
        "id": 265954706,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640294750
    },
    {
        "content": "<p>Yes, it means that the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>15</mn></mrow><annotation encoding=\"application/x-tex\">15</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">15</span></span></span></span>-th cyclotomic extension of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"double-struck\">F</mi><mn>5</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F}_5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the same at the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span>-rd cyclotomic extension, so in some sense one should never consider the former.</p>",
        "id": 265954825,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640294859
    },
    {
        "content": "<p>We have to think about how to state this in Lean</p>",
        "id": 265954840,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640294880
    },
    {
        "content": "<p>I think the only real thing is we'll get an odd-looking <code>finrank</code></p>",
        "id": 265955180,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640295160
    },
    {
        "content": "<p>What do you mean? The dimension is difficult to control, it depends on the base field (non only on the characteristic), for example any cyclotomic extension of <code>C</code> is of course again <code>C</code>.</p>",
        "id": 265955482,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640295475
    },
    {
        "content": "<p>What we can do is to define the prime-to-<code>p</code> part of function, <code>f : N \\to N</code> (maybe it is already in mathlib) and in an <code>n</code>-th cyclotomic extension we get primitive <code>f n</code>-th roots of unity.</p>",
        "id": 265955585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640295576
    },
    {
        "content": "<p>The problem is that we will have this <code>f</code> everywhere I am afraid</p>",
        "id": 265955591,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640295591
    },
    {
        "content": "<p>I am tempted to impose the condition in the definition of <code>is_cyclotomic_extension</code>.</p>",
        "id": 265955678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640295672
    },
    {
        "content": "<p>At the end we are not loosing anything, just some lines to prove that a given extension is cyclotomic</p>",
        "id": 265955695,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640295701
    },
    {
        "content": "<p>Ahh, of course, yea. I think that's reasonable, and then we can have a bunch of convenience methods within the class to give us the right instance of n ≠ 0 (or a bunch of instances of <code>no_zero_smul_divisors</code> - <a href=\"https://leanprover-community.github.io/mathlib_docs/find/no_zero_smul_divisors.iff_algebra_map_injective\">docs#no_zero_smul_divisors.iff_algebra_map_injective</a>). We only seem to be able to get boring results without this restriction</p>",
        "id": 265956351,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640296299
    },
    {
        "content": "<p>The one thing I'm wary about is how to make the char-zero case as easy to use as possible - the fact instance I have right now is nice, but it won't be allowed in mathlib because of <a href=\"https://leanprover-community.github.io/mathlib_docs/notes.html#fact%20non-instances\">fact non-instances</a>. maybe we can place it in a locale or something, or we could make a simple structure like <code>cast_ne_zero R n</code>; that may also be a nice solution because we can make the instances from earlier automatic</p>",
        "id": 265956529,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640296444
    },
    {
        "content": "<p>(and I think it makes <code>R</code> the head symbol? but I know nothing about TC)</p>",
        "id": 265956555,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1640296473
    },
    {
        "content": "<p>I've asked <a href=\"#narrow/stream/116395-maths/topic/Cyclotomic.20fields/near/265957185\">here</a></p>",
        "id": 265957203,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1640297034
    },
    {
        "content": "<p>I've just bumped mathlib, and I had to add a bunch of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">this_should_be_automatic</span> <span class=\"o\">:</span> <span class=\"n\">is_cyclotomic_extension</span> <span class=\"o\">{</span><span class=\"n\">p</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">p</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>I think this is just because now in mathlib we sometimes use <code>ne_zero (n : K)</code> and in the project we still have <code>ne_zero ((n : ℕ) : K)</code>. I will remove all <code>ne_zero ((n : ℕ) : K)</code> still used in mathlib, and then everything should work in the project.</p>",
        "id": 270021872,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643631516
    },
    {
        "content": "<p>urgh, so the issue is that the new instance goes <code>ne_zero (a : S) → ne_zero ((a:R):S)</code>, and the old path for the ℚ stuff was <code>ne_zero (n : ℕ) (pnat) → ne_zero ((n : ℕ) : ℚ) (char_zero)</code>, but now the goal is <code>ne_zero (n : ℚ)</code>, which is that previous goal<code>.trans</code> - not an instance as it would cause loops. I wish there was a way to have an <code>iff</code> between them, but I don't think that's possible. I think reversing the direction will help, but we may still have double coes in some places. Or maybe not. I'll start the PR to reverse the instances when I finish the galois stuff</p>",
        "id": 270029729,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643635384
    },
    {
        "content": "<p>I think this way round will put the onus at the use-case -- as in, where the <code>ne_zero</code> gets turned into a <code>≠ 0</code>, to use <code>coe_trans</code>, but I think that's fine and probably more desirable than this way round</p>",
        "id": 270030240,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643635616
    },
    {
        "content": "<p>hopefully stuff doesn't break</p>",
        "id": 270030244,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643635619
    },
    {
        "content": "<p>I think we should try to use <code>ne_zero (n : K)</code> in all the statement. If we need the double coercion in some proof it's not a big problem. Also, in the project we can always write <code>sorry</code> and think about it later, but we have to be careful when PRing stuff. I will soon add a file <code>cyclotomic.rat</code> about <code>ℚ</code>: we can maybe add a local instance at the beginning and forget it.</p>",
        "id": 270043506,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643640905
    },
    {
        "content": "<p>yes, I don't think we'll need the instance thankfully, just reversing the direction of things</p>",
        "id": 270081506,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643654156
    },
    {
        "content": "<p>I'm going to work on a branch to make sure the change works everywhere before I finalize it; don't want to re-reverse, that would be a fiasco</p>",
        "id": 270081600,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643654178
    },
    {
        "content": "<p>(and I promise this branch will live for far less time than <code>zeta_refactor</code>!)</p>",
        "id": 270081630,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643654190
    },
    {
        "content": "<p>okay, I've just had some sort of stab at it and I just think it may not be doable without either the double coes or someone that knows Lean coercion's far better than me. I wish there was some way to tell the type-class system that two instances are equivalent without causing loops; but without the double coes, I think all of the convenience of <code>ne_zero</code> pretty much instantly vanishes, as you have to play with coes again. see <a href=\"https://github.com/leanprover-community/mathlib/commit/bba2d7e4bc9d3297d838c66b55a1a602708a451f\">this</a> commit, for example: I get this weird error that I can't parse, and maybe is the key to allowing us to not have double-coes is: <code>failed to synthesize type class instance for ne_zero ↑(coe_b n)</code>. What is a <code>coe_b</code>? <code>coe_base</code>? but then why does it pretty-print different? how do I even deal with it?</p>",
        "id": 270135189,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643677924
    },
    {
        "content": "<p>anyways, unless we can find a good solution soon, I think the best shot is to revert this soon because it's already getting really annoying within the existing code; instances were breaking all over the place whilst finishing the galois proof.</p>",
        "id": 270135249,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643677962
    },
    {
        "content": "<p>(and just to be clear, by we I mean me - my mess, I should clean it up <span aria-label=\"nuclear\" class=\"emoji emoji-2622\" role=\"img\" title=\"nuclear\">:nuclear:</span>)</p>",
        "id": 270135539,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643678119
    },
    {
        "content": "<p>I don't know about <code>coe_b</code> and <code>coe_base</code>, but I don'think the problem with double coercion is so bad, I see two possibilities:</p>\n<ul>\n<li>I <em>think</em> that at the moment the problem comes from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a> that is stated (as it should) for <code>n : ℕ</code>. All our results are for <code>n : ℕ+</code>, and sooner or later we will stop using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a> (we will use results that <em>depend</em> on it, but everything will be for <code>n : ℕ+</code>).</li>\n<li>We can provide something like <code>polynomial.is_root_cyclotomic_iff</code> for <code>n : ℕ+</code> and using it to avoid the double coercion.</li>\n</ul>",
        "id": 270168503,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643704292
    },
    {
        "content": "<p>The issue is all the <code>ne_zero</code> results are also stated as results about <code>nat.cast</code>, so for example turning <code>ne_zero (n : K)</code> to <code>ne_zero (n : L)</code>requires stepping through the <code>ne_zero.of_no_zero_smul_divisors</code>, which also takes a nat. So I don't think that would work</p>",
        "id": 270169447,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643704716
    },
    {
        "content": "<p>Can we have results about <code>ne_zero</code> that apply directly to <code>pnat</code>?</p>",
        "id": 270171955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643705997
    },
    {
        "content": "<p>Maybe? I can try, anyways</p>",
        "id": 270172144,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643706053
    },
    {
        "content": "<p>I've just bumped mathlib in <a href=\"https://github.com/leanprover-community/flt-regular/commit/79a2fe5e95aa5671553f17e4f3883daad697005b\">79a2fe5</a>. I agree it is becoming quite annoying. As you say there is probably no perfect solution, we need to figure out how to minimize the number of <code>haveI ...</code>.</p>",
        "id": 270197274,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643717235
    },
    {
        "content": "<p>Don't worry if you don't want to try, but if we do <em>everything</em> for <code>n : pnat</code> we should at least get rid of the double coercion. I mean including a new version of docs##polynomial.is_root_cyclotomic_iff and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ne_zero.nat_of_injective\">docs#ne_zero.nat_of_injective</a>.</p>",
        "id": 270198676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643717827
    },
    {
        "content": "<p>This last one cannot be an instance, but at least it would be easy to use.</p>",
        "id": 270198717,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643717853
    },
    {
        "content": "<p>I've spent a bit of time messing around, and I'm fairly convinced that all the options for removing coes just don't work.</p>\n<ul>\n<li>One that seemed nice: making <code>ne_zero</code> a <code>@[class] def</code>, as double and single coes are defeq. this seemed to be the dream solution, but sadly doesn't work well either, and even though they're defeq, instance seach doesn't seem to work that way. Regardless, this would be banned in <code>mathlib</code> as <code>@[class] def</code> doesn't exist in Lean4. Do we know why this isn't allowed in Lean4?</li>\n<li>limiting the coe instances to just <code>nat.cast</code> - this also fails completely.</li>\n<li>making <code>pnat</code> versions of everything: this works, but feels really quite clunky. we have to prime pretty much every lemma for this</li>\n</ul>\n<p>my current best idea is just to deal with the double coercions in all their generality - they seem to work quite flexibly. maybe to make things easier, we should get one of the unicode arrows and make it local notation for <code>pnat.of_nat</code>, so that we can just write <code>ne_zero (⤉n : R)</code> (for example). I can't seem to find any other way that doesn't require <code>ne_zero ↑↑n ↔ ne_zero ↑n</code> in TC, and that doesn't seem possible to me. another bonus of this is that it makes what's going on a <a href=\"/user_uploads/3121/QaSs7AT4dF2xoGu-8UDq7Fdq/image.png\">bit more readable</a>...</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/QaSs7AT4dF2xoGu-8UDq7Fdq/image.png\" title=\"bit more readable\"><img src=\"/user_uploads/3121/QaSs7AT4dF2xoGu-8UDq7Fdq/image.png\"></a></div>",
        "id": 270207232,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643721596
    },
    {
        "content": "<p>Can you making a WIP PR with what you are trying? I am definitely not qualified to decide similar things about coercions, but we can do something like to following: in the <code>flt-regular</code> we provide any instance it is required just using <code>sorry</code> (this is what I am doing if a bump breaks stuff). We use the WIP PR to experiment with what is already in mathlib, to see if a modification helps or not.</p>",
        "id": 270212758,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643723559
    },
    {
        "content": "<p>Also, we should ask for some help in the general stream, it's very easy to abstract from cyclotomic stuff.</p>",
        "id": 270212876,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643723591
    },
    {
        "content": "<p>Yes, I'll try this. That's also worth doing, I'll post it when I have a WIP-PR ready!</p>",
        "id": 270214432,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643724109
    },
    {
        "content": "<p>Thanks for doing this! It doesn't look very funny...</p>",
        "id": 270215091,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643724340
    },
    {
        "content": "<p>Stupid question, but why can't you take the types you cast to as arguments to <code>ne_zero</code>?</p>",
        "id": 270248747,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643735684
    },
    {
        "content": "<p>That is, <code>ne_zero ℕ K n</code> instead of <code>ne_zero ((n : ℕ) : K)</code></p>",
        "id": 270248958,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643735762
    },
    {
        "content": "<p>iirc, this was the original suggestion, but we thought this a bit more flexible originally. this also seems reasonable, too, although we sometimes have only single-cast <code>ne_zero</code>s so we'd have to fiddle with how many types to put in the signature and such like</p>",
        "id": 270250560,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643736287
    },
    {
        "content": "<p>i've uploaded a version that compiles on the <code>ne_zero</code> branch of <code>flt-regular</code> - suggestions for the new <code>coe</code> arrow to use welcome. i'll also try out Yael's and Anne's suggestions later, but currently also in a game of chess! so will have to wait a couple hours ^^</p>",
        "id": 270251520,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643736651
    },
    {
        "content": "<p>I agree that the current <code>ne_zero</code> is very general, but it seems like you're always putting coercions into it, so you might as well use a class that's more tailored to your needs (and maybe call it <code>cast_ne_zero</code> or something).</p>",
        "id": 270254825,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643737794
    },
    {
        "content": "<p>the current approach is merged in, I think I will try your  idea Yael but at a later time, I'm tired of seeing the equation a ≠ 0 ;b</p>",
        "id": 270394731,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643813209
    },
    {
        "content": "<p>also, if someone has a better idea for an arrow for the <code>pnat</code> coe, I'm all ears -- currently using ⥉, but it's so rare that it's not even on the VSCode extension</p>",
        "id": 270394808,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643813241
    },
    {
        "content": "<p>A simple PR to the VSCode extension would fix it.</p>",
        "id": 270396522,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643813853
    },
    {
        "content": "<p>What is this arrow meant to represent?</p>",
        "id": 270396565,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643813875
    },
    {
        "content": "<p>just an easy way to type the coe from pnat to ℕ without having to type ascript, as we use that coercion a lot</p>",
        "id": 270397266,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643814102
    },
    {
        "content": "<p>Where does it appear? Currently in <code>ne_zero</code> but what I suggested should make that use obsolete. Anywhere else?</p>",
        "id": 270397433,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643814159
    },
    {
        "content": "<p>not particularly, I don't think. I still think it's nice as a temporary thing</p>",
        "id": 270397588,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643814219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/hn.20.3A.20.28.E2.86.91n.20.3A.20_.29.20.E2.89.A0.200/near/265953915\">said</a>:</p>\n<blockquote>\n<p>OMG I am stupid!!  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a> is false without <code>↑n ≠ 0</code>!</p>\n<p>Not completely, if <code>n = p ^ s * m</code> with <code>¬p ∣ m</code>, then <code>(polynomial.cyclotomic n R).is_root μ ↔ is_primitive_root μ m</code>.</p>\n</blockquote>\n<p>Cc <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>, this is when you last thought about this</p>",
        "id": 281665194,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652092763
    },
    {
        "content": "<p>It is surely needed in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.is_root_cyclotomic_iff\">docs#polynomial.is_root_cyclotomic_iff</a>, but in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cyclotomic_field.is_cyclotomic_extension\">docs#cyclotomic_field.is_cyclotomic_extension</a> I think it's not, for a nice coincidence. In any case Lean will tell us <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 281668520,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652095015
    },
    {
        "content": "<p>For sure! I just meant I think you figured this all out on the posts after that (click and you'll see). It should hopefully be easy to formalise!</p>",
        "id": 281668887,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652095314
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 281880505,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652213997
    }
]
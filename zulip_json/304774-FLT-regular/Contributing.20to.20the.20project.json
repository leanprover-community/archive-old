[
    {
        "content": "<p>Hi, I am Xavier Roblot. I am a number theorist in Lyon (and thus a colleague of <span class=\"user-mention\" data-user-id=\"300245\">@Filippo A. E. Nuccio</span> who introduced me to Lean). I saw <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span>'s talk about this  project at the \"Lean in Lyon\" workshop and I would really like to contribute if I can. I have been learning to work with Lean during the last few weeks and I am still very far for being proficient with it, but I hope I can be of some help.</p>",
        "id": 281879426,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652213413
    },
    {
        "content": "<p>Hi Xavier! Thanks for your message, and welcome to the Lean community!<br>\nI was very busy recently, so I have to sit down and think about a reasonable plan for the next weeks, but I will try to do as soon as possible.</p>",
        "id": 281879818,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652213634
    },
    {
        "content": "<p>You can have a look at our <a href=\"https://leanprover-community.github.io/flt-regular/\">blueprint</a>. The links are not updated, but essentially everything in section 2 is in mathlib</p>",
        "id": 281879982,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652213717
    },
    {
        "content": "<p>3.1 and 3.2 are also done</p>",
        "id": 281880111,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652213773
    },
    {
        "content": "<p>We have to think a little bit about 3.3, even to state it</p>",
        "id": 281880258,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652213864
    },
    {
        "content": "<p>We have some stuff for 3.3 but it still needs some annoying lemmas</p>",
        "id": 281880416,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652213942
    },
    {
        "content": "<p>But I would say that lemmas 3.3-3.7 are more or less what we should concentrate now</p>",
        "id": 281880423,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652213945
    },
    {
        "content": "<p>Ive also been very bad at updating links on the blueprint. I'll try and do that tomorrow</p>",
        "id": 281880484,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652213981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> if you want to have a look at the project just use <code>leanproject get flt-regular</code>, but a lot of results are already in mathlib, in the <code>number_theory/cyclotomic</code> folder.</p>",
        "id": 281880613,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652214039
    },
    {
        "content": "<p>Actually, I have been working on some version of 3.3 in the last few days as a pet project. But I am very far from a complete proof . Basically, I just (almost) proved so far that bounded roots give bounded coefficients, that might be already in mathlib... (Sorry posted in the wrong streams)</p>",
        "id": 281880624,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652214046
    },
    {
        "content": "<p>I have downloaded the project. I'll have a closer look tomorrow.</p>",
        "id": 281880902,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652214175
    },
    {
        "content": "<p>What is you github username?</p>",
        "id": 281880965,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652214201
    },
    {
        "content": "<p>I've been slowly working on 3.4 in the unit_lemmas.lean file, but we need some more facts about totient functions which could also be a fun place to start</p>",
        "id": 281881115,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652214250
    },
    {
        "content": "<p>My GitHub username is xroblot</p>",
        "id": 281882092,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652214680
    },
    {
        "content": "<p>I've sent you an invitation to the project. Feel free to push all sort of code to <code>master</code>, but try to avoid errors (<code>sorry</code> is of course totally fine).</p>",
        "id": 281882912,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652215072
    },
    {
        "content": "<p>Let me know if you are also interested in contributing to mathlib</p>",
        "id": 281883010,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652215099
    },
    {
        "content": "<p>I thought that I did bounded roots gives bounded coeffs, and that all roots abs val one implies root of unity in the project a while ago, but I'm not sure now, I'll try and find it later.</p>",
        "id": 281884903,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1652216061
    },
    {
        "content": "<p>Yeah you did, it's somewhere in the repo</p>",
        "id": 281885043,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652216160
    },
    {
        "content": "<p>I always saw that stuff and got a bit worried because it looked dissimilar to the galois stuff I did but it's probably likely I did stuff wrong</p>",
        "id": 281885312,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1652216292
    },
    {
        "content": "<p>Hi Xavier, I am happy to see you here. Welcome! I am sure that <span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> will have a lot of things to pass over to you, you won't be left without work <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 281890757,
        "sender_full_name": "Filippo A. E. Nuccio",
        "timestamp": 1652219315
    },
    {
        "content": "<p>Hi Xavier!</p>",
        "id": 281892727,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1652220464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/281884903\">said</a>:</p>\n<blockquote>\n<p>I thought that I did bounded roots gives bounded coeffs, and that all roots abs val one implies root of unity in the project a while ago, but I'm not sure now, I'll try and find it later.</p>\n</blockquote>\n<p>its <code>mem_roots_of_unity_of_abs_eq_one</code> which is in <code>number_theory/cyclotomic/absolute_value.lean</code></p>",
        "id": 281933271,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652258022
    },
    {
        "content": "<p>I've missed this one, nice!! Killing the two remaining <code>sorry</code> in that file would be very nice</p>",
        "id": 281935213,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652259137
    },
    {
        "content": "<p>One has the rather scary comment</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- this goal isn't true as stated right now, the rhs could be a power of the lhs</span>\n</code></pre></div>\n<p><span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 281935251,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652259167
    },
    {
        "content": "<p>Is someone interested in finishing this? I think it's a nice piece of math, and it definitely deserves to be put in mathlib.</p>",
        "id": 282759032,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652864632
    },
    {
        "content": "<p>By this do you mean lemma 3.3 from the blueprint? i.e <code>mem_roots_of_unity_of_abs_eq_one</code>?</p>",
        "id": 282760122,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1652865207
    },
    {
        "content": "<p>Yes, sorry</p>",
        "id": 282760651,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652865523
    },
    {
        "content": "<p>I guess I can try to finish it if <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span>  does not want to finish it himself. However, it will probably take me some time and I might need some help along the way <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 282923724,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652964717
    },
    {
        "content": "<p>If you need some advice just ask!</p>",
        "id": 282925816,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1652965597
    },
    {
        "content": "<p>I'm happy to help you help me! It's not so much that I don't want to finish it, just that I have a stack of other half finished Lean projects, and only so much time to devote to them. Its a very cool theorem and I definitely agree it belongs in mathlib, so if you'd like to finish it off that's great, thanks <span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span>. I'm happy to try and explain any of the choices I made, or things that I think can be improved from what I originally wrote.</p>",
        "id": 282926243,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1652965851
    },
    {
        "content": "<p>Ok, thanks for the answers. I'll try to finish it and I'll come back to you guys if I need help.</p>",
        "id": 282926484,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1652965981
    },
    {
        "content": "<p>Something we also want is <a href=\"https://leanprover-community.github.io/flt-regular/sect0003.html#lemma:ideals_mult_to_power\">Lemma 3.7</a> in the blueprint. It shouldn't be difficult is anyone wants to try (I didn't check, it can  somehow be already in mathlib).</p>",
        "id": 284099710,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653636244
    },
    {
        "content": "<p>Not sure if this is the cleanest approach, and not sure it's true for b=0, but:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_dedekind_domain</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cp</span> <span class=\"o\">:</span> <span class=\"n\">is_coprime</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">^</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">obtain</span> <span class=\"n\">rfl</span><span class=\"bp\">|</span><span class=\"n\">ha</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">a</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">zero_pow</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">contrapose</span><span class=\"bp\">!</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">le_zero_iff</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">pow_zero</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">zero_ne_one</span> <span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">fa</span> <span class=\"o\">:=</span> <span class=\"n\">unique_factorization_monoid.normalized_factors</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">fb</span> <span class=\"o\">:=</span> <span class=\"n\">unique_factorization_monoid.normalized_factors</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">fc</span> <span class=\"o\">:=</span> <span class=\"n\">unique_factorization_monoid.normalized_factors</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">d</span> <span class=\"bp\">∈</span> <span class=\"n\">fa</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">∉</span> <span class=\"n\">fb</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">d</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">unique_factorization_monoid.irreducible_of_normalized_factor</span> <span class=\"n\">_</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">irreducible.not_unit</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_coprime.is_unit_of_dvd'</span> <span class=\"n\">cp</span><span class=\"bp\">;</span>\n    <span class=\"n\">apply</span> <span class=\"n\">unique_factorization_monoid.dvd_of_mem_normalized_factors</span><span class=\"bp\">;</span>\n    <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">fa</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f.prod</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">unique_factorization_monoid.normalized_factors_prod</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">associated_eq_eq</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">multiset.prod_nsmul</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">hf</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">multiset.exists_smul_of_dvd_count</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hxb</span> <span class=\"o\">:=</span> <span class=\"n\">this</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">dvd_mul_right</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">fc.count</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">multiset.count_nsmul</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">unique_factorization_monoid.normalized_factors_pow</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">unique_factorization_monoid.normalized_factors_mul</span> <span class=\"n\">ha</span> <span class=\"n\">hb</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span> <span class=\"n\">multiset.count_add</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">add_zero</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">multiset.count_eq_zero_of_not_mem</span> <span class=\"n\">hxb</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 284112187,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653645028
    },
    {
        "content": "<p>Very nice! Would you mind to push it to master in the <code>flt-regular</code> repository? You can create a new file in the <code>ready_for_mathlib</code> folder</p>",
        "id": 284112477,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653645134
    },
    {
        "content": "<p>And of course if you want to PR it you're welcome!</p>",
        "id": 284112499,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653645150
    },
    {
        "content": "<p>I've sent you an invitation</p>",
        "id": 284112675,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653645248
    },
    {
        "content": "<p>I'm not sure I have all the right imports, so I made a pr: <a href=\"https://github.com/leanprover-community/flt-regular/pull/61\">https://github.com/leanprover-community/flt-regular/pull/61</a></p>",
        "id": 284113239,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653645625
    },
    {
        "content": "<p>Need to check where it goes wrong for plain ufds instead of ideals of Dedekind domains, though</p>",
        "id": 284115193,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653646927
    },
    {
        "content": "<p>For the project if it compiles then it's OK for <code>master</code> :)</p>",
        "id": 284115550,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653647131
    },
    {
        "content": "<p>this is symmetric in a+b, right? so it should work for b=0? especially as you don't use <code>hb</code> in the subproof</p>",
        "id": 284117119,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653648264
    },
    {
        "content": "<p>oh, I see that as usual my reading abilities drop to zero when I'm reading other people's code</p>",
        "id": 284117246,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653648395
    },
    {
        "content": "<p>thankfully the statement is true for b zero, proof pushed</p>",
        "id": 284117991,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653648927
    },
    {
        "content": "<p>You're faster than me!</p>",
        "id": 284118082,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653648985
    },
    {
        "content": "<p>I generalised <code>is_unit_iff'</code> to <code>comm_semiring</code>s, because of what Ruben said about ufds, but not sure how this could hold in UFDs; are UFDs' ideals atomic?</p>",
        "id": 284130487,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653657275
    },
    {
        "content": "<p>I wouldn't care about UFD, and it wouldn't be a generalization</p>",
        "id": 284131040,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653657552
    },
    {
        "content": "<p>Most Dedekind domains are not UFD</p>",
        "id": 284131069,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653657571
    },
    {
        "content": "<p>Right, fair, no big deal then</p>",
        "id": 284131196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1653657619
    },
    {
        "content": "<p>Of course for UFD the corresponding relevant statement is about elements, and it should be easy</p>",
        "id": 284131519,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653657792
    },
    {
        "content": "<p>Well I guess the generalization would be to unique factorization monoids rather than ideals of Dedekind domains</p>",
        "id": 284135304,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1653659460
    },
    {
        "content": "<p>The trick for <code>b=0</code> won't work in general I think (since there can be units that are not <code>p</code>-powers), but the rest should be the same.</p>",
        "id": 284137957,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653660511
    },
    {
        "content": "<p>I've got some pretty awful code up at <a href=\"https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346\">https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346</a> - might try to make something of it later</p>",
        "id": 284138326,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653660672
    },
    {
        "content": "<p>Sorry-free at least, but still hairy</p>",
        "id": 284167838,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653675938
    },
    {
        "content": "<p>Feel free to push it to <code>flt-regular</code> if you want, don't worry about names and similar stuff (and in exchange someone will fix any problem arising from mathlib bumps).</p>",
        "id": 284169905,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653677007
    },
    {
        "content": "<p>I am sorry but I am making very slow progress. I have a lot of difficulties figuring out even very easy things. For example, I have a <code>number_field K</code>, <code>number_field L</code> and <code>algebra K L</code>. So I should be able to see <code>K</code> as having type <code>intermediate_fields ℚ L</code>, but I cannot just figure out how to say to Lean to do that. Any help would be very welcome.</p>",
        "id": 284186414,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1653686574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284138326\">said</a>:</p>\n<blockquote>\n<p>I've got some pretty awful code up at <a href=\"https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346\">https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346</a> - might try to make something of it later</p>\n</blockquote>\n<p>In the end it turns out my generalization wasn't quite a generalization: I required <code>comm_ring</code> and ideals of Dedekind domains seem to only be a <code>comm_semiring</code>. Maybe <a href=\"https://github.com/leanprover-community/mathlib/pull/14423\">https://github.com/leanprover-community/mathlib/pull/14423</a> will help, we'll see. Got some interesting lemmas out of it, in any case</p>",
        "id": 284188275,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1653687929
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284186414\">said</a>:</p>\n<blockquote>\n<p>I am sorry but I am making very slow progress. I have a lot of difficulties figuring out even very easy things. For example, I have a <code>number_field K</code>, <code>number_field L</code> and <code>algebra K L</code>. So I should be able to see <code>K</code> as having type <code>intermediate_fields ℚ L</code>, but I cannot just figure out how to say to Lean to do that. Any help would be very welcome.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> a more effective way to ask questions is to give a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> , for example</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">number_theory.number_field</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">number_field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">number_field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">ℚ</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That way I don't have to figure out imports myself or start guessing that you probably mean <code>intermediate_field</code> not <code>intermediate_fields</code>.</p>\n<p>Here's a partial solution:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">number_theory.number_field</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">number_field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">number_field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- To make an intermediate field you need to give</span>\n<span class=\"c1\">-- (1) the subset, (called `carrier`)</span>\n<span class=\"c1\">-- (2) a proof that the subset contains ℚ, (called `algebra_map_mem'`)</span>\n<span class=\"c1\">-- (3) a proof of all the axioms for a subfield.</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">intermediate_field</span> <span class=\"n\">ℚ</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n  <span class=\"c1\">-- The subset is the image of the canonical map K → L</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">),</span>\n    <span class=\"c1\">-- this is a fairly incomprehensible proof</span>\n    <span class=\"c1\">-- that the image of the map from K to L</span>\n    <span class=\"c1\">-- must contain the image of the rationals.</span>\n  <span class=\"n\">algebra_map_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_rat_cast</span><span class=\"o\">],</span>\n    <span class=\"n\">convert</span> <span class=\"o\">(</span><span class=\"n\">map_rat_cast</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">ℚ</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">congr_arg</span> <span class=\"n\">_</span> <span class=\"n\">r.cast_id.symm</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- A ring homomorphism maps 0 to 0 so</span>\n  <span class=\"c1\">-- 0 is in the subset</span>\n  <span class=\"n\">zero_mem'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- Same story for 1; `map_one` says a ring hom maps</span>\n  <span class=\"c1\">-- 1 to 1.</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">map_one</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"c1\">-- This next begin/end block is a proof that the product</span>\n  <span class=\"c1\">-- of two things in the subset is in the subset. It uses</span>\n  <span class=\"c1\">-- the theorem that ring homomorphisms commute with</span>\n  <span class=\"c1\">-- multiplication, which is called `map_mul`.</span>\n  <span class=\"c1\">-- It also uses the `rintro rfl` trick.</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">-</span> <span class=\"bp\">-</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- Exercise for the reader.</span>\n  <span class=\"n\">add_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">neg_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"gr\">sorry</span> <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 284202298,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653702434
    },
    {
        "content": "<p>Kevin, thanks (again) for helping me. Sorry about the lack of <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>. I'll remember to add one next time. <br>\nSomehow, I thought there was a quick way to solve the problem, but I see that one has to construct the <code>intermediate_field</code> from the definition... Anyway, back to work</p>",
        "id": 284212773,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1653717665
    },
    {
        "content": "<p>In your example <code>K</code> is not literally an <code>intermediate_field</code> (this is false even mathematically, <code>K</code> is not a subset of <code>L</code>. Of course there is the image, but still...). The best question is probably why you want an intermediate field.</p>",
        "id": 284214532,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653720777
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284188275\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284138326\">said</a>:</p>\n<blockquote>\n<p>I've got some pretty awful code up at <a href=\"https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346\">https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346</a> - might try to make something of it later</p>\n</blockquote>\n<p>In the end it turns out my generalization wasn't quite a generalization: I required <code>comm_ring</code> and ideals of Dedekind domains seem to only be a <code>comm_semiring</code>. Maybe <a href=\"https://github.com/leanprover-community/mathlib/pull/14423\">https://github.com/leanprover-community/mathlib/pull/14423</a> will help, we'll see. Got some interesting lemmas out of it, in any case</p>\n</blockquote>\n<p>This</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unique_factorization_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_associated_pow_of_mul_eq_pow</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cp</span> <span class=\"o\">:</span> <span class=\"n\">is_coprime</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">associated</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">^</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>looks a good generalization, ideals of a Dedekind domain are a <code>unique_factorization_monoid</code>, and in this case associated means equal (do we have this lemma?).</p>",
        "id": 284214621,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653720930
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/associated_iff_eq\">docs#associated_iff_eq</a> ?</p>",
        "id": 284214664,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653720987
    },
    {
        "content": "<p>Sorry, you accidentally triggered <code>yael_search</code>!</p>",
        "id": 284214669,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653721011
    },
    {
        "content": "<p>Yes, that's probably it (I am still having my coffee, to early on Saturday morning to check  if we have <code>unique...</code>)</p>",
        "id": 284214684,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653721072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284214621\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284188275\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284138326\">said</a>:</p>\n<blockquote>\n<p>I've got some pretty awful code up at <a href=\"https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346\">https://gist.github.com/Ruben-VandeVelde/d82c653a8cc2315a3985e60ed4637346</a> - might try to make something of it later</p>\n</blockquote>\n<p>In the end it turns out my generalization wasn't quite a generalization: I required <code>comm_ring</code> and ideals of Dedekind domains seem to only be a <code>comm_semiring</code>. Maybe <a href=\"https://github.com/leanprover-community/mathlib/pull/14423\">https://github.com/leanprover-community/mathlib/pull/14423</a> will help, we'll see. Got some interesting lemmas out of it, in any case</p>\n</blockquote>\n<p>This</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">unique_factorization_monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_associated_pow_of_mul_eq_pow</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cp</span> <span class=\"o\">:</span> <span class=\"n\">is_coprime</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span><span class=\"bp\">*</span><span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"bp\">^</span><span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">associated</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">^</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>looks a good generalization, ideals of a Dedekind domain are a <code>unique_factorization_monoid</code>, and in this case associated means equal (do we have this lemma?).</p>\n</blockquote>\n<p>Ah, you have <code>variables {β : Type*} [comm_ring β] [is_domain β] [unique_factorization_monoid β]</code>, that's too much! <code>β</code> should only be a monoid.</p>",
        "id": 284214743,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653721160
    },
    {
        "content": "<p>I see <code>is_coprime</code> is defined via Bezout, so it wants a <code>semiring</code>.</p>",
        "id": 284214879,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653721311
    },
    {
        "content": "<p>I've asked a related question <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/.60semiring.60.20and.20.60cancel_comm_monoid_with_zero.60/near/284215346\">here</a></p>",
        "id": 284215391,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653722171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284214532\">said</a>:</p>\n<blockquote>\n<p>In your example <code>K</code> is not literally an <code>intermediate_field</code> (this is false even mathematically, <code>K</code> is not a subset of <code>L</code>. Of course there is the image, but still...). The best question is probably why you want an intermediate field.</p>\n</blockquote>\n<p>I need to prove that any embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">K \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> can be lifted to an embedding <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">L \\to \\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>. This should follow from the <code>intermediate_field.lifts</code> machinery using the primitive element theorem.</p>",
        "id": 284215393,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1653722189
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_alg_closed.lift\">docs#is_alg_closed.lift</a></p>",
        "id": 284215716,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653722753
    },
    {
        "content": "<p>In general it is a little tricky to decide if one wants to work with <code>substuff</code> of not. <code>substuff</code> has the advantage that you can literally prove that two things are equal by <code>ext</code>, you can take intersections and so on. But usually at some point you discover that something is not literally a subset and then you regret your choice. I suggest to try to avoid it if possible.</p>",
        "id": 284215959,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653723142
    },
    {
        "content": "<p>Riccardo, thanks for the advice. I wished I found out about <code>is_alg_closed.lift</code> sooner. I guess I am still not skilled enough at searching the library <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 284216545,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1653724060
    },
    {
        "content": "<p>I found it as follows: the reason why this is true is that <code>C</code> is algebraically closed, and I randomly tried <code>is_alg_closed.lift</code>. I would have been very surprised if we had it only for <code>intermediate_field</code>.</p>",
        "id": 284216719,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1653724261
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> there could well be an easier way -- it wouldn't surprise me if for a large class of morphisms (group homomorphisms, ring homomorphisms etc) there's a function already there which gives the construction of an image subobject. I was too lazy to look for it.</p>",
        "id": 284223073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653734514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284223073\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> there could well be an easier way -- it wouldn't surprise me if for a large class of morphisms (group homomorphisms, ring homomorphisms etc) there's a function already there which gives the construction of an image subobject. I was too lazy to look for it.</p>\n</blockquote>\n<p>Well, I was able to get a nice short proof with <code>is_alg_closed.lift</code>  so I am happy with that.</p>",
        "id": 284231855,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1653747720
    },
    {
        "content": "<p>By the way I totally agree that as a relative newcomer it's very hard to guess what the best way of implementing the data of a question should be. The Artin-Tate lemma (according to Atiyah--Macdonald, at least) is a statement involving three commutative rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and in the proof you build a 4th ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>⊆</mo><mi>D</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">B\\subseteq D\\subseteq C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.136em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span>. Are you supposed to let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A,B,C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> be types and give them <code>[ring]</code> instances, or should <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> be the ring (the type) and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> be subrings, or should <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> be the ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> a subring and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-algebra? Then all the same questions for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">D</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span>. Questions like this are rather delicate. In the old days your decisions would be influenced by questions such as \"do we have more API for <code>subring</code> or <code>algebra</code>\" but nowadays we have lots of API for both so in some sense it's probably true that whatever decision you make, you'll be able to get the proof out in the end. But bad design decisions might mean that constructing the proof is painful. In the case of the Artin-Tate lemma we eventually let all the rings be types and used <code>algebra</code> to glue everything together, and also <code>is_scalar_tower</code> (this is a statement that a triangle commutes).</p>",
        "id": 284240337,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653760090
    },
    {
        "content": "<p>I noticed we need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">totient_super_multiplicative</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.totient</span> <span class=\"bp\">*</span> <span class=\"n\">b.totient</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">totient</span>\n</code></pre></div>\n<p>this should be easy and it can go directly to mathlib. So if someone is looking for a place to start this looks like a nice small lemma.</p>",
        "id": 284868174,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654257930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284868174\">said</a>:</p>\n<blockquote>\n<p>I noticed we need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">totient_super_multiplicative</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.totient</span> <span class=\"bp\">*</span> <span class=\"n\">b.totient</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">totient</span>\n</code></pre></div>\n<p>this should be easy and it can go directly to mathlib. So if someone is looking for a place to start this looks like a nice small lemma.</p>\n</blockquote>\n<p>I'm actually working on this now. Actually, I'm proving that totient is <code>is_gcd_mult</code> (which is a made up name)</p>",
        "id": 284868315,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654258006
    },
    {
        "content": "<p>We also need </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">contains_two_primitive_roots</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive_root</span> <span class=\"n\">x</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive_root</span> <span class=\"n\">y</span> <span class=\"n\">q</span><span class=\"o\">):</span> <span class=\"o\">(</span><span class=\"n\">lcm</span> <span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">totient</span> <span class=\"bp\">≤</span>\n<span class=\"o\">(</span><span class=\"n\">finite_dimensional.finrank</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>But this might be harder/more annoying</p>",
        "id": 284868548,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654258152
    },
    {
        "content": "<p>can't we just create the explicit element of order <code>ф(lcm p q)</code> and then that gives us a bound on the finrank?</p>",
        "id": 284872483,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260297
    },
    {
        "content": "<p>not order... my words are vanishing in my head</p>",
        "id": 284872543,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260348
    },
    {
        "content": "<p>I think we have that K + a primitive root is a cyclotomic extension somewhere</p>",
        "id": 284872624,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260375
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284872483\">said</a>:</p>\n<blockquote>\n<p>can't we just create the explicit element of order <code>ф(lcm p q)</code> and then that gives us a bound on the finrank?</p>\n</blockquote>\n<p>Yeah thats the idea. I guess I don't know how easy it is at the moment to go from knowing we have some root of unity in the field, to giving a lower bound on the degree.</p>",
        "id": 284872872,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654260466
    },
    {
        "content": "<p>But I've not yet looked into the API for this, so maybe its easy</p>",
        "id": 284872901,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654260480
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.finrank\">docs#is_cyclotomic_extension.finrank</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.adjoin_is_cyclotomic_extension\">docs#is_primitive_root.adjoin_is_cyclotomic_extension</a></p>",
        "id": 284873532,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260716
    },
    {
        "content": "<p>I think we don't have that if <code>A C S</code> is a cycl extension, and <code>A B K</code> is one, then <code>B C (S / K)</code> is but maybe that follows from something like <code>is_cyclotomic_extension.trans</code></p>",
        "id": 284873712,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260768
    },
    {
        "content": "<p>and also I don't think we can turn for example <code>is_cycl_ext A B {p, q}</code> into <code>is_cycl_ext A B {lcm p q}</code> or for a nice challenge <code>is_cycl_ext A B S</code> to <code>is_cycl_extension A B {S.lcm id}</code></p>",
        "id": 284873940,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654260847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/284868174\">said</a>:</p>\n<blockquote>\n<p>I noticed we need</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">totient_super_multiplicative</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a.totient</span> <span class=\"bp\">*</span> <span class=\"n\">b.totient</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">totient</span>\n</code></pre></div>\n<p>this should be easy and it can go directly to mathlib. So if someone is looking for a place to start this looks like a nice small lemma.</p>\n</blockquote>\n<p>Alright, this is done, but its still a mess. I'll golf and look to PR it next week.</p>",
        "id": 284892595,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654269585
    },
    {
        "content": "<p>I've made some progress in <code>contains_two_primitive_roots</code>. It's quite annoying, but I've constructed an element of order <code>lcm p q</code> (modulo the fact that the order doesn't change under a coercion, this is an independent result that I don't find). I will not work on this for a couple of days, if someone wants to finish from here no problems.</p>",
        "id": 284934231,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654291309
    },
    {
        "content": "<p>The two sorry about the order are done.</p>",
        "id": 284935638,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654292169
    },
    {
        "content": "<p>I guess we need to generalize <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.finrank\">docs#is_cyclotomic_extension.finrank</a> to the case <code>L</code> is  domain. It should be very easy.</p>",
        "id": 284938791,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654294445
    },
    {
        "content": "<p>I'm not sure how easy that is with the current proof</p>",
        "id": 284968066,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654333644
    },
    {
        "content": "<p>I think there is simply nothing to do. Note that I don't want to generalize the base ring, just the big one.</p>",
        "id": 284968893,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654335031
    },
    {
        "content": "<p>I've tested <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.power_basis\">docs#is_primitive_root.power_basis</a> and it's OK</p>",
        "id": 284968903,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654335061
    },
    {
        "content": "<p>I mean like in <a href=\"https://github.com/leanprover-community/mathlib/pull/14550\">#14550</a>. I have to stop now, but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.finrank\">docs#is_cyclotomic_extension.finrank</a>  is OK in that PR. Something broke later, but I think it is just because <code>C</code> is implicit/explicit or something similar. If you have time and want to finish it feel free to work on it <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 284969796,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654336448
    },
    {
        "content": "<p>I'll have a try when I get to the airport and have some time :)</p>",
        "id": 284970434,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654337392
    },
    {
        "content": "<p>I am officially late for my lunch, but it should work now.</p>",
        "id": 284970585,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654337560
    },
    {
        "content": "<p>I didn't touch <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.embeddings_equiv_primitive_roots\">docs#is_primitive_root.embeddings_equiv_primitive_roots</a> (because I am lazy) but it should be generalizable too.</p>",
        "id": 284970615,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654337633
    },
    {
        "content": "<p>sorry, I had a hectic while, I think I should've fixed it now</p>",
        "id": 285097700,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654513609
    },
    {
        "content": "<p>I wonder if this is a Lean change more than anything, I assume that if you have a cycl extension over a field (apart from the fact that <code>unit</code> is the <code>{}</code>th cyclotomic extension) then we have that it is also a field though</p>",
        "id": 285097752,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654513656
    },
    {
        "content": "<p>but if it helps it helps!</p>",
        "id": 285097764,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654513666
    },
    {
        "content": "<p>if anyone is reading this stream, reviews on <a href=\"https://github.com/leanprover-community/mathlib/pull/14463\">#14463</a> would be good! (this is another one, changing the defn of is_cyclotomic_extension)</p>",
        "id": 285097869,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654513734
    },
    {
        "content": "<p>I have finished the proof of lemma 3.3: <code>mem_roots_of_unity_of_abs_eq_one</code>. I am going to take a few days to polish and clean the proof, but I should have something ready soon. What should I do when it's ready? should I just do a <code>git push origin</code> of my local branch?</p>",
        "id": 285104139,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1654518155
    },
    {
        "content": "<p>Yeah - though feel free to push your branch before polishing as well</p>",
        "id": 285107635,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1654519967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/285097752\">said</a>:</p>\n<blockquote>\n<p>I wonder if this is a Lean change more than anything, I assume that if you have a cycl extension over a field (apart from the fact that <code>unit</code> is the <code>{}</code>th cyclotomic extension) then we have that it is also a field though</p>\n</blockquote>\n<p>Yes, a domain that is a finite extension of a field is a field (multiplication by an element is injective, hence surjective). I guess this is somewhere with <code>is_field</code>.</p>",
        "id": 285113392,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654522831
    },
    {
        "content": "<p>I guess this doesn't hold for something like <code>{3,9,27,...}</code> though, although maybe it holds for deeper reasons</p>",
        "id": 285114736,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654523462
    },
    {
        "content": "<p>It holds (assuming it is a domain, I don't know whether this is automatic): take <code>x</code> in the extension. It is algebraic, so the subextension generated by it  it's finite and so it contains an inverse of <code>x</code>.</p>",
        "id": 285115180,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654523665
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_integral.is_field_iff_is_field\">docs#is_integral.is_field_iff_is_field</a></p>",
        "id": 285115279,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654523728
    },
    {
        "content": "<p>Well, I pushed my changes to the project. I hope I didn't break anything...</p>",
        "id": 285211084,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1654585702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/285115279\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_integral.is_field_iff_is_field\">docs#is_integral.is_field_iff_is_field</a></p>\n</blockquote>\n<p>indeed, right below <code>integral</code>, this works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">is_field</span> <span class=\"o\">(</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_cyclotomic_extension</span> <span class=\"n\">S</span> <span class=\"n\">K</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_field</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_integral.is_field_iff_is_field</span> <span class=\"o\">(</span><span class=\"n\">integral</span> <span class=\"n\">S</span> <span class=\"n\">K</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">$</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">K</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"bp\">$</span>\n  <span class=\"n\">field.to_is_field</span> <span class=\"n\">K</span>\n</code></pre></div>\n<p>I'll PR a fix to dot notation on that lemma, and when I get some actual time I'll try extend the proof to non-finite <code>S</code> for fun</p>",
        "id": 285215050,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654588610
    },
    {
        "content": "<p>I'll have a look at why your thing isn't building, Xavier! seems to just be a small namespace thing so apart from that it looks good</p>",
        "id": 285215258,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654588727
    },
    {
        "content": "<p>Thanks for working on <a href=\"https://github.com/leanprover-community/mathlib/pull/14550\">#14550</a>! Do you think it is ready for review?</p>",
        "id": 285351305,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654670978
    },
    {
        "content": "<p>oh, it compiled! yes, it is :)</p>",
        "id": 285370065,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654682931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"488648\">Xavier Roblot</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/285104139\">said</a>:</p>\n<blockquote>\n<p>I have finished the proof of lemma 3.3: <code>mem_roots_of_unity_of_abs_eq_one</code>. I am going to take a few days to polish and clean the proof, but I should have something ready soon. What should I do when it's ready? should I just do a <code>git push origin</code> of my local branch?</p>\n</blockquote>\n<p>I've missed this message, great job!</p>",
        "id": 285526683,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654778121
    },
    {
        "content": "<p>Thanks. But now I am hooked <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> Is there any thing else I can work on?</p>",
        "id": 285564698,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1654793737
    },
    {
        "content": "<p>Well, following the philosophy of the project I think you should PR this!</p>",
        "id": 285595601,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654808790
    },
    {
        "content": "<p>Do you have a roadmap for this project or some kind of plan? I'm hard at work with LTE now but when it's done I'd like to join the Fermat project too.</p>",
        "id": 285595930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1654808973
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/flt-regular/\">https://leanprover-community.github.io/flt-regular/</a></p>",
        "id": 285596006,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1654809004
    },
    {
        "content": "<p>We are almost ready to attack case I, right? I will check this tomorrow</p>",
        "id": 285596118,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654809067
    },
    {
        "content": "<p>I think the next boss is  the <a href=\"https://leanprover-community.github.io/flt-regular/sect0003.html#lemma:unit_lemma\">unit lemma</a>. We have a draft version <a href=\"https://github.com/leanprover-community/flt-regular/blob/349894f1f94337afb0ab68a53f2eec4bfeccc1c8/src/number_theory/cyclotomic/Unit_lemmas.lean#L591\">here</a> but we should probably refactor some definition/results. I have time now to produce a reasonable statement.</p>",
        "id": 285639649,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654845469
    },
    {
        "content": "<p>Yeah I agree. One think to fix is the Galois action on these things. I think at the moment it's probably a bit to hacky</p>",
        "id": 285642929,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654848043
    },
    {
        "content": "<p>Do we have somewhere that the conjugate of a complex number of norm <code>1</code> is its inverse? It should be easy anyway</p>",
        "id": 285643388,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654848406
    },
    {
        "content": "<p>it is essentially <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.norm_sq_eq_conj_mul_self\">docs#complex.norm_sq_eq_conj_mul_self</a></p>",
        "id": 285643621,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654848588
    },
    {
        "content": "<p>So I propose to redefine <code>is_gal_conj_real</code> in terms of the Galois group, connect it with <code>ℝ</code> in some way, and prove the unit lemma using this new \"is real\" notion.</p>",
        "id": 285644057,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654848873
    },
    {
        "content": "<p>Do we need to connect it to <code>ℝ</code>? If I remember correctly the proofs only ever use that things are fixed by complex conjugation.</p>",
        "id": 285644156,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654848940
    },
    {
        "content": "<p>Probably not, but it seems a reasonable thing to have. And it should be a couple of lines</p>",
        "id": 285644264,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654849018
    },
    {
        "content": "<p>Fair enough, I thought linking things to <code>ℝ</code> would make things more annoying because of extra <code>coe</code> maps. But maybe this is fine/you have something else in mind</p>",
        "id": 285644335,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654849081
    },
    {
        "content": "<p>I am not saying we should use <code>ℝ</code> anywhere in the project. Just the fact that <code>is_gal_conj_real x</code> is equivalent to <code>x ∈ ℝ</code> (strictly speaking this doesn't make sense), but this is useful only to explain what <code>is_gal_conj_real x</code> means, not to actually work with it.</p>",
        "id": 285644731,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654849340
    },
    {
        "content": "<p>Oh ok I get you! Yes then I agree</p>",
        "id": 285644786,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1654849368
    },
    {
        "content": "<p>I mean, if I see this in a PR I would immediately ask for it, even if mathematically it's not needed.</p>",
        "id": 285644799,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654849377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/285595601\">said</a>:</p>\n<blockquote>\n<p>Well, following the philosophy of the project I think you should PR this!</p>\n</blockquote>\n<p>Ok. Can you please give me access to push to mathlib? <br>\nAlso, there are some choices that need to be discussed. I'll create a new thread for that.</p>",
        "id": 285647852,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1654851316
    },
    {
        "content": "<p>You should have an invitation</p>",
        "id": 285648603,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654851783
    },
    {
        "content": "<p>Got it. Thanks!</p>",
        "id": 285648776,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1654851870
    },
    {
        "content": "<p>Having a PR accepted can be a little frustrating, so don't be afraid of asking questions, and be patient <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 285649031,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1654852027
    },
    {
        "content": "<p>Thanks to <a href=\"https://github.com/leanprover-community/mathlib/pull/14550\">#14550</a> <code>contains_two_primitive_roots</code> is now proved. I am not sure I have time today, but we need a small refactor of <code>number_theory/cyclotomic/Unit_lemmas</code>, replacing <code>KK</code> by a generic cyclotomic extension.</p>",
        "id": 286182264,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655282889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"488648\">@Xavier Roblot</span> do you mind moving the material you PRed to the <code>ready_for_mathlib</code> folder? Just to keep track of what we are adding to mathlib. (And I will have a look at you PR today)</p>",
        "id": 286327637,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655371690
    },
    {
        "content": "<p>I moved the things already PRed in a previous commit named <a href=\"https://github.com/leanprover-community/flt-regular/commit/cf3644d4be0e74fb1ecf36d41fc33a9527ad7d44\">PR #14749</a>. I am still working on the other PRs.</p>\n<p>Thanks for the taking the time to look at my PR!</p>",
        "id": 286329017,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1655372583
    },
    {
        "content": "<p>I've added a \"From flt-regular\" at the end of the description of the PR.</p>",
        "id": 286332993,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655375501
    },
    {
        "content": "<p>I've also left a couple of comments. I think a lot of the results you prove in your specific case are already somewhere in mathlib (in greater generality). It can be tricky to find them, but don't hesitate to ask here!</p>",
        "id": 286334938,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655376869
    },
    {
        "content": "<p>There is <code>unit_inv_conj_not_neg_zeta_runity</code> in <code>src/number_theory/cyclotomic/Unit_lemmas.lean</code> that is the last sorry in the file. If someone wants to try it please go ahead.</p>",
        "id": 286766544,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655715092
    },
    {
        "content": "<p>is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smodeq\">docs#smodeq</a> the correct way to talk about things being equal up to an ideal?</p>",
        "id": 286822499,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655746327
    },
    {
        "content": "<p>I don't really want to develop new API unless necessary but I know some people don't like the ideal/submodule R R defeq too much</p>",
        "id": 286822523,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655746349
    },
    {
        "content": "<p>Mathematically I would just work in the quotient, in mathlib I am not sure.</p>",
        "id": 286822605,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655746435
    },
    {
        "content": "<p>We don't actually have that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.power_basis\">docs#is_primitive_root.power_basis</a> is a Z-basis of (OK/docs#cyclotomic_ring), right? I guess we should also make the equiv to <code>polynomial K / (X ^ k - 1)</code>, which I dont think we have</p>",
        "id": 286844505,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655764445
    },
    {
        "content": "<p>I am afraid we don't have a lot about power basis over rings that are not fields. We know that that O_K is Z[zeta] (I am on mobile, sorry)</p>",
        "id": 286845864,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655765753
    },
    {
        "content": "<p>don't worry! O_K is <code>Z[zeta]</code> how? I see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cyclotomic_ring\">docs#cyclotomic_ring</a> but not the \"classic\" Z[zeta]</p>",
        "id": 286846106,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655766000
    },
    {
        "content": "<p>ah, if we have it as an <code>adjoin_root *</code> then we get <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.power_basis'\">docs#adjoin_root.power_basis'</a>. I'll try see if this is workable</p>",
        "id": 286846251,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655766112
    },
    {
        "content": "<p>I mean <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.rat.is_integral_closure_adjoing_singleton_of_prime_pow\">docs#is_cyclotomic_extension.rat.is_integral_closure_adjoing_singleton_of_prime_pow</a> for prime powers. The general case requires more work.</p>",
        "id": 286846362,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655766226
    },
    {
        "content": "<p>should be good enough for the last <code>sorry</code>, the prime assumption is missing right now but I don't think it's relevant to have it without, anyways</p>",
        "id": 286846542,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655766382
    },
    {
        "content": "<p>I guess what we really need is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_cyclotomic_extension</span> <span class=\"n\">S</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_cyclotomic_extension</span> <span class=\"n\">S</span> <span class=\"n\">K</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">L</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>(I mean, I think for what we need domains is fine, and obviously singleton extensions). I'm going to try work on it, but not too sure it'll work too well!</p>",
        "id": 286851452,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655771782
    },
    {
        "content": "<p>The case of field follows from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_cyclotomic_extension.splitting_field_X_pow_sub_one\">docs#is_cyclotomic_extension.splitting_field_X_pow_sub_one</a></p>",
        "id": 286864276,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655785744
    },
    {
        "content": "<p>I am not sure what to do with domains</p>",
        "id": 286864282,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655785767
    },
    {
        "content": "<p>Are you working on <code>unit_inv_conj_not_neg_zeta_runity</code>?</p>",
        "id": 286913437,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655818341
    },
    {
        "content": "<p>yeah, exactly the idea</p>",
        "id": 286915313,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655819174
    },
    {
        "content": "<p>not super actively though, just bits and bobs when I can find some spare time</p>",
        "id": 286915348,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655819192
    },
    {
        "content": "<p>Let me see if we can somehow produce a power basis over something it is not a field.</p>",
        "id": 286915725,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655819364
    },
    {
        "content": "<p>that's the hope with the equiv + <code>adjoin_root</code>, but I think actually this is just loops around the most important idea of getting the basis over not-a-field; this isn't \"free\" though, wasn't this something like a lattice or such? it's been a while since i've seen the standard texts</p>",
        "id": 286916519,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655819721
    },
    {
        "content": "<p>Yes, we cannot have this completely for free. For example if you take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><msqrt><mrow><mo>−</mo><mn>3</mn></mrow></msqrt><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R = \\mathbb{Z}[\\sqrt{-3}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1156em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8656em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">−</span><span class=\"mord\">3</span></span></span><span style=\"top:-2.8256em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1744em;\"><span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><msqrt><mrow><mo>−</mo><mn>3</mn></mrow></msqrt></mrow><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">x = \\frac{1+\\sqrt{-3}}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.383em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.038em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.4282em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">+</span><span class=\"mord sqrt mtight\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8712em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord mtight\" style=\"padding-left:0.833em;\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">3</span></span></span><span style=\"top:-2.8312em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail mtight\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1688em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span>, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mi>x</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[x]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">]</span></span></span></span> (the extension inside <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>=</mo><mrow><mi mathvariant=\"normal\">F</mi><mi mathvariant=\"normal\">r</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">c</mi></mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">K = \\mathrm{Frac}(R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">Frac</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>) is not free over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>, even if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> has minimal polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">x^2-x+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 286917678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655820128
    },
    {
        "content": "<p>The point is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is not integrally closed.</p>",
        "id": 286917701,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655820141
    },
    {
        "content": "<p>OK, I have a strategy. Let <code>R</code> be an integrally closed domain (for the mathlib proof we will need more, see below) with field of fraction <code>K</code>. Let <code>L</code> be an extension of <code>K</code> (probably very few assumption on  <code>L</code> are needed, not even a field I think) and let <code>x : L</code> integral over <code>R</code>, and let <code>f := minpoly R x</code>. We construct an isomorphism <code>adjoin_root f ≃ₐ[R] adjoin R x</code> as follows:</p>\n<ul>\n<li>the morphism is given by <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.lift_hom\">docs#adjoin_root.lift_hom</a>;</li>\n<li><code>x</code> is in the image, so it is surjective (I didn't check the details,  but everything is surely already in mathlib);</li>\n<li>injectivity is the interesting part. Let <code>P1 : adjoin_root f</code> be in the kernel. This gives via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.lift_hom_mk\">docs#adjoin_root.lift_hom_mk</a> a polynomial <code>P</code> that has <code>x</code> as root. Now, <em><code>f</code> divides <code>P</code></em>! This is in general false without some assumption on <code>R</code>, but true if <code>R</code> is integrally closed. In mathlib the best result we have is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/minpoly.gcd_domain_dvd\">docs#minpoly.gcd_domain_dvd</a>, that is good enough for <code>R = ℤ</code> (the assumption that <code>P</code> is primitive is harmless). Since <code>f</code> divides <code>P</code>, by definition <code>P1 = 0</code> and we're done.</li>\n</ul>",
        "id": 286921361,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655821577
    },
    {
        "content": "<p>Now one can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.power_basis'\">docs#adjoin_root.power_basis'</a> to get the power basis of <code>adjoin R x</code>.</p>",
        "id": 286921516,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655821651
    },
    {
        "content": "<p>I think this is a really nice result we absolutely want in mathlib (maybe with also a version for fields, even if this one can be obtained using an easier strategy).</p>",
        "id": 286921830,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655821782
    },
    {
        "content": "<p>the field one already exists, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.adjoin.power_basis\">docs#algebra.adjoin.power_basis</a></p>",
        "id": 286932668,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655825951
    },
    {
        "content": "<p>I mean the iso, but yes, it can be produced using this kind of results.</p>",
        "id": 286933750,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655826328
    },
    {
        "content": "<p>ah, right, I see</p>",
        "id": 286933778,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655826341
    },
    {
        "content": "<p>found this whilst looking for the surjectiveness: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly\">docs#alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly</a>. I'm not so sure the surjectiveness is in, but it's not too bad so I'll try make it.</p>",
        "id": 286948287,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655832569
    },
    {
        "content": "<p>Yep the point is exactly to generalize this from <code>field F</code> to <code>gcd_monoid F</code></p>",
        "id": 286982024,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655850382
    },
    {
        "content": "<p>this all comes back to <a href=\"https://github.com/leanprover-community/mathlib/pull/11523\">#11523</a>, I guess this is what you were thinking about back then!</p>",
        "id": 286985617,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655853132
    },
    {
        "content": "<p>Note that we don't need <a href=\"https://github.com/leanprover-community/mathlib/pull/11523\">#11523</a> in <code>flt-regular</code>, we want to apply this in the case <code>R = ℤ</code>, so the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/minpoly.gcd_domain_dvd\">docs#minpoly.gcd_domain_dvd</a> is enough. It should be really easy, I can write down a proof today.</p>",
        "id": 287024936,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655888831
    },
    {
        "content": "<p>I pushed what I had to a file called <code>z_basis.lean</code>. I'm not sure how much time I'll have further today, but I left some comments about what are the \"obvious\" sticking points; hopefully I get to sit down and work through them more methodically later.</p>",
        "id": 287031476,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655892335
    },
    {
        "content": "<p>I've added a new file <code>src/ready_for_mathlib/adjoin_root.lean</code> with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">minpoly.to_adjoin_equiv</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">minpoly</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"o\">({</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 287046678,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655901371
    },
    {
        "content": "<p>It is already sorry free. Now the idea is to transport  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.power_basis'\">docs#adjoin_root.power_basis'</a> via this equiv, to get a power basis <code>pb</code> of  <code>adjoin R ({x} : set A)</code> such that <code>pb.gen = x</code>.</p>",
        "id": 287047094,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655901590
    },
    {
        "content": "<p>This is also done.</p>",
        "id": 287049348,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655902682
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> do you agree that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cyclotomic_ring.eq_adjoin_primitive_root\">docs#cyclotomic_ring.eq_adjoin_primitive_root</a> is evil? It is stated as an equality of types, but I think it should an iso of algebras, or whatever.</p>",
        "id": 287058817,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655906881
    },
    {
        "content": "<p>Yes that's definitely evil! It will be hard to use</p>",
        "id": 287059037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1655906972
    },
    {
        "content": "<p>yeah, do we have eq_to_equiv or sth somewhere?</p>",
        "id": 287066688,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655910134
    },
    {
        "content": "<p>You should copy the subalgebra if you want to transfer results between LHS/RHS, right? Subalgebra equality is unproblematic. (Maybe no need to copy, just use the subalgebra equality.)</p>",
        "id": 287067668,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1655910511
    },
    {
        "content": "<p><code>cyclotomic_ring</code> is the subalgebra with everything automatically coerced: <code>def cyclotomic_ring : Type w := adjoin A { b : (cyclotomic_field n K) | b ^ (n : ℕ) = 1 }</code></p>",
        "id": 287067890,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655910613
    },
    {
        "content": "<p>it may be worth undoing that</p>",
        "id": 287067903,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655910617
    },
    {
        "content": "<p>I am not sure I follow your strategy. I just added to your file the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"bp\">+</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">char_zero</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ζ</span> <span class=\"o\">:</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">power_basis_int</span> <span class=\"o\">[</span><span class=\"n\">hcycl</span> <span class=\"o\">:</span> <span class=\"n\">is_cyclotomic_extension</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hζ</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive_root</span> <span class=\"n\">ζ</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">power_basis</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">_</span> <span class=\"o\">:=</span> <span class=\"n\">is_integral_closure_adjoing_singleton_of_prime_pow</span> <span class=\"n\">hζ</span> <span class=\"k\">in</span> <span class=\"kd\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"o\">(</span><span class=\"n\">adjoin.power_basis'</span> <span class=\"n\">ℚ</span> <span class=\"o\">(</span><span class=\"n\">hζ.is_integral</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n  <span class=\"o\">(</span><span class=\"n\">is_integral_closure.equiv</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">adjoin</span> <span class=\"n\">ℤ</span> <span class=\"o\">({</span><span class=\"n\">ζ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">power_basis_int_gen</span> <span class=\"o\">[</span><span class=\"n\">hcycl</span> <span class=\"o\">:</span> <span class=\"n\">is_cyclotomic_extension</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hζ</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive_root</span> <span class=\"n\">ζ</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">power_basis_int</span> <span class=\"n\">hζ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">gen</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">ζ</span><span class=\"o\">,</span> <span class=\"n\">hζ.is_integral</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">pos</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 287068416,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655910846
    },
    {
        "content": "<p>This is what we want, right? I don't think there is a need to speak about <code>cyclotomic_ring</code>. The real object is <code>𝓞 K</code> (that in this case is the same as <code>cyclotomic_ring</code>, but we can forget about it)</p>",
        "id": 287068536,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655910909
    },
    {
        "content": "<p>I'm suggesting we change <code>cyclotomic_ring</code> to <code>subalgebra A (cyclotomic_field n K)</code>, and whenever it needs to be coerced then so be it</p>",
        "id": 287068588,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655910936
    },
    {
        "content": "<p>but yes, I think this is what we want!</p>",
        "id": 287068599,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655910944
    },
    {
        "content": "<p>I've proved <code>power_basis_int_gen</code>, so we now have a <code>ℤ</code>-power basis of the ring of integers of a cyclotomic extensions of <code>ℚ</code> whose generator is any given primitive root of unity (in the <code>p^k</code>-case).</p>",
        "id": 287070217,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655911636
    },
    {
        "content": "<p>This completely characterize the ring structure of <code>𝓞 K</code> and since the API for <code>power_basis</code> is pretty complete, and we know everything about the minimal polynomial of the generator, nothing else should be needed to study <code>𝓞 K</code>.</p>",
        "id": 287070657,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655911813
    },
    {
        "content": "<p>I suggest to avoid <code>cyclotomic_ring</code>as much as possible, I am wondering if we shouldn't have defined it, but anyway</p>",
        "id": 287071293,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655912084
    },
    {
        "content": "<p>I have pushed some work to <code>unit_inv_conj_not_neg_zeta_runity</code> (and, sadly, a <code>power_basis_int'</code> because <code>x^1</code> is not defeq to <code>x</code> :[) some of it is an easy <code>sorry</code> (<code>conj ζⁿ = ζ⁻ⁿ</code> modulo coercions and whether we want to go into <code>zpow</code> or not) and the rest is the deciding how we're dealing with equality mod <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>ζ</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1 - \\zeta)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mclose\">)</span></span></span></span> - this could be trivial or fairly hard, I'm not sure. We'll also end up needing that <code>ζⁿ ∈ (1 - ζ)</code>, but I think we had that somewhere!</p>",
        "id": 287090320,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655920621
    },
    {
        "content": "<p>The need for <code>power_basis_int'</code> makes me a little sad, but that's like I guess.</p>",
        "id": 287091293,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655921086
    },
    {
        "content": "<p>I've never really thought about the math proof of <code>unit_inv_conj_not_neg_zeta_runity</code>. Which strategy are you following?</p>",
        "id": 287094997,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655922828
    },
    {
        "content": "<p>There is a proof in Washingtons book (if I remember correctly)</p>",
        "id": 287095184,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1655922902
    },
    {
        "content": "<p>I will have a look, but it is not trivial, right?</p>",
        "id": 287095370,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655922967
    },
    {
        "content": "<p>I thought you needed to use the basis for the ring of integers, but I'm not 100% sure. I'm on mobile right now, but I can check when I get home</p>",
        "id": 287095536,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1655923046
    },
    {
        "content": "<p>Yes, I'm following that proof. The idea is that you have a unit u and that is equal to sum a_iz^i, módulo the ideal it's sum a_i. The conjugate has a similar representation, and so 2u is in the ideal; but it's prime, and 2 is not in (1-z) and clearly neither is u.</p>",
        "id": 287096053,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655923298
    },
    {
        "content": "<p>Ah yes, I've found it. OK, it's not trivial but nothing specially difficult</p>",
        "id": 287096088,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655923318
    },
    {
        "content": "<p>You may want to modify what I did today to obtain a power basis whose generator is <code>ζ - 1</code>.</p>",
        "id": 287096475,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655923506
    },
    {
        "content": "<p>Hmm, no, that's OK.</p>",
        "id": 287096556,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655923557
    },
    {
        "content": "<p>In any case we need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>ζ</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(ζ - 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> is a prime ideal.</p>",
        "id": 287097319,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655923932
    },
    {
        "content": "<p>This follows from the fact that the norm is <code>p</code>, but we need to know that an algebraic integer with norm <code>1</code> is a unit.</p>",
        "id": 287099081,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655924785
    },
    {
        "content": "<p>Which in turn follows from the fact that the Galois conjugate of an algebraic integer are algebraic integers.</p>",
        "id": 287099116,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655924809
    },
    {
        "content": "<p>some more boring stuff been done, mostly on fleshing out <code>galois_action_on_cyclo</code> so it's not littered with zeros. I like my proof for <code>gal_conj_idempotent</code>:)</p>",
        "id": 287125769,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655939745
    },
    {
        "content": "<p>on a serious note, I'm not sure what to do about <code>embedding_conj</code>: can we get things as ℚ-alg homs for free somehow?</p>",
        "id": 287125822,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655939769
    },
    {
        "content": "<p>then we can use <code>power_basis.alg_hom_ext</code> to make things nice</p>",
        "id": 287125831,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655939779
    },
    {
        "content": "<p>aha, I found <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_hom.to_rat_alg_hom\">docs#ring_hom.to_rat_alg_hom</a>, but both <code>  have := φ.to_rat_alg_hom</code> and <code>have := (conj : ℂ →+* ℂ).to_rat_alg_hom</code> get into TC loops :/ is this to do with qsmul and such?</p>",
        "id": 287126598,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655940471
    },
    {
        "content": "<p>ok, I figured out a workaround anyways. something is weird with the instance caches in that file.</p>",
        "id": 287131980,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655945884
    },
    {
        "content": "<p><code>galois_action_on_cyclo</code> is now sorry-free, and <code>Unit_lemmas</code> is only waiting on finishing off this step.</p>",
        "id": 287133037,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655947190
    },
    {
        "content": "<p>Note that in <a href=\"#narrow/stream/113488-general/topic/Embeddings.20of.20a.20.20number.20field\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Embeddings.20of.20a.20.20number.20field</a> we decided to use ring hom for number fields, rather than <code>Q</code>-alg hom, so we should follow that decision.</p>",
        "id": 287159133,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655973058
    },
    {
        "content": "<p>Yeah, it was just to use some results temporarily. See the top of galois_action_on_cyclo</p>",
        "id": 287162267,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655975117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/287099116\">said</a>:</p>\n<blockquote>\n<p>Which in turn follows from the fact that the Galois conjugate of an algebraic integer are algebraic integers.</p>\n</blockquote>\n<p>where do you want to put this? may have some time to work on this all today</p>",
        "id": 287179900,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1655986069
    },
    {
        "content": "<p>In the project you can just create a new file, who cares. In mathlib it can go in the same file where <code>is_integral</code> is defined, it doesn't require any Galois theory. If <code>σ : B →ₐ[A] B</code>, where you have an algebra tower <code>R/A/B</code> and <code>x : B</code> is integral over <code>R</code>, then <code>σ x</code> is integral over <code>R</code>. It should be immediate, the minimal polynomial is the same.</p>",
        "id": 287180379,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655986352
    },
    {
        "content": "<p>Then I think the morally correct thing to do is define a function <code>norm' : 𝓞 K →* 𝓞 K</code> (it follows immediately from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.is_integral_norm\">docs#algebra.is_integral_norm</a>, but it is annoying to write <code>obtain ...</code> all the time) and prove that <code>x ∈ (𝓞 K)ˣ</code> iff <code>norm' x ∈ (𝓞 K)ˣ</code>.</p>",
        "id": 287183487,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1655988129
    },
    {
        "content": "<p>do we have algebra.norm in terms of the galois group or do I have to write it? there's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.norm_eq_prod_embeddings\">docs#algebra.norm_eq_prod_embeddings</a> but that doesn't work because that all ends up in a larger extension</p>",
        "id": 287212116,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656000405
    },
    {
        "content": "<p>I just delegated a PR that does that for the trace</p>",
        "id": 287214835,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656001523
    },
    {
        "content": "<p>It should be easy to adapt to the norm</p>",
        "id": 287214859,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656001535
    },
    {
        "content": "<p>I am on mobile, but check the running PR</p>",
        "id": 287214910,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656001560
    },
    {
        "content": "<p>Or use the product of the roots of the minimal polynomial</p>",
        "id": 287215518,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656001801
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14523\">#14523</a></p>",
        "id": 287215519,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656001801
    },
    {
        "content": "<p>thanks, I'll have a look at this</p>",
        "id": 287215714,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656001868
    },
    {
        "content": "<p>I've asked to do it for the norm. It should be really the same proof</p>",
        "id": 287216064,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656002016
    },
    {
        "content": "<p>So there is at the moment an ongoing discussion on the best way to prove the formula for the coefficients of a polynomial in terms of its roots from the results in <code>ring_theory.polynomia.vieta</code> (see <a href=\"https://github.com/leanprover-community/mathlib/pull/14908\">#1408</a>). Until it is resolved, my PR of <code>mem_roots_of_unity_of_abs_eq_one</code> is on hold. <br>\nSo is there anything else I can work on in the meantime?  I see you guys have been quite busy lately and made some significant progress.</p>",
        "id": 287309485,
        "sender_full_name": "Xavier Roblot",
        "timestamp": 1656063314
    },
    {
        "content": "<p>You can coordinate with <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> to finish the proof of <code>unit_inv_conj_not_neg_zeta_runity</code>.  We need that <code>ζ - 1</code> is prime and it does not divide <code>2</code> (both are computation with the norm, we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.sub_one_norm_prime_ne_two\">docs#is_primitive_root.sub_one_norm_prime_ne_two</a> but we are mising some glue to obtain the two results).</p>\n<p>Looking at the blueprint it seems that the only other missing result in sections 1-2-3 is <a href=\"https://leanprover-community.github.io/flt-regular/sect0003.html#lemma:fac_of_p_in_p_th_root\">Lemma 3.8</a>, I think we don't even have the statement.</p>",
        "id": 287313314,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656066004
    },
    {
        "content": "<p>Note that <a href=\"https://github.com/leanprover-community/mathlib/pull/14523\">#14523</a> will be in mathlib in a few hours, with the result about the norm.</p>",
        "id": 287313566,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656066209
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"453640\">@Iván Sadofschi Costa</span>! I am working on showing (1 - z) is prime, im away from a computer right now but I should push a proof for that by ~ <time datetime=\"2022-06-24T15:00:00Z\">2022-06-24T16:00:00+01:00</time></p>",
        "id": 287319236,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656070212
    },
    {
        "content": "<p>So Xavier, feel free to work on the other stuff (for now, just put it as a sorry that the ideal is prime)</p>",
        "id": 287319271,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656070245
    },
    {
        "content": "<p>i've finally pushed the unit stuff, sorry!</p>",
        "id": 287362466,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656092775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/287099081\">said</a>:</p>\n<blockquote>\n<p>This follows from the fact that the norm is <code>p</code>, but we need to know that an algebraic integer with norm <code>1</code> is a unit.</p>\n</blockquote>\n<p>how does this proof work? I had to return all my paper books now :(</p>",
        "id": 287362508,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656092801
    },
    {
        "content": "<p>The fact that <code>I = (z-1)</code> is prime? The math proof is that the norm (of the ideal) is <code>p</code>, so if <code>I = AB</code> then the norm of, say, <code>A</code> must be 1<code>. Now I have to think how to prove that this implies that </code>A` is trivial.  The point is that ideals are not necessarily principal</p>",
        "id": 287364499,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656093805
    },
    {
        "content": "<p>It can be possible to avoid speaking of ideals but I have to think about it</p>",
        "id": 287364632,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656093855
    },
    {
        "content": "<p>Mmm, do we want to develop the theory of the norm of an ideal? Maybe we want</p>",
        "id": 287366897,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656095055
    },
    {
        "content": "<p>z-1 is prime because if you quotient out by it then you get Z/pZ</p>",
        "id": 287371813,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097507
    },
    {
        "content": "<p>Do you have an elementary proof?</p>",
        "id": 287372025,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656097606
    },
    {
        "content": "<p>Ok, I see</p>",
        "id": 287372147,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656097679
    },
    {
        "content": "<p>The ideal z-1 can't be trivial because the norm of z-1 is p. In particular p is in the ideal (z-1). Now I claim that every element of Z[z] is of the form a+b(z-1) with a in {0,1,2,..,.p-1}, and the proof is...maybe you see :-)</p>",
        "id": 287372198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097689
    },
    {
        "content": "<p>z^n maps to 1 and p maps to 0 and it's game over.</p>",
        "id": 287372224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097709
    },
    {
        "content": "<p>Yes yes that's what I wanted to say but you're too fast</p>",
        "id": 287372247,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656097726
    },
    {
        "content": "<p>Still might be a slight challenge to formalise and to be honest I think your ideal argument is better because it's more conceptual so probably will have other uses.</p>",
        "id": 287372363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097787
    },
    {
        "content": "<p>If your definition of norm(I) is \"size of R/I\" then I think norm(I)=1 implies I=1, but maybe life is not so easy?</p>",
        "id": 287372527,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097852
    },
    {
        "content": "<p>I should say that once LTE is out of the way I am looking forward to joining this project. But of course you should all stop working on this project and come and help us finish LTE, all we have left is about 60 statements about abelian categories and they're quite good fun to prove :-)</p>",
        "id": 287372621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656097910
    },
    {
        "content": "<p>We have only the norm of an element, with all the basic property</p>",
        "id": 287375434,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656099377
    },
    {
        "content": "<p>And we know that the norm of <code>1-z</code> is <code>p</code></p>",
        "id": 287375458,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656099396
    },
    {
        "content": "<p>So <code>p</code> is in the ideal</p>",
        "id": 287375464,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656099407
    },
    {
        "content": "<p>I will try to formalize this tomorrow</p>",
        "id": 287375672,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656099543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/287372621\">said</a>:</p>\n<blockquote>\n<p>I should say that once LTE is out of the way I am looking forward to joining this project. But of course you should all stop working on this project and come and help us finish LTE, all we have left is about 60 statements about abelian categories and they're quite good fun to prove :-)</p>\n</blockquote>\n<p>I tried doing some of the self contained ones once and noped out very hard :b</p>",
        "id": 287380271,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656102032
    },
    {
        "content": "<p>I think doing the norm of an ideal is a good idea, I thought we had that but maybe we just have that it's finite because of Anne&amp;co's work</p>",
        "id": 287380325,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656102068
    },
    {
        "content": "<p>I am giving a try to prove that <code>1-z</code> is prime. It's maybe possible to do it rather directly, so let me see.</p>",
        "id": 287430891,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656157846
    },
    {
        "content": "<p>Norm prime implies prime of course</p>",
        "id": 287434989,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656163514
    },
    {
        "content": "<p>Yes, but that requires the norm of an ideal, that we don't have, right? If the norm of an element is prime that the element is irreducible, this is very easy, but primality seems to require a little bit of work.</p>",
        "id": 287435609,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656164407
    },
    {
        "content": "<p>We need (norm x) = ideal.norm (x)</p>",
        "id": 287436140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656165197
    },
    {
        "content": "<p>What I mean is that there is no <code>ideal.norm</code> at all at the moment, unless I missed it.</p>",
        "id": 287436728,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656166061
    },
    {
        "content": "<p>Is there not? If that's the case maybe I'll try and add that next. It feels like something we should have</p>",
        "id": 287436794,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1656166119
    },
    {
        "content": "<p>Can you reuse <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_norm\">docs#has_norm</a>?</p>",
        "id": 287436807,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656166144
    },
    {
        "content": "<p>Or at least start on it</p>",
        "id": 287436825,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1656166185
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> It's called norm but it's a rather different concept, for example it takes value in <code>Z</code>, or even better in the set of ideals.</p>",
        "id": 287436902,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656166264
    },
    {
        "content": "<p>it's related to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.norm\">docs#algebra.norm</a></p>",
        "id": 287436911,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656166274
    },
    {
        "content": "<p>How can the norm take value in the set of ideals? Also I thought it was N-valued (the defn I know is |Z/I|)</p>",
        "id": 287439078,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1656168715
    },
    {
        "content": "<p>There's a \"relative\" norm on elements N: A -&gt; R for any finite locally free R-algebra A I guess. If R is Noetherian then I guess this is the same as finite flat R-algebra. But for ideal norms I'm a bit more hazy about what's going on.</p>",
        "id": 287439654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656169410
    },
    {
        "content": "<p>The example I've taught is this absolute norm which Eric is talking about but this is specific to orders in integers of number fields or function fields</p>",
        "id": 287439705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656169470
    },
    {
        "content": "<p>I think I have a Lean proof that <code>1-z</code> is prime, avoiding the ideal norm. I will finish it after dinner</p>",
        "id": 287447166,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656179441
    },
    {
        "content": "<p>I have some work on a definition of the ideal norm, the absolute one at least. So if anyone else wants this we should coordinate a little!</p>",
        "id": 287448780,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1656181745
    },
    {
        "content": "<p>I've proved <a href=\"https://github.com/leanprover-community/flt-regular/blob/fa0c5bd666db87aa0ebdd9f8bb0b3ab24e9f1bec/src/norm_prime.lean#L81\">here</a> that if the norm (<span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> version taking values in the ring of integers) of the generator of an intgral power basis <code>pb</code> of a Galois extension of number fields is prime, then <code>pb.gen</code> is prime.</p>",
        "id": 287450317,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656184042
    },
    {
        "content": "<p>We need a little bit of glue to prove that <code>z-1</code> is prime, since we have the integral power basis given by <code>z</code>, not by <code>z-1</code>. Constructing this one only require that the ring of integers is <code>Z[z-1]</code>, that should be really easy given that we know it is <code>Z[z]</code>.</p>",
        "id": 287450378,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656184138
    },
    {
        "content": "<p>In any case the proof of <code>prime_of_norm_prime</code> is a nice detour to avoid the ideal norm.</p>",
        "id": 287450680,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656184517
    },
    {
        "content": "<p>I am done for today, but here is something to do if you're annoyed tonight.</p>\n<ul>\n<li>Prove  that<code>adjoin R {x+a} = adjoin R {x}</code> if <code>a : R</code>.</li>\n<li>Prove the results in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/number_theory.cyclotomic.rat\">docs#number_theory.cyclotomic.rat</a> with <code>ζ</code> replaced by <code>ζ - 1</code>.</li>\n<li>Construct the <code>power_basis ℤ (𝓞 K)</code> given by <code>ζ - 1</code> as it's done <a href=\"https://github.com/leanprover-community/flt-regular/blob/master/src/z_basis.lean\">here</a> for <code>ζ</code> (this file should be moved).</li>\n<li>Prove that <code>norm' K (ζ - 1) = (rat.ring_of_integers_equiv.symm p)</code> using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.sub_one_norm_prime\">docs#is_primitive_root.sub_one_norm_prime</a>.</li>\n<li>Finish the proof that <code>ζ - 1</code> is prime using <code>prime_of_norm_prime</code>.</li>\n</ul>",
        "id": 287451065,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656185072
    },
    {
        "content": "<p>I guess we should have some more general operations on power bases by appropriate affine transformations?</p>",
        "id": 287451857,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1656186292
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/power_basis.of_gen_mem_adjoin\">docs#power_basis.of_gen_mem_adjoin</a> that is very general. It works for fields, but it is possible that is generalizes more or less automatically.</p>",
        "id": 287452206,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656186790
    },
    {
        "content": "<p>Mmm, no, it uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.adjoin.power_basis\">docs#algebra.adjoin.power_basis</a> that is false in general.</p>",
        "id": 287452270,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656186864
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">zeta_sub_one_prime</span> <span class=\"o\">[</span><span class=\"n\">is_cyclotomic_extension</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)}</span> <span class=\"n\">ℚ</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hζ</span> <span class=\"o\">:</span> <span class=\"n\">is_primitive_root</span> <span class=\"n\">ζ</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">hodd</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">≠</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prime</span> <span class=\"o\">(⟨</span><span class=\"n\">ζ</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">hζ.sub_one_mem_ring_of_integers</span><span class=\"o\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>is <code>sorry</code> free.</p>",
        "id": 287501117,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656260184
    },
    {
        "content": "<p>The <code>simps</code> <a href=\"https://github.com/leanprover-community/flt-regular/blob/7405d7b5eba8f7f891c7e37a8f8437c4dea6903c/src/zeta_sub_one_prime.lean#L40\">here</a> is very slow... does anyone know to speed it up?</p>",
        "id": 287503352,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656263463
    },
    {
        "content": "<p>Did you try the now-standard technique of using <code>simps?</code> to find out what it's doing and then just doing it manually yourself? :-)</p>",
        "id": 287503445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656263536
    },
    {
        "content": "<p>I have no idea why <code>simps</code> is sometimes randomly super-slow but you're not the first person to notice it recently.</p>",
        "id": 287503460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656263562
    },
    {
        "content": "<p>Because <code>simps</code> lemmas have to be in simp normal form, <code>simps</code> calls <code>simp</code> (or just <code>dsimp</code>?) on the LHS, but this sometimes results in oversimplified statements.</p>",
        "id": 287503988,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1656264179
    },
    {
        "content": "<p>Yeah, adding it by hand seems faster.</p>",
        "id": 287504028,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656264222
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/14979\">#14979</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/14981\">#14981</a> If someone wants to have a look.</p>",
        "id": 287511780,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656274437
    },
    {
        "content": "<p>I will very little time this week,  but I will try to follow any progress.</p>",
        "id": 287511822,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1656274451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Contributing.20to.20the.20project/near/287313314\">said</a>:</p>\n<blockquote>\n<p>You can coordinate with <span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> to finish the proof of <code>unit_inv_conj_not_neg_zeta_runity</code>.  We need that <code>ζ - 1</code> is prime and it does not divide <code>2</code> (both are computation with the norm, we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_primitive_root.sub_one_norm_prime_ne_two\">docs#is_primitive_root.sub_one_norm_prime_ne_two</a> but we are mising some glue to obtain the two results).</p>\n<p>Looking at the blueprint it seems that the only other missing result in sections 1-2-3 is <a href=\"https://leanprover-community.github.io/flt-regular/sect0003.html#lemma:fac_of_p_in_p_th_root\">Lemma 3.8</a>, I think we don't even have the statement.</p>\n</blockquote>\n<p>I don't think we actually need 3.8, we basically need something slightly easier, so I've updated this on the blueprint.</p>",
        "id": 287709353,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1656419909
    },
    {
        "content": "<p>I'll add the statement in Lean as well.</p>",
        "id": 287709401,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1656419942
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"389019\">@Chris Birkbeck</span> have you added Lean statement? It seems something we can prove very quickly</p>",
        "id": 288518746,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657023249
    },
    {
        "content": "<p>Yes I added both the statement and proved it. Although the statement isnt quite the one I proved, but its the one we need,</p>",
        "id": 288571601,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1657044111
    },
    {
        "content": "<p>Ah sorry, didn't see it. It's not in the graph right?</p>",
        "id": 288571690,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657044137
    },
    {
        "content": "<p>Ah maybe not. I'll check that!</p>",
        "id": 288572235,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1657044387
    },
    {
        "content": "<p>I've finished <code>unit_inv_conj_not_neg_zeta_runity</code> and therefore <code>unit_lemma_gal_conj</code> is now sorry free. We are in the endgame!</p>",
        "id": 289121656,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657483955
    },
    {
        "content": "<p>Great! I think we just need to assemble these results into a proof of case 1!</p>",
        "id": 289122178,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1657484755
    },
    {
        "content": "<p>Great job!!</p>",
        "id": 289129218,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657495075
    },
    {
        "content": "<p>I will write down what exactly is missing this week.</p>",
        "id": 289129266,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657495127
    },
    {
        "content": "<p>I do think we should try tidy some things before we do that, and try and agree in quite what form we want to state theorems; we have lots of <code>cyclotomic_ring</code>, <code>adjoin ...</code> mixed about everywhere; I think there's probably about 5 different ways we state <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi><mrow><mo fence=\"true\">(</mo><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><mi>ζ</mi><mo stretchy=\"false\">)</mo><mo fence=\"true\">)</mo></mrow><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>ζ</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\"> \\mathcal{O} \\left( \\mathbb{Q}(\\zeta) \\right) = \\mathbb{Z}[\\zeta] </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\">(</span><span class=\"mord mathbb\">Q</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mclose\">)</span><span class=\"mclose delimcenter\" style=\"top:0em;\">)</span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"mclose\">]</span></span></span></span> and it makes shuffling things about painful</p>",
        "id": 289179104,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657540615
    }
]
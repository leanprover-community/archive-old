[
    {
        "content": "<p>I think it's time to do a recap of the status of the project.</p>\n<ul>\n<li>The definition and the basic properties of cyclotomic extensions (in full generality) is in mathlib.</li>\n<li>The definition of <code>cyclotomic_fied</code> and <code>cyclotomic_ring</code> is in mathlib.</li>\n<li>The definition of<code>zeta</code> and its basic properties are in mathlib.</li>\n<li>The structure of the Galois group is PRed.</li>\n<li>The discriminant of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msub><mi>ζ</mi><mi>p</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(\\zeta_p)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is PRed.</li>\n<li>I will take care of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msub><mi>ζ</mi><mi>p</mi></msub><mo stretchy=\"false\">)</mo></mrow></msub><mo>=</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><msub><mi>ζ</mi><mi>p</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_{\\mathbb{Q}(\\zeta_p)} = \\mathbb{Z}[\\zeta_p]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0608em;vertical-align:-0.3775em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathbb mtight\">Q</span><span class=\"mopen mtight\">(</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1645em;\"><span style=\"top:-2.357em;margin-left:-0.0738em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2819em;\"><span></span></span></span></span></span></span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3775em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07378em;\">ζ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0738em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>: the math is almost done in the project, and I already started PRing preliminary results, but just consider this as done.</li>\n</ul>\n<p>What should we do next? I am not sure, but suggestions are welcome!</p>",
        "id": 270702494,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643974649
    },
    {
        "content": "<p>Oh this is great, I just trying to catch up with what's been done. I guess the next big bits are results about elements in the ring of integers, such as these unit lemmas. This should almost be enough for case one.</p>",
        "id": 270702934,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643974963
    },
    {
        "content": "<p>I was just looking at this and we have things like <code>zeta_unit</code> and <code>zeta_runity</code> . What is the plan for these things? will this be added to the <code>zeta</code> PR eventually, or are we going to remove them completely and work with <code>zeta</code> only? (I've not seen whats in the PR, so maybe this is already all in there)</p>",
        "id": 270703094,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643975066
    },
    {
        "content": "<p>I think it may be good to start sorrying the full outline of the proof, so we can literally just jump in and solve a <code>sorry</code>. We can certainly start doing this for case I - I still haven't seen a full proof of case II, I'm going to try and grab a copy of Borevich and Shafarevich this weekend and see how close we are now.</p>",
        "id": 270703983,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643975656
    },
    {
        "content": "<p><code>zeta_unit, zeta_runity</code> I thought were basically conveniences so we can <code>change/rw</code> them whenever needed - for example, in the Galois group computation I often had to change into <code>↑↑(root of unity)</code> so that I could apply group lemmas.  Now, I'm not sure how much either of them are needed - I'm 99% sure that <code>zeta_unit</code> isn't, and maybe <code>zeta_runity</code> can be replaced by <code>(zeta_primitive_root ...).to_roots_of_unity</code> in most places (and indeed, this is what I did for the galois group, even when using ζ as opposed to a general root of unity)</p>",
        "id": 270704130,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643975762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/270703983\">said</a>:</p>\n<blockquote>\n<p>I think it may be good to start sorrying the full outline of the proof, so we can literally just jump in and solve a <code>sorry</code>. We can certainly start doing this for case I - I still haven't seen a full proof of case II, I'm going to try and grab a copy of Borevich and Shafarevich this weekend and see how close we are now.</p>\n</blockquote>\n<p>There is also a full proof in Washington's book.  It does seem like a lot of fiddly lemmas are required.</p>",
        "id": 270704314,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643975882
    },
    {
        "content": "<p>which one is Washington? if you guys are using that probably easier we grab the same source, and I'm a real sucker for irl books so I'll try grab it at the library</p>",
        "id": 270704470,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643975962
    },
    {
        "content": "<p>Introduction to Cyclotomic fields by Lawrence Washington. Its what I mainly used for the outline of case 1</p>",
        "id": 270704504,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643975999
    },
    {
        "content": "<p>But it might not be the best for case II. I'm still looking at several places to see which looks to be the lean-easiest</p>",
        "id": 270704655,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643976041
    },
    {
        "content": "<p>Case II is far more complicated, we should focus on case I.</p>",
        "id": 270704716,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643976085
    },
    {
        "content": "<p>There are also these notes by Keith Conrad (<a href=\"https://kconrad.math.uconn.edu/blurbs/gradnumthy/kummer.pdf\">https://kconrad.math.uconn.edu/blurbs/gradnumthy/kummer.pdf</a>) which are quite nice.</p>",
        "id": 270704733,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643976097
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/270704716\">said</a>:</p>\n<blockquote>\n<p>Case II is far more complicated, we should focus on case I.</p>\n</blockquote>\n<p>Yes I agree. We will need it for case II anyways, so may as well wait.</p>",
        "id": 270704802,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643976128
    },
    {
        "content": "<p>The problem with Conrad's notes is the he uses the Bernoulli def, and I don't think it's reasonable to have the class number formula in less than a year.</p>",
        "id": 270704891,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643976195
    },
    {
        "content": "<p>Yeah agreed. I dont think its the lean-easy version we want. Borevich and Shafarevich might be the way to go</p>",
        "id": 270705046,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643976280
    },
    {
        "content": "<p>I just checked and both B/S and Washington both need the Bernoulli condition, although I think Washington uses some stronger results</p>",
        "id": 270707504,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643977855
    },
    {
        "content": "<p>Washington seems to use Herbrand-Ribet</p>",
        "id": 270707555,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643977892
    },
    {
        "content": "<p>For case II you mean?</p>",
        "id": 270707565,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643977903
    },
    {
        "content": "<p>And I think the case I proof will be the same almost everywhere...</p>",
        "id": 270707605,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643977920
    },
    {
        "content": "<p>Case II is much complicated than I thought. This is why I think we should concentrate on case I, that is interesting and needed anyway. For case II the most reasonable thing to do seems to be to assume Kummer's lemma (so defining something like \"strong regularity\"), and proving the theorem. Having Kummer's lemma, the proof can avoid completely Bernoulli numbers I think.</p>",
        "id": 270707829,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643978040
    },
    {
        "content": "<p>Proving that regularity implies strong regularity is in some sense another project.</p>",
        "id": 270707904,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643978069
    },
    {
        "content": "<p>In my opinion projects like these one are just an excuse to put stuff into mathlib, so we should not rush towards the result. Sooner or later we will have CFT, L-functions and so on.</p>",
        "id": 270708218,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643978271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130384\">Riccardo Brasca</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/270707829\">said</a>:</p>\n<blockquote>\n<p>Case II is much complicated than I thought. This is why I think we should concentrate on case I, that is interesting and needed anyway. For case II the most reasonable thing to do seems to be to assume Kummer's lemma (so defining something like \"strong regularity\"), and proving the theorem. Having Kummer's lemma, the proof can avoid completely Bernoulli numbers I think.</p>\n</blockquote>\n<p>Yes the Bernoulli condition is just for Kummer's lemma really. If we assumed this, then we'd get case two with the current definition of regular.</p>",
        "id": 270711505,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980001
    },
    {
        "content": "<p>The downside is that we will have zero examples of (strongly) regular primes...</p>",
        "id": 270711810,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980147
    },
    {
        "content": "<p>Maybe <code>p=3</code> is doable, since the ring is norm euclidean</p>",
        "id": 270711848,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980167
    },
    {
        "content": "<p>Don't we already have FLT for <code>p=3</code>?</p>",
        "id": 270712033,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980249
    },
    {
        "content": "<p>I don't think so. We have it for <code>n=4</code>, that it's easier.</p>",
        "id": 270712076,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980271
    },
    {
        "content": "<p>Let me check</p>",
        "id": 270712083,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980274
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/fermat_42\">docs#fermat_42</a> for reference</p>",
        "id": 270712200,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1643980335
    },
    {
        "content": "<p><code>p=3</code> in usually dealt with differently than the other regular primes if I remember correctly. In Washington, its done directly looking modulo 9 I think.</p>",
        "id": 270712274,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980381
    },
    {
        "content": "<p>Really? I only know a proof using the <code>3</code>-rd cyclotomic field (that of course it's a quadratic extension in this case, and even a PID)</p>",
        "id": 270712361,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980430
    },
    {
        "content": "<p>(in case I at least)</p>",
        "id": 270712377,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980437
    },
    {
        "content": "<p>Sorry, I meant, case I for <code>p=3</code> isnt hard. Case II for <code>p=3</code> might well be harder</p>",
        "id": 270712542,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980500
    },
    {
        "content": "<p>even if we don't have it, <span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> <a href=\"https://github.com/Ruben-VandeVelde/flt/blob/main/src/euler.lean\">has it in his <code>flt</code> repo</a> (I just checked it's sorry-free)</p>",
        "id": 270712616,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643980546
    },
    {
        "content": "<p>Ah yes, case I can very well be elementary</p>",
        "id": 270712711,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643980588
    },
    {
        "content": "<p>Ok yeah, case II for p=3 is a long exercise in Washingtons book.  But it maybe doesnt need the full machinery that the others do.</p>",
        "id": 270713074,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/270712616\">said</a>:</p>\n<blockquote>\n<p>even if we don't have it, <span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"https://github.com/Ruben-VandeVelde/flt/blob/main/src/euler.lean\">has it in his <code>flt</code> repo</a> (I just checked it's sorry-free)</p>\n</blockquote>\n<p>Oh yes nice!</p>",
        "id": 270713370,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643980919
    },
    {
        "content": "<p>I was wondering if it was still worth trying to land with your work coming up, but it sounds like maybe it is?</p>",
        "id": 270713595,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1643981028
    },
    {
        "content": "<p>I'd think this is helpful, for sure</p>",
        "id": 270715442,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1643981932
    },
    {
        "content": "<p>Yeah definitely. Some proofs of the regular case assume that <code>p&gt;3</code> to simplify some things. Although the proof in BS works for any regular prime it seems.</p>",
        "id": 270715859,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643982146
    },
    {
        "content": "<p>Absolutely! Applying our result to <code>p=3</code> requires proving that <code>3</code> is regular, and even if not very difficult this is not trivial.</p>",
        "id": 270715870,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1643982152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/270703983\">said</a>:</p>\n<blockquote>\n<p>I think it may be good to start sorrying the full outline of the proof, so we can literally just jump in and solve a <code>sorry</code>. We can certainly start doing this for case I - I still haven't seen a full proof of case II, I'm going to try and grab a copy of Borevich and Shafarevich this weekend and see how close we are now.</p>\n</blockquote>\n<p>Going back to this, I think this is a good idea. Getting the skeleton of the proof would seem like a good next step.</p>",
        "id": 270716625,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1643982525
    },
    {
        "content": "<p>The n=3 case is done in Hardy and Wright via a descent. They actually prove the rank is 0 over Q(zeta_3) which is easier because then you can do a descent via an isogeny of degree 3 which is defined over this field (the Fermat cubic has CM over this field)</p>",
        "id": 270810439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644043991
    },
    {
        "content": "<p>I agree that case 1 would be a really nice milestone. It would prove that lean can actually do basic algebraic number theory and it's already way beyond what is done in any other prover as far as I know</p>",
        "id": 270810516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644044098
    },
    {
        "content": "<p>An analogue of Lemma 2.13 of the blueprint is now sorry free.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">z</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">eiseinstein_integral</span> <span class=\"o\">[</span><span class=\"n\">is_domain</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normalized_gcd_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_fraction_ring</span> <span class=\"n\">R</span> <span class=\"n\">K</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_integrally_closed</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_separable</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">power_basis</span> <span class=\"n\">K</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">prime</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hei</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">minpoly</span> <span class=\"n\">R</span> <span class=\"n\">B.gen</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_eisenstein_at</span> <span class=\"bp\">𝓟</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hBint</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">R</span> <span class=\"n\">B.gen</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">L</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hzint</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">R</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">•</span> <span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"o\">({</span><span class=\"n\">B.gen</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">L</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">adjoin</span> <span class=\"n\">R</span> <span class=\"o\">({</span><span class=\"n\">B.gen</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">L</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Lemma 2.12 is already in mathlib. The final computation about the ring of integer should be quite close now.</p>",
        "id": 270824769,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644064899
    },
    {
        "content": "<p>I've tried getting started on an outline, but have no more time today to finish it: it's <a href=\"https://github.com/leanprover-community/flt-regular/blob/1a31029df54f2b16514803bcb6de721683958820/src/number_theory/caseI.lean\">here</a>, and I decided to try and sugar it with as much mathematician-friendly notation as possible :)</p>",
        "id": 271153211,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644337694
    },
    {
        "content": "<p>Because so little is done, I was more wondering whether people would find this style of file helpful?</p>",
        "id": 271153258,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644337717
    },
    {
        "content": "<p>I surely like the math-friendly notation!</p>\n<p>Concerning <code>is_dedekind_domain ℤ[ζₚ]</code> if someone wants to prove it, just go ahead. What I am proving at the moment is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_integral_closure</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_ring</span> <span class=\"n\">n</span> <span class=\"n\">ℤ</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"n\">ℤ</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>The Dedekind domain instance should follows easily (the required math is in mathlib).</p>",
        "id": 271153898,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644337973
    },
    {
        "content": "<p>I also like the notation, it makes to easier to follow!</p>",
        "id": 271153984,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1644338011
    },
    {
        "content": "<p>I will be a little busy tomorrow, but I hope to break the last bit in several small sorrys on Thursday</p>",
        "id": 271154123,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644338059
    },
    {
        "content": "<p>Oh, the other thing I should flag up is that I'm using an invisible space for the pnat to nat coe, kinda like what LTE does for by exactI.</p>",
        "id": 271162969,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644341667
    },
    {
        "content": "<p>I am afraid I need at one point the power basis given by <code>zeta - 1</code>. <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> do you see a way of quickly obtaining it (I only need its existence, and that the generator is <code>zeta - 1</code>) or I have to copy what you did for <code>zeta</code>? It's not that much, but it would be nice to avoid it.</p>",
        "id": 271164779,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644342482
    },
    {
        "content": "<p>(we need both because using <code>zeta</code> we can compute the discriminant, and <code>zeta - 1</code> has eisenstein minimal polynomial).</p>",
        "id": 271164923,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644342545
    },
    {
        "content": "<p>And we also need that the two discriminant are the same.. time to prove it in general for <code>Z</code> I think</p>",
        "id": 271165095,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644342625
    },
    {
        "content": "<p>I'm not a huge fan of invisible spaces tbh, is the up arrow or type ascription so bad? It just seems destined to end up confusing someone</p>",
        "id": 271165187,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1644342689
    },
    {
        "content": "<p>Alex, I'm happy to just use some other arrow too, but the normal coe arrow usually gets confused about what I want the coe to go to</p>",
        "id": 271165296,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644342739
    },
    {
        "content": "<p>And I don't think so Riccardo, they're not conjugates... But maybe the correct generality is some method that adds the basis of something with a power basis + algebra_map t? That should work, I think</p>",
        "id": 271165487,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644342831
    },
    {
        "content": "<p>The math reason is that they \"clearly\" generate the same subalgebra. But of course Lean is not very smart :D But no problem I will do it. Maybe making them private or whatever, <code>zeta - 1</code> is a little less natural than <code>zeta</code>.</p>",
        "id": 271165845,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644342985
    },
    {
        "content": "<p>I agree, just thought that a power basis for <code>b + algebra_map A B a</code> from a power-basis for  <code>b</code> is the correct generality for this, which also gives you your thing</p>",
        "id": 271166643,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644343321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/271165296\">said</a>:</p>\n<blockquote>\n<p>Alex, I'm happy to just use some other arrow too, but the normal coe arrow usually gets confused about what I want the coe to go to</p>\n</blockquote>\n<p>Yeah that's why type ascriptions are normally better, I can see why doing <code>(n : ℕ)</code>  isn't super readable to outsiders</p>",
        "id": 271167024,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1644343456
    },
    {
        "content": "<p>Isn't there going to be some general lemma that if powers of <code>x</code> are a power basis for S/R then so are powers of <code>x + r</code> for r in R?</p>",
        "id": 271178932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644348635
    },
    {
        "content": "<p>I think that's missing right now, Kevin</p>",
        "id": 271178988,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1644348661
    },
    {
        "content": "<p>Right -- I'm just suggesting that this is the thing to prove, not that zeta - 1 gives a power basis</p>",
        "id": 271179189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644348755
    },
    {
        "content": "<p>This is only partly related, but something along the lines of what Kevin says is probably not far off from ˋpolynomial.taylor_stuffˋ.  Quite a bit of the API is already available and it may be very little work to prove that \"taylor of a basis is a basis\".</p>",
        "id": 271186399,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1644352186
    },
    {
        "content": "<p>If I am not too tired the right result is the following: if <code>B</code> is a power basis and <code>adjoin R B.gen = adjoin R x</code> then <code>x</code> gives a power basis.</p>",
        "id": 271191877,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1644354816
    },
    {
        "content": "<p>So section 3 of the blueprint is done.</p>",
        "id": 289466264,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657722156
    },
    {
        "content": "<p>The next thing to do is <code>flt_fact_2</code></p>",
        "id": 289466332,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657722189
    },
    {
        "content": "<p>Section 3 I guess you mean</p>",
        "id": 289466364,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1657722204
    },
    {
        "content": "<p><span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> yes</p>",
        "id": 289466495,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657722244
    },
    {
        "content": "<p>But I like <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span>'s idea of cleaning up some stuff. I propose to essentially avoid <code>cyclotomic_ring</code>, and just use <code>adjoin</code></p>",
        "id": 289466854,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657722368
    },
    {
        "content": "<p>Even better than <code>adjoin</code> we have <code>𝓞 K</code>. If I am not confused the statement <code>𝓞 K = adjoin ℤ {ζ}</code> is OK, since both are a <code>ℤ</code>-subalgebra of a given <code>ℚ</code>-cyclotomic extension <code>K</code>.</p>",
        "id": 289472999,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1657724868
    },
    {
        "content": "<p>yes, I think we should definitely just use both! we can maybe have some nice notation for the RHS and then we're all good</p>",
        "id": 289473471,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657725066
    },
    {
        "content": "<p>I just had to undelete a file whose changes got deleted by accident (note that <a href=\"https://github.com/leanprover-community/flt-regular/commit/d84cfce36b35855114383c6f6f1a1457fb7c3314\">this commit</a> doesn't show in the <a href=\"https://github.com/leanprover-community/flt-regular/commits/master/src/number_theory/regular_primes.lean\"><code>master</code> file history</a>) - please all take care with merge commits, it seems to be really easy to hide an important change with them!</p>",
        "id": 289574483,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657794698
    },
    {
        "content": "<p>it may be good to wait for the big algebra_rat refactor until we carry on with this - there's a lot of rat diamonds lurking in all the stuff we're doing</p>",
        "id": 289637355,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657826591
    },
    {
        "content": "<p>especially now that we're having to specialize to ℚ more</p>",
        "id": 289637373,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657826602
    },
    {
        "content": "<p>I'd be happy to help update to the algebra rat refactor, by the way. Happily, on our quadratic rings project, this was straightforward enough.</p>",
        "id": 289703708,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1657876786
    },
    {
        "content": "<p>that would be super helpful, many thanks!</p>",
        "id": 289704100,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1657877035
    },
    {
        "content": "<p>I am going to remove any mention of <code>cyclotomic_ring</code> from the project, using <code>𝓞 K</code> everywhere.</p>",
        "id": 290345884,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658390920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> now that the <code>algebra_rat</code> diamond should be fixed, can you have a look at <a href=\"https://github.com/leanprover-community/flt-regular/blob/a2855b2209ecf1407611ad8d3ddbd0b4ac5349af/src/number_theory/regular_primes.lean#L84\">this</a> proof? Thanks!</p>",
        "id": 290350893,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658394216
    },
    {
        "content": "<p>as far as I understand, actually, there's one more step I over-looked at the time. We have to change one of the <code>field</code> definitions so that the <code>qsmul</code> is convenient (I'm guessing we can't use <code>@[derive field]</code> for <code>cyclotomic_field</code> anymore). Is this correct, <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> ?</p>",
        "id": 290423235,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658431911
    },
    {
        "content": "<p>If you don't define any <code>has_smul ℚ</code> instances (or <code>module ℚ</code>, <code>algebra ℚ</code>, etc.) on your fields, then you can leave <code>qsmul</code> alone. Otherwise just define the <code>has_smul</code> instance before <code>field</code> and then set <code>qsmul := has_smul.smul</code> and the diamond should be solved.</p>",
        "id": 290439999,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658441049
    },
    {
        "content": "<p>The qsmul we're worried about is I think the one coming from the splttting field algebra. Let me try this out.</p>",
        "id": 290440801,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658441584
    },
    {
        "content": "<p>hold up, I'm now a bit confused. The problematic <code>qsmul</code> arises when <code>cyclotomic_field</code> is specialized to <code>ℚ</code>, and so then aren't we creating diamonds in the field instances? Because I don't see any way to set the <code>smul</code> to the correct thing apart from creating another <code>field</code> instance</p>",
        "id": 290443185,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658443187
    },
    {
        "content": "<p>e.g. this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[derive [comm_ring, algebra K, inhabited]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">cyclotomic_field</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"n\">n</span> <span class=\"n\">K</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">splitting_field</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">cyclotomic_field</span>\n\n<span class=\"kd\">@[priority 10000]</span> <span class=\"kd\">instance</span> <span class=\"n\">field'</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic_field</span> <span class=\"n\">n</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">qsmul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">•</span><span class=\"o\">),</span>\n  <span class=\"n\">qsmul_eq_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">splitting_field.field</span> <span class=\"o\">(</span><span class=\"n\">cyclotomic</span> <span class=\"n\">n</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 290443231,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658443203
    },
    {
        "content": "<p>I will on holiday for about 10 days, with almost no internet connection, so I am not going to work on the project. In any case now <code>cyclotomic_ring</code> is gone, and also <code>cyclotomic_field</code> is almost gone (it is still there in some proof, and that's OK, but in no statement. We should never have a statement abut <code>cyclotomic_field</code>, only about <code>is_cyclotomic_extension</code>).</p>",
        "id": 290480410,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658479766
    },
    {
        "content": "<p>Something very easy to do: I see in the graph that <code>flt_fact_4</code> has green border (that means the statement has been formalized), but there is no link to the Lean code. Is the statement really somewhere or should we make the border blue?</p>",
        "id": 290480521,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658479855
    },
    {
        "content": "<p>4 is in mathlib proper, might just need a link</p>",
        "id": 290482176,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1658481121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/290443185\">said</a>:</p>\n<blockquote>\n<p>hold up, I'm now a bit confused. The problematic <code>qsmul</code> arises when <code>cyclotomic_field</code> is specialized to <code>ℚ</code>, and so then aren't we creating diamonds in the field instances? Because I don't see any way to set the <code>smul</code> to the correct thing apart from creating another <code>field</code> instance</p>\n</blockquote>\n<p>Aha, so if the field instance derives from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field\">docs#polynomial.splitting_field</a>, then we'll have to fix it in mathlib.</p>",
        "id": 290482219,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658481125
    },
    {
        "content": "<p>Indeed <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field.algebra'\">docs#polynomial.splitting_field.algebra'</a> already has a comment that we need to fix that instance to avoid diamonds :P</p>",
        "id": 290482252,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658481162
    },
    {
        "content": "<p>From what I remember <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field\">docs#polynomial.splitting_field</a> is pretty cursed, and fixing it is pretty hard</p>",
        "id": 290482281,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658481193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307953\">Ruben Van de Velde</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/290482176\">said</a>:</p>\n<blockquote>\n<p>4 is in mathlib proper, might just need a link</p>\n</blockquote>\n<p>We need better names... <code>flt_fact_4</code> is not FLT for <code>n=4</code>...</p>",
        "id": 290482284,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1658481194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/290482281\">said</a>:</p>\n<blockquote>\n<p>From what I remember <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field\">docs#polynomial.splitting_field</a> is pretty cursed, and fixing it is pretty hard</p>\n</blockquote>\n<p>Because of the recursive construction by induction on the degree?</p>",
        "id": 290482391,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658481281
    },
    {
        "content": "<p>Wait, how does <code>rat_algebra</code> even apply to splitting_field? I can't see the char_zero instance</p>",
        "id": 290482670,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658481506
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/cyclotomic_field.char_zero\">docs#cyclotomic_field.char_zero</a></p>",
        "id": 290482731,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658481552
    },
    {
        "content": "<p>Ah I see, the problem is like with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/zmod\">docs#zmod</a> that the induction should happen per-field, not all at once for the whole structure.</p>",
        "id": 290483023,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658481737
    },
    {
        "content": "<p>The induction needs a field structure at each step I think though (the inductive step is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.field\">docs#adjoin_root.field</a>)</p>",
        "id": 290483048,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658481753
    },
    {
        "content": "<p>I just made <a href=\"https://github.com/leanprover-community/mathlib/pull/15620\">#15620</a> to bring the documentation slightly more up to date</p>",
        "id": 290483142,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658481821
    },
    {
        "content": "<p>(updated)</p>",
        "id": 290483251,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1658481882
    },
    {
        "content": "<p>It's time for dinner, and I won't have time to work this weekend. My result up to now is <a href=\"https://github.com/leanprover-community/mathlib/tree/splitting_field-diamond\">branch#splitting_field-diamond</a>. Bad news is that the diamond is not fixed yet, good news is that it is doable to get rid of all the defeq hacks in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/polynomial.splitting_field_aux\">docs#polynomial.splitting_field_aux</a></p>",
        "id": 290549000,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658514016
    },
    {
        "content": "<p>I'll try have a look in the weekend and see if this is possible, it would be nice to fix this wholly. With luck this is solvable before lean4's eta improvements</p>",
        "id": 290564598,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658522582
    },
    {
        "content": "<p>I proved the <code>is_scalar_tower</code> instance you had sorried; there seems to be some very weird defeq problems later on in the file that I'm 1000% unqualified to solve alone</p>",
        "id": 290697779,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658693745
    },
    {
        "content": "<p>I'm back, let's see how far I get!</p>",
        "id": 290731108,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658737308
    },
    {
        "content": "<p>The defeq problems are because we want to construct a <code>has_smul (splitting_field_aux n f)</code> instance recursively, assuming <code>is_scalar_tower</code> + <code>distrib_mul_action</code> on the predecessor (which depends on <code>add_monoid</code>). So first I'll define an <code>add_comm_group</code> instance, then the <code>is_scalar_tower</code> and <code>distrib_mul_action</code> instances, then we should be able to get the recursion going.</p>",
        "id": 290733833,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658739309
    },
    {
        "content": "<p>Ah right, we don't have a <code>distrib_mul_action ℚ K</code> if <code>K</code> doesn't have characteristic zero...</p>",
        "id": 290736259,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658741065
    },
    {
        "content": "<p>Okay, I'm nearly there. I ended up defining a new typeclass <code>distrib_smul</code> that states <code>smul a</code> distributes over <code>+</code> and <code>0</code> on the right hand side.</p>",
        "id": 290750445,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658750983
    },
    {
        "content": "<p>This is enough to define <code>polynomial.has_smul</code> and is satisfied by the <code>ℚ</code>-action on any division ring.</p>",
        "id": 290750529,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658751021
    },
    {
        "content": "<p>Let me mention <a href=\"https://github.com/leanprover-community/mathlib/pull/9123\">#9123</a></p>",
        "id": 290751089,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658751417
    },
    {
        "content": "<p>I need a weaker form of <code>distrib_mul_action</code>, this one is too strong! :)</p>",
        "id": 290751313,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658751570
    },
    {
        "content": "<p>Namely, <code>mul_smul : (a * b : ℚ) \\bu x = a \\bu x + b \\bu x</code> doesn't hold outside of characteristic 0.</p>",
        "id": 290751470,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658751646
    },
    {
        "content": "<p>I'm just mentioning in case you're making it a mixin, because then that would solve my problem too!</p>",
        "id": 290751872,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658751893
    },
    {
        "content": "<p>Alright, pushed a fix for the diamonds in <code>splitting_field_aux</code> scalar diamonds, let's see what breaks...</p>",
        "id": 290766929,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658759885
    },
    {
        "content": "<p>thanks so much for all this work!</p>",
        "id": 290768267,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1658760446
    },
    {
        "content": "<p>The <code>algebra</code> instances still aren't quite right...</p>",
        "id": 290772464,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658762075
    },
    {
        "content": "<p>It's dinner time and I haven't figured out how to solve the algebra diamond yet... The definition of <code>lift</code> should work for the <code>{nat,int,rat}_cast</code> fields but the induction works with an accumulating parameter so it's hard to prove anything about it.</p>",
        "id": 290780055,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1658765122
    },
    {
        "content": "<p>I've been thinking about this a bit more, the right solution for the <code>algebra_map</code> diamond is probably as follows:</p>\n<ul>\n<li>define <code>lift : K → splitting_field_aux n f</code> by recursion</li>\n<li>define <code>{nat,int,rat}_cast n</code> as <code>lift (↑n)</code></li>\n<li>define <code>lift_hom</code> as <code>lift</code> bundled into a ring hom</li>\n<li>define <code>algebra'.to_fun</code> as <code>lift_hom \\circ algebra_map</code></li>\n</ul>",
        "id": 291305397,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659090667
    },
    {
        "content": "<p>I don't have more than a few hours to work on this in the coming 2 weeks, so hopefully someone else manages to use this plan to fix the diamonds.</p>",
        "id": 291305411,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659090707
    },
    {
        "content": "<p>I don't think splitting fields are used to define algebraic closures (at least I think I know a way to do alg closures which avoids them), so why not just redefine splitting fields to be a subfield of the algebraic closure?</p>",
        "id": 291307374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659092129
    },
    {
        "content": "<p>The file defining algebraic closures definitely imports <code>splitting_field</code>.</p>",
        "id": 291307508,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659092219
    },
    {
        "content": "<p>But indeed it looks like the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_closure\">docs#algebraic_closure</a> currently doesn't directly rely on <code>splitting_field</code>. (It does however do the same kind of recursive definition that will lead to diamonds if we're not careful.)</p>",
        "id": 291307562,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1659092269
    },
    {
        "content": "<p>Aah yes the definition I was thinking of is definitely recursive :-/</p>",
        "id": 291307797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659092436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/291307374\">said</a>:</p>\n<blockquote>\n<p>I don't think splitting fields are used to define algebraic closures (at least I think I know a way to do alg closures which avoids them), so why not just redefine splitting fields to be a subfield of the algebraic closure?</p>\n</blockquote>\n<p>Actually, I was wondering the same thing. I recently proved that if a polynomial splits, then <code>intermediate_field.adjoin</code>ing all of its roots satisfies <code>is_splitting_field</code> (not PRed yet due to dependencies). And if the algebraic closure doesn't depend on splitting field, then this redefinition of splitting field could clean up <code>splitting_field.lean</code> a lot.</p>",
        "id": 291324611,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1659100168
    },
    {
        "content": "<p>The algebraic closure in mathlib is constructed by adjoining one root <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">r_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> of each monic irreducible polynomial <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> in F[X], quotienting out a maximal ideal to get a field, repeating the above construction, and taking the direct limit. In order for the maximal ideal to exist, the ring obtained by adjoining the roots needs to be nontrivial. And here is where the splitting field comes in: adjoining roots just means taking the mv_polynomial ring on variables <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>r</mi><mi>f</mi></msub></mrow><annotation encoding=\"application/x-tex\">r_f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7167em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span></span></span></span> and quotienting out by relations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mi>f</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(r_f)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>. For any finitely set of relations <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>r</mi><mi>f</mi></msub><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">f(r_f)=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0361em;vertical-align:-0.2861em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, there is a F-alg_hom from the mv_polynomial ring to the splitting field of the product of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>'s, whose image is nontrivial (contains F), so the ideal generated by any finitely many relations doesn't contain 1, which implies the ideal generated by all relations is not the whole mv_polynomial ring. For this argument, you can also adjoin one root at a time and use the injectivity of the inclusion of the base ring into <code>adjoin_root f</code>, where you need a generalized version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.coe_injective'\">docs#adjoin_root.coe_injective'</a> for arbitrary <code>comm_ring</code> instead of <code>field</code> but with an additional monic assumption (because after the first step the base ring may no longer be a field, though you can also quotient by a maximal ideal to get a field). This is still an inductive construction, but slightly simpler than  splitting_field (no need of factoring out linear factors and taking an irreducible factor).</p>\n<p>In fact, one step is enough; there is no need to repeat the \"adjoin one root for each monic irreducible polynomial\" construction and take the direct limit: if K/F contains one root for each monic irreducible polynomial in F[X], <a href=\"https://math.stackexchange.com/questions/721608/if-e-f-is-algebraic-and-every-f-in-fx-has-a-root-in-e-why-is-e-algebr\">K is already algebraically closed</a>, but the proof uses <a href=\"https://leanprover-community.github.io/mathlib_docs/find/field.exists_primitive_element\">docs#field.exists_primitive_element</a> and splitting_field as well.</p>\n<p>There is another similar construction where instead of adjoining one root, you effectively adjoin all roots of each monic irreducible polynomial in the base field. For <a href=\"https://kconrad.math.uconn.edu/blurbs/galoistheory/algclosureshorter.pdf\">this construction</a>, it's easy to prove that one step is enough, since it's easy to show if every monic irreducible polynomial in F[X] splits into linear factors in K/F, then K is algebraically closed; it suffices to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.is_algebraic_trans\">docs#algebra.is_algebraic_trans</a>. However, to show the ideal generated by relations is not the unit ideal for this construction, we really need splitting_field, and the iterative adjoin_root argument doesn't apply.</p>\n<p>An option of different flavor is to get an algebraic closure <a href=\"https://math.stackexchange.com/questions/2868927/on-the-proof-of-existence-of-algebraic-closure-using-zorns-lemma-in-patrick-mor\">directly by Zorn's lemma</a>. I imagine it would be easier to formalize in Lean, as we have global choice and hence \"global Zorn's lemma\"; I think the cardinality argument is unnecessary, and you just need to show a field is algebraically closed iff it has no nontrivial algebraic extension in the same universe, which is provided by <code>adjoin_root</code>.</p>\n<p>So the conclusion is that if you want to ditch the current splitting_field construction, you need to either use a \"totally nonconstructive\" proof using Zorn's lemma, or you need to use a weaker iterated adjoin_root construction (and your algebraic closure needs to be an inductive + direct limit construction). I have been thinking about generalizing splitting_field to the \"splitting ring\" of a monic polynomial over an arbitrary comm_ring, which is useful in <a href=\"https://mathoverflow.net/a/123526/3332\">https://mathoverflow.net/a/123526/3332</a> (see (1)=&gt;(2)), so if we decided to use algebraic closure to construct splitting field, we'd better think about how to generalize algebraic closure to comm_ring as well.</p>",
        "id": 291371955,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659123884
    },
    {
        "content": "<p>Hmm, it seems it's still necessary to use a cardinality argument; to show that any chain of field extensions has an upper bound, we need to take a direct limit, and that could cause a universe bump, so we need to restrict to field structures on subsets of a fixed type. So the Zorn's lemma argument isn't that simpler after all.</p>",
        "id": 291373556,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659124828
    },
    {
        "content": "<p>OK then how about renaming current splitting field into <code>splitting_field_really_annoying_to_use_version</code> and then defining splitting field as subfield of alg closure afterwards?</p>",
        "id": 291383367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659130400
    },
    {
        "content": "<p>I should have some time today maybe I can try both of these approaches and seeing if any works better with the defeqs or not.</p>",
        "id": 291431894,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659191343
    },
    {
        "content": "<p>well, this magical \"time\" I was meant to have evaporated, but there's some stuff I found</p>",
        "id": 291461909,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659231943
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/mCHeT5XKYCRkhExM8Yt5KMla/image.png\">image.png</a> firstly this definitely isn't helping</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/mCHeT5XKYCRkhExM8Yt5KMla/image.png\" title=\"image.png\"><img src=\"/user_uploads/3121/mCHeT5XKYCRkhExM8Yt5KMla/image.png\"></a></div>",
        "id": 291461910,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659231950
    },
    {
        "content": "<p>I'll see if I can fix that at that end but I assume this is a problem that requires a similar solution to this one</p>",
        "id": 291461952,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659231981
    },
    {
        "content": "<p>(thankfully the ℚ instance works, as can also be seen)</p>",
        "id": 291461957,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659231998
    },
    {
        "content": "<p>this ℤ cast issue goes really far down, because the <code>comm_ring</code> instance is for example defined using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal.quotient.comm_ring\">docs#ideal.quotient.comm_ring</a>; I guess I have to fix this at the source?</p>",
        "id": 291462028,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659232138
    },
    {
        "content": "<p>sorry, I'm still figuring this out little by little</p>",
        "id": 291462032,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659232159
    },
    {
        "content": "<p>okay, final thoughts - the fact that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/adjoin_root.has_coe_t.has_coe_t\">docs#adjoin_root.has_coe_t.has_coe_t</a> ◌<code>nat.cast : ℕ → K</code> isn't defeq to <code>nat.cast : ℕ → adjoin_root f</code>is really annoying. I would appreciate helps on the tips to fix this, because I think if this _was_ true then Anne's proof should work pretty verbatim.</p>",
        "id": 291463160,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659233890
    },
    {
        "content": "<p>I've pushed some ugly workaround for now, in case this isn't doable and we need to make lemmata for this instead.</p>",
        "id": 291463161,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659233905
    },
    {
        "content": "<p>(and PS: yes, that name is bad, there's a PR fixing it already)</p>",
        "id": 291463168,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659233927
    },
    {
        "content": "<p>with much help from <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , I identified some subsidiary diamonds that were making this proof much much harder than it had any right to be. the ℕ one is being fixed in <a href=\"https://github.com/leanprover-community/mathlib/pull/15778\">#15778</a> and the ℤ one is upcoming - merging both of these should make work on this a lit easier!</p>",
        "id": 291499925,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659285951
    },
    {
        "content": "<p>I am still on holiday, but I promise I will read all your messages on Thursday <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 291505428,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1659292511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/291305397\">said</a>:</p>\n<blockquote>\n<p>I've been thinking about this a bit more, the right solution for the <code>algebra_map</code> diamond is probably as follows:</p>\n<ul>\n<li>define <code>lift : K → splitting_field_aux n f</code> by recursion</li>\n<li>define <code>{nat,int,rat}_cast n</code> as <code>lift (↑n)</code></li>\n<li>define <code>lift_hom</code> as <code>lift</code> bundled into a ring hom</li>\n<li>define <code>algebra'.to_fun</code> as <code>lift_hom \\circ algebra_map</code></li>\n</ul>\n</blockquote>\n<p>update: the branch now has all up to <code>field</code> working. I'm having to make several PRs to fix diamonds that were found along the way + adding casts to everything that's needed. Could you spell out a bit more clearly what you want for the two steps? I think my brain is too much on \"fixing code\" mode and too little on maths mode to understand what's needed.</p>",
        "id": 291516093,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659306678
    },
    {
        "content": "<p>I started doing the Zorn's lemma proof just for fun. Now I've completed half of the proof, namely showing that a maximal element in the preorder of algebraic extensions is algebraically closed. I'm careful not to use the splitting field construction, and it's a bit tricky to show that there can't be any inclusion of a field inside itself that isn't surjective (edit: the inclusion needs to be an alg_hom over a base field over which the field is algebraic); it ends up depending on two missing lemmas that belong to ring_division.lean that I've long thought about adding.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_roots_le</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.map</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.roots.map</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">roots</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">card_roots_le_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">[</span><span class=\"n\">X</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">p.map</span> <span class=\"n\">f</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.roots.card</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">roots.card</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>See <a href=\"https://gist.github.com/alreadydone/ca738825fdfa3fe989ab79ef1af493b7\">this gist</a> for the WIP so far.</p>",
        "id": 291547852,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659344589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"460212\">@Sebastian Monnet</span> did you prove this at some stage? IIRC you needed that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> was algebraic then any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-linear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L\\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> was bijective.</p>",
        "id": 291548014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659344702
    },
    {
        "content": "<p>K-linear is not enough (if infinite extension), but K-alg_hom should do.</p>",
        "id": 291548729,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659345119
    },
    {
        "content": "<p>Yeah I meant K-linear ring hom :-)</p>",
        "id": 291548921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659345245
    },
    {
        "content": "<p>My proof is basically this (though I didn't prove exactly this result): if a K-alg_hom <code>f : L → L</code> is not surjective, take the minimal polynomial <code>p</code> over K of an element <code>a</code> that is not in the image (using algebraicity), which has the minpoly <code>q</code> of <code>a</code> over L as a factor. <code>q</code> has no roots in L, but <code>q.map f</code> has at least one root <code>a</code>. On the other hand, <code>(p/q).map f</code> has at least as many roots (counting multiplicity) in L as <code>p/q</code> (this is true for any ring_hom). So adding them up, <code>p.map f</code> has more roots than <code>p</code> in L. But <code>p.map f = p</code> because <code>f</code> is a K-alg_hom, contradiction.</p>",
        "id": 291550668,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659346270
    },
    {
        "content": "<p>Okay I have now completed the Zorn's lemma proof of existence of algebraic closure at <a href=\"https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695\">https://gist.github.com/alreadydone/daa9760056383d31669755bbb41e2695</a> It's 334 lines including comments, about the same as <a href=\"https://tqft.net/mathlib/field_theory/is_alg_closed/algebraic_closure\">file#field_theory/is_alg_closed/algebraic_closure</a>, but some lemmas should go into other files.</p>\n<p>It turns out my previous approach doesn't work; it defines the preorder using <code>nonempty (K₁ →ₐ[k] K₂)</code> which is bad, because to take a direct limit you need triangles of k-alg_homs to commute, so they can't be arbitrarily chosen, and there do exist non-identity <code>K ≃ₐ[k] K</code>, for example.</p>\n<p>However if you take the underlying types of the extensions to be subsets of a fixed type (coerced to types), then inclusion between subsets gives rise to canonical maps between the subtypes, and you can take the direct limit (which is just a union, but the direct limit API is convenient). And it's really crucial to use a cardinality argument to show a non-algebraically-closed algebraic extension of k carried by a subset of a big enough type <code>big k</code> can be extended to an algebraic extension of k carried by a (strict) superset.</p>\n<p>This approach doesn't use splitting field at all, but since the <code>field</code> and <code>algebra</code> instances are obtained by choice, it will require some work to fix the defeq if we want to use it in mathlib.</p>",
        "id": 292101161,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659667945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/291548014\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"460212\">Sebastian Monnet</span> did you prove this at some stage? IIRC you needed that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi mathvariant=\"normal\">/</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">L/K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> was algebraic then any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-linear map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L\\to L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">L</span></span></span></span> was bijective.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/291550668\">said</a>:</p>\n<blockquote>\n<p>My proof is basically this (though I didn't prove exactly this result): if a K-alg_hom <code>f : L → L</code> is not surjective, take the minimal polynomial <code>p</code> over K of an element <code>a</code> that is not in the image (using algebraicity), which has the minpoly <code>q</code> of <code>a</code> over L as a factor. <code>q</code> has no roots in L, but <code>q.map f</code> has at least one root <code>a</code>. On the other hand, <code>(p/q).map f</code> has at least as many roots (counting multiplicity) in L as <code>p/q</code> (this is true for any ring_hom). So adding them up, <code>p.map f</code> has more roots than <code>p</code> in L. But <code>p.map f = p</code> because <code>f</code> is a K-alg_hom, contradiction.</p>\n</blockquote>\n<p>There is a <a href=\"https://math.stackexchange.com/a/1541288/12932\">much easier proof</a> for this fact and my formalization is under 30 lines; will submit a PR.</p>",
        "id": 292112817,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659680733
    },
    {
        "content": "<p>Do you end up with a universe bump? Is the algebraic closure in the same universe as the field you started with?</p>",
        "id": 292114694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1659682368
    },
    {
        "content": "<p>It's in the same universe, and this is a perfectly valid ZFC proof. <br>\n<code>def algebraic_closure : Type u := (exists_alg_closure k).some.carrier</code></p>\n<p>Even if you end up in a higher universe, as long as there's an equiv with some type in the original universe (which exists by cardinality reason), you can transfer the instances (which is done twice in the gist above, but both in the same universe). There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/small\">docs#small</a> API to show the existence of an equiv with some type in a certain universe.</p>",
        "id": 292115479,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659682986
    },
    {
        "content": "<p>btw I PR'd some lemmas about algebraicity <a href=\"https://github.com/leanprover-community/mathlib/pull/15873\">#15873</a></p>",
        "id": 292115685,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659683126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  Let me know if you end up PRing the new algebraic closure construction, because then it would make sense to clean up the splitting field construction.</p>",
        "id": 292164409,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1659710978
    },
    {
        "content": "<p>I don't think we're far from fixing the splitting field construction, I just need to sit down and work on it some day</p>",
        "id": 292166821,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1659712161
    },
    {
        "content": "<p>there's plenty of other issues in the file that need to be fixed, but as far as I can see the diamonds are FINALLY GONE!</p>",
        "id": 292628667,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660068073
    },
    {
        "content": "<p>if anyone wants to figure out some of them as I'm really tired right now: <a href=\"https://github.com/leanprover-community/mathlib/tree/splitting_field-diamond\">branch#splitting_field-diamond</a></p>",
        "id": 292628724,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660068091
    },
    {
        "content": "<p>thanks for your roadmap <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>, it pretty much worked perfectly as described</p>",
        "id": 292628774,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660068106
    },
    {
        "content": "<p>oh, the file is fixed, I forgot to change the <code>algebra</code> instance from a <code>def</code> to an <code>instance</code> lol. yay! we can finally do flt-regular stuff again</p>",
        "id": 292631029,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660068860
    },
    {
        "content": "<p>I assume this is going to take a while to get into mathlib, so I suggest instead to run flt-regular off this branch until we merge everything.</p>",
        "id": 292631117,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660068891
    },
    {
        "content": "<p>I agree, this is much better. We will have time to catch up with new mathlib stuff later on</p>",
        "id": 292632371,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1660069347
    },
    {
        "content": "<p>Thank you very much <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> for putting in the work and finishing it!</p>",
        "id": 292646351,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1660074661
    },
    {
        "content": "<p>this is all working super well! if anyone wants to see good signs please look at <a href=\"https://github.com/leanprover-community/mathlib/commit/84e8946a86375e925d0f6bab319b845bbec375ba\">https://github.com/leanprover-community/mathlib/commit/84e8946a86375e925d0f6bab319b845bbec375ba</a></p>",
        "id": 292854777,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660180040
    },
    {
        "content": "<p>I have not yet made this work with <code>cyclotomic_ring</code> but that should likely die in a nice fire</p>",
        "id": 292854785,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660180064
    },
    {
        "content": "<p>the flt-regular bump will probably also go this way, with removing many <code>convert</code>s and such like</p>",
        "id": 292854854,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660180136
    },
    {
        "content": "<p>thanks to <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> who suggested a further refactor to Anne's ideas, instead of making <code>lift : (a -&gt; K) -&gt; a -&gt; splitting_field (f : K[X])</code> we instead have <code>mk : K -&gt; splitting_field (f :K[X])</code> and then composing with any required a -&gt; Ks. I thought this was required to fix some issues, in the end it wasn't, but it fixed issues that I wasn't expecting, so I think it's probably the correct thing to do.</p>",
        "id": 292854954,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660180256
    },
    {
        "content": "<p>I've bumped <code>flt_regular</code> to use this branch of mathlib on the branch <code>no_diamonds</code>; it was very easy. I also finished the proof that 2 was regular :)</p>",
        "id": 292922981,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660222037
    },
    {
        "content": "<p>Feel free to the branch even on master. I don't know how this will interact with the automatic update</p>",
        "id": 292949363,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1660230790
    },
    {
        "content": "<p>I think the automatic update will just fail and therefore not update, which is fine, we just have to remember to update the no_diamonds branch whenever we want anything new in it until it gets into master</p>",
        "id": 292950458,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1660231115
    },
    {
        "content": "<p>if anyone would like to PR parts of the branch to master I'd really appreciate it, I'm not so sure I will have time to do it. <code>distrib_smul</code> I think is the first thing that should be done there</p>",
        "id": 292950847,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660231247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/304774-FLT-regular/topic/Project.20status/near/292922981\">said</a>:</p>\n<blockquote>\n<p>I've bumped <code>flt_regular</code> to use this branch of mathlib on the branch <code>no_diamonds</code>; it was very easy. I also finished the proof that 2 was regular :)</p>\n</blockquote>\n<p>Wait what's your definition of regular? It's not the conjunction of about 37 things?</p>",
        "id": 292966097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1660236130
    },
    {
        "content": "<p>class number defn; we'll have to work on the bernoulli one later but we don't need that yet as we're in case 1</p>",
        "id": 292966549,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660236294
    },
    {
        "content": "<p>The idea is to introduce \"strongly regular primes\" and prove flt for them. Maybe in 3 years we will know that a prime is regular iff it is strongly regular</p>",
        "id": 292971087,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1660237806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> are you trying to PR your work?</p>",
        "id": 293878436,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1660735695
    },
    {
        "content": "<p>I've been busy and computer-less for about a week, hopefully I'll get some time soon :)</p>",
        "id": 293878755,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1660735831
    },
    {
        "content": "<p>Regarding the literature: if anyone who wants to work on this project can't proceed due to lacking access to scientific material, please let me know. I have unlimited access to scientific books, papers and journals. I will be happy to share any pdf you need.</p>",
        "id": 294205190,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1660886981
    },
    {
        "content": "<p>I've thought a little bit about what is better to do now, and I think that the fact the port to mathlib4 is really starting and we've just finished caseI is a nice coincidence.</p>\n<p>In my (personal) opinion the port is the most important Lean project now, and I will try to spend much of me Lean-time on it. What we can do with our project is try to PR (to mathlib3 of course) as much material as possible. This is surely less fun and interesting than formalizing new mathematics, but it has to be done.</p>",
        "id": 310245763,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1668531722
    },
    {
        "content": "<p>I think this is reasonable. I guess we need to decide what bits we should try to PR</p>",
        "id": 310256602,
        "sender_full_name": "Chris Birkbeck",
        "timestamp": 1668534916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> If you agree I am going to PR what you did about <code>norm'</code> (the norm as an element of the ring of integers). It's a useful notion and it should be in mathlib anyway. Then I think we can simplify certain proofs using the ideal norm that Anne is PRing.</p>",
        "id": 311408565,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1669044912
    },
    {
        "content": "<p>for sure it's okay, sorry i've not done much PRing</p>",
        "id": 311408672,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1669044954
    },
    {
        "content": "<p>Don't worry, it's very low priority stuff.</p>",
        "id": 311409842,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1669045269
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> I forgot what your tactic <code>may_assume</code> does. I think we are not using it.</p>",
        "id": 311416916,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1669047280
    },
    {
        "content": "<p>its a version of wlog that lets you add assumptions like that the numbers giving  a solution of the fermat equation are coprime, I think someone rewrote the main file not to use it at some point</p>",
        "id": 311417081,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1669047341
    },
    {
        "content": "<p>Yes, I did it. The tactic was for <code>ℕ</code> instead of <code>ℤ</code>, or something like that, and I felt like a general lemma was better. I am checking if we still use it somewhere.</p>",
        "id": 311418966,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1669047928
    },
    {
        "content": "<p>Sorry I don't understand, how could a tactic be for N and not Z? Maybe you had some other reason for removing it but that cant be it</p>",
        "id": 311419880,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1669048205
    },
    {
        "content": "<p>Mmm, maybe it worked for <code>ℕ</code> but not for <code>ℤ</code>, I don't remember exactly.</p>",
        "id": 311420447,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1669048346
    },
    {
        "content": "<p>I just tried a simple example and it works in the same way for the integers as naturals, the internals really don't depend on the type of the expressions involved, its just shuffling goals around</p>",
        "id": 311420603,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1669048386
    }
]
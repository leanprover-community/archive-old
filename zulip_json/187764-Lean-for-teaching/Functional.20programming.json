[
    {
        "content": "<p>Do you think that LEAN is suitable for a course on functional programming? The default option is Haskell.</p>\n<p>Most of the students will have previous experience with imperative programming, but I want the course to be accessible for everyone who can read and write. Hence, I'd also like to know whether \"LEAN as one's first programming language\" is too crazy.</p>",
        "id": 276456841,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1648118313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121542\">@Alexandre Rademaker</span> told me he's been thinking about it. From what I understood, he's truly considering teaching a course of functional programming using Lean. IIRC, he meant Lean 4.</p>\n<p>IMO, if you want to stick to the fundamentals of functional programming, Lean 4 works nicely. Haskell, on the other hand, has a huge package library and might be readier for those who want to program all sorts of systems at the moment</p>",
        "id": 276457667,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648118828
    },
    {
        "content": "<p>Lean has few advantages over Haskell here: less stable, less polished, less docs, less teaching resources, less libraries (important for cool projects), smaller community, less relevant in both academia and industry. Of course it's doable, but you'd be doing your students a disservice.</p>",
        "id": 276458266,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1648119206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256311\">Jannis Limperg</span> <a href=\"#narrow/stream/187764-Lean-for-teaching/topic/Functional.20programming/near/276458266\">said</a>:</p>\n<blockquote>\n<p>Lean has few advantages over Haskell here: less stable, less polished, less docs, less teaching resources, (...)</p>\n</blockquote>\n<p>You are talking about advantages of Haskell, right?</p>",
        "id": 276458739,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1648119493
    },
    {
        "content": "<p>Sorry, confusing wording. I mean \"Lean is less stable, less polished, ... than Haskell.\"</p>",
        "id": 276459069,
        "sender_full_name": "Jannis Limperg",
        "timestamp": 1648119642
    },
    {
        "content": "<p>What would be the reason not to use Haskell?</p>",
        "id": 276460692,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1648120601
    },
    {
        "content": "<p>Playing devil's advocate, there is an extent to which you want educators to be forward thinking, and I think there's value in exposing students to different ideas as long as the overall quality of instruction doesn't suffer. Universities started teaching classes like operating systems in Rust back in 2013/2014 which seems pretty prescient in hindsight (there's some info and student surveys for one class at the university of Virginia here: <a href=\"https://rust-class.org/0/pages/using-rust-for-an-undergraduate-os-course.html\">https://rust-class.org/0/pages/using-rust-for-an-undergraduate-os-course.html</a>).</p>\n<p>The overriding question is obviously whether your initial investigation leads you to believe that you can teach a course using Lean that is as good as or better than one using Haskell. If you have the ability to survey student interest in using something new/different that seems like it would be a good initial step.</p>",
        "id": 276461034,
        "sender_full_name": "Chris B",
        "timestamp": 1648120840
    },
    {
        "content": "<p>In my undergrad CS course, a teacher used some esoteric language to teach us the fundamentals of OOP. I can't even recall the name of the language! And in parallel, he taught us how to do the same things in C++ and Java. It caused a good impact on me because I was able to grasp the <em>idea</em> of OOP without confusing it with Java/C++ concepts, which I see happening quite often.</p>",
        "id": 276461496,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648121132
    },
    {
        "content": "<p>As a result, I was then able to pick up OOP in Python and Scala pretty quickly</p>",
        "id": 276461788,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648121302
    },
    {
        "content": "<p>Here is  a monkey wrench to gum up ones thinking. I first learned function programming on my own with F#, then OCaml, then ML, and then  Lambda Calculus (untyped and typed). I learned Lambda Calculus with \"An introduction to functional programming through Lambda calculus\" by Greg Michaelson <a href=\"http://www.worldcat.org/oclc/1026976972\">WorldCat</a>. I am now working through \"Types and Programming Languages\"<br>\nby Benjamin C. Pierce (<a href=\"https://www.worldcat.org/title/types-and-programming-languages/oclc/1077359413\">WorldCat</a>). When I started with Lambda Calculus so many of the errors I encountered with the other languages all started to make sense.</p>",
        "id": 276463068,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1648122188
    },
    {
        "content": "<p>Two other points to consider. 1. which has been noted is what I call the ethos of a language. Does the language have an active community, how hard is it to install and use the language. Does it have support on multiple OS. Is the community easy to reach and are helpful. etc. etc.  2. The boilerplate and syntax of the language. Languages that added functional after many years tend to have boilerplate code that is hard to grasp. F# on the other hand has <code>|&gt;</code> which made learning composition so nice.</p>",
        "id": 276463431,
        "sender_full_name": "Eric Taucher",
        "timestamp": 1648122437
    },
    {
        "content": "<p>I've been co-organising a functional programming course for 1000+ students/semester for 2 years. My take: students - in particular if they already have an imperative programming background - find FP concepts challenging and question the applicability of FP beyond academia. You will not do your students a favour if you introduce them to an even more powerful but less widespread language. You will also not do yourself a favour due to a lack of libraries and infrastructure; in particular, if you want to have automated tests for submissions, which I think is a must-have.</p>\n<p>If you are interested, here is our (work-in-progress) paper about and resources from our course <a href=\"https://github.com/kappelmann/engaging-large-scale-functional-programming\">https://github.com/kappelmann/engaging-large-scale-functional-programming</a></p>",
        "id": 276463777,
        "sender_full_name": "Kevin Kappelmann",
        "timestamp": 1648122617
    },
    {
        "content": "<p>Another strong functional programming language: <a href=\"https://clojure.org/\">Clojure</a>. It's even used in the industry, if that helps with motivation</p>",
        "id": 276464726,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648123210
    },
    {
        "content": "<p>My CS department had a strong culture of detachment from languages though. I think that changes the game a bit.</p>",
        "id": 276465627,
        "sender_full_name": "Arthur Paulino",
        "timestamp": 1648123679
    },
    {
        "content": "<p>Thank you for all your replies!</p>",
        "id": 276723226,
        "sender_full_name": "Martin Dvořák",
        "timestamp": 1648296973
    },
    {
        "content": "<p>Indeed, as <span class=\"user-mention\" data-user-id=\"451983\">@Arthur Paulino</span> said, I am planning a course on functional programming using Lean4 for next year. I have already discuss some ideas with <span class=\"user-mention\" data-user-id=\"112857\">@Leonardo de Moura</span> too. In my previous courses I have used Haskell and the books <a href=\"https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618\">https://www.amazon.com/Algorithm-Design-Haskell-Richard-Bird/dp/1108491618</a> and <a href=\"https://www.amazon.com/gp/product/B00O0RKGTO\">https://www.amazon.com/gp/product/B00O0RKGTO</a> both from Richard Bird. The hard part to adapt is the codes where lazy evaluation is used. On the other hand, many of the equational reasoning presented in the books can be formally proved in Lean..  Ideas are welcome. </p>\n<p>In another thread, with my hat of computational linguistics, this is another book that I want to translate to Lean from Haskell: <a href=\"https://staff.fnwi.uva.nl/d.j.n.vaneijck2/cs/\">https://staff.fnwi.uva.nl/d.j.n.vaneijck2/cs/</a></p>",
        "id": 276811938,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1648421112
    },
    {
        "content": "<p>I guess we can't talk about \"a course on functional programming\" without context. If you are in a CS department ori if your course will have +100 students, it may have some very different goals. I teach in an Applied Mathematics department and my course will be optional for 10-20 students at most.</p>",
        "id": 276812127,
        "sender_full_name": "Alexandre Rademaker",
        "timestamp": 1648421417
    }
]
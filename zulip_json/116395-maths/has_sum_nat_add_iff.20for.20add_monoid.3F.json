[
    {
        "content": "<p>If would like to apply the following lemma to <code>nnreal</code>, but it's proven only for topological additive groups.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">has_sum_nat_add_iff</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>I'm not really good at manipulating <code>has_sum</code>. Can someone tell me how to prove this for add_monoids?</p>",
        "id": 222447272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610465534
    },
    {
        "content": "<p>MWE?</p>",
        "id": 222452384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610467491
    },
    {
        "content": "<p>I haven't done it but here's the MWE. The proof in mathlib does only work for groups :-/</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_sum_nat_add_iff''</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222453622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610467951
    },
    {
        "content": "<p>Oh! <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> this was the example I mentioned to you the other day! The extraordinary file <code>topology.algebra.infinite_sum</code> assumes that alpha is an add_comm_monoid and a topological_space, and for the first 214 lines it does not assume that there is any relation between these two structures. Continuity of addition appears on line 214. It's quite surprising what they prove without this assumption!</p>",
        "id": 222455640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610468661
    },
    {
        "content": "<p>There will be more -- <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> gave me a preview of his linter's effect on <code>topology.algebra.ordered</code>, and it was quite drastic :)</p>",
        "id": 222455957,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610468777
    },
    {
        "content": "<p>Johan, I suspect the lemma is not true for general add_comm_monoids. If a monoid has some saturating element then a + sum can lose information.</p>",
        "id": 222456512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610468999
    },
    {
        "content": "<p>But it will definitely be true for <code>nnreal</code>.</p>",
        "id": 222456849,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610469111
    },
    {
        "content": "<p>It's easier to think of in terms of products, with the target a monoid with zero. If we have an infinite set S and a finite set F, then the product over S union F is the product of the product over S and the product over F, but if you know that the product over S union F is zero then you don't know which one caused it.</p>",
        "id": 222456920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469129
    },
    {
        "content": "<p>I think it's true in general</p>",
        "id": 222457083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469206
    },
    {
        "content": "<p>If you really need both directions then you'll need some extra assumption saying things cancel (which as Sebastien says is fine for nnreal); or do you only need the true way?</p>",
        "id": 222457146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469241
    },
    {
        "content": "<p>You can always assume WLOG that the sum contains any chosen finite set of summands because that's how the filter works, so you can assume in this case that you are only dealing with partial sums that contain <code>range k</code></p>",
        "id": 222457244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469280
    },
    {
        "content": "<p>Mario, a counterexample for <code>&lt;-</code> in the product version with target the reals (a topological monoid under multiplication) would be if f(0)=0 and k=1. Then RHS is true for any a because <code>0*a1*a2*a3*...</code> is always 0 whatever the product of the a_i converges to.</p>",
        "id": 222457490,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469376
    },
    {
        "content": "<p>Ah, I see, we're cancelling in the <code>&lt;-</code> direction</p>",
        "id": 222457650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469460
    },
    {
        "content": "<p>But if the goal is just <code>nnreal</code> we can just add <code>add_right_cancel</code> as a hypothesis</p>",
        "id": 222457929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469582
    },
    {
        "content": "<p>or use <code>add_left_cancel_monoid</code> or whatever it is called if it is a mixin</p>",
        "id": 222458048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469617
    },
    {
        "content": "<p>Looks like <code>add_cancel_comm_monoid</code> is a thing (I think everything has to be commutative)</p>",
        "id": 222458158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469666
    },
    {
        "content": "<p>We probably assume it but it's not strictly necessary for <code>tsum</code> stuff</p>",
        "id": 222458311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469726
    },
    {
        "content": "<p>you only need things to be \"eventually commutative\"</p>",
        "id": 222458339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610469739
    },
    {
        "content": "<p><del>My guess is that this is provable</del>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_cancel_comm_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_add</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_sum_nat_add_iff''</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Edit: it is not!</p>",
        "id": 222458356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469748
    },
    {
        "content": "<p>If I were doing this in class I would just say \"because alpha is cancellative we can just work in its group of fractions and now we're obviously done\"</p>",
        "id": 222458476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610469798
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_cancel_comm_monoid</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails :-(</span>\n</code></pre></div>",
        "id": 222459159,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470063
    },
    {
        "content": "<p>got it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_left_cancel_monoid</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works :-)</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_right_cancel_monoid</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails :-)</span>\n</code></pre></div>",
        "id": 222459911,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470264
    },
    {
        "content": "<p>Oh, some new theorems pop up when you try the obvious thing. Is it true that if <code>f + g ~&gt; a + b</code> and <code>f ~&gt; a</code> then <code>g ~&gt; b</code> (in a cancellative topological monoid)?</p>",
        "id": 222461012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470632
    },
    {
        "content": "<p>Oh surely.</p>",
        "id": 222461035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470647
    },
    {
        "content": "<p>wait stop</p>",
        "id": 222461058,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470657
    },
    {
        "content": "<p>I suspect you need some condition that plays a role analogous to \"negation is continuous\" in a group</p>",
        "id": 222461075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470662
    },
    {
        "content": "<p>Yeah!</p>",
        "id": 222461094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470669
    },
    {
        "content": "<p>like addition is an open map or something</p>",
        "id": 222461103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470673
    },
    {
        "content": "<p>Yeah I am now less sure that my example is provable!</p>",
        "id": 222461177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470689
    },
    {
        "content": "<p>For nnreal it's fine, but could one imagine a cancellative additive monoid where inverse is not continuous?</p>",
        "id": 222461227,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470716
    },
    {
        "content": "<p>Just to prove I'm not shirking, here's the fun I'm having:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.nnreal</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">@[protect_proj, ancestor add_right_cancel_semigroup add_monoid]</span>\n<span class=\"cm\">class add_right_cancel_monoid (M : Type u) extends add_right_cancel_semigroup M, add_monoid M</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_right_cancel_semigroup</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_right_cancel_monoid</span> <span class=\"n\">nnreal</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 222461346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470761
    },
    {
        "content": "<p>Seems like the same kind of thing as noncomputable inverses</p>",
        "id": 222461355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470763
    },
    {
        "content": "<p>BTW re: your example, you don't get a class just because you have all the superclasses</p>",
        "id": 222461627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470855
    },
    {
        "content": "<p>All we need is a topological space with a group structure such that multiplication is continuous and inverse isn't, and I know examples of these but they're quite pathological.</p>",
        "id": 222461640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610470860
    },
    {
        "content": "<p>you have to explicitly implement it, even if there are no fields</p>",
        "id": 222461674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610470873
    },
    {
        "content": "<p>OK I'll handle that. I suspect this example isn't going to help you but the adeles are the following topological subring of the product of the real numbers and the product over all p of the p-adic numbers: at all but finitely many of the p-adic places, the element must be an integer. This is a topological ring, and its units with the (bad) subspace topology are a topological monoid which is not a topological group because inverse is not continuous with the subspace topology.</p>",
        "id": 222462053,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471009
    },
    {
        "content": "<p>I like that my maths proof had this bug in :D</p>",
        "id": 222462119,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471036
    },
    {
        "content": "<p>I swear I could have delivered that line well enough to get it past anyone.</p>",
        "id": 222462210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471060
    },
    {
        "content": "<p>I will stop worrying about instances and try to find a counterexample.</p>",
        "id": 222462427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471131
    },
    {
        "content": "<p>OK so here's a pretty concrete example of negation not being continuous (translated down from my adelic example): if you give the integers the topology with basis <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[n,\\infty)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∈</mo><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">n\\in\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> then it seems to me that addition is continuous, because the pre-image of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>n</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[n,\\infty)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span> is the union over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">x+y=n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>x</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mi>y</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∞</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">[x,\\infty)\\times[y,\\infty)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∞</span><span class=\"mclose\">)</span></span></span></span>. But inverse is not continuous. I think.</p>",
        "id": 222463450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471471
    },
    {
        "content": "<p>ah, you just beat me to it. I was going to suggest the basis <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mn>0</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mclose\">}</span></span></span></span> for natural numbers under addition</p>",
        "id": 222463675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471551
    },
    {
        "content": "<p>So now what do we want? We're still asking questions about infinite sums, or were you asking about sequences?</p>",
        "id": 222463783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471600
    },
    {
        "content": "<p>I could imagine that an infinite sum converging upwards might have different behaviour to an infinite sum converging downwards with this topology</p>",
        "id": 222463878,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471642
    },
    {
        "content": "<p>Use the reals rather than the integers or naturals</p>",
        "id": 222463928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471653
    },
    {
        "content": "<p>I'm confused by the question</p>",
        "id": 222463971,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471671
    },
    {
        "content": "<p>all this just to satisfy Alex's linter! ;-)</p>",
        "id": 222463976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471673
    },
    {
        "content": "<p>infinite sums don't converge in any particular direction here</p>",
        "id": 222464049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471705
    },
    {
        "content": "<p>I'm just checking I understand the question. Originally we were talking about <code>has_sum</code>. I'm just checking that we still are.</p>",
        "id": 222464061,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471710
    },
    {
        "content": "<p>i.e. that your comment about <code>f + g ~&gt; a + b</code> was still a question about sums</p>",
        "id": 222464113,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471737
    },
    {
        "content": "<p>I think the has_sum question reduces to the question I posed about filter limits, which boils down to some continuity property</p>",
        "id": 222464137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471745
    },
    {
        "content": "<p>It's not about sequences, because <code>has_sum</code> can handle more general convergent nets of partial sums</p>",
        "id": 222464253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471784
    },
    {
        "content": "<p>Oh this topology isn't even Hausdorff! So probably 1+1+1+1+... tends to 37</p>",
        "id": 222464292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471804
    },
    {
        "content": "<p>this is looking good</p>",
        "id": 222464329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471820
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/has_sum_nat_add_iff.20for.20add_monoid.3F/near/222461346\">said</a>:</p>\n<blockquote>\n<p>Just to prove I'm not shirking, here's the fun I'm having:<br>\n...</p>\n</blockquote>\n<p>For some reason <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordered_cancel_comm_monoid.to_left_cancel_monoid\">docs#ordered_cancel_comm_monoid.to_left_cancel_monoid</a> exists but <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ordered_cancel_comm_monoid.to_right_cancel_monoid\">docs#ordered_cancel_comm_monoid.to_right_cancel_monoid</a> doesn't!</p>",
        "id": 222464413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610471855
    },
    {
        "content": "<p>Yes I'd got this far :-) But now I've been distracted by pathological topological monoids</p>",
        "id": 222464524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471890
    },
    {
        "content": "<p>how about an example like: take the nonnegative reals but make the topology discrete on [0, 1]</p>",
        "id": 222464610,
        "sender_full_name": "Reid Barton",
        "timestamp": 1610471929
    },
    {
        "content": "<p>But actually that property spells doom as a counterexample, because everything converges to everything</p>",
        "id": 222464615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610471931
    },
    {
        "content": "<p>No, because if you don't get far enough then you don't converge.</p>",
        "id": 222464714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610471980
    },
    {
        "content": "<p>0+0+0+0+... doesn't tend to 2 because it never makes it to [1,infty)</p>",
        "id": 222464814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472007
    },
    {
        "content": "<p>true, but that happens iff the sequence converges in the usual sense to infinity, and taking a few elements off won't change that</p>",
        "id": 222464836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472019
    },
    {
        "content": "<p>so I think that's it, right? 0+0+0+... doesn't tend to 2, but 1+1+1+... tends to 37 and the sum tends to 39.</p>",
        "id": 222464853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472032
    },
    {
        "content": "<p>but that's not a counterexample</p>",
        "id": 222464942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472084
    },
    {
        "content": "<p>you can only remove finitely many elements from the sequence</p>",
        "id": 222464995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/has_sum_nat_add_iff.20for.20add_monoid.3F/near/222461012\">said</a>:</p>\n<blockquote>\n<p>Oh, some new theorems pop up when you try the obvious thing. Is it true that if <code>f + g ~&gt; a + b</code> and <code>f ~&gt; a</code> then <code>g ~&gt; b</code> (in a cancellative topological monoid)?</p>\n</blockquote>\n<p>I don't know what this means, but I thought that I had given a counterexample to it.</p>",
        "id": 222465254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472239
    },
    {
        "content": "<p>Ah, you were giving a counterexample to that</p>",
        "id": 222465390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472284
    },
    {
        "content": "<p>I agree we don't have a counterexample to Johan's original question yet.</p>",
        "id": 222465402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472289
    },
    {
        "content": "<p>But we have Reid's comment to fall back on if this one doesn't give us something.</p>",
        "id": 222465463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472324
    },
    {
        "content": "<p>Actually a more accurate version of what you get by reducing Johan's question is if <code>f + b ~&gt; a + b</code> then <code>f ~&gt; a</code></p>",
        "id": 222465662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472414
    },
    {
        "content": "<p>Where the + b is acting on the convergents (partial sums), not the elements of the sum</p>",
        "id": 222465766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472463
    },
    {
        "content": "<p>I think that's equivalent to saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">_</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">\\_  + b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.89333em;vertical-align:-0.31em;\"></span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> is an open map</p>",
        "id": 222465883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472509
    },
    {
        "content": "<p>and in this example we're working with, right addition probably is an open map. So let's fall back on Reid's example because there it looks to me like it isn't.</p>",
        "id": 222466249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472653
    },
    {
        "content": "<p>So put the usual topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>, and then add a bunch more open sets -- any subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> is open -- and there's a topology.</p>",
        "id": 222466341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472691
    },
    {
        "content": "<p>But now addition is not continuous :-(</p>",
        "id": 222466435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472725
    },
    {
        "content": "<p>Needs to be the nonnegative reals for that reason</p>",
        "id": 222466449,
        "sender_full_name": "Reid Barton",
        "timestamp": 1610472733
    },
    {
        "content": "<p>yeah I just went to re-check your comment :-)</p>",
        "id": 222466486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/has_sum_nat_add_iff.20for.20add_monoid.3F/near/222464524\">said</a>:</p>\n<blockquote>\n<p>Yes I'd got this far :-) But now I've been distracted by pathological topological monoids</p>\n</blockquote>\n<p>Fixed in <a href=\"https://github.com/leanprover-community/mathlib/issues/5713\">#5713</a>, hopefully</p>",
        "id": 222466727,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610472848
    },
    {
        "content": "<p>I see. So the pre-image of a usual open set is certainly open because usual addition is continuous for the usual topology, and the preimage of a weird open set is open because it's in this [0,1] chaos.</p>",
        "id": 222466779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472879
    },
    {
        "content": "<p>Here's a formal rendering of the statement I gave above (with <code>f</code> in place of <code>+ b</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">property</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">filter</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">nhds</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"bp\">≤</span> <span class=\"n\">nhds</span> <span class=\"n\">a</span>\n</code></pre></div>",
        "id": 222466873,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472923
    },
    {
        "content": "<p>Thanks Eric! Does <code>nnreal</code> become an <code>add_cancel_comm_monoid</code> now?</p>",
        "id": 222466892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610472934
    },
    {
        "content": "<p>Who knows, the universe has to rebuild first</p>",
        "id": 222466922,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1610472949
    },
    {
        "content": "<p>this looks like something that should have a straightforward topological rendering, but I'm not sure what</p>",
        "id": 222466991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610472966
    },
    {
        "content": "<p>I would guess it's \"f is open\"</p>",
        "id": 222467212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610473080
    },
    {
        "content": "<p>OK I think I've got everything straight.</p>\n<p>So Reid's example gives us a cancellative add comm monoid with a topology for which addition is continuous but for which Johan's lemma fails, because 1/10+1/100+1/1000+... does _not_ tend to 0.11111111111...=1/9 because it never reaches the open set {1/9}. However 37+1/10+1/100+1/1000.. does tend to 37.1111... because over there the topology is sensible. Adding 37 isn't open. So this proves that my second attempt at a MWE is also not provable. </p>\n<p>The idea of adding a cancellative assumption was that we seemed to be cancelling, but we need to cancel continuously. So there is some predicate on topological add monoids which is strictly stronger than algebraic cancellation, it says that not only is adding x injective (from cancellative) and continuous (from the top add monoid assumption), it is also open. Presumably this is precisely the condition which one needs in order to make the top add monoid a submonoid of a top add group (certainly for submonoids, with the subspace topology, of top add groups, addition will be continuous). So this would be the natural assumption to put on alpha to make Johan's lemma true.</p>\n<p>My guess is that more generally if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a topological commutative monoid and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is a subset then there might be random ways to put a topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> but the nicest theorems will only hold under the assumption that multiplication by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">s\\in S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is an open map (because then division by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span></span></span></span> will be continuous). This seems like quite a neat project. In fact maybe <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">M[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> won't be a topological monoid if you just put a random topology on it somehow coming from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>, without this extra hypothesis.</p>\n<p>If Johan only needs the result for nnreal then I guess the most painless thing to do is to prove that adding a constant is an open map on nnreal, or alternatively trying to deduce the result on nnreal from the corresponding result for reals.</p>\n<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> thanks for the interesting question!</p>",
        "id": 222469069,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610473912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/has_sum_nat_add_iff.20for.20add_monoid.3F/near/222467212\">said</a>:</p>\n<blockquote>\n<p>I would guess it's \"f is open\"</p>\n</blockquote>\n<p>Confirmed, under the assumption that <code>f</code> is injective (which it is in our examples)</p>",
        "id": 222469074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610473915
    },
    {
        "content": "<p>Nice! So there is an argument for a \"topologically cancellative\" top monoid class.</p>",
        "id": 222469351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610474020
    },
    {
        "content": "<p>If you drop injectivity of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> then the lemma is probably false for other reasons (a1 + b = a2 + b and the infinite sum won't tend to both a1 and a2)</p>",
        "id": 222469597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610474105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> are these missing? Are you working on them?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_continuous_add</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_continuous_add</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"c1\">-- I have no idea whether we need these!</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lemma1</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lemma2</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ2</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ3</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222475907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610476871
    },
    {
        "content": "<p>we should have the first one already, but I doubt we have the second</p>",
        "id": 222475972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610476905
    },
    {
        "content": "<p>In <code>topology.algebra.infinite_sum</code> I couldn't find a single lemma about changing the target monoid. Should I be looking somewhere else? I'll remark in passing that if we used math notation (M, N for the monoids, alpha, beta for the index types) it would be easier to look!</p>",
        "id": 222476190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610476998
    },
    {
        "content": "<p>Hah, I see that you opened and closed some cans of worms while I put my kids in bed (-;</p>",
        "id": 222479119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610478382
    },
    {
        "content": "<p>I've nearly proved your lemma!</p>",
        "id": 222479150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610478399
    },
    {
        "content": "<p>Is this for the liquid stuff?</p>",
        "id": 222479175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610478410
    },
    {
        "content": "<p>yup</p>",
        "id": 222480364,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610478889
    },
    {
        "content": "<p>You led us up quite the garden path!</p>",
        "id": 222480693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610479024
    },
    {
        "content": "<p>mi sori</p>",
        "id": 222480707,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610479036
    },
    {
        "content": "<p>But it should be possible to get a statement that works for both <code>nnreal</code> and <code>nnrat</code> (when we ever get around to defining that one).</p>",
        "id": 222480790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610479081
    },
    {
        "content": "<p>Oh it was great fun, I have loads of things to do today and it was a wonderful excuse not to do any of them. I've just got it compiling.</p>",
        "id": 222480791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610479081
    },
    {
        "content": "<p>so what is the solution in the end? you're assuming that addition is open? I guess this should be a new typeclass... or did you already make it that?</p>",
        "id": 222480904,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610479127
    },
    {
        "content": "<p>No, the new typeclass is a proper little project. I figured that you just wanted it for <code>nnreal</code>. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology.algebra.infinite_sum</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.instances.nnreal</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nnreal</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">has_sum_nat_add_iff''</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">nnreal</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">nnreal</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"bp\">↔</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"bp\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">range</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">has_sum</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">tendsto_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">tendsto_coe</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_sum</span><span class=\"o\">],</span>\n  <span class=\"n\">convert</span> <span class=\"n\">has_sum_nat_add_iff</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">nnreal.coe_add</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">coe_sum</span><span class=\"o\">],</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I've not tidied it up yet.</p>",
        "id": 222481132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610479250
    },
    {
        "content": "<p>ok, so this is the \"cheaty\" version that falls back to <code>real</code> (-;</p>",
        "id": 222481440,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610479393
    },
    {
        "content": "<p>Here's what's going on. It's absolutely crucial that addition is an open map (otherwise the lemma is false). It's also crucial that the monoid is cancellative (otherwise the lemma is false). This should really be a new typeclass (\"topologically cancellative monoids -- the top monoids which are submonoids of top groups). The correct localisation theory for topological add_monoids (you want a topology on the localisation too) is, I suspect, when the things you're inverting have the property that adding them is an open map (Patrick will probably tell us that all of this is in Bourbaki). If you do it this way then basically you're reducing the question from top monoids to top groups. But to actually do the reduction you need lemma1 and lemma2 above, to move between the monoid and the group (and the corollary that for a continuous injective open map, like nnreal -&gt; real, sum = a iff coerced sum = a). This is the key thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">lemma1</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lemma2</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ1</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ2</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">corollary3</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→+</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ</span> <span class=\"o\">:</span> <span class=\"n\">continuous</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ2</span> <span class=\"o\">:</span> <span class=\"n\">injective</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hφ3</span> <span class=\"o\">:</span> <span class=\"n\">is_open_map</span> <span class=\"n\">φ</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">has_sum</span> <span class=\"n\">f</span> <span class=\"n\">m</span> <span class=\"bp\">↔</span> <span class=\"n\">has_sum</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">lemma1</span> <span class=\"n\">φ</span> <span class=\"n\">hφ</span><span class=\"o\">,</span> <span class=\"n\">lemma2</span> <span class=\"n\">φ</span> <span class=\"n\">hφ2</span> <span class=\"n\">hφ3</span><span class=\"o\">⟩</span>\n</code></pre></div>\n<p>I'm not sure we have those lemmas either! Mario was optimistic about lemma 1 but I couldn't find it. So on the face of it, your lemma looks like a lot of work!</p>\n<p>However Yury has already proved corollary 3 in the special case where the map is nnreal -&gt; real, so if you just need it in the nnreal case you may as well use Yury's result, which is what I used (<code>nnreal.tendsto_coe</code>). I was rather hoping it would be a really slick one-liner, but unfortunately you have to commute the coercions with everything. Also, for some reason the first <code>simp only</code> (which is a rewrite under a binder) takes forever right now. I'll try to tidy.</p>",
        "id": 222482244,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610479762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I'm looking at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/has_sum.map\">docs#has_sum.map</a> for <code>lemma1</code></p>",
        "id": 222483061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610480138
    },
    {
        "content": "<p>Nice! I missed it because the add_comm_monoid instance was put on the random type gamma. If it had been an <code>N</code> I would have been more likely to spot it! The lemma is before line 214 so indeed it does not assume that things are topological monoids! In particular my earlier comment <code>  [has_continuous_add M] [has_continuous_add N] -- I have no idea whether we need these!</code> -- indeed we don't seem to!</p>",
        "id": 222483502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610480321
    },
    {
        "content": "<p>I got it down to one line in the end! <a href=\"https://github.com/leanprover-community/mathlib/issues/5716\">#5716</a></p>",
        "id": 222491266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610484090
    }
]
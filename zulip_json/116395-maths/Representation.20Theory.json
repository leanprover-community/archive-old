[
    {
        "content": "<p>Hello, That good <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , i  have also a version of Maschke theorem.  </p>\n<p>But for me the big step is really to make the application over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> ! </p>\n<p>For example, the decomposition of a representation in irreducible representation.</p>\n<p>I think the decomposition in irrducible part is ok for field (not algebraically closed).</p>",
        "id": 198297535,
        "sender_full_name": "orlando",
        "timestamp": 1590049880
    },
    {
        "content": "<p>Could we move this thread to the math stream?</p>",
        "id": 198307212,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590057748
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Representation.20Theory\">#new members &gt; Representation Theory</a> by <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span></p>",
        "id": 198341355,
        "sender_full_name": "Notification Bot",
        "timestamp": 1590077920
    },
    {
        "content": "<p>Thanks Mario.</p>",
        "id": 198346016,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590079921
    },
    {
        "content": "<p>I am very new to Lean (Ive checked it in the past many years ago but I had deemed it to unwieldy to get started). I am just curious why the PR for Maschke's Thm don't define the notion of semisimplicity, and just state that k[G] is semisimple, which I think would be how most people would think Maschke's Thm actually looks like. (It unpacks the notion of semisimplicity into the notion of every submodule has a complementary subspace, which I think its equivalent?, though I only work with algebra over (commutative unital) rings, so I don't know the subtleties.)</p>",
        "id": 198419189,
        "sender_full_name": "Syx Pek",
        "timestamp": 1590137645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"128818\">@Syx Pek</span> Welcome! The reason is only that the definitions are not there yet. This PR does all the \"real work\", and we can easily repackage it in a follow-up PR. I agree that this should be done. We cannot claim that it's completely done yet (-;</p>",
        "id": 198421905,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590139787
    },
    {
        "content": "<p>In particular, the design decisions around \"which definition of semisimplicity should we use\" are probably harder than the actual calculation I did in that PR.</p>",
        "id": 198422199,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139975
    },
    {
        "content": "<p>There are a lot of ways to talk about semisimplicity!</p>",
        "id": 198422220,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590139992
    },
    {
        "content": "<p>Yes, I think the issue will be that nobody has defined semisimple algebras yet. I wonder if this is one of those situations where mathematicians are quite happy with several definitions of the same thing but computer scientists can't have this. Is the definition of a semisimple algebra something like \"finite sum of simple algebras\" or \"its representation theory is semisimple\"? There are theorems to be proved here and nobody has got round to it yet</p>",
        "id": 198422229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590139999
    },
    {
        "content": "<p>Yeah what Scott said</p>",
        "id": 198422268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140026
    },
    {
        "content": "<p>They won't be hard</p>",
        "id": 198422340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140044
    },
    {
        "content": "<p>It's just that we are understaffed right now because the universities aren't teaching this stuff</p>",
        "id": 198422381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590140083
    },
    {
        "content": "<p>Hello,</p>\n<p>I'm an incoming freshman student in California, USA, interested in mathematics and computer science. In particular, I'm interested in developing the representation theory library in mathlib. I'm looking for guidance, perhaps in the form of a summer internship, or someone who would be willing to oversee me in a project in representation theory. </p>\n<p>I was wondering if anyone here could be looking for interns or knew of such opportunities.</p>\n<p>I have experience contributing elementary results to mathlib. I'm comfortable with basic concepts in type theory, abstract algebra, and category theory. I'm not knowledgable in the fine details of representation theory, so there would be some inertia for me to contribute mathlib-level material--I would essentially be learning as I go. I know there's already a significant amount of un-PR'ed code spread out everywhere; I'm fine doing code transfer, but would prefer if I could prove something new. </p>\n<p>I'm excited to learn, and I would be happy to talk about this in more detail. Thanks for reading!</p>",
        "id": 231378582,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616444548
    },
    {
        "content": "<p>There's a ton of basic representation theory which is do-able but not done yet. You'd be welcome to join my group of students who will be meeting on Tuesdays throughout July and August.</p>",
        "id": 231378705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616444613
    },
    {
        "content": "<p>As a suggestion for source material: I like <a href=\"https://www-math.mit.edu/~etingof/repb.pdf\">Pavel Etingof's notes</a> (it's an AMS book, but also freely available from his webpage), which I think should be pretty readily formalisable.</p>",
        "id": 231389370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449390
    },
    {
        "content": "<p>I would love to see more rep th too. I did a little (the core fact of Maschke's theorem is at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.is_semisimple_module/src\">src#monoid_algebra.is_semisimple_module</a>), but it didn't seem like there were others wanting to work on it in the near future, so paused again.</p>",
        "id": 231389657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616449534
    },
    {
        "content": "<p>It would be wonderful to see the proof that the character table of a finite group is square.</p>",
        "id": 231390356,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616449858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thank you for the response! I would love to join your group over the summer--could I DM you on Zulip or Discord to talk about more details?</p>",
        "id": 231409432,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616462458
    },
    {
        "content": "<p>We have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_semisimple_module\">docs#is_semisimple_module</a> now. I think I see two directions from here:</p>",
        "id": 231418262,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470934
    },
    {
        "content": "<ul>\n<li>Continuing on the abstract algebra of semisimplicity towards Artin-Wedderburn (maybe the Jacobson Density Theorem first)?</li>\n</ul>",
        "id": 231418287,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616470982
    },
    {
        "content": "<ul>\n<li>Defining the setoid of conjugacy (if it isn't already lurking somewhere) and its quotient, the type of conjugacy classes of a group/monoid. From there, it's probably not such a long road to the basics of character theory.</li>\n</ul>",
        "id": 231418396,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616471109
    },
    {
        "content": "<p>I'd be happy to contribute at some point especially if someone wants to collaborate towards the first bullet point. A tricky point for the second bullet point is potentially to determine the correct set of assumptions on the ground field (because presumably one doesn't want to just work over the complex numbers).</p>",
        "id": 231433809,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1616486705
    },
    {
        "content": "<p>The work I did on Mashke only assumes the characteristic doesn't divide the order of the field.</p>",
        "id": 231437287,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616488842
    },
    {
        "content": "<p>Speaking of that, I feel like eventually whole files will assume that the characteristic doesn’t divide the order of the group, so we probably want to make that a <code>fact</code> instance</p>",
        "id": 231496296,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616515484
    },
    {
        "content": "<p>Hi. I'm trying to go through the code in <a href=\"https://github.com/leanprover-community/mathlib/tree/representation\">branch#representation</a> and make it work with the current version of lean again. I've run into this universe problem which I don't really understand. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n<span class=\"c1\">-- universe levels don't match</span>\n</code></pre></div>\n<p>Clicking on each thing in the viewer window tells me that <code>restrict_scalars</code> is a function <code>Type u_1 → Type u_2 → Type u_3 → Type u_3</code>. So I think the problem has to do with the final <code>u_3</code> not matching with the universe of <code>module k M</code>, but how do I fix this?<br>\n(cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> because this is basically a copy of his code.)</p>",
        "id": 231906728,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726596
    },
    {
        "content": "<p>Oh dear, that branch is very old. :-) I wouldn't believe it's a good idea...</p>",
        "id": 231906790,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616726654
    },
    {
        "content": "<p>Oh. What's wrong with this branch? I only needed to make minor changes up to this point, and everything seemed to work pretty well.</p>",
        "id": 231906852,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616726757
    },
    {
        "content": "<p>I'll have a look. Do you want to push what you have?</p>",
        "id": 231909047,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728750
    },
    {
        "content": "<p>From memory there was still significant uncertainty about how best to represent the simultaneous actions of k and G. There are potentially 3 different <code>has_smul</code> instances available: <code>k</code>, <code>G</code> and <code>monoid_algebra k G</code>.</p>",
        "id": 231909132,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616728813
    },
    {
        "content": "<p>Does the existence of <code>smul_comm_class</code> help with that?</p>",
        "id": 231910802,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730413
    },
    {
        "content": "<p>Pushed here: <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a></p>",
        "id": 231911110,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730662
    },
    {
        "content": "<p>It doesn't look like that branch has any commits that aren't on master?</p>",
        "id": 231911231,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1616730780
    },
    {
        "content": "<p>Oops. It should be there now.</p>",
        "id": 231911428,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616730910
    },
    {
        "content": "<p>This is pointed out in the docs for <code>restrict_scalars</code>, but how about using <code>module k M</code>, <code>module (monoid_algebra k G) M</code>, and <code>is_scalar_tower k (monoid_algebra k G) M</code>? Then there's a <code>smul_comm_class</code> from the tower instance. </p>\n<p>Is there anything that says if <code>A</code> is an <code>R</code>-algebra and <code>M</code> an <code>A</code>-monoid, then <code>is_scalar_tower R A M</code>?</p>",
        "id": 231912045,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1616731422
    },
    {
        "content": "<p>(I think my last work on this predates <code>is_scalar_tower</code>, and I've not yet got my head around it yet...)</p>",
        "id": 231914243,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616733456
    },
    {
        "content": "<p>Yes, this probably should use both <code>is_scalar_tower</code> and <code>smul_comm_class</code></p>",
        "id": 231916578,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616735773
    },
    {
        "content": "<p><code>is_scalar_tower R A M</code> requires a <code>has_scalar R M</code> instance to be used</p>",
        "id": 231932529,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749204
    },
    {
        "content": "<p>So I guess your question is \"is there a pair of definitions that produce a <code>has_scalar R M</code> instance and a corresponding <code>is_scalar_tower R A M</code>?\"</p>",
        "id": 231932824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616749356
    },
    {
        "content": "<p>If a group <code>G</code> acts on an abelian group <code>M</code> then this can also be viewed as a <code>k[G]</code>-module on <code>M</code>.</p>",
        "id": 231935234,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750827
    },
    {
        "content": "<p>And <code>G</code> also acts on <code>k[G]</code></p>",
        "id": 231935252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750840
    },
    {
        "content": "<p>So we want <code>is_scalar_tower G (monoid_algebra k G) M</code></p>",
        "id": 231935272,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616750854
    },
    {
        "content": "<p>And also one for k and k[G] and M?</p>",
        "id": 231939071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616752896
    },
    {
        "content": "<p>I still don't understand the concrete problem statement, but the error originally was confusing <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars\">docs#restrict_scalars</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.semimodule\">docs#restrict_scalars.semimodule</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"bp\">$</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231939945,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753308
    },
    {
        "content": "<p>You also want a distrib mul action of G on M</p>",
        "id": 231940084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753383
    },
    {
        "content": "<p>This type of thing is IMO a bad idea though, and safer is to not unfold <code>restrict_scalars</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">module_of_monoid_algebra_module</span> <span class=\"o\">:</span>\n  <span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">infer_instance</span>\n</code></pre></div>",
        "id": 231940091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753387
    },
    {
        "content": "<p>Alternatively just make M a module for the monoid algebra and deduce the k module structure and the distrib mul action structure from that</p>",
        "id": 231940228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753438
    },
    {
        "content": "<p>I think that to talk about a representation in a flexible way, we might need 4 lines of <code>variables</code></p>",
        "id": 231940465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753564
    },
    {
        "content": "<p>To give commuting k and G actions on M is to give an action of the monoid algebra</p>",
        "id": 231940484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753576
    },
    {
        "content": "<p>Mathematicians pass freely between the two points of view</p>",
        "id": 231940528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616753609
    },
    {
        "content": "<p>I think the <code>restrict_scalars</code>-free way to set this up is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940679,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753694
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">k</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 231940686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753699
    },
    {
        "content": "<p>And probably an <code>is_smul_comm_class</code> for good measurer?</p>",
        "id": 231940729,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753718
    },
    {
        "content": "<p>That's inferred from <code>is_scalar_tower</code> <del>I think?</del> via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_scalar_tower.to_smul_comm_class\">docs#is_scalar_tower.to_smul_comm_class</a></p>",
        "id": 231940753,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616753733
    },
    {
        "content": "<p>aah, right. So that should be fine</p>",
        "id": 231940928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753831
    },
    {
        "content": "<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>",
        "id": 231941042,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753888
    },
    {
        "content": "<p>You just want to say: \"Let <code>M</code> be a <code>k</code>-linear <code>G</code>-module.\"</p>",
        "id": 231941106,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616753924
    },
    {
        "content": "<p>Wait, actually I think you can do that</p>",
        "id": 231942405,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754553
    },
    {
        "content": "<p><del>Certainly the <code>module (monoid_algebra k G) M</code> instance is inferred already</del></p>",
        "id": 231942453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754580
    },
    {
        "content": "<p>(my orange bars conspired against me again)</p>",
        "id": 231942537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754604
    },
    {
        "content": "<p>Of course ideally we would abstract of <code>monoid_algebra k G</code>, and introduce a <code>k</code>-algebra <code>A</code> together with a predicate <code>is_monoid_algebra k G A</code>.</p>",
        "id": 231942708,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754694
    },
    {
        "content": "<p>Because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo><msub><mo>⊗</mo><mi>k</mi></msub><mi>R</mi><mo>=</mo><mi>R</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G] \\otimes_k R = R[G]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>, but Lean will not believe that equality.</p>",
        "id": 231942811,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616754736
    },
    {
        "content": "<p>I think perhaps this instance should exist and is missing?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 231942983,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616754829
    },
    {
        "content": "<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>",
        "id": 231943915,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755250
    },
    {
        "content": "<p>Maybe Eric's suggestion is better.</p>",
        "id": 231943934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616755261
    },
    {
        "content": "<p>That's goes in the reverse direction to most of mathlib, so is likely to form loops</p>",
        "id": 231943976,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755276
    },
    {
        "content": "<p>In practice, I have a Galois group <code>G</code> that acts on a field <code>L</code> that is an extension of <code>K</code>, and maybe I now want to view <code>L</code> as a <code>K[G]</code>-module.</p>",
        "id": 231944044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755322
    },
    {
        "content": "<p>So I don't want to derive the action of the Galois group <code>G</code> on <code>L</code> from the <code>K[G]</code>-module on <code>L</code>.</p>",
        "id": 231944126,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616755344
    },
    {
        "content": "<p>I assume the instance you want is something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"n\">kG</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 231944939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231941042\">said</a>:</p>\n<blockquote>\n<p>So clearly we are approaching the limit of comfy <code>variable</code> lines.</p>\n</blockquote>\n<p>I think they hit that limit in analysis some time ago!</p>",
        "id": 231944942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616755801
    },
    {
        "content": "<p>I'm pretty sure there's a clever way to build a bundled hom in <code>smul</code> such that all the <code>sorry</code>s are as trivial as the first two proofs</p>",
        "id": 231945115,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616755868
    },
    {
        "content": "<p>This gets two more proofs for free:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semimodule</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">finsupp.lift_add_hom</span> <span class=\"o\">:</span> <span class=\"n\">_</span> <span class=\"bp\">≃+</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+</span> <span class=\"n\">M</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_add_monoid_hom.comp</span>\n      <span class=\"o\">(</span><span class=\"n\">add_monoid_hom.pi</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">smul_add_hom</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">flip</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">flip</span> <span class=\"n\">kG</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>but needs <a href=\"https://github.com/leanprover-community/mathlib/issues/6891\">#6891</a> for the <code>g  •</code>, and a definition of <code>add_monoid_hom.pi</code> which appears to be missing.</p>",
        "id": 231949820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1616758489
    },
    {
        "content": "<p>Hi, I went back to trying stuff out with this and I've written up a representation theory version of <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s Maschke's lemma. It's pushed to <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. I've also copy pasted a whole bunch of stuff from <code>submodule</code> to create API for a<code>subrepresentation</code> structure I defined. There's also a lattice isomorphism between subrepresentations and submodules of the induced monoid algebra. (The equivalence between the module/representation theoretic versions of Maschke is easy after that.)</p>\n<p>I'm not really looking to push any of this into mathlib yet, since I mostly followed my nose and copy pasted along. I could very possibly have done something terribly wrong without realizing it. So, I just wanted to ask here for thoughts and suggestions from everybody. Also, I'm willing to put a lot more effort into this, but I thought it'd be best to tell everyone here first.</p>\n<p>Anything is welcome! :)</p>",
        "id": 236115794,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619408283
    },
    {
        "content": "<p>Looks promising! Presumably we should tweak <code>maschke.lean</code> so that it uses <code>representation</code>, rather than <code>module (monoid_algebra _ _)</code>.</p>",
        "id": 236121930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414503
    },
    {
        "content": "<p>Do you see any obstacle to doing that?</p>",
        "id": 236121934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414510
    },
    {
        "content": "<p>I'm about to PR Schur's lemma in any linear category over an algebraically closed field. I really hope we can use that statement to directly infer the group theoretical statement of Schur's lemma. (And, similarly, the Lie-theoretic statement.)</p>",
        "id": 236122000,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619414558
    },
    {
        "content": "<p>(This is now up as <a href=\"https://github.com/leanprover-community/mathlib/issues/7366\">#7366</a>, but it has some dependent PRs so may take a little while.)</p>",
        "id": 236124815,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619417280
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236121934\">said</a>:</p>\n<blockquote>\n<p>Do you see any obstacle to doing that?</p>\n</blockquote>\n<p>No, it should be pretty easy. I've started to phase the <code>monoid_algebra k G</code> out and so far the proofs look exactly the same.</p>",
        "id": 236286551,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502408
    },
    {
        "content": "<p>Since you're also working with this stuff, you can always tell me about possible conflicting work, or maybe possible converging work. I'm always happy to coordinate  :)</p>\n<p>(But I'm probably going into the finite groups, character theory direction -- I don't know much about category theory)</p>",
        "id": 236286699,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619502568
    },
    {
        "content": "<p>I think character theory is a lovely direction, and I don't have anything in progress there.</p>",
        "id": 236287912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503689
    },
    {
        "content": "<p>I would like to make sure my recent general statement of Schur's lemma is actually usable in representation theory.</p>",
        "id": 236287955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619503716
    },
    {
        "content": "<p>Ok. I don't really know what that connection should look like, but I can make sure to set up most of the concrete instances on the ground</p>",
        "id": 236289133,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619504791
    },
    {
        "content": "<p>Again this would be a really nice example showing that we can get theorems about concrete structures of interest from \"abstract nonsense\".</p>",
        "id": 236297404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619510301
    },
    {
        "content": "<p>I don't think Schur's lemma for linear categories exactly counts as abstract nonsense...</p>",
        "id": 236299032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619511322
    },
    {
        "content": "<p>By \"abstract nonsense\" I just mean \"any theorem about categories\"! We've already proved that categories are useful for mathematical definitions, because of schemes. The next step is to prove they're useful for theorems not in category theory and it looks like right now we have two great candidates for this (this and profinite stuff). Homological algebra will be a third.</p>",
        "id": 236312110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619518390
    },
    {
        "content": "<p>I'd love to start using the category theory stuff we have. I don't expect to get to this for some time but getting Schur's lemma for Lie modules as a dividend is just the motivation I need.</p>",
        "id": 236313520,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619519171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, I like that you're moving forward on actually defining <code>representation</code>s and <code>rep_hom</code>s, but of course I have opinions on which definition should be the basic definition.</p>",
        "id": 236365846,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539887
    },
    {
        "content": "<p>Personally, I'd choose the definition currently used in the library (a <code>module (monoid_algebra k G) V</code>), and I'm about to say why, but ultimately as long as that instance, the <code>smul_comm</code> instance, and the <code>to_monoid_hom/of_monoid_hom</code> structure are still there at the end of the day, I don't think it matters that much what the underlying definition is.</p>",
        "id": 236366039,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619539957
    },
    {
        "content": "<p>I vote for <code>representation k G V</code> to be defined as an <code>abbreviation</code> of <code>module (monoid_algebra k G) V</code>, because then <code>subrepresentation</code> can be an abbreviation of <code>submodule (monoid_algebra k G) V</code> and <code>rep_hom</code> can be an abbreviation of <code>linear_map</code>, again over <code>monoid_algebra k G</code>.</p>",
        "id": 236366454,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540123
    },
    {
        "content": "<p>You have to define all of the extra structure on <code>representation, subrepresentation, rep_hom</code> one way or another, but this way you don't have to copy and paste all the basic API just to define them and get the basic instances on them.</p>",
        "id": 236366833,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540277
    },
    {
        "content": "<p>Ok. Actually I think I agree with sticking to <code>monoid_algebra k G</code>; it would prevent all the duplication I've been doing.</p>",
        "id": 236366955,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619540297
    },
    {
        "content": "<p>It is not the definition we give to undergraduates, but experience has shown us that the fewer definitions we have, the better.</p>",
        "id": 236367068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540346
    },
    {
        "content": "<p>If I had seen the \"burn <code>vector_space</code>\" PR I would have suggested that it lived on as an <code>abbreviation</code></p>",
        "id": 236367170,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540397
    },
    {
        "content": "<p>If you abbreviate these things, and provide the <code>smul_comm</code> instances and so on, it should still be possible to work entirely with those other approaches (although even my undergrad class eventually switched to mostly using group-ring-modules...)</p>",
        "id": 236367383,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540466
    },
    {
        "content": "<p>As we move further into the library, it should also be possible to make <code>irreducible_representation</code> an abbreviation for <code>simple_module</code> and so on</p>",
        "id": 236367518,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540523
    },
    {
        "content": "<p>Yes, the way I was taught it was all G-actions on k-vector spaces and then suddenly this bombshell half way through that it's just R-modules for R=k[G] and about 3/4 of the lemmas we'd proved until that point were true in far greater generality</p>",
        "id": 236367562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619540530
    },
    {
        "content": "<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>",
        "id": 236367787,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540643
    },
    {
        "content": "<p>It'd also be nice if there's a short-and-sweet notation that approximates the <code>ρ g</code> notation that you use when talking about the group homomorphism</p>",
        "id": 236368254,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540814
    },
    {
        "content": "<p>Perhaps as simple as <code>ρ k M g</code>...</p>",
        "id": 236368493,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619540901
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236367787\">said</a>:</p>\n<blockquote>\n<p>I think here the key piece of code is a <code>def</code> (unfortunately not an instance, or it'd create a loop) that takes in a <code>smul_comm_class</code> of the right scalar actions and puts on a <code>module (monoid_algebra k G) M</code> structure</p>\n</blockquote>\n<p>I think this is what I've done indirectly. <code>representation</code> extends <code>smul_comm_class</code> for the <code>G</code> and <code>k</code> actions. Then I derive a <code>module</code> instance. </p>\n<p>I could just cut out defining a <code>representation</code> and do this directly</p>",
        "id": 236368832,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541036
    },
    {
        "content": "<p>But I didn't seem to hit any problems with the type class inference after I defined the <code>module</code> instance; is there an explicit loop we should be worried about?</p>",
        "id": 236369236,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619541193
    },
    {
        "content": "<p>Presumably you want to provide a <code>smul_comm_class</code> given a <code>module (monoid_algebra _ _)</code> AND vice versa, but only one can be an instance</p>",
        "id": 236371894,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619542253
    },
    {
        "content": "<p>Without having followed earlier conversation - the <code>of'</code> in <code>representation_theory/basic.lean</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>",
        "id": 236373177,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619542812
    },
    {
        "content": "<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>",
        "id": 236373373,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619542877
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373177\">said</a>:</p>\n<blockquote>\n<p>Without having followed earlier conversation - the <code>of'</code> in your branch is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.single_one_ring_hom\">docs#monoid_algebra.single_one_ring_hom</a></p>\n</blockquote>\n<p>Oh oops, I missed this. But the name is so long...</p>",
        "id": 236373901,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543078
    },
    {
        "content": "<p>Well, you can always define <code>of' := monoid_algebra.single_one_ring_hom</code> and sort out the name later - but there's no need to prove it again!</p>",
        "id": 236373979,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619543113
    },
    {
        "content": "<p>Yeah, that's going to be the first thing I do</p>",
        "id": 236374100,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619543163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236373373\">said</a>:</p>\n<blockquote>\n<p>Ok. I might be missing the point, but why do we want both directions?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- define this</span>\n</code></pre></div>\n<p>I was thinking that this setup would be the way to define representations. Going from <code>module (monoid_algebra k G) M</code> to <code>smul_comm_class k G M</code> seems like going backwards. (Also you would need <code>is_scalar_tower k (monoid_algebra k G) M</code> and <code>is_scalar_tower G (monoid_algebra k G) M</code> to make this work, maybe both or just one of them)</p>\n</blockquote>\n<p>If we define a representation as <code>module (monoid_algebra k G) M</code>, then whenever we want to use a representation, we'll assume <code>[representation k G M]</code> which will be equivalent to <code>[module (monoid_algebra k G) M]</code>. Once we're there, we'll sometimes want to refer directly to the <code>k</code>-action, and sometimes to the <code>G</code>-action, so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. We'll also want to know that those commute with each other and with the action of <code>monoid_algebra k G</code>, hence you'll want <code>smul_comm_class</code> and <code>is_scalar_tower</code> instances</p>",
        "id": 236377716,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619544738
    },
    {
        "content": "<blockquote>\n<p>so we want to have <code>module k M</code> instances and <code>distrib_mul_action G M</code> instances that follow from <code>[representation k G M]</code>. </p>\n</blockquote>\n<p>This doesn't make any sense, because you're not allowed to write <code>[representation k G M]</code> without writing <code>[module k M] [distrib_mul_action G M]</code> first</p>",
        "id": 236378169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544943
    },
    {
        "content": "<p>It's like saying you want an instance to go from <code>module k M</code> to <code>add_comm_monoid M</code></p>",
        "id": 236378228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619544967
    },
    {
        "content": "<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>",
        "id": 236378299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545019
    },
    {
        "content": "<p>Ohh, I understand. I'm also realizing that all of this was basically said before in this thread, I just didn't get it before (<span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  even wrote down the <code>module</code> instance explicitly right above my first comment <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> )</p>",
        "id": 236378308,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545023
    },
    {
        "content": "<p>Oh, I hadn't realized this thread had older replies from me in it!</p>",
        "id": 236378451,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236378299\">said</a>:</p>\n<blockquote>\n<p>Oh, sorry; you're talking about a different definition of <code>representation</code> to the one in the branch?</p>\n</blockquote>\n<p>Yes, I've been suggesting that we define it as <code>module (monoid_algebra k G) M</code>, which means basically flipping everything <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span> ' been doing backwards...</p>",
        "id": 236378555,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619545163
    },
    {
        "content": "<p>That's perfectly fine with me btw -- actually less work in the long run because there's no duplication</p>",
        "id": 236378757,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545264
    },
    {
        "content": "<p>Based on the recent <code>vector_space</code> removal, I think that is a definition that belongs only in a docstring</p>",
        "id": 236379929,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545729
    },
    {
        "content": "<p>Although I guess that argument applies to the definition in the branch too</p>",
        "id": 236380009,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545760
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?</p>\n</blockquote>",
        "id": 236380037,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619545771
    },
    {
        "content": "<p>I think the usual way to handle this is add instances in the forwards direction (the branch), and type aliases like <code>restrict_scalars</code> in the backwards direction (that suggestion)</p>",
        "id": 236380234,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619545837
    },
    {
        "content": "<p>Ok. It seems like I will follow the main mathlib direction with this setup then:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">blah</span> <span class=\"n\">blah...</span> <span class=\"c1\">-- a representation</span>\n</code></pre></div>\n<p>And we can go backwards with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module\">docs#restrict_scalars.module</a> and, err, hopefully <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.distrib_mul_action\">docs#restrict_scalars.distrib_mul_action</a></p>",
        "id": 236381558,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1619546307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"355764\">Hanting Zhang</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/236380037\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span>  Hmm, wait actually do you mean this way?<br>\n<span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/231943915\">said</a>:</p>\n<blockquote>\n<p>Could we go the other way instead? Deduce <code>[semimodule k M]</code> and <code>[distrib_mul_action G M]</code> from <code>[semimodule (monoid_algebra k G) M]</code>?<br>\n</p>\n</blockquote>\n</blockquote>\n<p>I definitely mean this.</p>",
        "id": 236426228,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1619566023
    },
    {
        "content": "<p>Looking at the branch, this instance worries me a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">has_group_scalar</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>because when <code>k = G</code> you end up with two <code>has_scalar G (monoid_algebra G G)</code> instances which have different actions.</p>",
        "id": 236488008,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608148
    },
    {
        "content": "<p>Perhaps no one ever uses <code>monoid_algebra G G</code> so it doesn't really matter</p>",
        "id": 236488210,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619608271
    },
    {
        "content": "<p>You'll have things like <code>G = units k</code>. But <code>G = k</code> is unlikely, I think.</p>",
        "id": 236488328,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619608334
    },
    {
        "content": "<p>I think I've seen <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[\\mathbb{Z}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathbb\">Z</span><span class=\"mclose\">]</span></span></span></span> before, but this is the integers as an additive monoid.</p>",
        "id": 236489458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609012
    },
    {
        "content": "<p>To avoid the issue we could create a type alias and instead declare the action <code>has_scalar (foo G) (monoid_algebra k G)</code></p>",
        "id": 236489696,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619609140
    },
    {
        "content": "<p>I think that in the additive setting, this is more likely to be a problem.</p>",
        "id": 236490390,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609474
    },
    {
        "content": "<p>Are we trying to do representation theory of additive monoid/groups as well?</p>",
        "id": 236490426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609492
    },
    {
        "content": "<p>Otherwise Kevin's example would end up begin <code>monoid_algebra int (multiplicative int)</code> and there wouldn't be a problem anyway.</p>",
        "id": 236490505,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1619609524
    },
    {
        "content": "<p>I am playing with <code>monoid_algebra</code> for the LTE, and I indeed suggest to avoid <code>add_monoid_algebra</code> if possible</p>",
        "id": 236490720,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609642
    },
    {
        "content": "<p>It really makes things confusing</p>",
        "id": 236490789,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609657
    },
    {
        "content": "<p>Is that a good reason to avoid it?</p>",
        "id": 236490830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609674
    },
    {
        "content": "<p>I tried to prove the Riemann hypothesis but it really got confusing</p>",
        "id": 236490918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609731
    },
    {
        "content": "<p>I mean, one can prove everything for <code>monoid_algebra</code>, and at the end translate the results for <code>add_monoid_algebra</code> using the fact that they are isomorphic</p>",
        "id": 236490955,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1619609756
    },
    {
        "content": "<p>Yes, that's a fair point.</p>",
        "id": 236490999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609765
    },
    {
        "content": "<p>Or, if you have an additive group <code>A</code> that you want to do representation theory with, just apply the theory to <code>multiplicative A</code></p>",
        "id": 236491066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619609813
    },
    {
        "content": "<p>Hi a third time,</p>\n<p>So I didn't do anything with representation theory for awhile, because I kind of sidetracked onto a project to prove the Artin-Wedderburn Theorem, which is finally coming along in <a href=\"https://github.com/leanprover-community/mathlib/tree/acxxa/representation\">branch#acxxa/representation</a>. It took 1500 loc though, so knowing me it will probably be another while before I can clean it up fully. </p>\n<p>Just posting this out here in case anyone else is planning (or already! -- that would be awkward) working on this.</p>",
        "id": 239917151,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621736902
    },
    {
        "content": "<p>I was working toward this, but I PRed all the work I did manage. I’ll take a look at what you’ve done.</p>",
        "id": 239919422,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1621739748
    },
    {
        "content": "<p>What is the maths-statement of the version of Artin-Wedderburn you're aiming at?</p>",
        "id": 239921043,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621741926
    },
    {
        "content": "<p>Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> be a semi-simple ring. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes as a direct sum of simple modules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>⨁</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi>n</mi><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\bigoplus_{i = 1}^k n_i S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and there is an ring isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span>. Here <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">M</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mo>−</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal M_{n} (-)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mclose\">)</span></span></span></span> is the ring of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n\\times n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> matrices. Actually we want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mtext>op</mtext></msup><mo>≃</mo><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R^\\text{op} \\simeq \\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> but I haven't thought too hard about how the <code>op</code>'s go yet.</p>\n<p>The tricky part was to figure out how to write the sum properly. Because letting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> range from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">1, \\dots, k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> really means something like going through the isomorphism classes of the set of simple submodules that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> decomposes into. Furthermore, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> quantifies the number of submodules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">S&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>≃</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S&#x27; \\simeq S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, which is the size of each isomorphism class containing <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n<p>In <code>direct_sum_stuff.lean</code>, <code>isomorphism_quot R R</code> is the quotient of <code>decomposition R R</code> by an isomorphism relation. Then for any <code>i : isomorphism_quot R R</code>, we define <code>quotient.class i</code> as the class of <code>i</code>'s representative. So <code>isomorphism_quot R R</code> is supposed to be <code>1,...,k</code> and <code>quotient.class i</code> is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. The isomorphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mtext>End</mtext><mi>R</mi></msub><mi>R</mi><mo>≃</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msub><mi mathvariant=\"script\">M</mi><msub><mi>n</mi><mi>i</mi></msub></msub><mo stretchy=\"false\">(</mo><msub><mtext>End</mtext><mi>R</mi></msub><mo stretchy=\"false\">(</mo><msub><mi>S</mi><mi>i</mi></msub><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{End}_R R \\simeq \\prod_{i = 1}^k \\mathcal {M}_{n_i} (\\text{End}_R (S_i))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≃</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord text\"><span class=\"mord\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">))</span></span></span></span> looks like this: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">something</span> <span class=\"o\">[</span><span class=\"n\">is_semisimple_module</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">isomorphism_quot</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">),</span>\n    <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">quotient.class</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">i.out</span><span class=\"o\">))</span> <span class=\"bp\">≃+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 239922346,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621743587
    },
    {
        "content": "<p>Hopefully this looks correct and understandable. (and sane?) I would be very happy to take any suggestions and/or talk about my code!</p>",
        "id": 239922692,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> Thanks in advance! Sorry everything is in the wrong place right now. I will be organizing code, files, and docstrings in the next few days so it should be much clearer then</p>",
        "id": 239922994,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744352
    },
    {
        "content": "<p>Oh and it shouldn't be too hard to go from the above and prove the version where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is also an algebra over some field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span>.</p>",
        "id": 239923135,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621744468
    },
    {
        "content": "<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>",
        "id": 239929435,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752160
    },
    {
        "content": "<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>",
        "id": 239929499,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752250
    },
    {
        "content": "<p>I think an important part of Artin-Wedderburn is that this decomposition is unique up to relabelling.</p>",
        "id": 239929519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752294
    },
    {
        "content": "<p>I had been proving this on a branch a while ago --- the version I wanted was that if you had a collection of objects so that homs between them were either zero or isomorphisms (e.g. the set of all simple objects), then decompositions into direct sums of these objects were unique (before we even come to the question of existence).</p>",
        "id": 239929606,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621752411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929435\">said</a>:</p>\n<blockquote>\n<p>The first statement \"R decomposes as a direct sum\" is just the definition of semisimple, right? Or are you using \"Jacobson radical is trivial\"?</p>\n</blockquote>\n<p>Yes, I'm just using the definition.</p>",
        "id": 239982586,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621808945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/239929499\">said</a>:</p>\n<blockquote>\n<p>The second statement \"there is a ring isomorphism ...\" has nothing to do with rings or modules: this is just a fact about endomorphisms of a direct sums of simple objects. (I'm just saying this to emphasise that these two parts are essentially separate projects.)</p>\n</blockquote>\n<p>As for the second part, I think I agree that the two parts are really separate things. I'm very out of depth on your first sentence though. What more general objects are you talking about when you say \"nothing to do with rings and modules\"?</p>",
        "id": 239982885,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809250
    },
    {
        "content": "<p>To be honest I wasn't even thinking about the unique part but now I'm realizing that it should also be a part of the proof. It shouldn't be too hard to prove from my approach just working concretely with the modules. May I ask how you've been approaching it? I guess which way do you think is more important?</p>",
        "id": 239983496,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1621809977
    },
    {
        "content": "<p>So we have the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.simple/src\">src#category_theory.simple</a>, which hopefully is enough to do the endomorphism ring calculation.</p>",
        "id": 239989405,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816430
    },
    {
        "content": "<p>Say you have a collection of objects <code>X i</code> in a preadditive category such that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>. Then if you have a direct sum of these objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mo>⨁</mo><msub><mi>n</mi><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A = \\bigoplus n_i X_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (quite how to state that hypothesis is actually the trickiest thing here), then it should be easy to provide the ring isomorphism from <code>End A</code> to the direct sum of matrices over the <code>End (X i)</code>.</p>",
        "id": 239989732,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816777
    },
    {
        "content": "<p>Then the next step is to assume something a little stronger: every nonzero morphism <code>X i ⟶ X i</code> is an isomorphism (e.g. this holds if you take <code>X i</code> to be the collection of simples). (I don't think we even need Schur's lemma yet, which says that if the category is linear over an algebraically closed field then every morphisms <code>X i ⟶ X i</code> is actually a multiple of the identity.)</p>\n<p>Now you can prove inductively, by a \"Gaussian elimination\" type argument, that if you have <span class=\"tex-error\">$$\\bigoplus n_i X_i \\iso \\bigoplus m_i X_i$$</span> then in fact <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">n_i = m_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 239989939,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621816952
    },
    {
        "content": "<p>I should say I haven't actually done this. I made one aborted attempt that was unnecessarily complicated, but I would like to do this at some point.</p>",
        "id": 239989975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817001
    },
    {
        "content": "<p>A final thing that would be nice to prove: </p>\n<p>Let's give a name to the two above conditions on a collection of <code>X i</code> (that <code>(X i ⟶ X j) = 0</code> when <code>i \\ne j</code>, and any nonzero endomorphism of an <code>X i</code> is invertible), \"<code>X</code> are mutually simple\". (Notice that the <code>X</code> aren't necessarily simple in this definition!)</p>\n<p>Then you can prove that if every object <code>Z</code> is isomorphic to some direct sum of the <code>X i</code> (in fact, in a unique way by the claim above), in fact the category is semisimple, and the <code>X i</code> are a set of representatives of the isomorphism classes of simples.</p>\n<p>This approach is useful for example in quantum topology: e.g. typically any \"diagrammatic algebra\", like the Temperley-Lieb algebra underlying the Jones polynomial, is awkward to prove semisimplicity \"via algebra\", and the best approach is to produce this family of mutually simple objects first, then conclude afterwards the category is semisimple. In the quantum topology literature this approach sometimes goes by the name \"Müger semisimplicity\", as he explained how to use it.</p>",
        "id": 239990403,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621817452
    },
    {
        "content": "<p>In the literature \"mutually simple\" is called a \"semibrick\". There is a related condition of a \"simple-minded collection\" in a triangulated category.</p>",
        "id": 240006782,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621832959
    },
    {
        "content": "<p>Oh, interesting, where do people use \"semibrick\"? I hadn't heard that one.</p>",
        "id": 240013032,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621839170
    },
    {
        "content": "<p>In representation theory of finite dimensional algebras, most recently in a generalisation of the classical theory of tilting modules called tau-tilting theory, see e.g. <a href=\"https://arxiv.org/abs/1610.05860\">https://arxiv.org/abs/1610.05860</a></p>",
        "id": 240014896,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1621840675
    },
    {
        "content": "<p>Here's a first cut at proving that morphisms between direct sums of hom-orthogonal objects can be decomposed into direct sums of matrix blocks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.shapes.biproducts</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.matrix.basic</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">subsingleton</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.eq_zero</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">⟶</span> <span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">o</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subsingleton.elim</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_zero_morphisms</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_finite_biproducts</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">hom_orthogonal.matrix_decomposition</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">ι</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">:</span> <span class=\"n\">hom_orthogonal</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"bp\">⨁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"bp\">≃</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">matrix</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">End</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">})</span> <span class=\"bp\">≫</span>\n      <span class=\"n\">biproduct.components</span> <span class=\"n\">z</span> <span class=\"n\">j</span> <span class=\"n\">k</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">biproduct.matrix</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">k</span> <span class=\"k\">then</span>\n      <span class=\"n\">z</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]⟩</span> <span class=\"bp\">≫</span> <span class=\"n\">eq_to_hom</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n    <span class=\"k\">else</span>\n      <span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">category.assoc</span><span class=\"o\">,</span> <span class=\"n\">biproduct.lift_π</span><span class=\"o\">,</span> <span class=\"n\">biproduct.ι_matrix</span><span class=\"o\">],</span>\n    <span class=\"n\">split_ifs</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">symmetry</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">o.eq_zero</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">i</span> <span class=\"o\">⟨</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">⟨⟩⟩</span> <span class=\"o\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">set.mem_singleton_iff</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">w.symm</span><span class=\"o\">],</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- TODO additive version? linear version?</span>\n</code></pre></div>",
        "id": 240309657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028589
    },
    {
        "content": "<p>unique decomposition in a semibrick (a <code>hom_orthogonal</code> family where each object's nonzero endomorphisms are invertible) is going to be a little bit more involved, but I'll try it soon.</p>",
        "id": 240309823,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622028710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all your replies! Since you're planning to work on this, I don't think my approach really makes sense anymore. Especially because mine seems to be strictly less general. Would you mind though if I tried to redo some of my work following your thoughts on the category theoretic version? To be clear I would like to try as more of a learning project rather than a <code>for mathlib</code> project, in case you don't want interference.</p>",
        "id": 240422417,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093831
    },
    {
        "content": "<p>Although a side effect may be that I start asking a lot of random category theory questions here.</p>",
        "id": 240422426,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622093849
    },
    {
        "content": "<p>Oops, sorry, I don't mean to stop you doing anything. I've been thinking about doing this for a while but haven't actually done it, so I don't want to discourage you!</p>",
        "id": 240422498,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622093910
    },
    {
        "content": "<p>I just didn't want to wait until you had a PR to make suggestions about how to decouple AW into smaller pieces. :-)</p>",
        "id": 240422583,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094031
    },
    {
        "content": "<p>One possibility would be to clean up what I posted above and get that ready for a PR. There are obvious next steps: show the equivalence I constructed is compatible with the obvious compositions on both sides, and then deduce the ring isomorphism for an endomorphism.</p>",
        "id": 240422632,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094116
    },
    {
        "content": "<p>Would you be interested in doing that?</p>",
        "id": 240422680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094159
    },
    {
        "content": "<p>Ah, my bad for misunderstanding. I kind of read too much into what you said lol</p>",
        "id": 240422685,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094183
    },
    {
        "content": "<p>You've seen all the work I've done so far! :-)</p>",
        "id": 240422699,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094204
    },
    {
        "content": "<p>Now I'm thinking I should definitely get my original code PR out so people can actually see what I'm trying to put into mathlib</p>",
        "id": 240422707,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094227
    },
    {
        "content": "<p>I would be very interested in doing a general version of Artin-Wedderburn as a follow up!</p>",
        "id": 240422765,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094287
    },
    {
        "content": "<p>Yes -- it's also no problem I think if first versions of things in mathlib are not in maximal generality. If someone upgrades your content later with something more general, you shouldn't feel sad about it, but happy that you provoked someone into doing work. :-)</p>",
        "id": 240422772,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622094304
    },
    {
        "content": "<p>I think I just have a bad habit of writing too much code without PRing any of it. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Time too clean up all of my code...</p>",
        "id": 240422876,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622094424
    },
    {
        "content": "<p>I mentioned in <a class=\"stream\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members\">#new members</a> wanting to add more representation theory to mathlib. While I only learned it from Fulton &amp; Harris, <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> suggested Etingof. Just starting a thread here to gather some opinions and advice.</p>",
        "id": 241665540,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622943398
    },
    {
        "content": "<p>Others have certainly been thinking about this recently: e.g. <span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>, myself (very slowly, sorry). I'm looking forward to more representation theory!</p>\n<p>I'm actually doing a bunch of low-level work at the moment, generalising a lot of our code about dimensions and bases to arbitrary noetherian and/or commutative rings (where previously it was just done over a field). I'm hoping this will be useful in representation theory per se soon.</p>",
        "id": 241665598,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943528
    },
    {
        "content": "<p>Higher up in this same thread there is discussion about Artin-Wedderburn.</p>",
        "id": 241665601,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943537
    },
    {
        "content": "<p>We already have Maschke's theorem (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra.submodule.is_complemented/src\">src#monoid_algebra.submodule.is_complemented</a>) and Schur's lemma.</p>",
        "id": 241665653,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943623
    },
    {
        "content": "<p>Although the current statement of Maschke's theorem is the \"core\" fact, and often you see it stated in a form that also gives various corollaries, so this might be a good first step. (i.e. find all the statements of Maschke's theorem you can in books, and make sure they follow from the version of Maschke's theorem already in mathlib!)</p>",
        "id": 241665664,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943700
    },
    {
        "content": "<p>I was actually having trouble finding Schur's lemma. Could you point me to it? I was actually trying to work up to proving it myself as practice. I'm not familiar with Maschke's theorem.</p>",
        "id": 241665801,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622943906
    },
    {
        "content": "<p>We actually have two independent proofs of versions of Schur's lemma!</p>",
        "id": 241665803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943911
    },
    {
        "content": "<p>There is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.bijective_of_ne_zero/src\">src#linear_map.bijective_of_ne_zero</a>, which states that a nonzero morphism between simple R modules is bijective.</p>",
        "id": 241665808,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943944
    },
    {
        "content": "<p>(for <code>R</code> any ring)</p>",
        "id": 241665810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943960
    },
    {
        "content": "<p>There is also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso_of_hom_simple/src\">src#category_theory.is_iso_of_hom_simple</a></p>",
        "id": 241665853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622943998
    },
    {
        "content": "<p>which is much more general, saying that any nonzero morphism between simple objects in a preadditive category with kernels is an isomorphism.</p>",
        "id": 241665860,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944028
    },
    {
        "content": "<p>We should unify these. I hadn't realised until today that the special case theorem existed in mathlib.</p>",
        "id": 241665864,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944053
    },
    {
        "content": "<p>There there are also various stronger versions of Schur's lemma.</p>",
        "id": 241665865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944067
    },
    {
        "content": "<p>in a <code>k</code>-linear category (<code>k</code> an algebraically closed field), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.finrank_hom_simple_simple_le_one/src\">src#category_theory.finrank_hom_simple_simple_le_one</a> says the dimension of the hom space between two simples is at most one.</p>",
        "id": 241665921,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944169
    },
    {
        "content": "<p>and two lemmas immediately afterwards say that it is 1 or 0 depending on whether the simple objects are isomorphic or not.</p>",
        "id": 241665941,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944202
    },
    {
        "content": "<p>(Also --- if you're having trouble finding Schur's lemma, you haven't learnt how to use the right search tools: you should have the mathlib folder open in VSCode, and in the search bar type <code>Schur</code>. You can't miss it.)</p>",
        "id": 241665984,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1622944276
    },
    {
        "content": "<p>I did not know there are these generalisations to Schur's lemma! As a theoretical physics person, I only know it for matrix representations.</p>",
        "id": 241666045,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944392
    },
    {
        "content": "<p>Ah no wonder. I've been using the documentation site's search function.</p>",
        "id": 241666050,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944440
    },
    {
        "content": "<p>I'll take a look at Etingof and compare with mathlib.</p>",
        "id": 241666149,
        "sender_full_name": "Winston Yin",
        "timestamp": 1622944611
    },
    {
        "content": "<p>I'm working on the Artin-Wedderburn theorem (also very slowly!) with the far-away goal to prove that character tables for finite groups are square.</p>",
        "id": 241669742,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1622950635
    },
    {
        "content": "<p>I wrote about 600 lines for some basic definitions and lemmas regarding representations of algebras, following the first few pages of Etingof. Would anyone like to give some advice/feedback? I'm getting stuck at defining the direct sum of representations and showing that decomposable representations are reducible.</p>",
        "id": 242457084,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512422
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/lsULBUVPUtkKrbXpHVGyKJt1/representation.lean\">representation.lean</a></p>",
        "id": 242457096,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512486
    },
    {
        "content": "<p>The proofs are certainly not efficient, so I welcome suggestions for improvement or tricks I should know</p>",
        "id": 242457172,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512605
    },
    {
        "content": "<p>I have some reservation regarding the notation. Currently, <code>representation</code> has a <code>coe_fn</code> from an algebra to an endomorphism of modules, which means the representation is identified with the function. Usually however, we say \"let vector space V be a representation of the algebra A\", so a representation is identified with the target space. I don't have enough experience to tell which one is better for mathlib.</p>",
        "id": 242457457,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623512910
    },
    {
        "content": "<p>Also, sorry in advance if the names don’t obey the convention</p>",
        "id": 242458440,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623514096
    },
    {
        "content": "<p>Winston, just in case you missed it (zulip doesn't mention if your topic title already exists), there is lots of discussion above your message</p>",
        "id": 242458558,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514281
    },
    {
        "content": "<p>Also, rather than uploading the txt file to zulip, could you create a gist on github? I get encoding issues when trying to read your text file on Android, which won't be true of a gist</p>",
        "id": 242458642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623514386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> I’ll do that in the morning (midnight here). Never done gist before</p>",
        "id": 242458947,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623514793
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span>, cool! Here are some thoughts from just looking at the file (I didn't actually run lean, so some of my suggestions might be wrong, let me know if I can clarify anything). Its easier for people to look at if you open a PR (tagged WIP for example) or at least make a git branch on mathlib so people can check the branch out more easily, let us know if you need assistance setting that up and we can help.</p>\n<ul>\n<li>If you have multiple rewrites in a row you can combine them so</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n<span class=\"n\">rw</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>becomes</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">]</span>\n</code></pre></div>\n<ul>\n<li>If you just run one tactic with <code>by {simp}</code> the curly braces <code>{}</code> aren't needed.</li>\n<li>The character <code>ᾰ</code> is awkward to type on purpose, the idea is that you shouldn't use it! Instead give a name to the thing you want to refer to, for <code>has_bot</code>:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ᾰ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">submodule.mem_bot</span>\n</code></pre></div>\n<p>you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">submodule.mem_bot</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">linear_map.map_zero</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">submodule.mem_bot</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>I believe.</p>\n<ul>\n<li>You apply theorems like <code>  apply linear_map.ext</code> you could likely replace this with just calling the <code>ext</code> tactic. Likewise for <code>    apply funext</code></li>\n<li>If you have multiple goals its easier to read and manage them if you separate each goal into a block with braces, so whenever you have <code>split</code> the next line should start with a brace <code>{</code> to focus the first goal only.</li>\n<li>There are some nice tactics for reducing repetition like <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#all_goals\">tactic#all_goals</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#repeat\">tactic#repeat</a>, for example you have</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span>\n\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span>\n</code></pre></div>\n<p>which could probably become</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"k\">show</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">direct_sum</span> <span class=\"n\">ι</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"n\">direct_sum_repr.to_fun</span> <span class=\"n\">ρ</span><span class=\"o\">,</span>\n  <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_one</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_mul</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_zero</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.map_add</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">direct_sum_repr.commutes</span> <span class=\"o\">}</span>\n</code></pre></div>\n<ul>\n<li>You have a line</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>probably <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#dsimp\">tactic#dsimp</a> will do this for you</p>",
        "id": 242459381,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1623515181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> those are great suggestions. Thank you!</p>",
        "id": 242459695,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623515636
    },
    {
        "content": "<p>A coule more: </p>\n<ul>\n<li>\n<p><code>Type _</code> is more usually done as <code>Type *</code>,</p>\n</li>\n<li>\n<p><code>simp</code> not at the end of the line is usually considered bad form, as it's hard to debug when you add more <code>@[simp]</code> lemmata. You should <code>squeeze_simp</code> them, or if you can put them at the end (potentially using <code>simpa</code>). You can also give <code>simp</code> bonus lemmata in the same sort of form that you pile up lemmata on <code>rw</code>, e.g. <code>simp [representation.smul_add]</code>.</p>\n</li>\n<li>\n<p>Some of your lemmas should definitely be tagged with <code>@[simp]</code>.</p>\n</li>\n<li>\n<p>You may be able to get away with reusing some lemmata from <code>linear_map</code> instead of having to re-prove them; you may have to put <code>local attribute [reducible] representation</code> in order to do this, though.</p>\n</li>\n<li>\n<p>You usually don't have to put <code>{ name . field := ... }</code> in the definitions of things; Lean will figure it out most of the time, and if it doesn't, it'll shout at you.</p>\n</li>\n<li>\n<p>I <em>think</em> the standard approach for sub-objects now is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set_like\">docs#set_like</a>.</p>\n</li>\n<li>\n<p>Lean usually prefers working backwards; proofs with a lot of <code>at this</code> tend to be a red flag that you could write it \"more idiomatically\".</p>\n</li>\n</ul>\n<p>There's some specific thoughts, too, that would be a lot easier to talk about in a github PR (e.g. the <code>rw</code> is unnecessary in <code>one_smul</code>). Have you got an invite to contribute to <code>mathlib</code>?</p>",
        "id": 242460159,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623516267
    },
    {
        "content": "<p>Not yet. I’ll try a GitHub PR in the morning and maybe get some help here</p>",
        "id": 242461842,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623518588
    },
    {
        "content": "<p>Before you go to sleep, drop your github username and maintainers should be able to give you an invite for the morning ^^</p>",
        "id": 242462375,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1623519581
    },
    {
        "content": "<p>If you haven't already seen it, check out our page with tips for contributors: <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>",
        "id": 242464386,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623522256
    },
    {
        "content": "<p>If somebody could invite me to GitHub: <a href=\"mailto:winstonyin@gmail.com\">winstonyin@gmail.com</a> Got too tired last night after all!</p>",
        "id": 242486001,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623552828
    },
    {
        "content": "<p>I just sent an invite to that email. You'll need to create a GitHub account if you don't already have one.</p>",
        "id": 242486534,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1623553802
    },
    {
        "content": "<p>I've pushed my commit: <a href=\"https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9\">https://github.com/leanprover-community/mathlib/commit/9215e39164877100d8bac41d0a7c241bb75a2cb9</a> (&lt;---- this is a mistake)</p>",
        "id": 242497905,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572295
    },
    {
        "content": "<p>I only added representation.lean, so I'm not sure why there are all these other changed files.</p>",
        "id": 242497913,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572329
    },
    {
        "content": "<p>I think I see the issue. There's an existing branch called <code>representation</code>, which I've just pushed to... I'm sorry! Please help me fix this mistake, as I'm not good with git. It also looks like that branch is trying to do some of the same things I'm doing but differently.</p>",
        "id": 242498028,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623572531
    },
    {
        "content": "<p>Ok the correct branch I've just created: <a href=\"https://github.com/leanprover-community/mathlib/compare/winstonyin/representation\">https://github.com/leanprover-community/mathlib/compare/winstonyin/representation</a></p>",
        "id": 242499506,
        "sender_full_name": "Winston Yin",
        "timestamp": 1623575213
    },
    {
        "content": "<p>Hi,<br>\nI would like to try to contribute to the extent of my knowledge to the representation theory project in mathlib, but I am unsure where to starts since it looks like a few people are already working on this but there's not a lot in mathlib itself. I was wondering what is the state of the project right now.<br>\nI found the pull request <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>, which seems to introduce a definition of group representations and prove equivalences with other usual definitions; it seems like a good starting point, but it has been closed without merging. Why is that so, were there fundamental flaws in the approach of this PR?</p>",
        "id": 260792262,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636461998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 260792855,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636462324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Is there a particular thing in repn thy that you would like to work on?</p>",
        "id": 260796972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636464549
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think that working towards orthogonality for characters of finite groups could be interesting. But I don't know if there are other things we'd need to get out of the way before working on that.</p>",
        "id": 260797537,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636464861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Sounds good. Maybe create a little mind map of the topics you would need?</p>",
        "id": 260800758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466429
    },
    {
        "content": "<p>E.g., mathlib doesn't have class functions at the moment. I guess you would want to have those</p>",
        "id": 260800793,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466448
    },
    {
        "content": "<p>If you have a list of things, we can quickly tell you what is there and what is not</p>",
        "id": 260800833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636466465
    },
    {
        "content": "<p>I remember from a past discussion of representation theory is that one difficulty is the variety of different ways a representation can be expressed.  As a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action\">docs#mul_action</a>, as a homomomorphism of the group into the automorphism group of the vector space, and as a module over the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoid_algebra\">docs#monoid_algebra</a> of <code>G</code>.  I don't even think we have glue among these different notions.  Did we ever decide which one should be primary?</p>",
        "id": 260803019,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636467342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  Yeah, that's why I asked about <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a>. The primary definition it takes is a <code>distrib_mul_action</code> such that the action of <code>G</code> commutes with that of <code>k</code> and it proves the equivalence with the two other definitions you mention. So it seems like it's already done, but have never been merged into mathlib.</p>",
        "id": 260813460,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471381
    },
    {
        "content": "<p>And yeah, I could try to create a little list of needed topics</p>",
        "id": 260813664,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636471451
    },
    {
        "content": "<p>The direction mathlib has gone since is to avoid things like <code>representation</code> which bundles together both actions and their compatibility, and instead chooses to have three separate typeclasses for these facts.</p>",
        "id": 260854918,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489214
    },
    {
        "content": "<p>i.e. use the <code>smul_comm_class</code> (which quite possibly didn't even exist when I closed that PR??).</p>",
        "id": 260855034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489274
    },
    {
        "content": "<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>",
        "id": 260855176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489326
    },
    {
        "content": "<p>Personally I hope that we will also make a bundled version, perhaps as <code>Rep k G</code>, and provide a categorical API for everything, too.</p>",
        "id": 260855288,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489374
    },
    {
        "content": "<p>There are a lot of functors used early on in representation theory (induction and restriction, particularly), and it seems to me a great shame if we do not express these as functors!</p>",
        "id": 260855373,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636489417
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260855176\">said</a>:</p>\n<blockquote>\n<p>Certainly it would be good to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/2431\">#2431</a> with a PR that shows the equivalence between gadgets equipped with compatible scalar actions by <code>k</code> and <code>G</code>, and gadgets equipped with an action of <code>monoid_algebra k G</code>.</p>\n</blockquote>\n<p>Ok, maybe I think I could try to do that first, since these equivalences seem to me like a necessary thing to get out of way before being able to work on interesting character theory.<br>\nI am not yet very comfortable with typeclasses and their subtleties, so would you mind explaining why it is a better approach to have separate typeclasses for the actions and their compatibilities? To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>",
        "id": 260874886,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636498701
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 260880171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502024
    },
    {
        "content": "<p>So you'd want definitions (perhaps instances in one direction) translating between <code>[module k V] [distrib_mul_action G V] [smul_comm_class k G V]</code> and <code>[module (monoid_algebra k G) V]</code>.</p>",
        "id": 260880378,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502142
    },
    {
        "content": "<p>Some of these hopefully already exist, in the files that develop <code>monoid_algebra</code>.</p>",
        "id": 260880460,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502173
    },
    {
        "content": "<p>But then I'd also define <code>Rep k G</code> to be a structure, (parametrised also be the ring structure on <code>k</code> and the group structure on <code>G</code>), which has as fields the carrier type <code>V</code> and the remaining type classes. Then put a category instance on that.</p>",
        "id": 260880539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502239
    },
    {
        "content": "<p>Given the way we do bundled morphisms, there is not really a good way to say \"a function V to W which is both <code>k</code> linear and <code>G</code> linear\". So I suspect the <code>module (monoid_algebra k G) V</code> version is going to be important, because we <em>can</em> easily talk about a function which is <code>monoid_algebra k G</code>-linear.</p>",
        "id": 260880684,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636502321
    },
    {
        "content": "<p>Thanks! So, for the backward direction (from <code>[module (monoid_algebra k G) V]</code>), would we have 3 definitions, one giving <code>[module k V]</code>, one giving <code>[distrib_mul_action G V]</code> and one giving <code>[smul_comm_class k G V]</code>, or should this be all bundled together somehow? In the first case, how would we formulate that the two parts pf the correspondence are inverses of each other?</p>",
        "id": 260886632,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636506365
    },
    {
        "content": "<p>There would be 3 definitions. (Almost surely the first one already exists.)</p>",
        "id": 260888128,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507683
    },
    {
        "content": "<p>I guess we could write an equivalence with lots of <code>letI := ...</code> statements on one side of the equivalence, to specifying explicitly using the instance that has gone back and forth through the equivalence.</p>",
        "id": 260888215,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1636507760
    },
    {
        "content": "<p>Another quick question : how can I make Lean figure out what the <code>distrib_mul_action</code> is in the definition of <code>[smul_comm_class k G V]</code>?<br>\nIn other words, how to avoid the error in the second definition here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_mul_action</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">to_has_scalar</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"o\">},</span>\n                     <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n                     <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260943866,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636517536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> One option is to use a type synonym for <code>V</code>, something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span> <span class=\"kd\">def</span> <span class=\"n\">rep_space</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">V</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">rep_space</span> <span class=\"n\">ρ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260944446,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518351
    },
    {
        "content": "<p>(The type synonym is when I rename <code>V</code> as <code>rep_space ρ</code>.)</p>",
        "id": 260944497,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518386
    },
    {
        "content": "<p>By the way, I rearranged your <code>distrib_mul_action_of_monoid_hom</code> a little for conciseness, but the only substantive change was from <code>def</code> to <code>instance</code>.</p>",
        "id": 260944511,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518432
    },
    {
        "content": "<p>What's the advantage of <code>instance</code> over <code>def</code>?</p>",
        "id": 260944587,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518517
    },
    {
        "content": "<p><code>instance</code> can be found by \"typeclass inference\", <code>def</code> can't.  So, for example, the fact that a metric space is in a natural way a topological space is found by typeclass inference.</p>",
        "id": 260944607,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518558
    },
    {
        "content": "<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>",
        "id": 260944624,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518599
    },
    {
        "content": "<p>Should <code>smul_comm_class_of_monoid_hom</code> also be an instance then?</p>",
        "id": 260944673,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636518620
    },
    {
        "content": "<p>Yes!</p>",
        "id": 260944684,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636518657
    },
    {
        "content": "<p>Btw, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> is the person to talk to when it comes to scalar actions in mathlib. I'm sure he knows the best way for moving back and forth between </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>and modules over <code>monoid_algebra k G</code>.</p>",
        "id": 260944760,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518743
    },
    {
        "content": "<p>He has been adding a lot of homomorphisms of the form <code>G -&gt; Aut _</code> or <code>R -&gt; End _</code> derived from scalar actions. So this might already be there.</p>",
        "id": 260944792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1636518797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260944624\">said</a>:</p>\n<blockquote>\n<p>Let me redo this for you with <code>def</code> rather than <code>instance</code>, so you can see the difference -- one sec ...</p>\n</blockquote>\n<p>OK, I got it working without typeclass inference (but as you can see, it's painful!).  Not even sure if I've missed some tricks:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">ρ</span> <span class=\"n\">g</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_monoid_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 260945191,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1636519316
    },
    {
        "content": "<p>Oof indeed, it seems like it's much better to use typeclass inference</p>",
        "id": 260945790,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636520075
    },
    {
        "content": "<p>Note that we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action.of_End_hom\">docs#mul_action.of_End_hom</a>; so we <em>could</em> have something called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.of_add_monoid_End_hom\">docs#distrib_mul_action.of_add_monoid_End_hom</a> similar to the <code>distrib_mul_action_of_monoid_hom</code> above</p>",
        "id": 260964520,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536738
    },
    {
        "content": "<p>Having said that, the implementation would just be <code>distrib_mul_action.comp_hom _ ρ</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"o\">:</span> <span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">distrib_mul_action.comp_hom</span> <span class=\"n\">_</span> <span class=\"n\">ρ</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">smul_comm_class_of_monoid_hom</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">mul_action.to_has_scalar</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">distrib_mul_action.to_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">distrib_mul_action_of_module_End_hom</span> <span class=\"n\">ρ</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 260964705,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636536816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks! Is there a reason you used def instead of instance as Heather suggested?<br>\nAlso is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>",
        "id": 260982846,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636547941
    },
    {
        "content": "<p>The first one can't be an instance because it depends on <code>ρ</code>, while the second one already exists so you don't need it anyway</p>",
        "id": 260988228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550815
    },
    {
        "content": "<blockquote>\n<p>Also is there do you know if we already have also the equivalence with modules over the monoid algebra?</p>\n</blockquote>\n<p>Can you give me the lean statement?</p>",
        "id": 260988265,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550828
    },
    {
        "content": "<p>Is this the forward statement?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- are these the defining properties of the action you want?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">of_smul</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra.of</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">algebra_map_smul</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">algebra_map</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 260988453,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636550917
    },
    {
        "content": "<p>What do you think of the proposition of Heather which is to define a vector space which is just a copy of <code>V</code> and put <code>distrib_mul_action</code> and <code>smul_comm_class</code> instances on it? And yes, that would be the forward statement .</p>",
        "id": 260990340,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636551867
    },
    {
        "content": "<p>I think that's a reasonable idea</p>",
        "id": 260992095,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636552720
    },
    {
        "content": "<p>Whether it's necessary depends on whether <code>V = monoid_algebra k G</code> would create ambiguity</p>",
        "id": 261003750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636557281
    },
    {
        "content": "<p>I don't think I understand what you mean, <code>V</code> is the module, not the monoid algebra</p>",
        "id": 261006106,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636558231
    },
    {
        "content": "<p>V is any type that satisfies the module axioms. <code>V = monoid_algebra k G</code> is one such type.</p>",
        "id": 261008694,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559337
    },
    {
        "content": "<p>If your instance can be parameterized to give a <code>has_scalar (monoid_algebra k G) (monoid_algebra k G)</code> instance, it must definitionally satisfy <code>a • b = a * b</code> to avoid diamonds</p>",
        "id": 261008980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636559462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260874886\">said</a>:</p>\n<blockquote>\n<p>To make it concrete, how would you write \"let V be a representation of G over k\" in Lean with this approach?</p>\n</blockquote>\n<p>In addition to the great advice, examples already provided you could also look at some of our Lie theory, at least to see one way to set things like this up in terms of typeclasses. E.g., <a href=\"https://leanprover-community.github.io/mathlib_docs/find/lie_module\">docs#lie_module</a> is the definition of a representation of a Lie algebra.</p>",
        "id": 261025294,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1636565775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Do you know if we have the equivalence, for an algebra <code>A</code> over <code>k</code>, of <code>module A M</code> with <code>is_scalar_tower k A M</code> and algebra maps from <code>A</code> to <code>M →ₗ[k] M</code></p>",
        "id": 261293336,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636742127
    },
    {
        "content": "<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>",
        "id": 261294067,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742491
    },
    {
        "content": "<p>It seems we have neither</p>",
        "id": 261294169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742526
    },
    {
        "content": "<p>Oh, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/distrib_mul_action.to_linear_map\">docs#distrib_mul_action.to_linear_map</a>, if you just want <code>A → M →ₗ[R] M</code></p>",
        "id": 261294863,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636742890
    },
    {
        "content": "<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">module.to_module_End_hom</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+*</span> <span class=\"n\">module.End</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">one_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">mul_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">zero_smul</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">linear_map.ext</span> <span class=\"bp\">$</span> <span class=\"n\">add_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 261295133,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743065
    },
    {
        "content": "<p>I never PR'd that because I couldn't find a good place to put it where I had all the typeclasses available</p>",
        "id": 261295173,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261294067\">said</a>:</p>\n<blockquote>\n<p>I would guess that would be <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End_hom\">docs#module.to_module_End_hom</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.to_module_End\">docs#module.to_module_End</a></p>\n</blockquote>\n<p>Actually I mostly want the other direction</p>",
        "id": 261295580,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743273
    },
    {
        "content": "<p>That's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.apply_module\">docs#linear_map.apply_module</a></p>",
        "id": 261295690,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743349
    },
    {
        "content": "<p>Which probably should be renamed to <code>module.End.apply_module</code></p>",
        "id": 261295709,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743362
    },
    {
        "content": "<p>Or at least, it's that if you combine it with <code>module.comp_hom f</code> where <code>f : A →+* module.End R M</code></p>",
        "id": 261295782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743395
    },
    {
        "content": "<p>Note that <code>is_scalar_tower</code> was the wrong condition, <code>smul_comm_class</code> is what you need</p>",
        "id": 261295952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636743494
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 261296811,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1636743913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/261295133\">said</a>:</p>\n<blockquote>\n<p>If you want the stronger <code>A →+* module.End R M</code>, it's:</p>\n</blockquote>\n<p>PR'd as <a href=\"https://github.com/leanprover-community/mathlib/issues/10300\">#10300</a></p>",
        "id": 261298706,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636744879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> are you still working on this?</p>",
        "id": 265624146,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1640039878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267205\">@Nicolò Cavalleri</span>  I've put it on hold a little bit to do other stuff including some linear algebra which I felt would be needed for rep theory, but yes I have some stuff done and I have the intention to come back to it soonish.</p>",
        "id": 265624695,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1640040275
    },
    {
        "content": "<p>Hi,<br>\nI was wondering if anyone understand why the scalar action is not recognized in <code>smul_single</code>. It works with <code>of k G g</code> but not with <code>finsupp.single g 1</code>, which is quite annoying.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.equiv.module</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.monoid_algebra.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra.trace</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">monoid_algebra</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">representation</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">as_monoid_hom</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">distrib_mul_action.to_linear_map</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"n\">map_mul'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">g'</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_smul</span><span class=\"o\">],</span> <span class=\"o\">},</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_monoid_hom_apply_apply</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">as_algebra_hom</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_def</span> <span class=\"o\">:</span>\n  <span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">as_algebra_hom_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">):</span>\n  <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_monoid_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_algebra_hom_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">as_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"n\">module.comp_hom</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">as_module_apply</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">):</span>\n  <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">as_algebra_hom</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453119,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685146
    },
    {
        "content": "<p>Here's a hacky fix:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"bp\">→₀</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- fails</span>\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">finsupp.single</span> <span class=\"n\">g</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274453442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685331
    },
    {
        "content": "<p>Even though <code>monoid_algebra k G</code> and <code>G →₀ k</code> are definitionally equal, they are not syntactically equal, and type class inference works up to syntactic equality. What is happening in <code>(finsupp.single g 1 : monoid_algebra k G)</code> is that the syntactic type of <code>finsupp.single g 1</code> is <code>G →₀ k</code>, and <code>(finsupp.single g 1 : monoid_algebra k G)</code> means \"check <code>finsupp.single g 1</code> has type <code>monoid_algebra k G</code> and then continue\" -- but it doesn't actually <em>syntactically change</em> the type, so <code>has_scalar (G →₀ k) V</code> is what Lean ends up searching for, and it can't find it. However adding that little <code>id</code> hack actually does syntactically change the type of the term to <code>monoid_algebra k G</code> and then type class inference works. The \"correct\" thing to do here would be to use the appropriate <code>monoid_algebra</code> constructor for <code>monoid_algebra k G</code> as opposed to <code>finsupp.single g 1</code> which is the <code>finsupp</code> constructor.</p>",
        "id": 274453907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685601
    },
    {
        "content": "<p>Will the simplifier still simplify <code>(finsupp.single g 1) •  v</code> to <code>g •  v</code> if I add <code>id</code>?</p>",
        "id": 274454254,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646685746
    },
    {
        "content": "<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 274454386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646685831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274454386\">said</a>:</p>\n<blockquote>\n<p>Looking through the monoid algebra file it seems that the appropriate constructor is <code>of_magma</code>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">smul_single</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">of_magma</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"bp\">=</span>  <span class=\"n\">g</span> <span class=\"bp\">•</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">as_module_apply</span><span class=\"o\">]</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>My first intention was to state it as <code>(of k G g) • v = g • v</code> but the linter complained that the LHS simplifies to <code>(finsupp.single g 1) •  v</code>. Won't the same problem happen with <code>of_magma</code>?</p>",
        "id": 274455018,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646686120
    },
    {
        "content": "<p>oh I see!</p>",
        "id": 274455552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686401
    },
    {
        "content": "<p>Yes you're absolutely right, the simp linter doesn't like it. I think that it's a bad idea to have <code>of = single</code> and <code>of_magma = single</code> as global <code>@[simp]</code> lemmas. I can quite understand why one might want them locally to be <code>simp</code> lemmas when making the API, but for a \"user\" like you who doesn't ever want to see <code>finsupp</code>s but still wants to use the simplifier, the strategy of making <code>of = single</code> a <code>simp</code> lemma is preventing you from doing this.</p>\n<p>I saw the same phenomenon showing up in the <a href=\"https://github.com/ImperialCollegeLondon/complex-number-game\">complex number game</a>. I wanted to make <code>complex.ext</code> a <code>simp</code> lemma, so that whenever Lean was faced with a goal <code>z = w</code> it would replace it with <code>z.re = w.re</code> and <code>z.im = w.im</code>. This worked <em>great</em> for me when I was making the API for complex numbers, because to e.g. prove that multiplication of complex numbers is associative you <em>absolutely</em> want to check this on real and imaginary parts. However when you go deeper into the theory and are developing complex analysis, the last thing you want the simplifier to do is to keep taking real and imaginary parts of things; you want this to be available to you as an option, but definitely <em>not</em> be the \"this is the only sensible way to proceed\" option, which is kind of what <code>simp</code> lemmas are.</p>\n<p>So I would suggest that (perhaps after getting the nod from one or more maintainers) that you make a PR removing the global simp tags from the lemmas which are causing the trouble and then adding them again with <code>local attribute [simp] of_eq_single</code> (or whatever it's called) so that they're there for API development of <code>monoid_algebra</code> but don't leak out.</p>",
        "id": 274456417,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646686810
    },
    {
        "content": "<p>In my opinion <code>monoid_algebra</code> should be irreducible and <code>finsupp.single G 1 : monoid_algebra</code> should not even typecheck. I mean, it should typecheck in the file making the API for <code>monoid_algebra</code>, and then it should stop typechecking and the simplifier should stop trying to flow in that direction.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℕ</span>\n<span class=\"kd\">def</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"mi\">37</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"c1\">-- fails</span>\n</code></pre></div>",
        "id": 274456898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> am I talking nonsense?</p>",
        "id": 274456955,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687028
    },
    {
        "content": "<p>I've not read the whole of today's discussion, but yes, we shouldn't be writing <code>finsupp.single</code> about <code>monoid_algebra</code></p>",
        "id": 274457169,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687111
    },
    {
        "content": "<p>The problem is that the alternative is copying over all the lemmas about <code>finsupp.single</code> to a new <code>monoid_algebra.single</code></p>",
        "id": 274457220,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687134
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> should I make a PR to remove the global simp tag to lemmas like <code>monoid_algebra.of_apply</code>?</p>",
        "id": 274458555,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646687693
    },
    {
        "content": "<p>I'm not sure. I guess you could open one with the WIP tag and see what breaks</p>",
        "id": 274458632,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687722
    },
    {
        "content": "<p>I am not convinced that there is too much stuff to be said about <code>monoid_algebra.single</code>. One could even get away with not having it, and just sticking with <code>of</code>. The big advantage of <code>single</code> over <code>of</code> is that <code>single</code> span <code>G -&gt;_0 k</code> as an abelian group so you can use simpler induction principles, but I wonder whether we ever see these in practice.</p>",
        "id": 274458657,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687731
    },
    {
        "content": "<blockquote>\n<p>I am not convinced that there is too much stuff to be said about monoid_algebra.single. </p>\n</blockquote>\n<p>(edit: we would need lemmas saying what the) Behavior of 0, 1, addition, subtraction, negation, multiplication, nsmul, zsmul, pow, and maybe some stuff about summation is?</p>",
        "id": 274458855,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687795
    },
    {
        "content": "<p>Also I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_algebra.of\">docs#add_monoid_algebra.of</a> is nasty due to <code>multiplicative</code></p>",
        "id": 274458925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687833
    },
    {
        "content": "<p>I don't know what you mean by all this.</p>",
        "id": 274458941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687842
    },
    {
        "content": "<p>Also <code>of</code> doesn't work on magma algebras, which is annoying</p>",
        "id": 274459054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687885
    },
    {
        "content": "<p>sure define <code>0</code> and <code>1</code> and etc in the <code>monoid_algebra.lean</code> API file using <code>single</code>, and then close it off, giving the user access to <code>of</code>, and a proof that <code>of (g * h) = of g * of h</code></p>",
        "id": 274459073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687894
    },
    {
        "content": "<p>I think if we want to remove <code>of_apply</code>, we need to unbundle <code>of</code></p>",
        "id": 274459076,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687896
    },
    {
        "content": "<p>Things like addition are not about <code>of</code> or <code>single</code></p>",
        "id": 274459151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687942
    },
    {
        "content": "<p>Ah, you're talking about the \"One could even get away with not having [monoid_algebra.single]\" option, which is where we are today minus the finsupp mess</p>",
        "id": 274459163,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274459151\">said</a>:</p>\n<blockquote>\n<p>Things like addition are not about <code>of</code> or <code>single</code></p>\n</blockquote>\n<p><code>single g r + single g s = single g (r + s)</code> is the type of thing I'm describing</p>",
        "id": 274459202,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646687967
    },
    {
        "content": "<p>But we only want <code>single x 1</code> so I'm not interested in this</p>",
        "id": 274459293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646687994
    },
    {
        "content": "<p>I disagree, we need <code>single x r</code> for <code>polynomial.monomial</code></p>",
        "id": 274459403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688030
    },
    {
        "content": "<p>Unless you also want to kill <code>monomial</code> at the same time</p>",
        "id": 274459439,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688048
    },
    {
        "content": "<p>I'm well aware that we need it for <code>G -&gt;0 k</code></p>",
        "id": 274459447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688053
    },
    {
        "content": "<p>I'm suggesting that we forego it only for <code>monoid_algebra</code> because to me it looks a bit useless when we're thinking about group representation theory.</p>",
        "id": 274459522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688084
    },
    {
        "content": "<p><code>polynomial</code> is <code>(add_)monoid_algebra</code> not <code>-&gt;0</code> though</p>",
        "id": 274459544,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688097
    },
    {
        "content": "<p>Right. I'm suggesting we don't need <code>single</code> for <code>monoid_algebra</code> (only).</p>",
        "id": 274459644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688127
    },
    {
        "content": "<p>Are you suggesting we should have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>?</p>",
        "id": 274459712,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688163
    },
    {
        "content": "<p>What I learnt when working on a multivariable polynomial project was that it's really handy to have <code>single</code> because then you can prove stuff about <code>G -&gt;_0 k</code> by checking it's true on <code>single x y</code> and then checking that the subset where it's true is a subgroup. I'm suggesting that this is not a common method of proof for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274459884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688228
    },
    {
        "content": "<p>If I call it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> then you can figure out what I mean in Lean, but I mean \"the group ring\". I'm not talking about subtle differences between additive and multiplicative structures. I just mean that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">tg</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8095em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> doesn't show up much in this theory when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mo>≠</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">t\\not=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"inner\"><span class=\"mord\"><span class=\"mrel\"></span></span></span><span class=\"fix\"></span></span></span></span></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.3669em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 274460048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688297
    },
    {
        "content": "<p>So I don't care if I not only can't coerce <code>finsupp.single x y</code> into <code>monoid_algebra</code> but that there's no substitute in monoid_algebra world, because I will just do <code>of_ring x * of_group y</code> for the appropriate <code>of</code>s (one from the ring, one from the group).</p>",
        "id": 274460260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646688381
    },
    {
        "content": "<p>I think multivariate polynomials are confusing things here, since they are of type <code>add_monoid_algebra R (σ →₀ ℕ)</code> which has both things you're talking about in it</p>",
        "id": 274460395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688453
    },
    {
        "content": "<p>My polynomial remarks are about <code>polynomial R = add_monoid_algebra R ℕ</code> where <code>polynomial.monomial = add_monoid_algebra.single</code> (modulo structure eta)</p>",
        "id": 274460535,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688520
    },
    {
        "content": "<p>If we forbid using <code>finsupp.single</code> with <code>add_monoid_algebra</code> and don't add a <code>add_monoid_algebra.single</code> to replace it, then we're pulling the rug out from under <code>polynomial</code>.</p>",
        "id": 274460602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688558
    },
    {
        "content": "<p>And if we have <code>add_monoid_algebra.single</code> but not <code>monoid_algebra.single</code>, then we're being inconsistent</p>",
        "id": 274460651,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646688589
    },
    {
        "content": "<p>I see. Do you understand <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274463333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646689946
    },
    {
        "content": "<p>Yes, but unrelated to the <code>single</code> topic, I don't yet know how to avoid the diamonds that PR creates</p>",
        "id": 274463782,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690190
    },
    {
        "content": "<p>do we have any diamonds that don't get fixed with definitional eta? i've often said how little I like the current diamond-fixing approach as much as I understand it's necessary</p>",
        "id": 274464196,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690383
    },
    {
        "content": "<p>Yeah, these are straight-up non-equal diamonds</p>",
        "id": 274464224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690394
    },
    {
        "content": "<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>",
        "id": 274464383,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1646690425
    },
    {
        "content": "<p>(there are some equal-but-not-defeq diamonds that appear in that PR too, but they're not so big a deal)</p>",
        "id": 274464426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690430
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138\">https://github.com/leanprover-community/mathlib/blob/1b4ee53b3df5db827f8dc29f660bf613bfa2939e/test/instance_diamonds.lean#L124-L138</a> is the proof of the non-equal diamond</p>",
        "id": 274464525,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690470
    },
    {
        "content": "<p>But it amounts to saying that the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> is ambiguous, as is the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span></p>",
        "id": 274464673,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690523
    },
    {
        "content": "<p>(I bring up the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> example to avoid the \"well we only care about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a group\" counterargument)</p>",
        "id": 274464904,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690641
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284160\">Eric Rodriguez</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274464383\">said</a>:</p>\n<blockquote>\n<p>more type synonyms? :/ seems to be how mathcomp deal with it</p>\n</blockquote>\n<p>I think this would solve the problem, but I suspect it will be very annoying for what Kevin wants to do.</p>",
        "id": 274465037,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690692
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- If this were an instance, it would conflict with the natural</span>\n<span class=\"c1\">-- action of `k[k]` on itself given by multiplication.</span>\n</code></pre></div>\n<p>The thing is that <code>k[k]</code> doesn't happen except in pathological computer science land (edit: just seen your comment on k[k^*]). In fact if <code>R</code> is a nontrivial ring (which it always is) and <code>G</code> is a group (which it always is, except when you're making polynomials) then <code>R</code> can never be <code>G</code> because nontrivial rings can never be groups. However they can certainly be additive groups.</p>\n<p>So there is something interesting going on here with <code>monoid_algebra</code> v <code>add_monoid_algebra</code>. I claim that they are in some sense different beasts, because <code>monoid_algebra</code> eats a ring and a monoid, and <code>add_monoid_algebra</code> eats a ring and an add_monoid. Problems with scalar actions might occur with one if the ring is the monoid and with the other if the ring is the add_monoid. In particular the two problems are not \"reflected\" by <code>to_additive</code>.</p>",
        "id": 274465074,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690707
    },
    {
        "content": "<p>I don't think we need to worry about <code>add_monoid_algebra k A</code> much here, since it's just <code>monoid_algebra k (multiplicative A)</code> so the same arguments apply</p>",
        "id": 274465283,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690800
    },
    {
        "content": "<p>OK so it really is true that there are two distinct actions of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>K</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">K^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 274465293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690806
    },
    {
        "content": "<p>So we just make the important one (the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span>) the instance</p>",
        "id": 274465367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690848
    },
    {
        "content": "<p>and then just use <code>of k * x</code> for the other one</p>",
        "id": 274465391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690864
    },
    {
        "content": "<p>The other action is the one that says <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> is a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>-algebra though, which is also important</p>",
        "id": 274465511,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690911
    },
    {
        "content": "<p>Sure, but that's the K-action not the K^*-action. Or does every R-action on a thing induce an R^*-action?</p>",
        "id": 274465571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690941
    },
    {
        "content": "<p>When this sort of thing happens in lectures, mathematicians just introduce two different notations for the two actions</p>",
        "id": 274465632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646690976
    },
    {
        "content": "<blockquote>\n<p>Or does every R-action on a thing induce an R^*-action?</p>\n</blockquote>\n<p>Yes (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/units.mul_action\">docs#units.mul_action</a>). This turns out to be useful, because it means we can turn every monoid action into a group action if we know we're working with the units</p>",
        "id": 274465634,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646690977
    },
    {
        "content": "<p>It can absolutely happen that X can act on Y in more than one way.</p>",
        "id": 274465723,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691006
    },
    {
        "content": "<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>",
        "id": 274465894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646691109
    },
    {
        "content": "<p>One way out of the problem is to just use <code>f : X →* perm Y</code> and <code>f x y</code> instead of <code>x • y</code></p>",
        "id": 274465952,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691125
    },
    {
        "content": "<p>Or even <code>f x • y</code> if you like your <code>•</code>s, since we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.apply_mul_action\">docs#equiv.perm.apply_mul_action</a></p>",
        "id": 274465999,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691160
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274465894\">said</a>:</p>\n<blockquote>\n<p>We can fix it in this case by defining G to be a group defeq to K^*. Then we have the G-action and the K^*-action and that's a nice fix. You can even make G irreducible the moment you did it, for safety.</p>\n</blockquote>\n<p>This would be more appealing if we could tell lean to emit an error if someone tries to work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> rather than giving them rope to hang themselves with</p>",
        "id": 274466114,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691240
    },
    {
        "content": "<p>That is, a means of blacklisting instances</p>",
        "id": 274466172,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646691254
    },
    {
        "content": "<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>",
        "id": 274472578,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646694659
    },
    {
        "content": "<p>Do people ever actually think about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> and/or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> in real life?</p>",
        "id": 274473440,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695205
    },
    {
        "content": "<p>I once wrote a paper in a scenario where this on this sort of thing, and I did use a type synonym. I had a Lie group G and was doing representation theory over the complex numbers. An example of the Lie group could have been <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">C</mi><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7713em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> but I called it <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mover accent=\"true\"><mi mathvariant=\"double-struck\">R</mi><mo stretchy=\"true\">‾</mo></mover><mo>×</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\overline{\\R}^\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0501em;\"></span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8889em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span><span style=\"top:-3.8089em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.0501em;\"><span style=\"top:-3.3418em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span></span></span></span> because the mathematics was telling me that it was a \"different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>\" to the one in the coefficient field.</p>",
        "id": 274473445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695210
    },
    {
        "content": "<p>Adam -- yes. Representation theory of real reductive groups.</p>",
        "id": 274473465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695225
    },
    {
        "content": "<p>Ah right</p>",
        "id": 274473475,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695236
    },
    {
        "content": "<p>But as I say, they're in some sense \"two different copies of the complex numbers\"; one of them is just an abstract algebraic closure of the reals (or at least it was in the paper of Langlands I was using).</p>",
        "id": 274473512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695268
    },
    {
        "content": "<p>I should say that Langlands didn't explicitly say this, it came out of me trying to make what was happening in the paper more functorial.</p>",
        "id": 274473535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646695305
    },
    {
        "content": "<p>But anyway I agree with you Kevin, the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> inside of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><mi>K</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">]</span></span></span></span> should really be thought of as different from the scalars</p>",
        "id": 274473544,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695313
    },
    {
        "content": "<p>The correct spelling of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msup><mi>K</mi><mo>×</mo></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[K^\\times]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0213em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7713em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">×</span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> should be <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo stretchy=\"false\">[</mo><msub><mi mathvariant=\"double-struck\">G</mi><mi>m</mi></msub><mo stretchy=\"false\">(</mo><mi>K</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">K[\\mathbb{G}_m(K)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathbb\">G</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">)]</span></span></span></span> anyway.</p>",
        "id": 274474089,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646695712
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274473465\">said</a>:</p>\n<blockquote>\n<p>Adam -- yes. Representation theory of real reductive groups.</p>\n</blockquote>\n<p>I'm surprised that the case I constructed to prove a point actually turns out to be a thing people care about</p>",
        "id": 274475980,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274472578\">said</a>:</p>\n<blockquote>\n<p>I am not convinced that this problem is any more real than the following situation. A user finds themselves in a situation where they really do want two group structures on a type. They go ahead with <code>[inst1 : group G] [inst2 : group G]</code> and then nothing works, and then we explain to them that they have to do <code>def H := G</code> and <code>[inst2 : group H]</code>.</p>\n</blockquote>\n<p>This seems like a reasonable argument to me as long as we're only talking about <code>K[G]</code> on groups and not monoids (which is why we probably need separate <code>group_algebra</code> and <code>monoid_algebra</code></p>",
        "id": 274476865,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646697615
    },
    {
        "content": "<p>I know that in Iwasawa theory people talk about the completion of the group ring <span class=\"tex-error\">$$\\Z_p{\\Z_p^\\times]$$</span> too. I would like to argue that this diamond is there independent of this whole group ring business. If we just have a group G and a field k acting on an object (which can happen independent of whether one has made the group ring) then the units of the field act on the object so if the units of the field happen to be the group then you have two actions and already this is a diamond in some sense. The fix here should be a type synonym eg <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><msub><mi>L</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">GL_1(R)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span> instead of <code>units R</code>. What I'm saying is that the monoid algebra definition is not creating any <em>new</em> diamonds, it's just bringing to the fore an issue which was already there because if we use typeclasses then we're only allowed one action of X on Y, just like we're only allowed one monoid structure on X (which is an action of X on X). So I propose we ignore this issue as I don't believe it will impede progress.  With this in mind do we still need this type synonym in the group algebra PR?</p>",
        "id": 274503456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722741
    },
    {
        "content": "<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>",
        "id": 274503631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646722872
    },
    {
        "content": "<p>I agree that this is probably just a diamond that we have to live with.</p>",
        "id": 274503842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723064
    },
    {
        "content": "<p>But it would be good to record it somewhere, so that we don't forget when it exists.</p>",
        "id": 274503866,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723096
    },
    {
        "content": "<p>It's because it's there in reality! The complex representation theory of real reductive groups really does give you two different actions of C^* on a vector space</p>",
        "id": 274503957,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646723171
    },
    {
        "content": "<p>Sure, but the question is how to deal with it later on. This could be via a type synonym for the group, or via specialized notation to distinguish the two actions. But we can figure that out when we get there.</p>",
        "id": 274504315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646723538
    },
    {
        "content": "<blockquote>\n<p>An easier way of seeing the problem might be that if we have the statement \"if G \\times H acts on X then we get induced actions of G and H on X\" then we have what you would call a diamond in the case where G=H and what I would call nothing to worry about</p>\n</blockquote>\n<p>This situation doesn't arise in mathlib though: we don't have instances that go in this direction, precisely because they would create diamonds. Instances build data for \"big\" types (like <code>G × H</code>) out of instances on the pieces, not vice versa.</p>",
        "id": 274505789,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725044
    },
    {
        "content": "<p>Does <code>G</code> act on <code>G \\times H</code>? I can imagine we would have an instance for that in mathlib.</p>",
        "id": 274506085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725258
    },
    {
        "content": "<p>Well then I claim we shouldn't have an induced action of <code>units K</code> on V given an action of K on V for the same reason</p>",
        "id": 274506139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725309
    },
    {
        "content": "<p>Because <code>units K</code> is obviously smaller than K (although the type theorists are going to argue that it's bigger)</p>",
        "id": 274506205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725349
    },
    {
        "content": "<p>Yes, I mean \"big\" in the type theory sense</p>",
        "id": 274506242,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> But if we have an action of <code>G</code> on <code>G \\times H</code>, and also an action of <code>H</code> on <code>G \\times H</code>, then we have a diamond. That's the same problem as we have with <code>monoid_algebra</code>.</p>",
        "id": 274506350,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725451
    },
    {
        "content": "<p>And the fix is not yet another type ascription, it's to just leave it alone and let people fix it if they run into it. Mathematicians will know if they're running into it, their Spidey senses go off if they have two actions of X on Y</p>",
        "id": 274506485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725563
    },
    {
        "content": "<p>We have no global instance for <code>has_scalar G (G × H)</code> though (unless G acts on H too, then it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar\">docs#prod.has_scalar</a>), nor would it be safe to add one</p>",
        "id": 274506493,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725570
    },
    {
        "content": "<p>Oh boo</p>",
        "id": 274506508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725581
    },
    {
        "content": "<p>How about bimodules? Do we have these yet?</p>",
        "id": 274506603,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725681
    },
    {
        "content": "<p>Over two different rings? Yes, <code>[module R M] [module Sᵐᵒᵖ M] [smul_comm_class R Sᵐᵒᵖ M]</code></p>",
        "id": 274506704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725801
    },
    {
        "content": "<p>Modules for group rings are a situation in real mathematics where two (generically) distinct objects act on the same side on an object. We have to support this and worry about \"what if the objects are the same\" later</p>",
        "id": 274506769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725851
    },
    {
        "content": "<p>Why don't we add an action of <code>G^mop</code> on <code>monoid_algebra K G</code>? Does that solve all our problems?</p>",
        "id": 274506782,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646725870
    },
    {
        "content": "<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there. But that doesn't mean that we can't develop a theory of bimodules. It just means we ignore the issue</p>",
        "id": 274506851,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646725923
    },
    {
        "content": "<blockquote>\n<p>Does that solve all our problems</p>\n</blockquote>\n<p>Not after <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> it doesn't, which adds the kᵐᵒᵖ action</p>",
        "id": 274506874,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646725940
    },
    {
        "content": "<blockquote>\n<p>Well what about bimodules where the the two rings are the same? We can't use Eric's suggestion there.</p>\n</blockquote>\n<p>Why can't we use the spelling above for bimodules over the same ring?</p>",
        "id": 274506961,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726040
    },
    {
        "content": "<p>Fair enough. But it will certainly make the problems very tiny.</p>",
        "id": 274507002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726049
    },
    {
        "content": "<p>If we're going to use this with a type synonym like <code>mul_opposite</code>, we could also solve it with a dedicated synonym</p>",
        "id": 274507045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726100
    },
    {
        "content": "<p><code>mul_opposite</code> would be natural: On <code>k[G]</code> there is an action of <code>k</code> on the left, and an action of <code>G</code> on the right.</p>",
        "id": 274507077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726145
    },
    {
        "content": "<p>Lean forces us to accept an action of <code>k</code> on the right. But maybe <em>that</em> shouldn't be a global instance.</p>",
        "id": 274507137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726183
    },
    {
        "content": "<p>I agree that algebras are bimodules, but should that be a <code>def</code> or an <code>instance</code>?</p>",
        "id": 274507152,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726206
    },
    {
        "content": "<p>It could <del>certainly</del> maybe be an instance only in a locale</p>",
        "id": 274507196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726249
    },
    {
        "content": "<p>Although if algebras must be bimodules (and therefore carry a right action), then the <code>algebra R (A →ₗ [R] A)</code> instance requires lean to find the right action on <code>A</code></p>",
        "id": 274507472,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726424
    },
    {
        "content": "<p>I could still be persuaded that <a href=\"https://github.com/leanprover-community/mathlib/pull/10716\">#10716</a> is a bad idea, but am like 80% sure we probably want it</p>",
        "id": 274507545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646726486
    },
    {
        "content": "<p>So how do you suggest we deal with the <code>G</code>-action on <code>k[G]</code>?</p>",
        "id": 274508053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726884
    },
    {
        "content": "<p>Just multiply with <code>of g</code>, where <code>of : G -&gt; k[G]</code>?</p>",
        "id": 274508072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646726903
    },
    {
        "content": "<p>In representation theory you absolutely want that action because it's the regular representation. Already you have this pathological \"what if G is syntactically k^*\" question</p>",
        "id": 274508210,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646727006
    },
    {
        "content": "<p>What's the downside of the <code>of g * x</code> approach? (Other than being less appealing visually)</p>",
        "id": 274509871,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728374
    },
    {
        "content": "<p>Presumably there are bits of the action API you want access to; do you know which bits?</p>",
        "id": 274510006,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646728465
    },
    {
        "content": "<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>",
        "id": 274510759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646728987
    },
    {
        "content": "<p>For me, you saying \"well perhaps we have to completely avoid making the action because of the extremely unlikely event that G is syntactically k^*\" is like you saying \"well I think we should stop using typeclasses for groups because of the extremely unlikely event that we want two distinct groups structures on a type\"</p>",
        "id": 274510900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646729068
    },
    {
        "content": "<p>To be clear, I'm begrudgingly ok with the action as long as it's on the <code>group_algebra</code> where it's less likely to cause harm than the <code>(add_) monoid_algebra</code></p>",
        "id": 274511444,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729436
    },
    {
        "content": "<p>But I'd also like to understand what actually changes in practice if we say \"let's not use • syntax for this action, let's just use a suitably bundled function\"</p>",
        "id": 274511507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>We want all of it I suspect, because one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>This can be phrased as how the <code>k[G]</code>-module <code>k[G]</code> over itself decomposes as sum of irreducibles.</p>",
        "id": 274511813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729718
    },
    {
        "content": "<p>Often, the action is also written as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>L</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">L_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>R</mi><mi>g</mi></msub><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">R_g a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9694em;vertical-align:-0.2861em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2861em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">a</span></span></span></span> if you want to act on the left or on the right. This could be easily mimicked by using a type synonym <code>foo G</code> for <code>G</code>, acting on whatever you want, and calling the identity map from <code>G</code> to <code>foo G</code> as <code>L</code>, and then writing <code>L g \\bu a</code> is totally non-ambiguous, diamond free, and close enough to common mathematical practice.</p>",
        "id": 274512020,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1646729867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>",
        "id": 274512203,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646729995
    },
    {
        "content": "<p>Another solution would be a pretty way of writing \"<code>g</code> viewed as element of <code>k[G]</code>\". I'm not sure a coercion will do. In maths, it is common to write <code>[g]</code>.</p>",
        "id": 274512205,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646729998
    },
    {
        "content": "<p>We discussed having the quotient brackets work for free constructions like that in another thread</p>",
        "id": 274512369,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730043
    },
    {
        "content": "<p>I think there was general agreement but no one volunteered to do the work</p>",
        "id": 274512400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274512203\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/274510759\">said</a>:</p>\n<blockquote>\n<p>one of the big theorems in representation theory of finite groups is how the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><mi>G</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[G]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">]</span></span></span></span> decomposes as a sum of irreducibles.</p>\n</blockquote>\n<p>What would a lean statement of that look like under your preferred spelling, so that we can compare other spellings?</p>\n</blockquote>\n<p>As Johan says, it should probably be a statement of the form \"The R-module R is R-isomorphic to a certain exterior direct sum\"</p>",
        "id": 274512414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730077
    },
    {
        "content": "<p>Where did R come from?</p>",
        "id": 274512446,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730108
    },
    {
        "content": "<p>It's k[G]</p>",
        "id": 274512510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730128
    },
    {
        "content": "<p>It doesn't sound like the lean statement even mentions a G action then?</p>",
        "id": 274512747,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646730295
    },
    {
        "content": "<p>The thing is that a k-linear G-action on a k-vector space is the same thing as a k[G]-action. We already have a good theory of module actions, so if we could get the group algebra merged somehow (and right now I'm really confused about whether it needs to be different from the module algebra) then the theory of G-modules could just be developed as a theory of k[G]-modules.</p>",
        "id": 274512898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> how about making <code>monoid_algebra</code> and <code>add_monoid_algebra</code> irreducible and not making <code>group_algebra</code> at all, and disregarding the issue that G could in theory syntactically be <code>units k</code> because mathematicians are only too well aware when they have two distinct actions of A on B and will know to take evasive action via a type synonym (which can be described to them in some docstring). Does this solve the problems which started this thread and the problems with <a href=\"https://github.com/leanprover-community/mathlib/pull/11574\">#11574</a>?</p>",
        "id": 274513365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730706
    },
    {
        "content": "<p>The examples which have been flagged before have had <code>G</code> definitionally <code>k^*</code> but not syntactically.</p>",
        "id": 274513478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1646730766
    },
    {
        "content": "<p>The main problem I had that started this thread was <code>monoid_algebra.of</code> simplifying to <code>finsupp.single</code> even though that's not really wanted. I suppose this wouldn't be the case anymore if <code>monoid_algebra</code> was made irreducible?</p>",
        "id": 274618062,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646779085
    },
    {
        "content": "<p>Making <code>monoid_algebra</code> irreducible is orthogonal to your issue</p>",
        "id": 274618820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779599
    },
    {
        "content": "<p>Removing the simp lemma is enough, but right now that creates more problems that it solves</p>",
        "id": 274618851,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779621
    },
    {
        "content": "<p>Because we can't choose <code>of</code> as the canonical spelling (right now) because it doesn't work on magma algebras</p>",
        "id": 274618919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779668
    },
    {
        "content": "<p>So until we introduce something better, the only suitable spelling right now is <code>finsupp.single</code>, even though that had the wrong type.</p>",
        "id": 274619026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1646779715
    },
    {
        "content": "<p>I see, so for now I guess I'll just make my problematic lemma use <code>of</code> but not make it a <code>simp</code> lemma</p>",
        "id": 274619862,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1646780239
    },
    {
        "content": "<p>Hi! I want to define the tensor product of two representations of a monoid <code>G</code> by <code>g • (v ⊗ₜ w) = (g • v) ⊗ₜ (g • w)</code>, but I noticed that there is already <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_has_scalar\">docs#tensor_product.left_has_scalar</a> which defines the action by letting <code>G</code> act only on the left factor. What are the reasons for this definition of an action on the left only, and is it possible to define the action I want on <code>V ⊗ W</code> without ambiguity with the other definition? Do I need to use a type synonym?</p>",
        "id": 279021918,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649970897
    },
    {
        "content": "<p>I suspect the action on the left is useful when you want to consider the base-change of an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> to some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, which is defined as the tensor product <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><msub><mo>⊗</mo><mi>A</mi></msub><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">B \\otimes_A M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 279022137,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1649971016
    },
    {
        "content": "<p>The action on the left is the obvious one when the action is by the field of the two vector spaces (and equal to the equivalent action on the right), which is why it's the default</p>",
        "id": 279024322,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972209
    },
    {
        "content": "<p>So I have to use a type synonym?</p>",
        "id": 279024399,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972273
    },
    {
        "content": "<p>If you want to use <code> •</code> notation and not something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.map\">docs#tensor_product.map</a>, yes</p>",
        "id": 279024627,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972406
    },
    {
        "content": "<p>I don't know whether it makes more sense to put the type synonym on the tensor type or the action type</p>",
        "id": 279024744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972474
    },
    {
        "content": "<p>You might be able to get away without the synonym... What would the typeclass requirements for such an action be?</p>",
        "id": 279024931,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024931\">said</a>:</p>\n<blockquote>\n<p>You might be able to get away without the synonym... What would the requirements for such an action be?</p>\n</blockquote>\n<p>Something like that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 279025054,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972675
    },
    {
        "content": "<p>Is that enough for <code>distrib_mul_action G (V ⊗[R] W)</code>?</p>",
        "id": 279025205,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649972784
    },
    {
        "content": "<p>I think it is, yes</p>",
        "id": 279025363,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649972891
    },
    {
        "content": "<p>Yeah, you definitely need a type synonym then</p>",
        "id": 279025548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973024
    },
    {
        "content": "<p>I would guess putting the type synonym on G works out better</p>",
        "id": 279025891,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1649973301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279025891\">said</a>:</p>\n<blockquote>\n<p>I would guess putting the type synonym on G works out better</p>\n</blockquote>\n<p>Why is that? Putting the type synonym on the tensor product seems more natural to me since otherwise we can't compare the tensor representation to other representations of <code>G</code>.</p>",
        "id": 279028773,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1649975026
    },
    {
        "content": "<p>Youch. Yes both the diagonal action for a tensor product group rep and the left action for base extension are pretty important :-/</p>",
        "id": 279038375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1649983229
    },
    {
        "content": "<p>shame our subscript options are so limited, or we could use  •_D and  •_L</p>",
        "id": 279043388,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989316
    },
    {
        "content": "<p>or the like</p>",
        "id": 279043389,
        "sender_full_name": "Robert Maxton",
        "timestamp": 1649989317
    },
    {
        "content": "<p>It's not really a matter of notation but a matter of API. If you start using <code>•_D</code> and <code>•_L</code>, then all the lemmas about <code>•</code> don't apply anymore.</p>",
        "id": 279054053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1650004755
    },
    {
        "content": "<p>Is this evidence that we should <em>not</em> define a G-representation over a field k as being definitionally a k[G]-module?</p>",
        "id": 279056734,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650007797
    },
    {
        "content": "<p>I thought <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/260880171\">we already decided</a> that <code>[module (monoid_algebra k G) X]</code> was definitely the wrong way to go anyway (and instead to go via the separate actions of <code>k</code> and <code>G</code>)</p>",
        "id": 279059055,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010168
    },
    {
        "content": "<p>Perhaps a type alias <code>representation</code> used as <code>representation G</code> solves most of the issues</p>",
        "id": 279059110,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650010206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/279024399\">said</a>:</p>\n<blockquote>\n<p>So I have to use a type synonym?</p>\n</blockquote>\n<p>Yes.</p>\n<p>I thought about this in some detail a while back and shared some details here: <a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a> which may or may not be useful.</p>",
        "id": 279068370,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650018517
    },
    {
        "content": "<p>I am  trying to implement the type synonym following <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>'s suggestions, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">G</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[derive [add_comm_monoid, module k]</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">tensor_rep</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">V</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">tensor_rep</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n<span class=\"kd\">notation</span> <span class=\"n\">v</span> <span class=\"bp\">`</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"bp\">`</span> <span class=\"n\">k</span> <span class=\"bp\">`</span><span class=\"o\">,</span><span class=\"bp\">`</span> <span class=\"n\">G</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">tensor_product.tmul</span> <span class=\"n\">k</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>The last line is problematic because I reference <code>V</code> and <code>W</code>. This shouldn't be a problem since I think there should be a way to infer <code>V</code> and <code>W</code> as the types of <code>v</code> and <code>w</code>. Is there a way to do that?</p>",
        "id": 279115715,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650051601
    },
    {
        "content": "<p>You should define a <code>to_rep</code> function that changes a tensor product to your type</p>",
        "id": 279115876,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051713
    },
    {
        "content": "<p>Like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/to_lex\">docs#to_lex</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual.to_dual\">docs#order_dual.to_dual</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/conj_act.to_conj_act\">docs#conj_act.to_conj_act</a>, etc</p>",
        "id": 279115940,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051743
    },
    {
        "content": "<p>Then use that definition in your notation</p>",
        "id": 279115978,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650051779
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 279117268,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650052634
    },
    {
        "content": "<p>Hi! After working for a bit on representation theory, I noticed that the approach I took to define <code>k</code>-linear representations of <code>G</code> on a vector space <code>V</code> as <code>distrib_mul_action G V</code> + <code>smul_comm_class G k V</code>causes a lot of issues due to ambiguity between different actions and potential diamonds. After some discussion with <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> , we came to the conclusion that it might be better to avoid entirely scalar multiplication when doing representation theory and stick with the definition <code>G →* (V →ₗ [k] V)</code>, writing <code>φ g v</code> everywhere we previously wrote <code>g • v</code>, where <code>φ </code> is the name of the representation (which is slightly less convenient, especially when  <code>φ </code> is actually a long name, but seems like the least worst solution).<br>\nBefore I start refactoring all I did so far, I was wondering what were the opinions of other people interested in representation theory in mathlib on this matter. Does anyone see downsides of this approach that we might have missed?</p>",
        "id": 279432277,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650385064
    },
    {
        "content": "<p>I think we should be able to obtain a situation similar to informal mathematics: when there is a single (or distinguished) action on a space then we can use the scalar multiplication notation. However when we are considering several actions simultaneously, and do not wish to distinguish any of them, (as happens quite a bit in representation theory) then we will be explicit and give the action a name.</p>",
        "id": 279433648,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385662
    },
    {
        "content": "<p>If you've been talking with Eric about this then it's very likely the approach you have in mind is sound.</p>",
        "id": 279433866,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650385746
    },
    {
        "content": "<p>To elaborate on that idea, the outline was something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">representation</span> <span class=\"o\">:=</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.trivial</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">representation.tprod</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">tensor_product.map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"n\">g</span><span class=\"o\">),</span> <span class=\"bp\">..</span><span class=\"gr\">sorry</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- I have no idea what a good name is</span>\n<span class=\"kd\">def</span> <span class=\"n\">representation.on_monoid_algebra</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoid_algebra</span> <span class=\"n\">k</span> <span class=\"n\">G</span> <span class=\"bp\">→+*</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- notation something like `rV →R rW` -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">representation_map</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">rW</span> <span class=\"o\">:</span> <span class=\"n\">representation</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">W</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_repr</span> <span class=\"o\">:</span> <span class=\"bp\">\\</span><span class=\"k\">forall</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">rV</span> <span class=\"n\">g</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">rW</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 279434138,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385845
    },
    {
        "content": "<p>My feeling generally was that this would generate less boilerplate than the equivalent approach with type synonyms</p>",
        "id": 279434321,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1650385923
    },
    {
        "content": "<p>I think we'll probably want both approaches eventually but I am certain that we'll want something similar to the above whatever we do.</p>",
        "id": 279435049,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1650386248
    },
    {
        "content": "<p>For what it's worth, I also much prefer this approach over using <code>has_scalar</code>, there are just too many scalar actions around in this context.</p>",
        "id": 279494087,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1650425003
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a></p>",
        "id": 279695863,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650554983
    },
    {
        "content": "<p>I've defined <code>Rep k G</code>, the category of (bundled) representations of <code>G</code> over <code>k</code>. It seems to be nicely compatible with the new design.</p>",
        "id": 280033231,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872637
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></p>",
        "id": 280033274,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872646
    },
    {
        "content": "<p>I was pleased to find that verifying it has (co)limits and a natural monoidal structure was very smooth!</p>",
        "id": 280033334,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872697
    },
    {
        "content": "<p>The PR doesn't include preparing the <code>preadditive</code> and <code>abelian</code> instances, but this shouldn't be too hard now.</p>",
        "id": 280033706,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650872921
    },
    {
        "content": "<p>Cool! Unfortunately you're hitting a timeout here: <a href=\"https://github.com/leanprover-community/mathlib/pull/13683/files\">https://github.com/leanprover-community/mathlib/pull/13683/files</a></p>",
        "id": 280033812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650872982
    },
    {
        "content": "<p>I'm still a bit sad that it looks like we can't use scalar multiplication in rep'n theory. But I guess that's life in lean, for now.</p>",
        "id": 280033990,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650873096
    },
    {
        "content": "<p>Fixed the timeouts.</p>",
        "id": 280035459,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650873860
    },
    {
        "content": "<p>Nice, that's definitely gonna be very useful! If we prove enough properties of this category we're gonna be able to use <code>category_theory.preadditive.schur</code>, which is great since I'll need Schur's lemma to get to the orthogonality of characters.</p>",
        "id": 280088170,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650901545
    },
    {
        "content": "<p>I've added PRs</p>\n<ul>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>: <code>Rep k G</code> is symmetric monoidal</li>\n<li><a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a>: <code>Rep k G</code> is abelian</li>\n</ul>",
        "id": 280089298,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650901995
    },
    {
        "content": "<p>I guess showing that it is a <code>k</code>-linear category should be done as well (easy?), and also that it is monoidal closed (not sure).</p>",
        "id": 280089393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650902037
    },
    {
        "content": "<p>For monoidal closed, I think the internal hom should be what I called <code>lin_hom</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13573\">#13573</a>, and I don't think it should be too hard to prove that it's adjoint to the tensor product.</p>",
        "id": 280093222,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1650903673
    },
    {
        "content": "<p>Another TODO:</p>\n<ul>\n<li>Equivalence with <code>Module k[G]</code>.</li>\n</ul>",
        "id": 280095000,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650904509
    },
    {
        "content": "<p>Another to-do: Tannakian?</p>",
        "id": 280144176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1650930043
    },
    {
        "content": "<p>I've never really dared to say it. But Tannaka duality would be a wonderful milestone.</p>",
        "id": 280162585,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1650950292
    },
    {
        "content": "<p>I did the equivalence with <code>Module k[G]</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>. (Still needs some linting, and one declaration is mysteriously incredibly slow; if anyone wants to have a look at <code>counit_iso</code> in <code>src/representation_theory/Rep.lean</code>?)</p>",
        "id": 280206399,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978244
    },
    {
        "content": "<p>This is a bit painful as we have to grapple with all the different actions and fight the typeclass system as we convert between them. But it seems to work out okay.</p>",
        "id": 280206464,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978273
    },
    {
        "content": "<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>",
        "id": 280206623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978350
    },
    {
        "content": "<p>More immediately important is to hook up the existing work on schur's lemma and maschke's theorem, and show <code>Rep k G</code> is semisimple when it is.</p>",
        "id": 280206726,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1650978380
    },
    {
        "content": "<p>I've added <code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, which acquires cheaply a rigid structure when <code>G</code> is a group.</p>",
        "id": 280332358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651056821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280206623\">said</a>:</p>\n<blockquote>\n<p>I think tannakian (just the fact that Rep G is tannakian, not tannakian duality itself) is probably pretty easy! We'll have the rigid structure soon, and I think we already know that the forgetful functor is monoidal and exact.</p>\n</blockquote>\n<p>Maybe we can actually get Tannaka <em>reconstruction</em> fairly quickly in the case of <em>finite groups</em>. After all, the general case requires algebraic groups, and I don't think we are anywhere near those.</p>",
        "id": 280333854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651057543
    },
    {
        "content": "<p>Here's a summary of the current stack of PR's on representation theory.</p>\n<ul>\n<li><code>Rep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a></li>\n<li><code>Rep k G</code> is symmetric monoidal in <a href=\"https://github.com/leanprover-community/mathlib/pull/13685\">#13685</a>, depending on a PR about braidings in <a href=\"https://github.com/leanprover-community/mathlib/pull/13684\">#13684</a></li>\n<li><code>Rep k G</code> is abelian in <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a></li>\n<li><code>fdRep k G</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13738\">#13738</a> which in turn depends on two PRs about rigid structures in <a href=\"https://github.com/leanprover-community/mathlib/pull/13736\">#13736</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>.</li>\n<li><code>Rep k G ≌ Module (monoid_algebra k G)</code> in <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a>, depending on refactoring PRs in <a href=\"https://github.com/leanprover-community/mathlib/pull/13760\">#13760</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a>.</li>\n</ul>",
        "id": 280580666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201005
    },
    {
        "content": "<p>In particular currently needing review are <a href=\"https://github.com/leanprover-community/mathlib/pull/13683\">#13683</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13684\">#13684</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13736\">#13736</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13707\">#13707</a>, and <a href=\"https://github.com/leanprover-community/mathlib/pull/13760\">#13760</a>. (<a href=\"https://github.com/leanprover-community/mathlib/pull/13759\">#13759</a> is back to me after a helpful review from Eric.)</p>",
        "id": 280580748,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651201101
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all those PRs. I finally had some time to look at them. They're great.</p>",
        "id": 280583593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1651204255
    },
    {
        "content": "<p>Added:</p>\n<ul>\n<li><code>Rep k G</code> is <code>k</code>-linear and <code>k</code>-linear monoidal, waiting on <a href=\"https://github.com/leanprover-community/mathlib/pull/13689\">#13689</a>.</li>\n</ul>",
        "id": 280594717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651216697
    },
    {
        "content": "<p>and</p>\n<ul>\n<li><code>FinVect k</code> has all finite limits, <a href=\"https://github.com/leanprover-community/mathlib/pull/13793\">#13793</a> depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13792\">#13792</a></li>\n</ul>",
        "id": 280636687,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651240860
    },
    {
        "content": "<p>I'm very satisfied by the last one. We've had Schur's lemma in mathlib for over a year, but stated in maximal generality: it holds for any linear category over an algebraically closed field, with finite dimensional hom spaces, and kernels.</p>\n<p>Finally, <code>fdRep k G</code> satisfies those hypotheses, so we can write:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Verify that Schur's lemma applies out of the box.</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">finrank_hom_simple_simple</span> <span class=\"o\">[</span><span class=\"n\">is_alg_closed</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">fdRep</span> <span class=\"n\">k</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">simple</span> <span class=\"n\">W</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">finrank</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">⟶</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"k\">if</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"bp\">≅</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"n\">category_theory.finrank_hom_simple_simple</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">W</span>\n</code></pre></div>",
        "id": 280640690,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242678
    },
    {
        "content": "<p>That's wonderful! I think we're not very far from the orthogonality of characters, though there's still some linear algebra missing.</p>",
        "id": 280641174,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651242946
    },
    {
        "content": "<p>Sometime over the weekend I'll hook up Maschke's theorem with the new setup.</p>",
        "id": 280641252,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651242970
    },
    {
        "content": "<p>After that, I think if I keep working on representation theory I might take an excursion into semisimple categories, and decompositions into simple objects.</p>",
        "id": 280641351,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651243028
    },
    {
        "content": "<p>For Schur's lemma applied to endomorphisms, there's a generalization due to Dixmier (and generalized further by <a href=\"https://www.ams.org/journals/proc/1969-021-01/S0002-9939-1969-0238892-4/home.html\">Quillen</a>) that if you have a simple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an algebra over an algebraically closed field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, if  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">End</mi><mo>⁡</mo></mrow><mi>A</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">\\operatorname{End}_A(M)\\cong k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">End</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. (If you drop \"algebraically closed\" then instead the conclusion is that endomorphisms are all algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>). For example, the space of endomorphisms of a countable-dimensional simple representation of a group over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is one-dimensional.</p>\n<p>If somebody were to try to formalize this, where would be a good place for it? (still src/category_theory/preadditive/schur.lean?) Potentially it would pull in things about transcendence degree.</p>",
        "id": 280650353,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651247144
    },
    {
        "content": "<blockquote>\n<p>For example, the space of endomorphisms of a countable-dimensional simple representation of a group over \\mathbb{C}C is one-dimensional.</p>\n</blockquote>\n<p>This result is used in the basic theory of smooth admissible representations of p-adic groups, which we will have all the ingredients for when we've figured out how to do continuous representations of topological groups.</p>",
        "id": 280678849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651261068
    },
    {
        "content": "<p>This would be great to have. If it pulls in transcendence degrees then just make a new file for it.</p>",
        "id": 280698947,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272730
    },
    {
        "content": "<p>Does the proof really use that it is an A-module? I've never looked at these generalisations. Schur's lemma is usually stated for modules, but in fact this is irrelevant for the version in mathlib.</p>",
        "id": 280699162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651272933
    },
    {
        "content": "<p>It seems like it's important that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module, but maybe there's some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>-linear category trick. There's a step where you give <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> the structure of a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> using the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure. You also need that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> to get its dimension.</p>\n<p>Here's the proof I know: Let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">f:M\\to M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-linear endomorphism. Suppose for sake of contradiction that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is not algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>. Then by Schur's lemma, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is an isomorphism since it's not zero.  We have that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a vector space over the field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> of rational functions, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> acting by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is nonzero we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow></msub><mi>M</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\dim_{k(t)}M\\geq 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0496em;vertical-align:-0.3552em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">t</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3552em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>, so <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>M</mi><mo>≥</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\dim_k M \\geq \\dim_k k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8444em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span>. Since <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mo stretchy=\"false\">(</mo><mi>t</mi><mo>−</mo><mi>c</mi><msup><mo stretchy=\"false\">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>∣</mo><mi>c</mi><mo>∈</mo><mi>k</mi><mo stretchy=\"false\">}</mo><mo>⊂</mo><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\{ (t-c)^{-1} \\mid c\\in k\\}\\subset k(t)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{(</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span></span></span></span> is a linearly independent set over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> (since, clearing denominators, a linear dependence would be that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">t</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6151em;\"></span><span class=\"mord mathnormal\">t</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>), we also have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mi>k</mi><mo stretchy=\"false\">(</mo><mi>t</mi><mo stretchy=\"false\">)</mo><mo>≥</mo><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">\\dim_k k(t) \\geq |k|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">t</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span></span></span></span>. But, we assumed that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mi>k</mi><mi mathvariant=\"normal\">∣</mi><mo>&gt;</mo><msub><mrow><mi>dim</mi><mo>⁡</mo></mrow><mi>k</mi></msub><mo stretchy=\"false\">(</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">|k|&gt;\\dim_k(M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\">dim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, so we have a contradiction, hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> is algebraic over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>.</p>\n<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is algebraically closed, then you use the minimal polynomial to get an eigenvalue for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and do the usual algebraically closed Schur's lemma proof.</p>",
        "id": 280703983,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651277282
    },
    {
        "content": "<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>",
        "id": 280709008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651282823
    },
    {
        "content": "<p>This this is the proof Taylor taught me :-) I thought the 1/(t-c) trick was brilliant.</p>",
        "id": 280714084,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1651290267
    },
    {
        "content": "<p>That same trick is also used for what I've seen referred to as a \"quick and dirty\" proof of the Nullstellensatz.  You can see the trick in the highest scoring answer <a href=\"https://mathoverflow.net/questions/15226/elementary-interesting-proofs-of-the-nullstellensatz\">here</a>.</p>",
        "id": 280716318,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1651293604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/280709008\">said</a>:</p>\n<blockquote>\n<p>That proof doesn't actually use the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> module structure, I think, just the fact that there is a faithful k-linear functor to k-Vect?</p>\n</blockquote>\n<p>Oh, yeah, that's all you need. I got confused and forgot <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> was just an endomorphism, so the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structure is not used. (If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> acts on the right, then I like to think of the morphisms as acting on the left since then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>x</mi><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">fxa</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">a</span></span></span></span> suggests the usual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">af(x)=f(ax)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span>.  The proof only uses the left action by the category and some things about dimension.)</p>\n<p>It's interesting how this is true no matter the faithful k-linear functor. Over an algebracially closed field, is it true that there's always one that sends simple modules to 1D vector spaces? I know that's true for semisimple algebras over an algebraically closed field.</p>",
        "id": 280744646,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651336872
    },
    {
        "content": "<p>Hi! I need to talk about equivalence of representations, and I was wondering if I should use for that the isomorphisms provided by the category <code>Rep k G</code> defined by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> or if I should define independently types <code>rep_hom</code> and <code>rep_equiv</code> which would extend <code>linear_map</code> and <code>linear_equiv</code>. I'm not very familiar with how category theory is used in mathlib, so I'd appreciate some advice on this.</p>",
        "id": 280875885,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651499480
    },
    {
        "content": "<p>We're potentially on new ground here... I'm tempted to suggest we try and proceed \"within\" the category theory API for now, and only bail out and define everything \"unbundled\" as necessary. But we will have to be careful trip interpret \"necessary\" liberally: the first sign of your theoretic troubles caused by using the category theory library should cause us to retreat.</p>",
        "id": 280941829,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529623
    },
    {
        "content": "<p>But this is only one opinion, and a biased one.</p>",
        "id": 280941856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529639
    },
    {
        "content": "<p>But I do like the idea of finally being able to stop defining the same basic ideas (isomorphism, etc), and using the polymorphic model provide by category theory. Worth a try, as an experiment?</p>",
        "id": 280941956,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529694
    },
    {
        "content": "<p>This all said, I think most of the future work on representation theory for a while should be developing the representation theory of (finite dimensional) algebras.</p>",
        "id": 280942100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529764
    },
    {
        "content": "<p>The main representations-of-groups specific fact is already there in <code>maschke.lean</code>, and most of what is needed to hook that up to decomposition into irreducibles and character theory is true more generally.</p>",
        "id": 280942201,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529847
    },
    {
        "content": "<p>I was thinking that perhaps we should just plough through Etingof's notes on representation theory. They are a bit nonlinear, but if we just do whatever subset is on the minimal path to his treatment of representations of finite groups I think we'd get a very pretty, and appropriately generalized, treatment.</p>",
        "id": 280942370,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651529953
    },
    {
        "content": "<p>This is actually why I wrote my \"simple implies indecomposable\" PR last night: it was the first statement I could find in his notes that we didn't have.</p>",
        "id": 280942479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651530013
    },
    {
        "content": "<p>So far I focused on group representations because my goal was to get orthogonality of characters. I'm not really aware of how character theory generalizes to finite-dimensional algebras, is there a more general version of orthogonality of characters for finite groups?</p>",
        "id": 280943437,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651530662
    },
    {
        "content": "<p>Something that comes to mind is finite-dimensional Hopf algebras. These have a one-dimensional space of \"integrals\" that you can use to generalize averaging-over-the-group arguments.  (Group algebras are Hopf algebras, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\sum_{g\\in G}g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.1858em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is an integral.) I'm pretty sure these are all you need to get that characters of non-isomorphic simple representations are orthogonal, where you define something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow></msub><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Δ</mi><mo stretchy=\"false\">(</mo><mo>∫</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V, W\\rangle = \\operatorname{tr}_{V\\otimes W^*}(\\Delta(\\int))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1111em;vertical-align:-0.3061em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span><span class=\"mbin mtight\">⊗</span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2083em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">Δ</span><span class=\"mopen\">(</span><span class=\"mop op-symbol small-op\" style=\"margin-right:0.19445em;position:relative;top:-0.0006em;\">∫</span><span class=\"mclose\">))</span></span></span></span> (the trace of the action of the comultiplication of the integral on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>⊗</mo><msup><mi>W</mi><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">V\\otimes W^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>). That can be rewritten in terms of characters for V and W.</p>\n<p>The way that formula expands for groups using the un-scaled integral is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>V</mi><mo separator=\"true\">,</mo><mi>W</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></msub><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>V</mi></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\langle V,W\\rangle = \\sum_{g\\in G} \\operatorname{tr}_V(g)\\operatorname{tr}_W(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2499em;vertical-align:-0.4358em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1786em;\"><span style=\"top:-2.4003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">g</span><span class=\"mrel mtight\">∈</span><span class=\"mord mathnormal mtight\">G</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4358em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, using the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><msup><mi>W</mi><mo>∗</mo></msup></msub><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub><mo stretchy=\"false\">(</mo><msup><mi>g</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_{W^*}(g)=\\operatorname{tr}_{W}(g^{-1})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6183em;\"><span style=\"top:-2.786em;margin-right:0.0714em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> (for Hopf algebras in general, the antipode can be used to put things in terms of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">tr</mi><mo>⁡</mo></mrow><mi>W</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\operatorname{tr}_W</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mop\"><span class=\"mop\"><span class=\"mord mathrm\">tr</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">W</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>)</p>",
        "id": 280945611,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651532149
    },
    {
        "content": "<p>even if we don't go via hopf algebras, while orthogonality of characters doesn't hold generally, there are interesting statements. e.g. Theorem 3.6.2 of <a href=\"https://klein.mit.edu/~etingof/repb.pdf\">https://klein.mit.edu/~etingof/repb.pdf</a></p>\n<blockquote>\n<p>(i) Characters of (distinct) irreducible finite dimensional representations of A are linearly independent.<br>\n(ii) If A is a finite dimensional semisimple algebra, then these characters form a basis of (A/[A, A])^∗</p>\n</blockquote>",
        "id": 280949933,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535577
    },
    {
        "content": "<p>But I guess for just checking orthogonality there's no point knowing anything about the relationship with characters of algebras.</p>",
        "id": 280950147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535773
    },
    {
        "content": "<p>But the facts the characters span, and determine the representation, come from more general facts, and ideally we would deduce these facts in the Rep G setting from the more general statements.</p>",
        "id": 280950171,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651535822
    },
    {
        "content": "<p>but don't hesitate to do whatever work on orthogonality you like</p>",
        "id": 280950406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536003
    },
    {
        "content": "<p>if we want to relate the characters you define for G and the characters for k[G], we can retrofit that later</p>",
        "id": 280950458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651536024
    },
    {
        "content": "<p>Anyway for now I've been mostly doing linear algebra and proving stuff about traces of linear maps, which will be useful both for algebras and for groups</p>",
        "id": 280950592,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536122
    },
    {
        "content": "<p>I forget -- do you need anything beyond semisimplicity to get that A/[A,A] is isomorphic to the center Z(A) as a vector space?</p>",
        "id": 280950644,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1651536143
    },
    {
        "content": "<p>But I'll try to get more familiar with the category theory API soon</p>",
        "id": 280950783,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651536244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> has open PRs defining several natural maps involving dual modules, contractions and traces (<a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR147-R157\">for example</a>), and I am wondering whether all this stuff (including definition of trace) should be rewritten in terms of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact_pairing\">docs#category_theory.exact_pairing</a>. I'm not suggesting to simply adopt the categorical formalism, but at least we would like to easily convert between both formalisms. And the current definition of trace (which landed in mathlib two years ago <a href=\"https://github.com/leanprover-community/mathlib/pull/3125\">#3125</a>) only works for finite free modules, but I think we eventually want it for finite projective modules as well, for K-theory or whatever, and <code>exact_pairing</code> probably offers us greatest generality. I'd appreciate comments from <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> on this.</p>",
        "id": 280956826,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542515
    },
    {
        "content": "<p>Yes, I hope this can be aligned as closely as possible, so that \"bundling\" statements up as statements about rigid categories is as trivial as possible.</p>",
        "id": 280956912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651542631
    },
    {
        "content": "<p>Is it true that <code>dual_tensor_hom R M N</code> is an equivalence whenever <code>M</code> is a finite projective module?</p>",
        "id": 280956947,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651542685
    },
    {
        "content": "<p>I believe so. (Here is a \"reference\": <a href=\"https://mathoverflow.net/a/156274/3332\">https://mathoverflow.net/a/156274/3332</a>)</p>",
        "id": 280957013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542756
    },
    {
        "content": "<p>It seems in the module case, you can derive all isomorphisms involving duals from <code>(module.dual R M) ⊗[R] M →ₗ[R] module.End R M</code> being an isomorphism, which seems a simpler statement than exact_pairing. Is there some advanced theory that I can look into?</p>",
        "id": 280957056,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651542839
    },
    {
        "content": "<p>Can you derive the more general <code>(module.dual R M) ⊗[R] N →ₗ[R] (M →ₗ[R] N)</code> from this?</p>",
        "id": 280957224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543049
    },
    {
        "content": "<p>It's pretty easy to define <code>Mᵛ → M → (M → N) → Mᵛ ⊗ N</code> which <code>lift</code> to <code>Mᵛ ⊗ M → (M → N) → Mᵛ ⊗ N</code>, and if you have the canonical element in <code>Mᵛ ⊗ M</code> that corresponds to <code>1 : End M</code> then you get <code>(M → N) → Mᵛ ⊗ N</code>. (I'm using <code>ᵛ</code> to denote the dual; I think this is a common notation but forget where I saw it; Wikipedia uses <code>*</code>.)</p>",
        "id": 280957542,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651543352
    },
    {
        "content": "<p>I see, that's nice!</p>",
        "id": 280958372,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651543991
    },
    {
        "content": "<p>The check notation is particularly nice for duals once you reach dagger categories and start interacting with operator algebras. At that point <code>*</code> is so massively overloaded that no one is allowed to use it. :-)</p>",
        "id": 280958856,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651544440
    },
    {
        "content": "<p>It seems that the following are all equivalent:<br>\n(1) The identity is in the image of the natural map <code>Mᵛ ⊗ M → End M</code>.<br>\n(2) <code>M</code> is a <a href=\"https://en.wikipedia.org/wiki/Rigid_category\">rigid object</a> in the category of <code>R</code>-modules, with <code>M</code> and <code>Mᵛ</code> forming an exact_pairing ((1) is basically one of the \"triangle\" identities saying <code>M → M</code> is id, and the other one follows (the proof invokes extensionality, showing that two linear functionals agree on every element of <code>M</code>, and doesn't seem to follow from axioms of symmetric closed monoidal categories)).<br>\n(3) The natural map <code>Mᵛ ⊗ M → End M</code> is an isomorphism (with inverse given by the construction <code>(M → N) → Mᵛ ⊗ N</code> above (also on the Wikipedia page)).<br>\n(4) <code>M</code> is a finite projective module (finiteness is trivial; projectivity follows from <a href=\"https://en.wikipedia.org/wiki/Projective_module#Dual_basis\">https://en.wikipedia.org/wiki/Projective_module#Dual_basis</a>, <a href=\"https://math.stackexchange.com/a/22403/12932\">proof</a>).</p>\n<p>So we can just work with finite projective modules for maximal generality.<br>\nNotice that <code>M → Mᵛᵛ</code> being an isomorphism (<code>M</code> reflexive) is strictly weaker, as <code>M</code> doesn't have to be finite or projective (e.g. the direct sum of countably many Z).</p>\n<p>One may be tempted to construct all natural maps involving tensor and Hom and prove identities between them using the axioms of symmetric closed monoidal categories and rigid objects, but that's likely cumbersome (though a ramped up <code>coherence</code> tactic might help); simply using extensionality would be easier: if the identity doesn't involve the inverse of <code>Mᵛ ⊗ M → End M</code> it's probably <code>rfl</code>, but I think we need to figure out a better (and uniform) way to do <a href=\"https://github.com/leanprover-community/mathlib/pull/13728/files#diff-ec1bbf49e36abe03e05ca365b4000aafad3eb62309460fe6525297e4c208e63dR159\">proofs like this</a> where the inverse is involved.</p>",
        "id": 281160272,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1651673286
    },
    {
        "content": "<p>In the categorical language, when the inverse is involved can't we just use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_iso.inv_comp_eq\">docs#category_theory.is_iso.inv_comp_eq</a> to get rid of the inverse, just as I used <code>linear_map.cancel_right</code> when doing these kinds of proofs in the linear algebra language?</p>",
        "id": 281218942,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1651698120
    },
    {
        "content": "<p>Could I just ping on a few PRs on the <a href=\"https://bit.ly/3zVLgqR\">#queue</a>: <a href=\"https://github.com/leanprover-community/mathlib/pull/13713\">#13713</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13870\">#13870</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13908\">#13908</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13967\">#13967</a> <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> (and hopefully <a href=\"https://github.com/leanprover-community/mathlib/pull/13740\">#13740</a>, it's just linting now after a merge conflict)?</p>",
        "id": 281507930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1651882820
    },
    {
        "content": "<p>I started trying to work with <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> 's <code>Rep k G</code> category, and one issue I noticed is that it assumes that <code>k</code> is a ring (due to <code>Module k</code> assuming a ring), while so far I've tried to only assume <code>semiring</code> when possible. Is there any reason why <code>Module k</code> isn't defined for semirings?</p>",
        "id": 281620148,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652046881
    },
    {
        "content": "<p>I don't know if there's really any interesting case in which we have a semiring which is not a ring, but if there are some things that we can state in this generality I guess that it's better to do so?</p>",
        "id": 281620224,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652047019
    },
    {
        "content": "<p>Probably this can be generalized. I suspect that at the time Module was defined the library was less generalized than it is now. If you'd like to have a go at this please do, otherwise I can try soon.</p>",
        "id": 281622233,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050290
    },
    {
        "content": "<p>And yes, I think it's good if results are stated as generally as possible. It seems to pay off later in a mathlib style library. :-) Also often it's helpful for understanding proofs when the hypotheses are as weak as possible --- fewer misleading clues about wrong directions you might take!</p>",
        "id": 281622306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652050396
    },
    {
        "content": "<p>I tried quickly to check what happens what happens if I replace <code>ring</code> by <code>semiring</code> in <code>Module</code>, and the problem is that we also need to replace <code>add_comm_group</code> by <code>add_comm_monoid</code> for the underlying abelian group of the module, which causes some problems for example in <code>has_forget_to_AddCommGroup</code> since <code>M</code> doesn't have an <code>add_comm_group</code> instance anymore.</p>",
        "id": 281627211,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652057971
    },
    {
        "content": "<p>There's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.add_comm_monoid_to_add_comm_group\">docs#module.add_comm_monoid_to_add_comm_group</a> but it's a def and not an instance so I'm not sure how to use it.</p>",
        "id": 281627327,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652058055
    },
    {
        "content": "<p>Okay, I spent a while on this, and I think it is sadly impossible.</p>",
        "id": 281632116,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064483
    },
    {
        "content": "<p>I can get <code>Module/basic.lean</code> to compile, but only be constructing dubious instances, which later break everything.</p>",
        "id": 281632149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064521
    },
    {
        "content": "<p>Hm, that's unfortunate...</p>",
        "id": 281632163,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652064552
    },
    {
        "content": "<p>I'd been worried that we would need a different <code>Module</code> to handle modules over <code>k</code>-algebras, but so far I can get away with just the one.</p>",
        "id": 281632281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064713
    },
    {
        "content": "<p>But this seems worse.</p>",
        "id": 281632284,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064717
    },
    {
        "content": "<p>What did you want to do over semirings? Maybe looking at a concrete statement will lead to inspiration. :-)</p>",
        "id": 281632377,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652064810
    },
    {
        "content": "<p>As an example, I was thinking of restating <a href=\"https://leanprover-community.github.io/mathlib_docs/find/representation.lin_hom\">docs#representation.lin_hom</a> in the category theory language using <code>Rep k G</code>. Currently this definition works for semirings, but <code>Rep k G</code> requires a ring.</p>",
        "id": 281632572,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652065069
    },
    {
        "content": "<p>I see. It would be nice to construct the closed monoidal instance on <code>Rep k G</code>.</p>",
        "id": 281635261,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068292
    },
    {
        "content": "<p>I propose that for now we just proceed with the restriction that <code>k</code> is a ring in <code>Rep k G</code>...</p>",
        "id": 281635265,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068310
    },
    {
        "content": "<p>I don't think I've ever met someone who does representation theory over semirings.</p>",
        "id": 281635321,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652068345
    },
    {
        "content": "<p>Fair enough</p>",
        "id": 281635593,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1652068709
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13845\">#13845</a>, <a href=\"https://github.com/leanprover-community/mathlib/pull/13933\">#13933</a> would like some review, and are on the \"representation theory queue\", if anyone reading here would like to take a look. :-)</p>",
        "id": 282393704,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597477
    },
    {
        "content": "<p>I'm hoping that soon I will have the equivalence of \"is a sum of simple objects\" and \"every subobject is complemented\" in any preadditive category (with a few bits and pieces), and after that the density theorem (the map <code>A ⟶ End V</code> is surjective for any irreducible f.d. representation V of a <code>k</code>-algebra A).</p>",
        "id": 282393819,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1652597651
    },
    {
        "content": "<p>I  see that we have a <code>right_rigid_category</code> instance for <code>fdRep k G</code>, but we don't have <code>left_rigid_category</code>. This is very annoying since we need the left version in order to get the <code>monoidal_closed</code> structure (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/monoidal_closed_of_left_rigid_category\">docs#monoidal_closed_of_left_rigid_category</a>). <br>\nI looked at <code>FinVect</code> and noticed that here also we weirdly only have the right rigid structure but not the left one. Is there any reason for that?  If I want to access the monoidal structure of <code>fdRep k G</code>, should I go back to <code>FinVect</code> and add the left rigid structure there, or is it available in another way that I am missing?</p>",
        "id": 283176767,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653143901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 283176870,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144034
    },
    {
        "content": "<p>I think no good reason this is missing. Maybe it would be nice to show that if you're braided one implies the other?</p>",
        "id": 283176887,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144089
    },
    {
        "content": "<p>Or just do it directly for FinVect.</p>",
        "id": 283176888,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144100
    },
    {
        "content": "<p>The PR that did this was just plugging together immediately available pieces.</p>",
        "id": 283176934,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653144141
    },
    {
        "content": "<p>I don't think we even have that <code>FinVect</code> is braided so for now I think the second option is simpler.</p>",
        "id": 283177291,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653144629
    },
    {
        "content": "<p>Though proving braiding for <code>FinVect</code> shouldn't be too hard. The natural way to do it would be to prove it more generally for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.monoidal_category.full_monoidal_subcategory\">docs#category_theory.monoidal_category.full_monoidal_subcategory</a>. By the way, is there a reason why this is not an instance?</p>",
        "id": 283178197,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653145772
    },
    {
        "content": "<p>Ok, so trying to prove that <code>FinVect</code> is symmetric, I figured I should probably use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.braided_category_of_fully_faithful\">docs#category_theory.braided_category_of_fully_faithful</a>, but for that I need a monoidal version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.full_subcategory_inclusion\">docs#category_theory.full_subcategory_inclusion</a>. How do I get lean to figure out the monoidal structure on <code>{X : C // P X}</code> here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">full_monoidal_subcategory_inclusion</span>\n  <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h_id</span> <span class=\"o\">:</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"n\">_</span> <span class=\"n\">C</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h_tensor</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⊗</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">monoidal_functor</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">//</span> <span class=\"n\">P</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 283179780,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653147933
    },
    {
        "content": "<p>I think the best approach here will be to introduce <code>monoidal_subcategory P  h_id h_tensor</code> as a synonym for <code>{X : C // P X}</code> and put a monoidal_category instance on that.</p>",
        "id": 283208421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191120
    },
    {
        "content": "<p>Perhaps even add <code>monoidal_predicate</code> which bundles together <code>P</code>, <code>h_id</code> and <code>h_tensor</code>.</p>",
        "id": 283208428,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191156
    },
    {
        "content": "<p>Does that make sense / seem plausible?</p>",
        "id": 283208487,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653191177
    },
    {
        "content": "<p>Sounds good, done in <a href=\"https://github.com/leanprover-community/mathlib/pull/14311\">#14311</a>. Let me know what you think.</p>",
        "id": 283247112,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653247068
    },
    {
        "content": "<p>Left a few comments. Mostly looks promising, thanks for doing this!</p>",
        "id": 283256290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653260036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What are your thoughts on <a href=\"https://github.com/leanprover-community/mathlib/pull/14311#discussion_r878940321\">that comment</a>?</p>",
        "id": 283320796,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1653313554
    },
    {
        "content": "<p>Yes, this looks good.</p>",
        "id": 283697414,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653367947
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>",
        "id": 286095492,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1655222718
    },
    {
        "content": "<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>",
        "id": 307566451,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406691
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 307566748,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"329754\">Antoine Labelle</span> <a href=\"#narrow/stream/116395-maths/topic/Representation.20Theory/near/286095492\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (depending on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>) is all I'm missing to PR a proof of the orthogonality of characters for finite groups. It has been open for a while, so it would be great if it could get merged soonish! If left some comment on <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>.</p>\n</blockquote>\n<p>(I am also a new user, so maybe I'm doing something wrong, but I think this commit is not in my local copy yet...)</p>",
        "id": 307566857,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667406793
    },
    {
        "content": "<p>All those commits are on a branch (<a href=\"https://github.com/leanprover-community/mathlib/tree/orthogonality\">branch#orthogonality</a>) which is not yet merged into master so your local version of master won't have them yet.</p>",
        "id": 307567981,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407101
    },
    {
        "content": "<p>It looks like the first thing that needs to happen to get the ball rolling on these again is to fix the merge conflicts in <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> with master</p>",
        "id": 307568538,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667407271
    },
    {
        "content": "<p>I just tried to fix <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a> lets see if the other branches also work now</p>",
        "id": 307579089,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667410150
    },
    {
        "content": "<p>Ok and I've merged branch 'semorrison/fdRep-linear' into semorrison/fdRep-schur and it looks like it builds ok, so <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> will hopefully turn green after a while and be ready for review when the first PR is merged</p>",
        "id": 307585217,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1667411915
    },
    {
        "content": "<blockquote>\n<p>Are there any status updates on this? I had started to work on similar things (Schur orthogonality etc), but I don't want to duplicate efforts, and it seems like most of it has been done already.</p>\n</blockquote>\n<p>Yes, we basically have orthgonality of characters modulo the merging of these old PRs. We don't have yet that the characters span the class functions though, that would be a next natural step.</p>",
        "id": 307625238,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426292
    },
    {
        "content": "<p>Or incorporating this in a more general setting of representations of algebras.</p>",
        "id": 307625365,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667426358
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"127136\">@Alex J. Best</span> for fixing <a href=\"https://github.com/leanprover-community/mathlib/pull/13789\">#13789</a>. It's merged now, and I've just updated <a href=\"https://github.com/leanprover-community/mathlib/pull/13794\">#13794</a> (Schur's lemma applies to fdRep) and it looks good. Hopefully someone can approve it shortly.</p>",
        "id": 307650969,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1667445678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329754\">@Antoine Labelle</span> Oh great! Should I pick it up somewhere, or are you rolling with these representations?</p>",
        "id": 307730132,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482709
    },
    {
        "content": "<p>(Our local Lean workshop is working towards Burnside's p^aq^b theorem, so there are many other parts that I could start working on.)</p>",
        "id": 307730213,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482736
    },
    {
        "content": "<p>But I love thinking about general finite dimensional representation theory too, so I'm more than happy to dive in here as well.</p>",
        "id": 307730476,
        "sender_full_name": "Remy van Dobben de Bruyn",
        "timestamp": 1667482807
    },
    {
        "content": "<p>I haven't worked on that for a few months, so feel free to start working on any result that we don't currently have.</p>",
        "id": 307730711,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482886
    },
    {
        "content": "<p>Let me know if you have any questions on the current API.</p>",
        "id": 307731021,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667482977
    },
    {
        "content": "<p>I've updated <a href=\"https://github.com/leanprover-community/mathlib/pull/16043\">#16043</a>, it's now ready to be reviewed.</p>",
        "id": 307818092,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1667502388
    }
]
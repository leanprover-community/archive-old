[
    {
        "content": "<p>As is well-known and almost always ignored in graduate textbooks and courses in anything involving homological algebra, a distinction between small and large categories has to be made in set theory. This is due to the fact that the set of all sets can not be formed due to Russel paradox.<br>\nHowever, Lean is not based on set theory, but rather in a version of type theory I do not yet understand very well. But it seems like a type of all types which are not its own members does not make sense in Lean. Does no Russel paradox mean it is ok to form the category of all types?<br>\nSo I want to understand two things:<br>\na) Where can I find a list of type theory axioms which Lean uses, preferably summarized in a mathematician’s notation.<br>\nb) Where can I find a summary of what difficulties in standard smallness-sensitive category-theoretic constructions (Freyd adjoint functor theorem, localization of categories, enough injectives in abelian categories, etc) disappear in type theory, and what are some new difficulties? A concrete example — how to define a derived category of R-mod not yet in Lean, but in Lean’s type theory informally? Are large Hom-sets allowed? Does a theorem that these Hom-sets are actually small makes any sense?</p>",
        "id": 235457996,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618983181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407114\">@Stepan Nesterov</span> Everything has a type. The type of the natural numbers <code>nat</code> is called <code>Type</code>. This thing <code>Type</code> is the type of all types. And mathlib knows that it is a \"large\" category. But since everything has a type, <code>Type</code> also needs to have a type. In some systems, <code>Type</code> is it's own type, which leads to Russell-like paradoxes. In Lean <code>Type</code> the type turns out to be <code>Type 1</code>. And <code>Type 1</code> has type <code>Type 2</code>. Etc...</p>",
        "id": 235459348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618984512
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Does it have any kind of a 'reduction axiom' as Russell was trying to have in the 1900's? Let's say, if we can prove that a 'Type 1' is a countable 'Type 1', then can it be regarded as a 'Type'?</p>",
        "id": 235459577,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618984721
    },
    {
        "content": "<p>Nope, not really. You can try to define an equivalence (aka isomorphism, aka bijection) between <code>X : Type 1</code> and <code>Y : Type</code>, and for countable types that will always be possible.</p>",
        "id": 235459658,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618984802
    },
    {
        "content": "<p>But in general it's tricky to downsize your universe.</p>",
        "id": 235459720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618984828
    },
    {
        "content": "<p>Bumping up is easy: there's a function <code>ulift : Type u -&gt; Type (max u v)</code></p>",
        "id": 235459751,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618984850
    },
    {
        "content": "<p>And do all the definitions in Lean have 'Type 1' counterpart? Say, a Gromov-Hausdorff space (<a href=\"https://en.wikipedia.org/wiki/Gromov%E2%80%93Hausdorff_convergence\">https://en.wikipedia.org/wiki/Gromov%E2%80%93Hausdorff_convergence</a>) is a metric space whose points are isomorphism classes of compact metric spaces. A correct statement in Lean is than 'Gromov-Hausdorff space is a 'Metric Space 1' which is non-canonically isomorphic to a 'Metric Space'', is that right?</p>",
        "id": 235460041,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618985077
    },
    {
        "content": "<p>Yes, almost everything in mathlib is \"universe polymorphic\"</p>",
        "id": 235460279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985262
    },
    {
        "content": "<p>Note that mathlib knows about your example: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Gromov_Hausdorff.GH_space\">docs#Gromov_Hausdorff.GH_space</a></p>",
        "id": 235460373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985328
    },
    {
        "content": "<p>But metric spaces (and almost all other definitions) are defined using a <code>universe variable u</code>, so that they make sense in <code>Type u</code> for arbitrary <code>u</code>.</p>",
        "id": 235460403,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985373
    },
    {
        "content": "<p>I type #check Gromov_Hausdorff.GH_space and it says Type though.<br>\nWhile you just explained it should be Type 1. I'm confused</p>",
        "id": 235460683,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618985605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235460403\">said</a>:</p>\n<blockquote>\n<p>But metric spaces (and almost all other definitions) are defined using a <code>universe variable u</code>, so that they make sense in <code>Type u</code> for arbitrary <code>u</code>.</p>\n</blockquote>\n<p>Is u here a natural number? Or is there a Type \\omega and more?</p>",
        "id": 235460771,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618985678
    },
    {
        "content": "<p>It's not a natural number as in <code>nat</code>, but you can only construct them using <code>zero</code>, <code>succ</code>, and <code>max</code>.</p>",
        "id": 235460897,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985824
    },
    {
        "content": "<p>So effectively there's countably many universes.</p>",
        "id": 235460914,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985848
    },
    {
        "content": "<p>You cannot quantify explicitly over <code>u</code>.</p>",
        "id": 235460936,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985868
    },
    {
        "content": "<p>I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Gromov_Hausdorff.isometry_rel.setoid\">docs#Gromov_Hausdorff.isometry_rel.setoid</a> explains why this particular example is in <code>Type</code>. It's not defined (in mathlib) exactly in the way you described.</p>",
        "id": 235461036,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985959
    },
    {
        "content": "<p>So maybe <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cardinal\">docs#cardinal</a> is a better example.</p>",
        "id": 235461054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618985997
    },
    {
        "content": "<p>Yes, Gromov-Hausdorff space is defined as a space of all subspaces of l^{\\infty}(\\R), and than it is a theorem that every compact metric space so arises.</p>",
        "id": 235461336,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618986199
    },
    {
        "content": "<p>Is there a list of axioms anywhere in mathlib docs, so that I can see full list of which consructions are possible? I can't find one in there.</p>",
        "id": 235461489,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618986295
    },
    {
        "content": "<p>What exactly do you mean by axioms? Things like how to construct new types from existing ones? Those are usually not called axioms, afaik.</p>",
        "id": 235461616,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618986389
    },
    {
        "content": "<p>I mean, in ZFC we have Axiom of Union, Axion of Comprehension, Axiom of Powerset, etc</p>",
        "id": 235461672,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618986447
    },
    {
        "content": "<p>What is Lean's analogue for that?</p>",
        "id": 235461691,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618986472
    },
    {
        "content": "<p>I don't know ZFC, but your questions are probably answered in Mario's thesis. (searching link for you)</p>",
        "id": 235461755,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618986508
    },
    {
        "content": "<p><a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>",
        "id": 235461789,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618986545
    },
    {
        "content": "<p>Looks like it, thanks!</p>",
        "id": 235461908,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618986629
    },
    {
        "content": "<p>It is possible to resize types both up and down. The general mechanism for resizing up is <code>ulift</code>, so for example if you need a copy of the real numbers in a big universe you can use <code>ulift real</code></p>",
        "id": 235465339,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618988989
    },
    {
        "content": "<p>To resize down, you have to know some kind of smallness property of the type. For example if the type is countable, then by definition that means it is isomorphic to a subset of nat, and that subset lives in <code>Type</code></p>",
        "id": 235465428,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618989034
    },
    {
        "content": "<p>We also have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/small/src\">src#small</a>, for working with types that you know are \"smaller\" than the universe that the typechecker knows they inhabit.</p>",
        "id": 235465474,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618989083
    },
    {
        "content": "<p>Also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.essentially_small/src\">src#category_theory.essentially_small</a>, for the corresponding categorical idea.</p>",
        "id": 235465496,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618989109
    },
    {
        "content": "<p>If you want to think in terms of set theory, lean is fairly well approximated by thinking of it as ZFC + countably many inaccessible cardinals. The types <code>Type</code>, <code>Type 1</code>, <code>Type 2</code> correspond to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><msub><mi>κ</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\kappa_i}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">κ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>κ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\kappa_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">κ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the i'th inaccessible</p>",
        "id": 235465652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618989234
    },
    {
        "content": "<p>In particular, <code>Type</code> can be used to construct a model of ZFC, <code>Type 1</code> can be used to construct a model of ZFC with one inaccessible, and so on</p>",
        "id": 235465745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618989296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235465652\">said</a>:</p>\n<blockquote>\n<p>If you want to think in terms of set theory, lean is fairly well approximated by thinking of it as ZFC + countably many inaccessible cardinals. The types <code>Type</code>, <code>Type 1</code>, <code>Type 2</code> correspond to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>V</mi><msub><mi>κ</mi><mi>i</mi></msub></msub></mrow><annotation encoding=\"application/x-tex\">V_{\\kappa_i}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.93343em;vertical-align:-0.2501em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139199999999997em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">κ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3280857142857143em;\"><span style=\"top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.143em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2501em;\"><span></span></span></span></span></span></span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>κ</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\kappa_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">κ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the i'th inaccessible</p>\n</blockquote>\n<p>So in particular, Axiom of Replacement is provable/has an analogue in Lean?<br>\nHow do I define \\aleph_\\omega?</p>",
        "id": 235466211,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618989660
    },
    {
        "content": "<p>Another problem with set theory-based category theory is that the embeddings V_k into V are not necessary elementary. Can we prove an analogue of reflection principle for Type u universes in Lean?</p>",
        "id": 235466446,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618989810
    },
    {
        "content": "<p>The axiom schema of replacement is a set-theoretic concept really. Lean's dependent type theory is equiconsistent with ZFC + infinitely many inaccessibles in the sense that we can build a model of ZFC + inaccessibles in Lean, and conversely in ZFC one can build sets which correspond to Lean's dependent types. This doesn't mean however that there is some direct translation between the axioms of ZFC and what is happening in Lean.</p>",
        "id": 235471107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618992660
    },
    {
        "content": "<p>Any function in Lean has a well-defined domain and codomain. The axiom of replacement talks about this more general concept of a mapping or whatever you want to call it; such a concept does not really exist in Lean's type theory.</p>",
        "id": 235471261,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618992732
    },
    {
        "content": "<p>Lean's maths library does have a model of ZFC in it, and within that model you can define stuff like its aleph_omega.</p>",
        "id": 235471588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618992913
    },
    {
        "content": "<p>Here's a more math way of reformulating the Replacement issue: does Lean prove that the category of all types has all (small) limits and colimits?</p>",
        "id": 235471849,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618993069
    },
    {
        "content": "<p>Yup, that's in mathlib</p>",
        "id": 235471914,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618993095
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/limits/types.html#category_theory.limits.types.sort.category_theory.limits.has_limits\">https://leanprover-community.github.io/mathlib_docs/category_theory/limits/types.html#category_theory.limits.types.sort.category_theory.limits.has_limits</a></p>",
        "id": 235472249,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618993279
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 235472325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993318
    },
    {
        "content": "<p>We should have a <code>:wat:</code> emoji</p>",
        "id": 235472447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618993358
    },
    {
        "content": "<p>Gah, somehow the name is not what it should be, so it's hard to link to in the documentation.</p>",
        "id": 235472472,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618993376
    },
    {
        "content": "<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>\nAssume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \\times Y) = Hom(Z,X) \\times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>\nIs this just as much pain in Lean as it is in set theory?</p>",
        "id": 235472498,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618993394
    },
    {
        "content": "<p>I <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span> instance names</p>",
        "id": 235472520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472498\">said</a>:</p>\n<blockquote>\n<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>\nAssume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \\times Y) = Hom(Z,X) \\times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>\nIs this just as much pain in Lean as it is in set theory?</p>\n</blockquote>\n<p>Yes. But it doesn't happen in \"real math\" so it hasn't really bitten us yet.</p>",
        "id": 235472645,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993458
    },
    {
        "content": "<p>Also, that's not actually \"the definition\" of having products. :-)</p>",
        "id": 235472694,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618993483
    },
    {
        "content": "<p>Of course as a lemma one has that equivalence (not equality :-).</p>",
        "id": 235472762,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618993515
    },
    {
        "content": "<p>We do run into universe problems sometimes when trying to be uber-general (e.g. if we're proving theorems about two modules over a ring, the mathlib style is to have the ring in universe u, one module in universe v and the other in universe w, and then maybe the tensor product of them will be in universe max(u,v,w)). If universes get out of hand then we tend to roll back and start putting things in the same universe. But in the kind of maths which is happening in mathlib, if you just restrict everything to one universe then this in practice solves all your universe problems.</p>",
        "id": 235472905,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472645\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407114\">Stepan Nesterov</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235472498\">said</a>:</p>\n<blockquote>\n<p>And here's a math explanation of the problem with embeddings of V_k -&gt; V:<br>\nAssume that we have proved that the category of all schemes inside Type has products. By definition, that means that for a small scheme Z one has Hom(Z,X \\times Y) = Hom(Z,X) \\times Hom(Z,Y). But what if we changed our mind and at some point needed a scheme in Type 1 or Type 2? Then for such a large scheme Z the universal property has no reason to hold.<br>\nIs this just as much pain in Lean as it is in set theory?</p>\n</blockquote>\n<p>Yes. But it doesn't happen in \"real math\" so it hasn't really bitten us yet.</p>\n</blockquote>\n<p>I learned some etale cohomology recently and I believe that it present an example of such a 'real-math' universe juggling.<br>\nLet X be a scheme in Type. Then its etale site is Type 1, and therefore so is any etale sheaf and any of its injective resolution. Therefore the etale cohomology of X are a priori abelian groups in Type 1 until we prove otherwise in the cases we deem interesting.</p>",
        "id": 235473199,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618993783
    },
    {
        "content": "<p>Yes that's absolutely right.</p>",
        "id": 235473283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993812
    },
    {
        "content": "<p>But I understand that etale cohomology is not coming to Lean anytime soon sadly :(</p>",
        "id": 235473286,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618993814
    },
    {
        "content": "<p>That's not right!</p>",
        "id": 235473308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993823
    },
    {
        "content": "<p>I thought we didn't even have that the category of affine schemes is antiequivalent to commutative rings</p>",
        "id": 235473361,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618993868
    },
    {
        "content": "<p>It's on the horizon, like lots of other things, and indeed we will have to deal with your issue, either by doing the kind of thing de Jong does, or by not caring.</p>",
        "id": 235473370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993872
    },
    {
        "content": "<p>The only reason schemes are stagnating right now is that nobody is working hard on them because all of the algebraic geometers and category people and number theorists have been sucked into this Scholze formalisation project going on in <a class=\"stream\" data-stream-id=\"267928\" href=\"/#narrow/stream/267928-condensed-mathematics\">#condensed mathematics</a></p>",
        "id": 235473449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618993919
    },
    {
        "content": "<p>What is happening in practice is that those of us who care about these things have decided that getting homological algebra off the ground is a more important project, and here we run into a type theory issue which probably does not exist in set theory (although I'm not sure about this, I've never formalised mathematics in set theory).</p>",
        "id": 235473670,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994014
    },
    {
        "content": "<p>As you can imagine, a solid homological algebra base is going to be necessary before we embark on a serious cohomology theory project. It is possible to get around it, e.g. I have had an MSc student formalising group cohomology, but they stopped before they proved the long exact sequence (they just defined <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(G,M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> and proved they were functorial).</p>",
        "id": 235473870,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994110
    },
    {
        "content": "<p>There's no reason etale cohomology can't be in mathlib a year after condensed sets are done. :-)</p>",
        "id": 235473954,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618994160
    },
    {
        "content": "<p>The problem we run into when formalising is that if we have abelian groups <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_i\\to A_{i+1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> then we have maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{i-1}\\to A_{(i-1)+1}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.03853em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span>, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">(i-1)+1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> is equal, but not definitionally equal, to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>, which means that although there are canonical maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_{(i-1)+1}\\to A_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.03853em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and the other way, these are not in some sense \"the identity function\", and this causes an added layer of confusion which we're still learning how to tame.</p>",
        "id": 235474071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994208
    },
    {
        "content": "<p>(Or just a year from now if we keep finding new people at this rate. Or 6 months if someone is especially keen.)</p>",
        "id": 235474079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618994215
    },
    {
        "content": "<p>(...I better get back to the <code>homology2</code> branch. I got bored for a few days.)</p>",
        "id": 235474136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618994242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Small.20and.20large.20categories.20in.20Type.20Theory/near/235473449\">said</a>:</p>\n<blockquote>\n<p>The only reason schemes are stagnating right now is that nobody is working hard on them because all of the algebraic geometers and category people and number theorists have been sucked into this Scholze formalisation project going on in <a class=\"stream\" data-stream-id=\"267928\" href=\"/#narrow/stream/267928-condensed-mathematics\">#condensed mathematics</a></p>\n</blockquote>\n<p>Okay, makes sense, will check this out.<br>\nI'd love to join some work on schemes after I play with some easy theorems and get the hang of it, hopefully soon :)</p>",
        "id": 235474155,
        "sender_full_name": "Stepan Nesterov",
        "timestamp": 1618994255
    },
    {
        "content": "<p>Right -- group cohomology was sufficiently \"easy\" to do that an MSc student with no Lean experience at all could formalise the objects (which involved doing a lot of combinatorics with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^2=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> etc) in 9 months whilst working on his other masters courses.</p>",
        "id": 235474242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994290
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407114\">@Stepan Nesterov</span> you might also be interested in the \"Schemes in Isabelle/HOL\" thread in this #maths stream. In particular <a href=\"#narrow/stream/116395-maths/topic/Schemes.20in.20Isabelle.2FHOL/near/235395589\">there is some recent activity</a> due to Justus Springer.</p>",
        "id": 235474330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618994347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> has recently been doing some great work improving our existing material on sheaf theory. Johan and I wrote much of the first version of this that made it into mathlib, and it wasn't uniformly lovely. <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> has then done sheaves on sites, but we haven't unified the two developments yet. :-(</p>",
        "id": 235474385,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1618994389
    }
]
[
    {
        "content": "<p>We've been working on Galois theory, and it would be nice to have a notion of isomorphic field extensions. If <code>E/F</code> is a field extension (i.e., <code>[field F] [field E] [algebra F E]</code>) and if <code>E'/F'</code> is another field extension, then an isomorphism of field extensions might consist of two ring isomorphisms <code>a : E → E'</code> and <code>b : F → F'</code> such that <code>a(f • e) = b(f) • a(e)</code>. Is this a reasonable definition to make, and if so, where should it go in mathlib?</p>\n<p>If this does end up in mathlib, then the next thing to do would be to prove that various things are preserved by it (i.e., integral elements, minimal polynomials, separable extensions, normal extensions, galois extensions, dimension, findim, etc...)</p>",
        "id": 215381928,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604352740
    },
    {
        "content": "<p>also, it might not be necessary for the definition to require F and E to be fields</p>",
        "id": 215382036,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604352791
    },
    {
        "content": "<p>the reason why we want such a definition is that the usual notion of an algebra isomorphism doesn't work when the base field changes. For example, if you know something about the extension E/(bot : intermediate_field F E) and want to conclude the same thing about E/F</p>",
        "id": 215382389,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604352981
    },
    {
        "content": "<p>Could one split this into two simpler \"transport\" problems -- if you have <code>algebra F E</code> and an F-algebra F' then by tensoring you get <code>algebra F' (E \\otimes_F F')</code>, and if F' is isomorphic to F you can port stuff along that construction. And then you can restrict to a constant base and talk about F-algebra isomorphisms E -&gt; E' and transport stuff along that. Maybe it's easier to approach in two steps like that? Not sure though.</p>",
        "id": 215383246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604353432
    },
    {
        "content": "<p>There was some discussion about semilinear algebra recently. Whatever happened with that? This could be an extension of that.</p>",
        "id": 215383382,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1604353488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215383246\">said</a>:</p>\n<blockquote>\n<p>Could one split this into two simpler \"transport\" problems -- if you have <code>algebra F E</code> and an F-algebra F' then by tensoring you get <code>algebra F' (E \\otimes_F F')</code>, and if F' is isomorphic to F you can port stuff along that construction. And then you can restrict to a constant base and talk about F-algebra isomorphisms E -&gt; E' and transport stuff along that. Maybe it's easier to approach in two steps like that? Not sure though.</p>\n</blockquote>\n<p>What if you don't automatically know that <code>F'</code> is an <code>F</code>-algebra?</p>",
        "id": 215383969,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604353784
    },
    {
        "content": "<p>for example, F and F'=(bot : intermediate_field F E). F' is an F-algebra, but thinking of F as an F'-algebra is a little weird.</p>",
        "id": 215384206,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604353902
    },
    {
        "content": "<p>Actually, it is true that so far we only need to change either <code>F</code> or <code>E</code> and not both at once. But I think there are two advantages to formalizing a transformation of field extensions <code>F/E -&gt; F'/E'</code>. First, it is possible that at some point we will need to change both the base field and the extension for isomorphic copies at the same time; you could imagine needing to know that <code>top/bot</code> (as intermediate fields of <code>E/F</code>) is the same as <code>E/F</code> or something. Second, when proving that things like separability or normality are preserved by isomorphism, it seems simpler to prove it a single time for this more general notion of isomorphism than to prove it both for isomorphism of the base field and isomorphism of the extension</p>",
        "id": 215384350,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604353968
    },
    {
        "content": "<p>But you could make the <code>equiv</code> surely? And then push along some noncomputable map or whatever, but the theorems won't care about computability.</p>",
        "id": 215384369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604353983
    },
    {
        "content": "<p>One argument for biting the bullet and changing both at once is that one could imagine later on wanting to replace a short exact sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0\\to A\\to B\\to C\\to 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> by an isomorphic one <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>B</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>C</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0\\to A' \\to B' \\to C' \\to 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> and here it seems tricky to change them one at a time.</p>",
        "id": 215384450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215384369\">said</a>:</p>\n<blockquote>\n<p>But you could make the <code>equiv</code> surely? And then push along some noncomputable map or whatever, but the theorems won't care about computability.</p>\n</blockquote>\n<p>Are you replying to Thomas here? I think it's true that this would work for the specific case of <code>E/bot</code> being isomorphic to <code>E/F</code>. But in more general situations it might be annoying</p>",
        "id": 215384518,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604354058
    },
    {
        "content": "<p>Actually, why isn't there already a notion of changing the base ring of an algebra? This doesn't seem super specific to fields</p>",
        "id": 215384557,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604354084
    },
    {
        "content": "<p>Changing the base ring of an algebra will surely be done using tensor product, right?</p>",
        "id": 215384590,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354104
    },
    {
        "content": "<p>Well, I guess it depends on how you're changing it :-)</p>",
        "id": 215384610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354114
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215384590\">said</a>:</p>\n<blockquote>\n<p>Changing the base ring of an algebra will surely be done using tensor product, right?</p>\n</blockquote>\n<p>Yeah, I guess so. I guess in the case of fields it's easier because you can only have isomorphism or embeddings</p>",
        "id": 215384741,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604354179
    },
    {
        "content": "<p>Aah. How about this? There should be some way of switching between <code>algebra F E</code> and <code>F : subring E</code>. You have the same E, so perhaps for your use case you want to think about subrings of E rather than extensions of F</p>",
        "id": 215384751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354183
    },
    {
        "content": "<p>I guess in our case we actually only care about things isomorphic to <code>F</code></p>",
        "id": 215384832,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604354227
    },
    {
        "content": "<p>in your case you'll be able to prove they're the same subring</p>",
        "id": 215384886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354257
    },
    {
        "content": "<p>You're running into a similar sort of issue which we ran into when doing the Artin-Tate Lemma in commutative algebra. We have this mental model where everything is easy, but when you translate it down into type theory it is suddenly more complicated than you want it to be. \"Consider three rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> becomes this nightmare of <code>A : subring B</code>, <code>A : subring C</code>, <code>B : subring C</code>, <code>algebra A B</code>, <code>algebra A C</code> and <code>algebra B C</code>, six different ideas which are all compatible in some way which becomes completely transparent from the set-theoretic perspective. After months of haitus, Kenny Lau came up with <code>is_scalar_tower</code> which seems to work (it works for the Artin-Tate Lemma at least). Does it help you? You could get a tower from F to bot to E.</p>",
        "id": 215385312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354463
    },
    {
        "content": "<p>We've used is_scalar_tower a bit. For instance, with separable extensions we proved lemmas that the top and bottom of an is_scalar_tower are also separable. With normal however, you don't in general know that the bottom of an is_scalar_tower is also normal.</p>",
        "id": 215385681,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604354662
    },
    {
        "content": "<p>so in the example of showing that (E/bot is normal) iff (E/F is normal), I don't think that is_scalar_tower helps</p>",
        "id": 215385732,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604354705
    },
    {
        "content": "<p>This is a good test question!</p>",
        "id": 215385781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354732
    },
    {
        "content": "<p>E/F normal implies E/bot normal shouldn't be too hard. But the other way is interesting.</p>",
        "id": 215385968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604354855
    },
    {
        "content": "<p>Oh but there are bundled subfields. Doesn't this help a lot in your use case? You should be able to prove that the subfields F and bot of E are equal, and then hopefully pass normal between them.</p>",
        "id": 215386332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355005
    },
    {
        "content": "<p>F isn't a subfield of E though</p>",
        "id": 215386415,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355079
    },
    {
        "content": "<p>F is just a field, and E is just a field which happens to be an F-algebra</p>",
        "id": 215386456,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355107
    },
    {
        "content": "<p>Right, but E is an F-algebra so presumably there's a construction which makes a subfield</p>",
        "id": 215386465,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355112
    },
    {
        "content": "<p>that would be (bot : intermediate_field)</p>",
        "id": 215386520,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355130
    },
    {
        "content": "<p>at least, that's what we've been using to turn F into a subfield of E</p>",
        "id": 215386551,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355155
    },
    {
        "content": "<p>I don't know what <code>intermediate_field</code> is. I'm talking about making a term of type <code>subfield E</code> from <code>algebra F E</code>. This shouldn't be too hard.</p>",
        "id": 215386601,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355194
    },
    {
        "content": "<p>(and might be there already)</p>",
        "id": 215386615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355201
    },
    {
        "content": "<p>One option is to put a field structure on <code>set.range (algebra_map F E)</code> (this is what we did a while ago, but it's painful). Now I would use <code>(bot : intermediate_field F E).to_subfield</code></p>",
        "id": 215386744,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355300
    },
    {
        "content": "<p>and I'm suggesting that one could prove that this is the subfield which one could build directly as the image of the algebra map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>.</p>",
        "id": 215386880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355392
    },
    {
        "content": "<p>(without using intermediate_field)</p>",
        "id": 215386898,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355414
    },
    {
        "content": "<p>So what does your <code>normal</code> predicate eat right now?</p>",
        "id": 215386935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355447
    },
    {
        "content": "<p><code>[field F] [field E] [algebra F E]</code></p>",
        "id": 215386956,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355464
    },
    {
        "content": "<p>(that's what the field_theory folder uses for field extensions)</p>",
        "id": 215387020,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355489
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215386880\">said</a>:</p>\n<blockquote>\n<p>and I'm suggesting that one could prove that this is the subfield which one could build directly as the image of the algebra map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>.</p>\n</blockquote>\n<p>You still have to do the hard work of transporting normality (for instance) across the algebra map from F to its image in E</p>",
        "id": 215387108,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355558
    },
    {
        "content": "<p>So now we could define a second <code>normal'</code> predicate on <code>subfield E</code>, by saying that if <code>A : subfield E</code> then <code>normal' A</code> is true iff the corresponding <code>algebra \\u A E</code> was normal</p>",
        "id": 215387109,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355558
    },
    {
        "content": "<p>I see, and then the issue is that you start with F then make the subfield and then make a new type and it's perhaps not equal to F</p>",
        "id": 215387199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355608
    },
    {
        "content": "<p>yes</p>",
        "id": 215387207,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604355617
    },
    {
        "content": "<p>you start with some abstract type F equipped with a map to E and end up with a subtype of E corresponding to the image of the map. And set theorists can't tell the difference.</p>",
        "id": 215387390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355742
    },
    {
        "content": "<p>So one needs to somehow push the entire problem over to <code>subfield E</code>. I want to argue that <code>algebra F E</code> is normal iff <code>F' : subfield E</code> is <code>normal'</code> iff <code>algebra \\u bot E</code> is normal. This is what you have to do to talk about E/bot being normal, right? You have to promote bot to some type (a subtype) and make E a bot-algebra? Is this what you mean when you talk about E/bot being normal?</p>",
        "id": 215387738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604355951
    },
    {
        "content": "<p>yeah, when I say <code>normal bot E</code>, there's secretly an algebra structure <code>algebra bot E</code></p>",
        "id": 215387947,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356051
    },
    {
        "content": "<p>(and bot is being promoted from a term to a type)</p>",
        "id": 215387979,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356071
    },
    {
        "content": "<p>in general, if <code>K : intermediate_field F E</code> then there is an algebra structure <code>algebra F K</code> and <code>algebra K E</code></p>",
        "id": 215387984,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356076
    },
    {
        "content": "<p>What's the definition of normal?</p>",
        "id": 215388064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356118
    },
    {
        "content": "<p>It seems to me that this could be made to work if you knew normal iff splitting field, which presumably you guys did a while ago</p>",
        "id": 215388156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356193
    },
    {
        "content": "<p>something about minimal_polynomials, I think. But the point isn't to prove this specific thing about normality being preserved. There are also other cases where we want to transport some property along isomorphic field extensions, which is why I was thinking that some more general framework would be helpful.</p>",
        "id": 215388321,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356284
    },
    {
        "content": "<p>I want to define K : subfield E to be <code>normal'</code> iff <code>algebra \\uK E</code> is normal. Now one wants to prove that if algebra F E then this is normal iff the corresponding \"F\" : subfield E is normal, and one could do this by checking that the \"same\" polynomials worked.</p>",
        "id": 215388436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356337
    },
    {
        "content": "<p>Making some new structure saying that E/F and E'/F' are isomorphic isn't going to solve any problems though, right? You'll still have to go through the proof I'm outlining above (or find another one)</p>",
        "id": 215388492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356385
    },
    {
        "content": "<p>because you can't just pass mathematical predicates along isomorphisms.</p>",
        "id": 215388525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356399
    },
    {
        "content": "<p>yes, we'll have to do basically that proof</p>",
        "id": 215388530,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356401
    },
    {
        "content": "<p>but it's a question of how to state it</p>",
        "id": 215388549,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356413
    },
    {
        "content": "<p>I see</p>",
        "id": 215388558,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356419
    },
    {
        "content": "<p>it seems nicer to have a general statement that certain properties are preserved by isomorphism and then to prove that various isomorphisms exist than to prove for each instance that we care about that those properties are preserved</p>",
        "id": 215388653,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604356477
    },
    {
        "content": "<p>even if right now we don't really need the greater generality</p>",
        "id": 215388668,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604356487
    },
    {
        "content": "<p>but what I'm suggesting is that if one makes a new structure which captures the idea of \"F/E and F'/E' are isomorphic\" then that structure itself doesn't solve any problems, in fact in some sense it opens up a big class of problems each of which needs to be solved individually.</p>",
        "id": 215388741,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356540
    },
    {
        "content": "<p>you'll have to prove that for each instance you care about the properties are preserved anyway</p>",
        "id": 215388807,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356570
    },
    {
        "content": "<p>and the proof that normality is preserved is going to be harder in this setting because you'll have to control the top field as well as the bottom one</p>",
        "id": 215388847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356611
    },
    {
        "content": "<p>That's true, but it seems better to me to have this work all done in one place (for each property that is preserved). Get it over and done with.</p>",
        "id": 215388968,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356690
    },
    {
        "content": "<p>I agree with kevin that two isomorphisms are harder than one</p>",
        "id": 215389191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604356848
    },
    {
        "content": "<p>what applications would this be put to?</p>",
        "id": 215389270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604356905
    },
    {
        "content": "<p>right now, the main thing is transporting various properties between E/F and E/(bot : intermediate_field) and (top : intermediate_field)/F</p>",
        "id": 215389355,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604356949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you were saying the other day that this transfer/transport/whatever it's called tactic has never really been a well-defined problem. But instances do pop up. Here is one. If we have ring homomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">a:F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>:</mo><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">a':F' \\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> which are isomorphic in the sense that there are isomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">F\\to F'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">E\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> making the square commute, then there are a ton of mathematical predicates which one can put on ring homomorphisms (being finite type, module finite, integral, etc) and with extra assumptions (e.g. everything is a field) then there are even more (being normal, separable, Galois...). At the minute, transferring every predicate across involves some pain, and there are a fair few predicates that show up in Galois theory.</p>",
        "id": 215389370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356957
    },
    {
        "content": "<p>But one also has to think carefully about whether if there was some way of passing mathematical predicates along isomorphisms, whether it would actually solve the problem at hend.</p>",
        "id": 215389421,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604356999
    },
    {
        "content": "<p>I agree that all of these theorems should exist, but I don't think they will be used particularly often</p>",
        "id": 215389437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357019
    },
    {
        "content": "<p>We have ring equivs, we have noetherian rings, therefore we should have the theorem that says they cohere</p>",
        "id": 215389518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357057
    },
    {
        "content": "<p>Actually, this sort of thing about properties that \"obviously\" carry across isomorphisms seems to come up all the time in formalization and be a big pain. Why can't this be automated? There is already a decent mathematical way to capture many instances of this: first order definable properties of models in a language transfer across isomorphisms of models in that language. Why can't proof assistants do this automatically? Like if I define a new type of structure I should automatically get the right notion of isomorphism and any property stated in a first order way should automatically transfer over isomorphisms</p>",
        "id": 215389586,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604357136
    },
    {
        "content": "<p>It can't be automated until it is done manually</p>",
        "id": 215389600,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357154
    },
    {
        "content": "<p>I'm not totally sure what you mean. I agree that right now Lean does not even have the infrastructure to do this sort of thing, but why not?</p>",
        "id": 215389699,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604357214
    },
    {
        "content": "<p>It has plenty of infrastructure to support this in principle. The problem is that we don't know what the result should actually be</p>",
        "id": 215389742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357257
    },
    {
        "content": "<p>so it needs to first be done by hand enough times to make the pattern clear</p>",
        "id": 215389761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357277
    },
    {
        "content": "<p>I see what you mean now</p>",
        "id": 215389813,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604357286
    },
    {
        "content": "<p>I have heard people argue for this for a long time but no one is putting in the legwork to write out isomorphism theorems manually</p>",
        "id": 215389845,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357311
    },
    {
        "content": "<p>I guess the basic model theory result seems like it captures many instances of this pattern but not all, and I'm not sure how it should be actually implemented in a usable way in a proof assistant</p>",
        "id": 215389904,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604357357
    },
    {
        "content": "<p>in any case, the proofs are all fairly simple, we may find out that it's not even worth the work of automating because the theorems themselves are all that we needed</p>",
        "id": 215389975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604357399
    },
    {
        "content": "<p>i've been looking for good target problems to try out <code>rewrite_search</code> or similar automatic tactics on and i'm curious what people would want automation to do here - is there some set of theorems that you would like to write out the statements and then have the automation automatically find a proof? or does the automation need to be generating the theorems themselves?</p>",
        "id": 215390299,
        "sender_full_name": "Kevin Lacker",
        "timestamp": 1604357592
    },
    {
        "content": "<p>There is some progress towards automation of this by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  at <a href=\"#narrow/stream/116395-maths/topic/definition.20of.20integrally.20closed/near/199303207\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/definition.20of.20integrally.20closed/near/199303207</a></p>",
        "id": 215390406,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1604357672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238605\">Kevin Lacker</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215390299\">said</a>:</p>\n<blockquote>\n<p>i've been looking for good target problems to try out <code>rewrite_search</code> or similar automatic tactics on and i'm curious what people would want automation to do here - is there some set of theorems that you would like to write out the statements and then have the automation automatically find a proof? or does the automation need to be generating the theorems themselves?</p>\n</blockquote>\n<p>Either way would be helpful I guess. In my ideal world, once I know that two things are isomorphic, any time one of them appears in a certain type of expression, I can simply replace it with the other one. But even something that can just automatically fill in proofs would be nice</p>",
        "id": 215390596,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604357866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215388807\">said</a>:</p>\n<blockquote>\n<p>you'll have to prove that for each instance you care about the properties are preserved anyway</p>\n</blockquote>\n<p>So we do need some theorems stating that certain properties are preserved. The question is: In the case of field extensions, what's the right way to state changing the base field?</p>",
        "id": 215390774,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358000
    },
    {
        "content": "<p>One option that Kevin might be hinting at is to have theorems relating things to subfield E</p>",
        "id": 215390908,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358069
    },
    {
        "content": "<p>i.e., that properties are preserved when passing to subfield E</p>",
        "id": 215390932,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358089
    },
    {
        "content": "<p>and then if the subfields agree, then obviously the property is preserved</p>",
        "id": 215390953,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358103
    },
    {
        "content": "<p>So two options so far are:<br>\n(a) prove theorems that properties are preserved when dealing with isomorphic F-algebras (so that you can change the top), and theorems that properties are preserved when passing to <code>subfield E</code> (so that you can change the bottom).<br>\n(b) define a general notion of field extension isomorphism (as described at the top of the thread) and prove that properties are preserved by such an isomorphism.<br>\nAny others?</p>",
        "id": 215391534,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358500
    },
    {
        "content": "<p>I should note that this doesn't require any grand planning. Theorems about preservation under isomorphisms or homomorphisms or surjective homs or subfield extensions are often specific to the context. State it using the language idiomatic to that part of the library, and don't worry about putting all these isomorphism theorems under one banner</p>",
        "id": 215391853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604358724
    },
    {
        "content": "<p>Just thinking about it a bit more (whilst cleaning the kitchen) I realise that transferring a property of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>:</mo><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">a:F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> over to a property of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>:</mo><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">a' : F' \\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> still feels like a two step process. We have isomorphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>:</mo><mi>F</mi><mo>→</mo><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">i:F\\to F'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>:</mo><mi>E</mi><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">j:E\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> making a commutative square, but now to move from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">a'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> it feels like the natural way to go is via <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>a</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>∘</mo><mi>i</mi><mo>:</mo><mi>F</mi><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">a'\\circ i:F\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, thus splitting up the transfer problem into two simpler transfer problems of moving from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">F\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">F\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>E</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">F'\\to E'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> (here using the inverse of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>).</p>",
        "id": 215392037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604358851
    },
    {
        "content": "<p>Can't you also transfer <code>a:F-&gt;E</code> to <code>a:F ~= F'</code> where <code>F' : subfield E</code>?</p>",
        "id": 215392086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604358900
    },
    {
        "content": "<p>If you have a set-sized class of all subfields, you can transfer structure that way</p>",
        "id": 215392148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604358946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Isomorphism.20of.20Field.20Extensions/near/215392086\">said</a>:</p>\n<blockquote>\n<p>Can't you also transfer <code>a:F-&gt;E</code> to <code>a:F ~= F'</code> where <code>F' : subfield E</code>?</p>\n</blockquote>\n<p>Isn't this option (a) above?</p>",
        "id": 215392220,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604358981
    },
    {
        "content": "<p>Yes, this is somehow what I was thinking about earlier: because in this situation all maps are injective (any field homomorphism is injective) every field map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo>→</mo><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">F\\to E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> is isomorphic to one where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span></span></span></span> is a subfield of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>.</p>",
        "id": 215392238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604358996
    },
    {
        "content": "<p>One slight issue with the subfield approach is that it isn't the most general. Properties like separable and normal are stated in greater generality than just fields (although maybe you could replace subfields with subrings?)</p>",
        "id": 215392286,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1604359054
    },
    {
        "content": "<p>right, one could imagine working in some appropriate generality which will change depending on what predicate is being transferred.</p>",
        "id": 215392347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1604359088
    },
    {
        "content": "<p>it's a boon if the collection of F such that E/F is set-sized though</p>",
        "id": 215392384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604359135
    },
    {
        "content": "<p>at least up to isomorphism</p>",
        "id": 215392400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604359146
    },
    {
        "content": "<p>Why is that useful?</p>",
        "id": 215392423,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604359170
    },
    {
        "content": "<p>It means you can construct universal objects more easily</p>",
        "id": 215392437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604359189
    },
    {
        "content": "<p>I don't know if I can give a specific example off hand though</p>",
        "id": 215392500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604359220
    },
    {
        "content": "<p>I see. But that doesn't seem to say which way we should solve this particular problem since in either case, there is still a set-sized collection with a representative from every isomorphism class</p>",
        "id": 215392513,
        "sender_full_name": "Patrick Lutz",
        "timestamp": 1604359231
    },
    {
        "content": "<p>sure, but we have regular isos for that</p>",
        "id": 215392525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1604359251
    }
]
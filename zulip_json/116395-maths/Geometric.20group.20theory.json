[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"466209\">@Georgi Kocharyan</span>, <span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span>, <span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span>, <span class=\"user-mention\" data-user-id=\"466727\">@Jim Fowler</span>, let's coordinate in this thread.</p>",
        "id": 290390971,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658417318
    },
    {
        "content": "<p>I just refactored marked groups to be type synonyms (rather than classes). I am now copying over Georgi's material and adapting it to the new paradigm.</p>",
        "id": 290391065,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658417366
    },
    {
        "content": "<p>Wow, that's contentful! <br>\nPersonally, I'd like to try and cover the ends of graphs first, and use that as a stepping stone for the ends of groups hopefully; and Bass-Serre at some point in the near future.<br>\nOther than that I'd be happy to collaborate on whatever should come first, but there is some (a lot of) getting up to speed for me I see (even more so after seeing your transformation up there!).</p>\n<p>[Re ends of graphs: I have some code <a href=\"https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean\">here</a> but it's very messy and I have a feeling it's not headed in the right direction; I'd welcome some coaching on the coding side!]</p>\n<p>(I'm heading off for today)</p>",
        "id": 290394898,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658419025
    },
    {
        "content": "<p>Link to other threads:</p>\n<p><a href=\"#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Word.20metric.20on.20group.20--.20a.20new.20attempt</a></p>\n<p><a href=\"#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Geometric.20Group.20Theory.20coordination.20.3F</a></p>",
        "id": 290395644,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1658419313
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/15594\">#15594</a> for group seminorms.</p>",
        "id": 290415873,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658428579
    },
    {
        "content": "<p>Is it all-right if I bring <a href=\"https://github.com/leanprover-community/mathlib/blob/quasi_isometry/src/topology/metric_space/coarse/basic.lean\">my file on nets and separated subsets</a> here?</p>",
        "id": 290469766,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658470771
    },
    {
        "content": "<p>Please do!</p>",
        "id": 290476163,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658476770
    },
    {
        "content": "<p>Done. The theorem therein might be useful when/if one wants to show that from a quasi-isometry one can get a bilipschitz bijection between nets contained in the spaces.</p>",
        "id": 290496046,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658490992
    },
    {
        "content": "<p>By the way, about quasi-isometries: Is it worth it to also define coarsely Lipschitz maps and closeness for two maps into a metric space and have equivalence between all possible notions of equivalences, or should one stick to only talking about quasi-isometries for now?<br>\nOne definition I liked was: X and Y are QI if there exists a pair f:X -&gt;Y, g:Y-&gt;X, both coarsely Lipschitz, and such that both f o g and g o f are close to the identity.</p>\n<p><a href=\"https://github.com/bottine/mathlib/tree/11ed62ddb3d6c6db743365856184dcd93337b951/src/topology/metric_space/coarse\">here</a> I've got stuff about close maps and coarse Lipschitz maps.</p>",
        "id": 290496589,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658491313
    },
    {
        "content": "<p>Would it make sense to set up some variation of a <code>roadmap.txt</code> file with a list of goals and subgoals and who is working on what?</p>",
        "id": 290608216,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658574660
    },
    {
        "content": "<p>I have been following this and related threads for a while and would also like to contribute to building geometric group theory in mathlib. I have a nearly complete proof of the fact that the Cayley graph is connected (modulo two very easy <code>sorry</code>s), and I would like to push the changes to the <code>geometric-group-theory</code> branch. Can I please have write access to the non-master branches of mathlib? My GitHub username is <code>0art0</code>. Thanks!</p>",
        "id": 290609255,
        "sender_full_name": "Anand Rao",
        "timestamp": 1658576227
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span></p>",
        "id": 290610082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658577441
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span> I sent you an invitation</p>",
        "id": 290610164,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1658577589
    },
    {
        "content": "<p>Got it, thanks. I have pushed my code.</p>",
        "id": 290610629,
        "sender_full_name": "Anand Rao",
        "timestamp": 1658578313
    },
    {
        "content": "<p>I've been trying to make some progress on my code for ends of graphs, and am getting sort of lost starting from <a href=\"https://github.com/bottine/mathlib/blob/5fd6076d47a5dd5a0860fe96a4d85ca071a43aab/src/combinatorics/simple_graph/ends.lean#L763\">here</a>.<br>\nThe point is that I want to show that given any finite set of vertices and infinite connected component outside this set, I can define an end that corresponds to this component. My problem is that I have to do some transports along equalities for it to make sense, and I feel like I'm not going in the right direction.</p>\n<p>For instance, the definition <code>extend_along_fam</code> seems quite complicated, and the lemma <code>extend_along_const</code> needs transport even just to get correctly stated.<br>\nI believe I'm missing some theoretical/technical aspect here.</p>\n<p>Any idea on how I should proceed to make sense of this all? I'd welcome some structuring insights too!</p>",
        "id": 290611893,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658580032
    },
    {
        "content": "<p>I'm not sure it would simplify anything, but I thought I'd mention we now have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/simple_graph.subgraph.delete_verts\">docs#simple_graph.subgraph.delete_verts</a> so you can define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">simple_graph.connected_outside</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">delete_verts</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe.connected</span>\n</code></pre></div>\n<p>and if you have <code>s : finset V</code> you can write <code>G.connected_outside s</code>.  (This definition means \"G as a subgraph itself, once you delete the vertices from s, it is connected.\")</p>",
        "id": 290624570,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658597297
    },
    {
        "content": "<p>For ends of graphs, I imagined that one might take the poset of finite sets, which is closed under intersections, then define an inverse system over finite sets <code>s</code> of the types <code>((⊤ : G.subgraph).delete_verts s).coe.connected_component</code>. The limit of this inverse system consists of the ends.</p>\n<p>We have a theorem that if these types are always finite and nonempty then this limit is nonempty too (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_sections_of_fintype_inverse_system\">docs#nonempty_sections_of_fintype_inverse_system</a>) so in that case you'd have the graph has at least one end.</p>\n<p>I'm not sure how good this definition of ends would be to work with, but it at least wouldn't be too much work to set up. (Modulo some missing API around <code>delete_verts</code> and <code>connected_component</code>.)</p>",
        "id": 290624806,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658597603
    },
    {
        "content": "<p>Thanks! I'm wary of swapping out my constructions for the alternatives you provided though since as of now, my definitions do sort of work… but yeah, the inverse system theorem is a nice tool.</p>",
        "id": 290651911,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658637131
    },
    {
        "content": "<p>Would you go with something like this ?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.set.finite</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.sym.sym2</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.connectivity</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.metric_space.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.setoid.partition</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.functor.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n<span class=\"kn\">open</span> <span class=\"n\">set</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">simple_graph.walk</span>\n<span class=\"kn\">open</span> <span class=\"n\">relation</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"c1\">--local attribute [instance] prop_decidable</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n\n<span class=\"kd\">variables</span>  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n           <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">ends</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">conn_comp_outside</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">delete_verts</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe.connected_component</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">conn_comp_outside.finite</span> <span class=\"o\">[</span><span class=\"n\">locally_finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preconnected</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">conn_comp_outside.nonempty</span>  <span class=\"o\">[</span><span class=\"n\">locally_finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preconnected</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Ginf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set.univ</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">infinite</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">conn_comp_outside.to_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">:</span><span class=\"n\">v</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">G.subgraph</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">delete_verts</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe.connected_component_mk</span> <span class=\"o\">(⟨</span><span class=\"n\">v</span><span class=\"o\">,</span><span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"n\">exact</span> <span class=\"n\">p</span><span class=\"o\">}⟩)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n  <span class=\"bp\">∃!</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"n\">conn_comp_outside.to_set</span> <span class=\"n\">G</span> <span class=\"n\">t</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside.to_set</span> <span class=\"n\">G</span> <span class=\"n\">s</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">conn_comp_outside_back</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n  <span class=\"n\">classical.some</span> <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">conn_comp_outside_back.iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">):</span>\n  <span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside.to_set</span> <span class=\"n\">G</span> <span class=\"n\">t</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside.to_set</span> <span class=\"n\">G</span> <span class=\"n\">s</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"n\">equ</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">equ</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">unique_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">conn_comp_outside_back.refl</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">unique_of_exists_unique</span>\n  <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">set.subset.refl</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside.to_set</span> <span class=\"n\">G</span> <span class=\"n\">s</span> <span class=\"n\">c</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">conn_comp_outside_back.comm</span>  <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">conn_comp_outside</span> <span class=\"n\">G</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">k.trans</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">unique_of_exists_unique</span>\n  <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">k.trans</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some_spec.trans</span>\n     <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back</span> <span class=\"n\">G</span> <span class=\"n\">h</span> <span class=\"n\">c</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_of_exists_unique</span> <span class=\"o\">(</span><span class=\"n\">conn_comp_outside_back_unique</span> <span class=\"n\">G</span> <span class=\"o\">(</span><span class=\"n\">k.trans</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">c</span><span class=\"o\">)))</span>\n\n\n<span class=\"c1\">-- def ends_system := category_theory.functor.mk (conn_comp_outside G) (conn_comp_outside_back G)</span>\n\n\n<span class=\"kd\">end</span> <span class=\"n\">ends</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 290657481,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658646142
    },
    {
        "content": "<p>mmh, or I might as well take a hybrid approach: sticking with my version of connected components, but then using the inverse systems machinery…</p>",
        "id": 290657733,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658646613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> Do we have lemmas stating that the sections of your functor over an inverse system are in bijection with the sections over a suitably cofinite subsystem?</p>",
        "id": 290657799,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658646746
    },
    {
        "content": "<p>Well, after cleaning up my code a bit <a href=\"https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean\">here</a> I think I'll stay with the elementary approach I took until now. I'll leave the surjectivity of ends onto connected components alone while I try to attack Hopf-Freudenthal and come back to it afterwards, hopefully with a clearer mind. The inverse system approach is probably better all things compared, but in the end you still have to deal with pretty much the same things, and my elementary approach is easier for me still.</p>",
        "id": 290667125,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658661455
    },
    {
        "content": "<p>I asked in another thread but would I be able to get writing access on the branch? I have a bunch of stuff on svarcmilnor i'd like to push! my github is GregorSamsa42</p>",
        "id": 290679105,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1658668247
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"2494\">@maintainers</span></p>",
        "id": 290681471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1658670721
    },
    {
        "content": "<p>Invite sent! <a href=\"https://github.com/leanprover-community/mathlib/invitations\">https://github.com/leanprover-community/mathlib/invitations</a></p>",
        "id": 290682271,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1658671818
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290657799\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> Do we have lemmas stating that the sections of your functor over an inverse system are in bijection with the sections over a suitably cofinite subsystem?</p>\n</blockquote>\n<p>I haven't seen that in mathlib, and I presume it doesn't exist yet (but maybe I just haven't found it).</p>\n<p>It's fine continuing with an elementary approach to get a better understanding of formalization issues -- that limit nonemptiness lemma started out that way as a first project, until it eventually morphed into a specialization of a statement about cofiltered limits of nonempty compact hausdorff spaces.</p>",
        "id": 290686554,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658677453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> I think the following strategy (inspired heavily by the equivalence of different characterisations of ends described on <a href=\"https://en.wikipedia.org/wiki/End_(graph_theory)#Definition_and_characterization\">Wikipedia</a>) may work for getting a lower bound on the number of ends:</p>\n<ul>\n<li>To show that the number of ends of an infinite graph is bounded below by the number of infinite connected components, it suffices to show that every infinite connected graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> has at least one end.</li>\n<li>Since \"infinite\" is defined as \"not finite\" in mathlib, it should be fairly easy to show the existence of arbitrarily large paths in the graph <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>. Consequently, it should be possible to show the existence of a ray <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> (i.e., a semi-infinite path, which can be described concretely as an embedding of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">N</span></span></span></span>, considered as a graph, into <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>).</li>\n<li>To finally construct the end, we define its value on a finite set of vertices <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> to be the unique connected component of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">G \\backslash K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> containing infinitely many vertices of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>.</li>\n<li>More concretely, the set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>n</mi><mo>:</mo><mi mathvariant=\"double-struck\">N</mi><mi mathvariant=\"normal\">∣</mi><mi>R</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>K</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{n : \\mathbb{N} \\vert R(n) \\in K\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">N</span><span class=\"mord\">∣</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mclose\">}</span></span></span></span> is finite, and has an upper bound <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>. The value of the end of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> can be defined to be the connected component of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R(m+1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>. It can be proved as a theorem that the ray <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>R</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><mi>R</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">R&#x27;(n) := R((m  + 1) + n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">((</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> is contained entirely within this connected component.</li>\n</ul>",
        "id": 290755254,
        "sender_full_name": "Anand Rao",
        "timestamp": 1658753989
    },
    {
        "content": "<p>Mmh, I was aiming for an adaptation of the proof in the stacks project <a href=\"https://stacks.math.columbia.edu/tag/002Z\">here</a> to my specific case.<br>\nThe problem I foresee with the infinite ray approach is that it's not so immediate to construct the equivalence between ends as equivalence classes of rays and as limits.</p>",
        "id": 290760810,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658756962
    },
    {
        "content": "<p>The proof I outlined actually uses the definition of ends described in your code - as a function that takes in a finite set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> of the graph and returns a connected component of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mi mathvariant=\"normal\">\\</mi><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">G \\backslash K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mord\">\\</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> and satisfying the consistency condition on subsets (I should have mentioned this earlier).</p>\n<p>The definition of ends as equivalence classes of rays is not necessary here, and only the existence of a single ray in an infinite connected graph is required.</p>\n<p>The inverse limit approach is fine too, and I may also contribute to the proof.</p>",
        "id": 290765518,
        "sender_full_name": "Anand Rao",
        "timestamp": 1658759267
    },
    {
        "content": "<p>That's good to hear!</p>",
        "id": 290766219,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658759579
    },
    {
        "content": "<p>I've worked some more, and have a <a href=\"https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends.lean\">rough outline of the proof of Hopf-Freudenthal</a>.</p>\n<p>There are now plenty of missing pieces:</p>\n<ul>\n<li>The surjectivity of the <code>eval</code> map is the big one.</li>\n<li>The fact that taking a finite set of vertices, one can extend it so that it is both connected, and all connected components outside of this finite set are infinite. (that's used in one of the preliminary lemmas towards Hopf-Freudenthal)</li>\n<li>The fact that applying an automorphism sends connected components to connected components, etc (should be easy with enough <code>simple_graph</code>-fu).</li>\n<li>Lots of small things for which I'm not good enough with lean to figure out efficiently.</li>\n</ul>\n<p>But all in all, I think I'm getting to something viable. <br>\nThe next step is probably to sort of clean up the structure a bit, reorganize as necessary, and then fill out the sorrys.<br>\n<span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span>: What do you think of that plan?</p>\n<p>(I'm heading off for today!)</p>",
        "id": 290766493,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658759707
    },
    {
        "content": "<p>Sounds good! I will try to familiarise myself with the code a bit more soon. I will start with some of the easier <code>sorry</code>s.</p>",
        "id": 290768221,
        "sender_full_name": "Anand Rao",
        "timestamp": 1658760421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  I have a few questions about <code>simple_graph</code> if I may:</p>\n<p>First, would the following lemmas fit in the api:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">walk.mem_support_iff_exists_append</span>  <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">p.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q.append</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.support_append_subset_left</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.support</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">p.append</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">walk.support_append</span><span class=\"o\">,</span><span class=\"n\">list.subset_append_left</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.support_append_subset_right</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">q.support</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">p.append</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"n\">walk.support_append</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">support_nil</span><span class=\"o\">,</span> <span class=\"n\">list.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">list.append_nil</span><span class=\"o\">,</span> <span class=\"n\">list.cons_subset</span><span class=\"o\">,</span> <span class=\"n\">end_mem_support</span><span class=\"o\">,</span> <span class=\"n\">list.nil_subset</span><span class=\"o\">,</span> <span class=\"n\">and_self</span><span class=\"o\">],},</span>\n    <span class=\"o\">{</span><span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">support_cons</span><span class=\"o\">,</span> <span class=\"n\">list.tail_cons</span><span class=\"o\">,</span> <span class=\"n\">list.cons_subset</span><span class=\"o\">,</span> <span class=\"n\">list.mem_append</span><span class=\"o\">,</span> <span class=\"n\">end_mem_support</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">,</span> <span class=\"n\">list.subset_append_right</span><span class=\"o\">,</span><span class=\"n\">and_self</span><span class=\"o\">],},</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>Second, is there a nice way to deal with walks and their images via an automorphism and such?<br>\nFinally, is there something like <code> lemma {V : Type *} {G : simple_graph V} [locally_finite G] [preconnected G] (v : V) (n : nat) : (ball v n).finite  := sorry </code> ?</p>",
        "id": 290864194,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658825231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Yes, these would be nice to have. The first one seems like it might be more convenient in many cases than using <code>take_until</code> and <code>drop_until</code> manually.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- right after `walk.take_spec`?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.mem_support_iff_exists_append</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">w</span> <span class=\"bp\">∈</span> <span class=\"n\">p.support</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"bp\">=</span> <span class=\"n\">q.append</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p.take_spec</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"c1\">-- right after `walk.mem_support_append_iff`?</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.subset_support_append_left</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.support</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">p.append</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">walk.support_append</span><span class=\"o\">,</span> <span class=\"n\">list.subset_append_left</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.subset_support_append_right</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">q.support</span> <span class=\"bp\">⊆</span> <span class=\"o\">(</span><span class=\"n\">p.append</span> <span class=\"n\">q</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">support</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">{</span> <span class=\"n\">contextual</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 290865687,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658826270
    },
    {
        "content": "<p>Shall I just copy, insert, and do a PR?</p>",
        "id": 290865864,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658826421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> The function for mapping walks over a graph equivalence has some dependent type complexity, and I'm not really sure the best way to deal with it. Here's most of one possibility:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">≃</span> <span class=\"n\">G'.walk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">walk.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">f.symm</span> <span class=\"o\">:</span> <span class=\"n\">G'</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">a</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nil</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">b</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"n\">apply</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">a'</span> <span class=\"n\">b</span> <span class=\"n\">b'</span> <span class=\"n\">c</span> <span class=\"n\">c'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c'</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span><span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span>\n        <span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"n\">cons</span> <span class=\"n\">he</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n          <span class=\"bp\">=</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hb</span><span class=\"o\">])</span> <span class=\"n\">he</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">a'</span> <span class=\"n\">b'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cast</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">])</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">b'</span> <span class=\"n\">c'</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">congr'</span> <span class=\"o\">},</span>\n      <span class=\"n\">all_goals</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 290868740,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658828321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290864194\">said</a>:</p>\n<blockquote>\n<p>Finally, is there something like <code> lemma {V : Type *} {G : simple_graph V} [locally_finite G] [preconnected G] (v : V) (n : nat) : (ball v n).finite  := sorry </code> ?</p>\n</blockquote>\n<p>The \"walks of a given length\" section of simple_graph/connectivity could be generalized to this situation. I think you can drop the <code>preconnected</code> assumption.</p>",
        "id": 290869041,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658828486
    },
    {
        "content": "<p>Ah, yeah, right, I was thinking of something else for the preconnected assumption: namely that in this case the graph is countable.</p>",
        "id": 290869383,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658828671
    },
    {
        "content": "<p>Could elaborate on the use of <code>contextual := tt</code> ? The docs aren't very helpful as far as I could find.</p>",
        "id": 290869435,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658828714
    },
    {
        "content": "<p>There's a little bit at <a href=\"https://leanprover-community.github.io/extras/simp.html\">https://leanprover-community.github.io/extras/simp.html</a></p>\n<p>When it simplifies <code>a -&gt; b</code>, it simplifies <code>b</code> with <code>a</code> added as a simp lemma.</p>",
        "id": 290869572,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658828805
    },
    {
        "content": "<p>Thanks, I'm sort of mystified that you made the <code>append_right</code> version shorter than the <code>append_left</code> one, given that it's not as direct as far as I understood.</p>",
        "id": 290869917,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658829044
    },
    {
        "content": "<p>Here's a locally finite version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">locally_finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_rel</span> <span class=\"n\">G.adj</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n\n<span class=\"sd\">/-- The `finset` of length-`n` walks from `u` to `v`.</span>\n<span class=\"sd\">This is used to give `{p : G.walk u v | p.length = n}` a `fintype` instance, and it</span>\n<span class=\"sd\">can also be useful as a recursive description of this set when `V` is finite.</span>\n\n<span class=\"sd\">See `simple_graph.coe_finset_walk_length_eq` for the relationship between this `finset` and</span>\n<span class=\"sd\">the set of length-`n` walks. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">finset_walk_length</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span>\n           <span class=\"k\">then</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">{</span><span class=\"n\">walk.nil</span><span class=\"o\">}</span> <span class=\"o\">}</span>\n           <span class=\"k\">else</span> <span class=\"bp\">∅</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_finset</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">attach.bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G.neighbor_finset</span> <span class=\"n\">u</span><span class=\"o\">),</span>\n                  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">w.2</span><span class=\"o\">,</span>\n                  <span class=\"o\">(</span><span class=\"n\">finset_walk_length</span> <span class=\"n\">n</span> <span class=\"n\">w</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">walk.cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"n\">q</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_finset_walk_length_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.finset_walk_length</span> <span class=\"n\">n</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">|</span> <span class=\"n\">p.length</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">huv</span> <span class=\"o\">:=</span> <span class=\"n\">eq_or_ne</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"bp\">;</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">finset_walk_length</span><span class=\"o\">,</span> <span class=\"n\">set_walk_length_zero_eq_of_ne</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">finset_walk_length</span><span class=\"o\">,</span> <span class=\"n\">set_walk_length_succ_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">finset.coe_bUnion</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_univ</span><span class=\"o\">,</span> <span class=\"n\">set.Union_true</span><span class=\"o\">],</span>\n    <span class=\"n\">ext</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_Union</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">set.mem_image</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_neighbor_finset</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_attach</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_map</span><span class=\"o\">,</span> <span class=\"n\">embedding.coe_fn_mk</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">exists_true_left</span><span class=\"o\">,</span>\n  <span class=\"n\">subtype.exists</span><span class=\"o\">],</span>\n    <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n    <span class=\"n\">congr'</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">congr'</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">huw</span><span class=\"o\">,</span>\n    <span class=\"n\">congr'</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span> <span class=\"n\">p'</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.ext_iff</span><span class=\"o\">,</span> <span class=\"n\">finset.mem_coe</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ih</span><span class=\"o\">],</span>\n    <span class=\"n\">rintro</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 290870069,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658829161
    },
    {
        "content": "<p>The proof of <code>coe_finset_walk_length_eq</code> isn't pretty -- I was just trying to get it to work quickly</p>",
        "id": 290870103,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658829190
    },
    {
        "content": "<p>If you wanted to PR this sort of generalization (with a nicer proof), that'd be great! If not, I'll get around to it at some point.</p>",
        "id": 290870217,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658829255
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290869917\">said</a>:</p>\n<blockquote>\n<p>I'm sort of mystified that you made the <code>append_right</code> version shorter than the <code>append_left</code> one</p>\n</blockquote>\n<p>You can actually use the <code>append_right</code> proof for <code>append_left</code> too, but I left it since your proof was a <code>simp only</code>. It's too bad that <code>walk.support_append</code> has that asymmetry...</p>",
        "id": 290870454,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658829410
    },
    {
        "content": "<p>right, I originally planned it by way of enough <code>reverse</code>s, but it felt ugly.</p>",
        "id": 290870601,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658829483
    },
    {
        "content": "<p>As for contributing to the ball and other lemmas, I hope to do at some point. But I also would like to sort of stay focused on my <code>ends</code> code for now, and every little things takes lots of time still, so it may not be so soon.</p>",
        "id": 290871167,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658829875
    },
    {
        "content": "<p>PR here: <a href=\"https://github.com/leanprover-community/mathlib/pull/15687\">https://github.com/leanprover-community/mathlib/pull/15687</a></p>",
        "id": 290871227,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658829925
    },
    {
        "content": "<p>I made your <code>simp</code> into <code>simp only</code> since I believe it's what should be done but maybe I was mistaken. I also made the two <code>subset</code> lemmas into <code>@[simp]</code>.</p>",
        "id": 290871579,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658830170
    },
    {
        "content": "<p>huh, I don't understand why the bulid fails :(</p>",
        "id": 290872634,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658830861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> Here's the finite ball. It's intended to go right after <code>fintype_set_walk_length</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">ball_finset</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">finset</span> <span class=\"n\">V</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">u</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">∪</span> <span class=\"o\">(</span><span class=\"n\">G.neighbor_finset</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">bUnion</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">ball_finset</span> <span class=\"n\">n</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">coe_ball_finset_eq</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">G.ball_finset</span> <span class=\"n\">n</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">p.length</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ball_finset</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ball_finset</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">(</span><span class=\"n\">rfl</span> <span class=\"bp\">|</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n      <span class=\"o\">{</span> <span class=\"n\">use</span> <span class=\"n\">walk.nil</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">huw</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">w</span><span class=\"o\">),</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">walk.cons</span> <span class=\"n\">huw</span> <span class=\"n\">p</span><span class=\"o\">],</span>\n        <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">],</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">cases</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">right</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">p_v</span><span class=\"o\">,</span> <span class=\"n\">p_h</span><span class=\"o\">],</span>\n        <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">v</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ih</span> <span class=\"n\">p_v</span><span class=\"o\">),</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n        <span class=\"n\">use</span> <span class=\"n\">p_p</span><span class=\"o\">,</span>\n        <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">nat.succ_eq_add_one</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ball</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">locally_finite</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">p.length</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ball_finite</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">locally_finite</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">G.ball</span> <span class=\"n\">u</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">classical</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ball</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">coe_ball_finset_eq</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">set.to_finite</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 290873070,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658831132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290872634\">said</a>:</p>\n<blockquote>\n<p>huh, I don't understand why the bulid fails :(</p>\n</blockquote>\n<p>I just retriggered the linting job. Sometimes things fail for no discernible reason.</p>",
        "id": 290873338,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658831297
    },
    {
        "content": "<p>It might be easier to prove that set is finite by induction on n more directly than by going through finsets. The algorithm I wrote for <code>ball_finset</code> is really bad -- it doesn't need to be exponential like that -- so it's not useful having that as a computable definition.</p>",
        "id": 290873612,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658831503
    },
    {
        "content": "<p>and it might make sense to use the induced metric directly, so that the balls really are the metric ball, I guess?</p>",
        "id": 290874103,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658831819
    },
    {
        "content": "<p>Ah, that's where <code>connected</code> comes in, for <code>simple_graph.dist</code> to be meaningful here.</p>",
        "id": 290874996,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658832416
    },
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/15705\">#15705</a> for multiplicative normed groups.</p>",
        "id": 290970850,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1658879812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> thanks for correcting the PR :) Can you tell me how you knew what made the linter unhappy ? I ran <code>scripts/lint-style.sh</code> but that didn't spot anything iirc.</p>",
        "id": 290988358,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658897610
    },
    {
        "content": "<p>Once the linter finally ran, it gave some error messages that you can see inline in the code view on GitHub.  It's derived from this output: <a href=\"https://github.com/leanprover-community/mathlib/runs/7518225899?check_suite_focus=true\">https://github.com/leanprover-community/mathlib/runs/7518225899?check_suite_focus=true</a></p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>/- The `dup_namespace` linter reports: -/\n/- DUPLICATED NAMESPACES IN NAME: -/\n-- combinatorics/simple_graph/connectivity.lean\n#check @simple_graph.walk.walk.subset_support_append_left /- The namespace `walk` is duplicated in the name -/\nError: simple_graph.walk.walk.subset_support_append_left - The namespace `walk` is duplicated in the name\n... etc. ...\n</code></pre></div>",
        "id": 290989481,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1658898782
    },
    {
        "content": "<p>Ah, thanks, I tried to see the output on the first run but somehow it seemed to be empty. Is there a way to do it locally?</p>",
        "id": 290989609,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1658898946
    },
    {
        "content": "<p>You can add <code>#lint</code> to the end of every file you touch to see the output, make sure you remove it before committing though!</p>",
        "id": 291031199,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1658927511
    },
    {
        "content": "<p>My proof of svarc-milnor is now (virtually) complete, along with an example that proves Z quasi-isometric to R.<br>\nIt relies on a few easy lemmas about marked_group which i've added to the file now (I think most should be one liners, but my knowledge doesn't suffice). <br>\nIf anyone is bored you're welcome to have a look at them :)</p>",
        "id": 291042796,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1658932315
    },
    {
        "content": "<p>We're making some progress on the Freundenthal-Hopf theorem, but have some trouble dealing with instances/typeclasses, as typically shown <a href=\"https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends/reachable_outside.lean#L334\">here</a>. How should I proceed to assume throughout (without the need to reference it explicitely) that my graph is locally finite and preconnected?<br>\nIn the same vein, under the hypotheses, I would like to assume everywhere that a specific set is finite (as shown <a href=\"https://github.com/bottine/mathlib/blob/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends/reachable_outside.lean#L477\">here</a> but the instance doesn't \"take\", it seems.</p>",
        "id": 291164464,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659004037
    },
    {
        "content": "<p>Are you writing instances that depend on a <code>locally_finite</code> assumption? If not, I would stick with passing it around explicitly.</p>",
        "id": 291165566,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659004989
    },
    {
        "content": "<p>I am, yeah: I need <code>locally_finite G</code> to say that removing a finite set of vertices yield a finite number of connected components.</p>",
        "id": 291165805,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659005169
    },
    {
        "content": "<p>That's the type <code>inf_ro_components G K</code>. I'd like to have <code>[fintype (inf_ro_components G K)]</code> everywhere (well, once I actually prove it).</p>",
        "id": 291165875,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659005237
    },
    {
        "content": "<p>Yes but again do you need to go through typeclass inference for this?</p>",
        "id": 291165912,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659005268
    },
    {
        "content": "<p>Mmh, I admit I don't understand the question: I'm not sure what typeclass inference is. Maybe it's time to look at the docs instead of blindly swapping out <code>()</code> for <code>[]</code> and see what sticks</p>",
        "id": 291166167,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659005449
    },
    {
        "content": "<p>Basically you shouldn't treat TC inference as a big theorem bookkeeper. Instead (at least for Prop-valued stuff), it should be used for assumptions that are derived structurally (typically, <code>p ∧ q ∨ r</code> will be decidable because <code>p</code>, <code>q</code>, <code>r</code> is).</p>",
        "id": 291166365,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659005624
    },
    {
        "content": "<p>Mmh, I see, and what's the rationale for this? \"structurally derived\" theorems are easier for lean to understand/bookkeep?</p>",
        "id": 291166725,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659005860
    },
    {
        "content": "<p>TC inference is not meant to nor can be used as a SMT solver.</p>",
        "id": 291168943,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1659007429
    },
    {
        "content": "<p>Alright, thanks! I'll try and look at the docs in a bit more depth.</p>",
        "id": 291169064,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659007497
    },
    {
        "content": "<p>Isn't <code>gen_norm_le_one</code> in <code>marked_group</code> wrong for exactly the reason <span class=\"user-mention\" data-user-id=\"263407\">@Laurent Bartholdi</span> mentionned above: a generator might be mapped to the identity ?</p>",
        "id": 291184559,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659016417
    },
    {
        "content": "<p>For what it's worth, my motivation for slipping in <code>locally_finite</code> was to support different limiting arguments on subgraphs, for instance defining ends of graphs or lifting properties about finite graphs to infinite graphs (like how you can lift the 4-color theorem of finite planar graphs to infinite planar graphs).</p>\n<p>Generally you'd be looking at the instances <code>[locally_finite G]</code> giving <code>[locally_finite (G.delete_verts s)]</code> or <code>[locally_finite (G.induce s)]</code> (or however those graphs are written), and you won't be doing any algebraic manipulation of <code>G</code> itself -- it's being used more like a type than a term, so to speak.</p>\n<p>That's not to say I knew what I was doing back when I slipped it in, but given what I've learned in the meantime I think <code>locally_finite</code>instances are still justifiable for this application.</p>",
        "id": 291210994,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659022846
    },
    {
        "content": "<p>Actually, <code>locally_finite</code> is not the worst offender here (lean seems to like it being an instance well enough), but <code>preconnected G</code> and the diverse <code>fintype X</code> are.</p>",
        "id": 291211656,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659023136
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/290868740\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> The function for mapping walks over a graph equivalence has some dependent type complexity, and I'm not really sure the best way to deal with it. Here's most of one possibility:</p>\n</blockquote>\n<p>I've made a definitionally better version of the walk equiv but unfortunately it requires a re-definition of <code>simple_graph.walk</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.basic</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">}</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">walk</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">walk</span> <span class=\"n\">u</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">walk.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"o\">:</span> <span class=\"n\">V'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">),</span>\n  <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">→</span> <span class=\"n\">G'.walk</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">walk.nil</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">walk.nil</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">hv</span><span class=\"o\">])</span>\n<span class=\"bp\">|</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"n\">w</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">walk.cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"bp\">▸</span> <span class=\"n\">f.map_adj</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">walk.map</span> <span class=\"n\">rfl</span> <span class=\"n\">hv</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">walk.equiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"o\">:</span> <span class=\"n\">V'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">≃</span> <span class=\"n\">G'.walk</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">walk.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">walk.map</span> <span class=\"o\">(</span><span class=\"n\">f.symm</span> <span class=\"o\">:</span> <span class=\"n\">G'</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hu</span><span class=\"o\">])</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">hv</span><span class=\"o\">]),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">u'</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">p_ih</span> <span class=\"n\">hv</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">walk.cons</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">congr'</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span> <span class=\"o\">{</span> <span class=\"n\">conv_rhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"bp\">@</span><span class=\"n\">p_ih</span> <span class=\"n\">hv</span> <span class=\"o\">(</span><span class=\"n\">f.symm</span> <span class=\"n\">p_v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">},</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">walk.equiv'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">≃</span> <span class=\"n\">G'.walk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">walk.equiv</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 291267419,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659051951
    },
    {
        "content": "<p>I'm not sure if allowing equality in <code>walk.nil</code> is really necessary; we may use <code>eq.rec (walk.nil ...)</code>, and if <code>f (g v) = v</code> definitionally then it would compute to <code>walk.nil ...</code>.</p>",
        "id": 291267518,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659052021
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> That's a good idea. There's a trick that lets us avoid needing to modify the inductive type itself that is theoretically equivalent, which is to add in a <code>copy</code> function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">walk.copy</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">p</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>Then the modified inductive type corresponds to wrapping constructors with this <code>copy</code> function.</p>\n<p>With this and some accompanying lemmas, the <code>left_inv</code> and <code>right_inv</code> proofs are <code>simp</code> (in my code below it's longer because there are still some missing lemmas).</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">combinatorics.simple_graph.connectivity</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">V'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G'</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V'</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">V''</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G''</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V''</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"n\">w'</span> <span class=\"n\">u''</span> <span class=\"n\">v''</span> <span class=\"n\">w''</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">simple_graph</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">walk.copy</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">subst</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">p</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">walk.copy_rfl_rfl</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.copy</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.copy_copy</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu'</span> <span class=\"o\">:</span> <span class=\"n\">u'</span> <span class=\"bp\">=</span> <span class=\"n\">u''</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv'</span> <span class=\"o\">:</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">v''</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p.copy</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">hu'</span> <span class=\"n\">hv'</span> <span class=\"bp\">=</span> <span class=\"n\">p.copy</span> <span class=\"o\">(</span><span class=\"n\">hu.trans</span> <span class=\"n\">hu'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv.trans</span> <span class=\"n\">hv'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.copy_nil</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">walk.nil</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">u</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">hu</span> <span class=\"n\">hu</span> <span class=\"bp\">=</span> <span class=\"n\">walk.nil</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.copy_cons</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">w'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"n\">h</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">hu</span> <span class=\"n\">hw</span> <span class=\"bp\">=</span> <span class=\"n\">walk.cons</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">hu</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">p.copy</span> <span class=\"n\">rfl</span> <span class=\"n\">hw</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.cons_copy</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">G.adj</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">v'</span> <span class=\"n\">w'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v'</span> <span class=\"bp\">=</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hw</span> <span class=\"o\">:</span> <span class=\"n\">w'</span> <span class=\"bp\">=</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">walk.cons</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">p.copy</span> <span class=\"n\">hv</span> <span class=\"n\">hw</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">walk.cons</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">})</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"n\">rfl</span> <span class=\"n\">hw</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.map_copy</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hu</span> <span class=\"o\">:</span> <span class=\"n\">u</span> <span class=\"bp\">=</span> <span class=\"n\">u'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">=</span> <span class=\"n\">v'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p.copy</span> <span class=\"n\">hu</span> <span class=\"n\">hv</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">hu</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">subst</span> <span class=\"n\">hv</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">p</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">u'</span> <span class=\"n\">v'</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">walk.copy_cons</span><span class=\"o\">],</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">walk.map</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">walk.copy_cons</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">],</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.map_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">G'</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G''</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f'</span> <span class=\"bp\">=</span> <span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">f'.comp</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">walk.map_id</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p.map</span> <span class=\"n\">hom.id</span> <span class=\"bp\">=</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">induction</span> <span class=\"n\">p</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">walk.map_of_eq</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">subst_vars</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">walk.equiv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">≃</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">≃</span> <span class=\"n\">G'.walk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">walk.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"o\">(</span><span class=\"n\">f.symm</span> <span class=\"o\">:</span> <span class=\"n\">G'</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">),</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">walk.map_map</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">walk.map_of_eq</span> <span class=\"n\">hom.id</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">walk.map_map</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">walk.map_of_eq</span> <span class=\"n\">hom.id</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">simple_graph</span>\n</code></pre></div>",
        "id": 291348197,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659111894
    },
    {
        "content": "<p>This is somewhat like manipulating sigma types, however with this you get constant definitional control over the endpoints of walks, which is quite nice!</p>",
        "id": 291348392,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659111988
    },
    {
        "content": "<p>If you <code>#print walk.copy</code> you see it's just <code>eq.rec (eq.rec p hv) hu</code> though and not of the form <code>nil</code> or <code>cons</code>. If <code>hu</code> and <code>hv</code> are not defeqs it doesn't compute/reduce.</p>",
        "id": 291348637,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659112122
    },
    {
        "content": "<p>I almost wrote it as <code>eq.rec</code> directly, but I thought using <code>subst</code> was clearer.</p>",
        "id": 291348978,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659112305
    },
    {
        "content": "<p>That's true they don't reduce, however having a custom <code>eq.rec</code> means it's easier to write all the supporting simp lemmas, which is a point I forgot to mention explicitly.</p>",
        "id": 291349061,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659112336
    },
    {
        "content": "<p>Yeah eq_to_hom is also secretely an <code>eq.rec</code>...</p>",
        "id": 291349153,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1659112388
    },
    {
        "content": "<p>This lets us deal with the \"evilness\" of rewriting morphisms(/functors):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">walk.map_of_eq</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→</span><span class=\"n\">g</span> <span class=\"n\">G'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G.walk</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">p.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p.map</span> <span class=\"n\">f'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">copy</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 291349179,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659112408
    },
    {
        "content": "<p>The idea is that the simp normal form for <code>copy</code> is to be the outermost thing in an expression, so that way <code>copy_copy</code> merges them, and eventually you can (hopefully) eliminate them completely.</p>",
        "id": 291349308,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659112475
    },
    {
        "content": "<p>Unlike for category theory, this evilness is a necessary evil since we aren't working with vertices up to isomorphism, but actually up to equality. There are no higher morphisms to save us.</p>",
        "id": 291349726,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1659112686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/291184559\">said</a>:</p>\n<blockquote>\n<p>Isn't <code>gen_norm_le_one</code> in <code>marked_group</code> wrong for exactly the reason <span class=\"user-mention silent\" data-user-id=\"263407\">Laurent Bartholdi</span> mentionned above: a generator might be mapped to the identity ?</p>\n</blockquote>\n<p>uh yes true, the version for subsets is right but I forgot to change the original version (the name le_one is correct though ^^)</p>",
        "id": 291537625,
        "sender_full_name": "Georgi Kocharyan",
        "timestamp": 1659336524
    },
    {
        "content": "<p>Hey, so we've been working on Freudenthal-Hopf with <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span> for a while, and are getting sort of stuck/unsure about how to architect things. The \"pure graph theoretical\" part is mostly done, with a few sorries, but to prove the surjectivity of ends onto infinite connected components, we finally decided on using the lemma from mathlib about finite nonempty filtered inverse systems, and this cascaded into wanting to define ends really as limits, rather than as our own type, and then noticing that most of our code really should be stated in this more general setting. The code is <a href=\"https://github.com/bottine/mathlib/tree/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends\">here</a> if anyone wants to chime in with some feedback. I believe the correct way wrt mathlib would be to have as much general stuff out of our code as possible, but it seems there is a pretty heavy infrastructure code to this.</p>",
        "id": 291676980,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1659427346
    },
    {
        "content": "<p>OK, after some more work <a href=\"https://github.com/bottine/mathlib/tree/bottine/simple_graph_ends/src/combinatorics/simple_graph/ends\">here</a>, we're planning on merging our work with the <code>geometric-group-theory</code> branch: anybody minds?</p>\n<p>We're close to having:</p>\n<ul>\n<li>Ends for (locally finite, connected) graphs in <code>ends_limit_construction.lean</code>.</li>\n<li>A slightly modified statement of Freudenthal-Hopf in <code>Freudenthal_Hopf.lean</code>.</li>\n<li>A notion of \"coarse maps\" of graphs and closeness for such maps, in order to have functoriality of ends in <code>functoriality.lean</code>.</li>\n<li>The fact that quasi-isometries of graphs yield bijections of ends (again, slightly modified to match our definitions).</li>\n<li>Plenty of <code>sorry</code>s peppered around, but mostly stuff that we feel should be easy from (eventual) <code>mathlib</code> lemmas.</li>\n<li>The set of connected components outside of a finite set is defined in <code>comp_out.lean</code>: we took a kind of hybrid approach: defining the connected components outside of <code>K</code> as <code>(G.remove_verts K).connected_component</code> made coercions sort of unmanageable. <br>\n  Instead, we define a subgraph on the same vertex set that deconnects all of <code>K</code>, and then we just look at the components disjoint from <code>K</code>.<br>\n  This worked well enough for us.</li>\n</ul>\n<p>The plan now is to do some cleanup and reorganization of the files, and then merge, assuming that's OK with people.</p>",
        "id": 297186158,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662366975
    },
    {
        "content": "<p>And now I want to start working on Bass-Serre theory, and for this I'd welcome some opinions:</p>\n<ul>\n<li>\n<p>I was thinking of starting with <em><a href=\"https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/jlms/s2-13.1.145\">The fundamental groupoid of a graph of groups</a></em> by Higgins. <br>\n  It seems to work at a nice abstraction level, but:</p>\n</li>\n<li>\n<p>This relies on presentations of groupoids, e.g. <em><a href=\"https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/presentations-of-groupoids-with-applications-to-groups/BEB206703D950FA10E18DD51CB52F019\">Presentations of groupoids, with applications to groups</a></em> by Higgins also.</p>\n</li>\n</ul>\n<p>As far as I could find, there is essentially no code for presentations of groupoids in mathlib: the closest is the code for Nielsen-Schreier.<br>\nDoes it make sense to start this low down the hierarchy and actually take the time to define presentations of groupoids, and then go up again via Higgins' paper, to, eventually, start working on Bass-Serre, or is a hands-on approach (maybe even forsaking groupoids) more reasonable?</p>\n<p>The paper <em>Presentations of groupoids…</em> actually has Nielsen-Schreier and Kurosh as applications, which makes me believe that it might not be a bad idea to start here: we can already get non-trivial stuff from that approach, and in any case, I guess presentations of groupoids might prove useful more generally than for Bass-Serre?</p>",
        "id": 297311453,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662446590
    },
    {
        "content": "<p>By the way, I am still reorganising norms to defin multiplicative normed groups. It's taking ages.</p>",
        "id": 297320797,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662451367
    },
    {
        "content": "<p>I think that presentations of groupoids would definitely be useful by itself, independantly of Bass-Serre theory.</p>",
        "id": 297461528,
        "sender_full_name": "Antoine Labelle",
        "timestamp": 1662488324
    },
    {
        "content": "<p>OK, I imported our work into the <code>geometric-group-theory</code> branch. <br>\n<span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> before doing the (manual) import, I tried running <code>leanproject rebase</code> on the <code>ggt</code> branch, but the rebase failed because of a duplicate definition of <code>seminorm</code> (or something like that). I expect that is because you had a preliminary definition locally in the <code>ggt</code> branch and you're now comitting bits on <code>master</code>. Can I safely remove the local definition?</p>",
        "id": 297962286,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662726814
    },
    {
        "content": "<p>I think so, but what definition is it exactly?</p>",
        "id": 297962442,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662726851
    },
    {
        "content": "<p>oh, maybe I misread the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">&gt;</span> <span class=\"n\">leanproject</span> <span class=\"n\">rebase</span>\n<span class=\"n\">Checking</span> <span class=\"n\">out</span> <span class=\"n\">master...</span>\n<span class=\"n\">Pulling...</span>\n<span class=\"bp\">`</span><span class=\"n\">get</span><span class=\"bp\">-</span><span class=\"n\">mathlib</span><span class=\"bp\">-</span><span class=\"n\">cache</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">for</span> <span class=\"n\">projects</span> <span class=\"n\">which</span> <span class=\"n\">depend</span> <span class=\"n\">on</span> <span class=\"n\">mathlib</span><span class=\"o\">,</span> <span class=\"n\">not</span> <span class=\"n\">for</span> <span class=\"n\">mathlib</span> <span class=\"n\">itself.</span> <span class=\"n\">Running</span> <span class=\"bp\">`</span><span class=\"n\">get</span><span class=\"bp\">-</span><span class=\"n\">cache</span><span class=\"bp\">`</span> <span class=\"n\">instead.</span>\n<span class=\"n\">Looking</span> <span class=\"n\">for</span> <span class=\"n\">mathlib</span> <span class=\"n\">oleans</span> <span class=\"n\">for</span> <span class=\"mi\">75</span><span class=\"n\">cc1ae964</span>\n  <span class=\"n\">locally...</span>\n  <span class=\"n\">Found</span> <span class=\"kn\">local</span> <span class=\"n\">mathlib</span> <span class=\"n\">oleans</span>\n<span class=\"n\">Using</span> <span class=\"n\">matching</span> <span class=\"n\">cache</span>\n<span class=\"n\">Applying</span> <span class=\"n\">cache</span>\n  <span class=\"n\">files</span> <span class=\"n\">extracted</span><span class=\"o\">:</span> <span class=\"mi\">2674</span> <span class=\"o\">[</span><span class=\"mi\">00</span><span class=\"o\">:</span><span class=\"mi\">14</span><span class=\"o\">,</span> <span class=\"mi\">179</span><span class=\"bp\">.</span><span class=\"mi\">97</span><span class=\"bp\">/</span><span class=\"n\">s</span><span class=\"o\">]</span>\n<span class=\"n\">Checking</span> <span class=\"n\">out</span> <span class=\"n\">geometric</span><span class=\"bp\">-</span><span class=\"n\">group</span><span class=\"bp\">-</span><span class=\"n\">theory...</span>\n<span class=\"n\">Rebasing...</span>\n<span class=\"n\">Cmd</span><span class=\"o\">(</span><span class=\"bp\">'</span><span class=\"n\">git'</span><span class=\"o\">)</span> <span class=\"n\">failed</span> <span class=\"n\">due</span> <span class=\"n\">to</span><span class=\"o\">:</span> <span class=\"n\">exit</span> <span class=\"n\">code</span><span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n  <span class=\"n\">cmdline</span><span class=\"o\">:</span> <span class=\"n\">git</span> <span class=\"n\">rebase</span> <span class=\"n\">master</span>\n  <span class=\"n\">stdout</span><span class=\"o\">:</span> <span class=\"bp\">'</span><span class=\"n\">Auto</span><span class=\"bp\">-</span><span class=\"n\">merging</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">analysis</span><span class=\"bp\">/</span><span class=\"n\">seminorm.lean</span>\n<span class=\"n\">CONFLICT</span> <span class=\"o\">(</span><span class=\"n\">content</span><span class=\"o\">):</span> <span class=\"n\">Merge</span> <span class=\"n\">conflict</span> <span class=\"k\">in</span> <span class=\"n\">src</span><span class=\"bp\">/</span><span class=\"n\">analysis</span><span class=\"bp\">/</span><span class=\"n\">seminorm.lean'</span>\n<span class=\"n\">error</span><span class=\"o\">:</span> <span class=\"n\">could</span> <span class=\"n\">not</span> <span class=\"n\">apply</span> <span class=\"mi\">8</span><span class=\"n\">bbccf027f...</span> <span class=\"n\">use</span> <span class=\"n\">type</span> <span class=\"n\">synonyms</span><span class=\"o\">,</span> <span class=\"n\">group</span> <span class=\"n\">seminorms</span>\n<span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"n\">Resolve</span> <span class=\"n\">all</span> <span class=\"n\">conflicts</span> <span class=\"n\">manually</span><span class=\"o\">,</span> <span class=\"n\">mark</span> <span class=\"n\">them</span> <span class=\"n\">as</span> <span class=\"n\">resolved</span> <span class=\"k\">with</span>\n<span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"s2\">\"git add/rm &lt;conflicted_files&gt;\"</span><span class=\"o\">,</span> <span class=\"k\">then</span> <span class=\"n\">run</span> <span class=\"s2\">\"git rebase --continue\"</span><span class=\"bp\">.</span>\n<span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"n\">You</span> <span class=\"n\">can</span> <span class=\"n\">instead</span> <span class=\"n\">skip</span> <span class=\"n\">this</span> <span class=\"n\">commit</span><span class=\"o\">:</span> <span class=\"n\">run</span> <span class=\"s2\">\"git rebase --skip\"</span><span class=\"bp\">.</span>\n<span class=\"n\">hint</span><span class=\"o\">:</span> <span class=\"n\">To</span> <span class=\"n\">abort</span> <span class=\"n\">and</span> <span class=\"n\">get</span> <span class=\"n\">back</span> <span class=\"n\">to</span> <span class=\"n\">the</span> <span class=\"n\">state</span> <span class=\"n\">before</span> <span class=\"s2\">\"git rebase\"</span><span class=\"o\">,</span> <span class=\"n\">run</span> <span class=\"s2\">\"git rebase --abort\"</span><span class=\"bp\">.</span>\n<span class=\"n\">Could</span> <span class=\"n\">not</span> <span class=\"n\">apply</span> <span class=\"mi\">8</span><span class=\"n\">bbccf027f...</span> <span class=\"n\">use</span> <span class=\"n\">type</span> <span class=\"n\">synonyms</span><span class=\"o\">,</span> <span class=\"n\">group</span> <span class=\"n\">seminorms'</span>\n</code></pre></div>",
        "id": 297962597,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662726901
    },
    {
        "content": "<p>Ah yes, that's different. You will have to fix conflicts by hand. I can do it if you promise me not to touch the branch for the next half hour</p>",
        "id": 297963203,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662727108
    },
    {
        "content": "<p>Alright, informing <span class=\"user-mention\" data-user-id=\"303675\">@Anand Rao</span> too, thanks!</p>",
        "id": 297963373,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662727182
    },
    {
        "content": "<p>Done!</p>",
        "id": 297964226,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1662727454
    },
    {
        "content": "<p>quick half hour, thanks a lot!</p>",
        "id": 297964331,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1662727491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Geometric.20group.20theory/near/297311453\">said</a>:</p>\n<blockquote>\n<p>And now I want to start working on Bass-Serre theory, and for this I'd welcome some opinions:</p>\n<ul>\n<li>\n<p>I was thinking of starting with <em><a href=\"https://londmathsoc.onlinelibrary.wiley.com/doi/abs/10.1112/jlms/s2-13.1.145\">The fundamental groupoid of a graph of groups</a></em> by Higgins. <br>\n  It seems to work at a nice abstraction level, but:</p>\n</li>\n<li>\n<p>This relies on presentations of groupoids, e.g. <em><a href=\"https://www.cambridge.org/core/journals/mathematical-proceedings-of-the-cambridge-philosophical-society/article/abs/presentations-of-groupoids-with-applications-to-groups/BEB206703D950FA10E18DD51CB52F019\">Presentations of groupoids, with applications to groups</a></em> by Higgins also.</p>\n</li>\n</ul>\n<p>As far as I could find, there is essentially no code for presentations of groupoids in mathlib: the closest is the code for Nielsen-Schreier; but <code>category_theory.path_category</code> and <code>category_theory.quotient</code> should provide good building blocks.<br>\nDoes it make sense to start this low down the hierarchy and actually take the time to define presentations of groupoids, and then go up again via Higgins' paper, to, eventually, start working on Bass-Serre, or is a hands-on approach (maybe even forsaking groupoids) more reasonable?</p>\n<p>The paper <em>Presentations of groupoids…</em> actually has Nielsen-Schreier and Kurosh as applications, which makes me believe that it might not be a bad idea to start here: we can already get non-trivial stuff from that approach, and in any case, I guess presentations of groupoids might prove useful more generally than for Bass-Serre?</p>\n</blockquote>\n<p>Chapter IV of Bourbaki's Topologie algébrique has another result on these lines, which looks more general than Higgins, at least it is framed in terms of coequalizers of groupoids. With applications to  the van Kampen theorem where they give formulas that I do not think exist at other places.</p>",
        "id": 298517922,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1663048497
    },
    {
        "content": "<p>I'll take things slow and start with trying to mimick the <code>subgroup</code> API for <code>subgroupoids</code></p>",
        "id": 298994764,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663255822
    },
    {
        "content": "<p>Can't you just use <code>subobject C</code> where <code>C</code> is a groupoid ?</p>",
        "id": 299014323,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663261707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I imagine that word \"just\" is standing in for various design tradeoffs and how you imagine subobjects working in general. Would you mind elaborating? (That's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject\">docs#category_theory.subobject</a> correct?)</p>",
        "id": 299019424,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663263537
    },
    {
        "content": "<p>It seems to me that it's easier to work with explicit subsets rather than isomorphism classes of monomorphisms, sort of like how for simple graphs we can represent a subgraph as a subset of vertices and a sub-relation. Maybe it's workable building up API around <code>category_theory.subobject</code> for concrete categories, to let you ignore the quotient in practice.</p>",
        "id": 299020129,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663263780
    },
    {
        "content": "<p>That wasn't a rhetorical question! What I have in mind, in decreasing order of preference and increasing of boilerplate, is:</p>\n<ol>\n<li>We can just use <code>subobject C</code> and its API</li>\n<li>We can just use <code>subobject C</code> but we need specific API </li>\n<li>We introduce a new structure for subgroupoids, show its equivalence to <code>subobject C</code> and use the <code>subobject</code> API through that equivalence</li>\n<li>We introduce a new structure for subgroupoids, show its equivalence to <code>subobject C</code> and transfer the <code>subobject</code> API through that equivalence</li>\n<li>We introduce a new structure for subgroupoids, build its API separately, and possibly show its equivalence to <code>subobject C</code></li>\n<li>We introduce a new structure for subgroupoids that's not equivalent to <code>subobject C</code>, and build its API separately</li>\n</ol>",
        "id": 299021578,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1663264302
    },
    {
        "content": "<p>uh, I was heading in <a href=\"https://github.com/bottine/Bass-Serre/blob/5194d4ac1f55bab3df469c9c4c3834837d4f3097/src/groupoid_presentation.lean#L137\">this</a> direction. which I now understand not to be ideal.</p>",
        "id": 299022850,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663264730
    },
    {
        "content": "<p>But both groups and graphs are sort of following this pattern, so I thought I was safe. Aren't I?</p>",
        "id": 299022910,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663264754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461830\">@Rémi Bottinelli</span> That's a nice encoding trick you have, where the existence of an identity arrow corresponds to whether an object is present in the subgroupoid. I wonder if it would make sense, though, to introduce <code>subquiver</code> and have <code>subgroupoid</code> extend that? Or maybe you keep it the same but have it extend <a href=\"https://leanprover-community.github.io/mathlib_docs/find/wide_subquiver\">docs#wide_subquiver</a>? (I'm not sure if this leads to any issues.)</p>",
        "id": 299030921,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663267566
    },
    {
        "content": "<p>I think Yael's suggestion is reasonable but more on the speculative end of things -- <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Do we have much experience in mathlib with defining subobjects using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject\">docs#category_theory.subobject</a>? I think we understand how to create subobjects using custom structures fairly well.</p>",
        "id": 299031563,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1663267810
    },
    {
        "content": "<p>Using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.subobject\">docs#category_theory.subobject</a> is great if all you care about is the lattice structure of the type of subobjects, but I think making a custom structure is a better approach whenever you want to work with <em>actual elements</em> of the subobject.</p>",
        "id": 299043575,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1663272394
    },
    {
        "content": "<p>What would <code>subquiver</code> bring to the table? I think in that case we would lose the \"trick\" you're refering to, right?</p>",
        "id": 299130355,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663323440
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 299158808,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663334355
    },
    {
        "content": "<p>I'm working on the free groupoid and have a question:<br>\nI've defined a custom inductive type of \"words\" on my initial quiver as <a href=\"https://github.com/bottine/Bass-Serre/blob/be28357e39b05f756b58bdc1e4870cde6cbcfa31/src/free_groupoid.lean#L26\">here</a> but there is also <code>quiver.path</code> and <code>quiver.symmetrify</code>.<br>\nThe problem with using <code>quiver.path</code> and <code>quiver.symmetrify</code> is mostly that I have to deal with the type synonym introduced by <code>quiver.symmetrify</code>.</p>\n<p>Should I work with what's already here anyway?</p>",
        "id": 300116767,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1663842246
    },
    {
        "content": "<p>Just wanna let you geometric group theory folks know about the <a href=\"https://github.com/leanprover-community/mathlib/search?q=author%3Amatthias567+is%3Apr&amp;type=issues\">amenable group PRs</a> (<a href=\"#narrow/stream/113489-new-members/topic/Amenable.20Groups/near/300269636\">Zulip discussion</a>); maybe you would be interested in helping reviewing them? The code looks like it needs to go through a lot of revisions, but firstly we need to make some design decisions. The references listed in the PRs are:</p>\n<ul>\n<li>[C. Löh, <em>Geometric Group Theory</em>, Definition 9.1.1][loeh17]</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Amenable_group\">https://en.wikipedia.org/wiki/Amenable_group</a></li>\n<li>[A.L.T. Paterson, <em>Amenability</em>, Definition 0.2][Paterson1988]</li>\n</ul>",
        "id": 300279031,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1663899266
    },
    {
        "content": "<p>Heads up that <a href=\"https://github.com/leanprover-community/mathlib/pull/15705\">#15705</a> is in, so we now can PR marked groups and such!</p>",
        "id": 302750296,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665094419
    },
    {
        "content": "<p>Great! For now I'm busy trying to deal with groupoids and eventually Bass-Serre hopefully. <br>\nThere was a discussion about marked groups perhaps not being the best place to start with the geometry of groups: is there a consensus on that?</p>\n<p>By the way, I noticed I'm starting to use quivers quite extensively, and will probably use them to do graph theory: say talk about the existence of maximal trees, etc. There already was <code>[has_reverse]</code> on quivers, and I added <code>[has_involutive_reverse]</code> and now I feel this is dangerously close to simply talking of graphs. <br>\nWould it make sense to take this as an opportunity to make this the official definition of \"unoriented multigraph\" ? (opinion, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> ?)</p>",
        "id": 303100218,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665300448
    },
    {
        "content": "<p>Do you know about <a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a>?</p>",
        "id": 303100292,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665300506
    },
    {
        "content": "<p>I didn't, no! hum, this makes my stuff quite redundant… Why not base it on quivers?</p>",
        "id": 303100359,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665300593
    },
    {
        "content": "<p>There are several reasons, really. But I think both approaches are viable.</p>",
        "id": 303100448,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665300643
    },
    {
        "content": "<p>I like using quivers since it allows a natural \"symmetrization\", and <del>you have fewer equalities to deal with</del> <strong>I'm used to it already</strong>, in some sense… I assume changing the implementation of <code>multigraphs</code> isn't acceptable? What do you recommend I do, then?</p>",
        "id": 303100550,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665300753
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16100\">#16100</a> is just experimental, but I do not believe your \"there are fewer equalities to deal with\". Multigraphs are so that you should never need defeq on the type of edges.</p>",
        "id": 303100579,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665300791
    },
    {
        "content": "<p>I see, yeah. I wanted to use the \"Serre\" definition of graphs to begin with, but after looking at what they do in Bass-Serre, it's always orientation-preserving actions (and the involution on edges has no fixed points), meaning you can just choose an orientation and be done with it: hence quivers.</p>",
        "id": 303100917,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665301093
    },
    {
        "content": "<p>OK, so what's the way forward with this, and how can I help it making progress?</p>\n<p>Note also that the quiver definition make the passage to categories very easy but with this custom definition you need to add more glue code as far as I can see.</p>",
        "id": 303199004,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665379879
    },
    {
        "content": "<p>Something else I'd like to get some opinions on: I need to talk about \"free products\" and quotients of groupoids. My first instinct was to define this by hand, but actually I see that there is code for <code>Cats</code> and <code>Groupoids</code> talking about limits and such, and I'm wondering how much of the existing tooling I should/can use.</p>\n<ul>\n<li>If I'm not mistaken, I can take limits/colimits in <code>Cats</code> and they'll actually also define limits/colimits in <code>Groupoids</code> (that's a general mathematical statement, not talking about mathlib).</li>\n<li>On the other hand, I actually don't see that <code>Cats</code> has coequalizers in mathlib, is that right?</li>\n<li>Also, I'm wondering if defining those construction via \"the category of …\" will involve much more boilerplate than defining them by hand.</li>\n</ul>\n<p>So, in short, where should I draw the line, and what's the correct way to proceed here?</p>",
        "id": 303261952,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665409164
    },
    {
        "content": "<p>Limits in Cat was done by Joseph Hua <a href=\"#narrow/stream/116395-maths/topic/1-limits.20in.20Cat\">in this thread</a> back in February, but was added to mathlib by <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> in March in <a href=\"https://github.com/leanprover-community/mathlib/pull/12979\">#12979</a>, maybe using a different approach, I didn't check. I'm pretty sure we don't have colimits yet, given that category_theory.category.Cat.limit has no siblings in the same directory.</p>",
        "id": 303293013,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665420152
    },
    {
        "content": "<p>(Sorry, I had completely missed Joseph's thread, I think.)</p>",
        "id": 303336296,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665442987
    },
    {
        "content": "<p>As an aside, there is something I don't totally get with the organization of mathlib. <br>\nWhat does the organization wrt \"what should be included in what order using which construction\" look like?<br>\nThis might be a bit naive of my part, but it feels like it's some kind of a big soup of people contributing what they feel like and reviewers accepting on a case-by-case basis without much \"long-term\"/organizational thought. I'd expect to see some kind of hierarchy of subjects, with working groups deciding on the design and strategy of the subject in a way that makes it harder for people to work blindly on something that will be useless or already worked on. I don't want to spit in the soup, and am very grateful to everyone involved for the coaching and help in getting stuff included, but I'm wondering if these is some margin for streamlining of the process?</p>",
        "id": 303403113,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665486286
    },
    {
        "content": "<p>Have you seen <a href=\"#narrow/stream/113488-general/topic/mathlib.20organization\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/mathlib.20organization</a> ?</p>",
        "id": 303404023,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665486691
    },
    {
        "content": "<p>I have, but missed the \"teams\" part. <br>\nIt's indeed part of what I'm talking about, but doesn't seem to cover a more involved hierarchy of subjects and plans as for how to cover them, does it? Is having such a specified plan just too ambitious and bureaucratic, and a risk of killing the \"organic\" flow mathlib is currently working with?</p>",
        "id": 303405784,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1665487356
    },
    {
        "content": "<p>I'd think that the current canonical answer to \"How to prevent oneself from working blindly on something that will be useless or already worked on\" is to ask on zulip before starting.</p>",
        "id": 303406425,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665487600
    },
    {
        "content": "<p>I think the answer is mostly that the \"long-term organizational thought\" doesn't actually come to much without someone able/willing to write the code, and so we mostly prefer to let mathlib grow organically according to what people actually want to write.</p>\n<p>We're mostly extremely liberal on what counts as \"appropriate to mathlib\", with occasional exceptions.</p>\n<p>That said, I think there is a lot of \"organizational planning\" that happens off in branches, and during the PR process. It's not at all unusual that it takes several developments of the same material before it actually makes it into mathlib.</p>",
        "id": 303539257,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665532878
    },
    {
        "content": "<p>Perhaps they are underutilized, but we also have <a href=\"https://github.com/leanprover-community/mathlib/projects?query=is%3Aopen\">projects</a> on GitHub for this sort of thing.</p>",
        "id": 303550774,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1665542221
    },
    {
        "content": "<p>Hey, so I've finally managed to get the quotient construction for groupoids working, and thus presentations.<br>\nMy construction for the quotient is perhaps unorthodox, in that (as said above) I first quotient by the isotropy groups only, which means no collapsing of vertices, and then quotient by what remains, which is always <code>graph_like</code> i.e. has at most one edge between two vertices.</p>\n<p>I'd be thankful if someone could have a look at the <a href=\"https://github.com/leanprover-community/mathlib/compare/master...bottine:mathlib:bottine/quotient_groupoids?expand=1\">code here</a> and tell me if it's worth cleaning up to make a PR, of if this approach is considered too dirty.</p>",
        "id": 305115200,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1666259977
    }
]
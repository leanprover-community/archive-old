[
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/issues/10509\">#10509</a>, Bhavik and I are computing small Roth numbers. The <code>n</code>-th Roth number is the size of the largest subset of <code>finset.range n</code> which doesn't contain arithmetic progressions of length 3 (aka Salem-Spencer set). Our current decidability instances (aka algorithms <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>) for <code>roth_number_nat n ≤ m</code> run in <code>O (n.choose m * m^2)</code>. Can we do better?</p>",
        "id": 263729893,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638649859
    },
    {
        "content": "<p>One idea would be to define inductively the maximal (wrt inclusion) Salem-Spencer subsets of a finset. This can work quite quickly because you know that a maximal Salem-Spencer subset of <code>insert a s</code> is a maximal Salem-Spencer subset of <code>s</code> with eventually <code>a</code> added.</p>",
        "id": 263730223,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638650306
    },
    {
        "content": "<p>And we can trim further by restricting to maximal Salem-Spencer subsets but this time wrt card. It happens that quite often there's a unique such maximal subset, which can speed up subsequent calculations.</p>",
        "id": 263730329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638650500
    },
    {
        "content": "<p>I guess this is a question to <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, how much can we get out of working over lists rather than finsets, and is there any way we can speed up using some lazy evaluation or related black magic?</p>",
        "id": 263730528,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638650798
    },
    {
        "content": "<p>Not exactly sure what the algorithm is, but it sounds like it's possible to do better</p>",
        "id": 263730594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638650912
    },
    {
        "content": "<p>You probably don't need to do anything fancy with lazy evaluation, and it doesn't make much difference whether you are working over finsets or lists but lists are generally easier to work with</p>",
        "id": 263730616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638650958
    },
    {
        "content": "<p>also you don't want to use <code>insert</code> to build a finset unless you have to</p>",
        "id": 263730623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638650991
    },
    {
        "content": "<p>What would you use instead of <code>insert</code>?</p>",
        "id": 263730730,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638651124
    },
    {
        "content": "<p><code>cons</code></p>",
        "id": 263730760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638651133
    },
    {
        "content": "<p>Ah sure!</p>",
        "id": 263730765,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638651142
    },
    {
        "content": "<p>Another perk of lists is that you can use the underlying order on the elements to cut down by a factor of 3 or 6 the amount of computation required.</p>",
        "id": 263730882,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638651351
    },
    {
        "content": "<p>I can't tell if this is correct. It seems to be unique all the time</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">check</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.all</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">check</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">[])]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">ls</span> <span class=\"o\">:=</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"n\">n</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">candidates</span> <span class=\"o\">:=</span> <span class=\"n\">ls.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">check</span> <span class=\"n\">n</span> <span class=\"n\">p.2</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">maxlen</span> <span class=\"o\">:=</span> <span class=\"n\">candidates.foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"n\">a</span> <span class=\"n\">l.1</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"k\">in</span>\n  <span class=\"n\">candidates.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">=</span> <span class=\"n\">maxlen</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"mi\">80</span>\n<span class=\"c1\">-- [(59, [79, 78, 77, 74, 73, 71, 70, 69, 67, 66, 65, 62, 61, 59, 58, 57, 56, 55, 54, 53, 51, 48, 47, 46,</span>\n<span class=\"c1\">--    43, 42, 41, 40, 39, 38, 37, 35, 34, 33, 31, 30, 29, 27, 26, 24, 23, 22, 21, 19, 17, 16, 15, 14, 13, 11, 10, 8, 7, 6, 5, 3, 2, 1, 0])]</span>\n</code></pre></div>",
        "id": 263731611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638652362
    },
    {
        "content": "<p>I know it should be unique at 14, not unique for 15,16,17 or 18, and not unique at a few points below that too; it's definitely not unique at 4: {0,1,3} and {0,2,3} both work</p>",
        "id": 263731780,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638652612
    },
    {
        "content": "<p>It's worth adding that there has been research on this from the computer science side: eg <a href=\"https://www.cs.umd.edu/~gasarch/papers/3apI.pdf\">https://www.cs.umd.edu/~gasarch/papers/3apI.pdf</a></p>",
        "id": 263732002,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638652812
    },
    {
        "content": "<p>There is an important difference however in that to prove lower bounds we can just provide an example (computed by someone else), but to prove upper bounds we'd need to re-do the search in Lean (or find some clever other method, which is itself hard)</p>",
        "id": 263732087,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638652945
    },
    {
        "content": "<p><code>check</code> should use addition instead of multiplication. Otherwise it looks correct to me</p>",
        "id": 263732318,
        "sender_full_name": "David Wärn",
        "timestamp": 1638653176
    },
    {
        "content": "<p>The numbers all seem to match the computations in the PR but it's definitely not finding all the solutions</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">check</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.all</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">check</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">[(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">[])]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">let</span> <span class=\"n\">ls</span> <span class=\"o\">:=</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"n\">n</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">candidates</span> <span class=\"o\">:=</span> <span class=\"n\">ls.map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">check</span> <span class=\"n\">n</span> <span class=\"n\">p.2</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">p.1</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">::</span><span class=\"n\">p.2</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"k\">in</span>\n  <span class=\"k\">let</span> <span class=\"n\">maxlen</span> <span class=\"o\">:=</span> <span class=\"n\">candidates.foldl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">max</span> <span class=\"n\">a</span> <span class=\"n\">l.1</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"k\">in</span>\n  <span class=\"n\">candidates.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p.1</span> <span class=\"bp\">=</span> <span class=\"n\">maxlen</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"mi\">50</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mmap</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">p</span> <span class=\"o\">:=</span> <span class=\"n\">maximal_salem_spencer</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">tactic.trace</span> <span class=\"n\">sformat</span><span class=\"bp\">!</span><span class=\"s2\">\"roth {n} = {p.head.1}, {p.length} solutions\"</span><span class=\"o\">)</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">roth</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">3</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">4</span> <span class=\"bp\">=</span> <span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">5</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">6</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">7</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">8</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">9</span> <span class=\"bp\">=</span> <span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">10</span> <span class=\"bp\">=</span> <span class=\"mi\">5</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">11</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">12</span> <span class=\"bp\">=</span> <span class=\"mi\">6</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">13</span> <span class=\"bp\">=</span> <span class=\"mi\">7</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n<span class=\"n\">roth</span> <span class=\"mi\">14</span> <span class=\"bp\">=</span> <span class=\"mi\">8</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"n\">solutions</span>\n</code></pre></div>",
        "id": 263732327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638653192
    },
    {
        "content": "<p>In the example for 4, the issue is that {0, 2} is not marked as a maximal set for n = 3 because it is not obtained by adding 2 to a maximal set for n = 2</p>",
        "id": 263732438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638653305
    },
    {
        "content": "<p>Oh, so you need to keep track of all maximal sets wrt inclusion.</p>",
        "id": 263732475,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638653385
    },
    {
        "content": "<p><code>roth 51</code> should be 17, for example - but <code>maximal_salem_spencer</code> computes 16</p>",
        "id": 263732588,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638653522
    },
    {
        "content": "<p>Wait, that doesn't work either <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 263732637,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638653546
    },
    {
        "content": "<p>Even removing the max size restriction doesn't help, because {0} is not maximal wrt inclusion for n = 2 but it participates in a maximal set for n = 3</p>",
        "id": 263732640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638653548
    },
    {
        "content": "<p>So what's true is that if the Roth number increases, then the new maximal Salem-Spencer subsets come from previous ones.</p>",
        "id": 263732688,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638653613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263732588\">said</a>:</p>\n<blockquote>\n<p><code>roth 51</code> should be 17, for example - but <code>maximal_salem_spencer</code> computes 16</p>\n</blockquote>\n<p><code>1 2 4 5 10 13 14 17 31 35 37 38 40 46 47 50 51</code> (1-indexed rather than 0-indexed, sorry) is an example</p>",
        "id": 263732742,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638653672
    },
    {
        "content": "<p>And if it doesn't increase, then it comes from a previous maximal subset, or a previous almost maximal subset</p>",
        "id": 263732771,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638653717
    },
    {
        "content": "<p>maybe the candidates need to consider not just <code>n :: l</code> where l is from the previous set but also <code>n :: (l \\ a)</code> where a is an element from l</p>",
        "id": 263732777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638653733
    },
    {
        "content": "<p>May I point you to the paper I linked above to save some time, since there are some algorithms given to do these computations (eg in section 6 - also section 9 talks about a dynamic program which I think is similar to the one above)</p>",
        "id": 263732866,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638653864
    },
    {
        "content": "<p>I think this is a rendering of the BASIC2 algorithm from the paper:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">three_free</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">l.all</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">three_free</span> <span class=\"n\">a</span> <span class=\"n\">l</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth_aux</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">::</span> <span class=\"n\">sz</span><span class=\"o\">)</span> <span class=\"n\">n</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n  <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"bp\">≥</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"n\">roth_aux</span> <span class=\"n\">sz</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">||</span>\n  <span class=\"o\">(</span><span class=\"n\">three_free</span> <span class=\"n\">n</span> <span class=\"n\">α</span> <span class=\"bp\">&amp;&amp;</span> <span class=\"k\">match</span> <span class=\"n\">d</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n    <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">d'</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">roth_aux</span> <span class=\"n\">sz</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">::</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n    <span class=\"kd\">end</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"o\">[])</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">let</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">roth</span> <span class=\"n\">n</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"k\">if</span> <span class=\"n\">roth_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">a</span> <span class=\"o\">[]</span> <span class=\"k\">then</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n\n<span class=\"k\">#eval</span> <span class=\"o\">(</span><span class=\"n\">roth</span> <span class=\"mi\">40</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">reverse.enum</span>\n<span class=\"c1\">-- [(0, 0), (1, 1), (2, 2), (3, 2), (4, 3), (5, 4), (6, 4), (7, 4), (8, 4), (9, 5), (10, 5), (11, 6), (12, 6), (13, 7), (14, 8), (15, 8),</span>\n<span class=\"c1\">--  (16, 8), (17, 8), (18, 8), (19, 8), (20, 9), (21, 9), (22, 9), (23, 9), (24, 10), (25, 10), (26, 11), (27, 11), (28, 11), (29, 11), (30, 12),</span>\n<span class=\"c1\">--  (31, 12), (32, 13), (33, 13), (34, 13), (35, 13), (36, 14), (37, 14), (38, 14), (39, 14)]</span>\n</code></pre></div>",
        "id": 263735966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638657922
    },
    {
        "content": "<p>unfortunately it times out before getting to 51</p>",
        "id": 263735972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638657953
    },
    {
        "content": "<p>That's already much better than we what we currently have! Ours times out at 15.</p>",
        "id": 263736300,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638658439
    },
    {
        "content": "<p>oh hey, I ran it at the console and it gave <code>roth 51 = 17</code></p>",
        "id": 263736769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659028
    },
    {
        "content": "<p>after 49 seconds</p>",
        "id": 263736815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659049
    },
    {
        "content": "<p>I leave the proof of correctness as an exercise to the reader :D</p>",
        "id": 263736854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659140
    },
    {
        "content": "<p>This ios gonna be a tough one <span aria-label=\"cold sweat\" class=\"emoji emoji-1f630\" role=\"img\" title=\"cold sweat\">:cold_sweat:</span></p>",
        "id": 263736946,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638659273
    },
    {
        "content": "<p>Is there any reason to use <code>bool</code> here? Does it compute faster somehow?</p>",
        "id": 263737228,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638659655
    },
    {
        "content": "<p>faster than what?</p>",
        "id": 263737238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659671
    },
    {
        "content": "<p>than <code>Prop</code></p>",
        "id": 263737254,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638659707
    },
    {
        "content": "<p>prop doesn't compute at all; you would have to write a decidability instance on top of this, which would more than double the length (more because the decidability instance is dependent over the original function so it has to do a bunch of cases and simp stuff)</p>",
        "id": 263737307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659770
    },
    {
        "content": "<p>you can think of <code>bool</code> as being a cheap way to bundle a prop with its decidability instance</p>",
        "id": 263737321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659812
    },
    {
        "content": "<p>Also, I want to be very sure that the <code>&amp;&amp;</code> and <code>||</code> are short circuiting here, otherwise the algorithm doesn't work at all</p>",
        "id": 263737333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638659855
    },
    {
        "content": "<p>Aaah okay. I had never seen how both ways of computing relate. And, to be honest, I had no idea how to compute anything remotely nontrivial until 4 days ago.</p>",
        "id": 263737383,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638659906
    },
    {
        "content": "<p>ANd what's the correct way to get information out of a <code>bool</code>? That is, what should my lemma relating <code>roth_number_nat</code>/|<code>add_salem_spencer</code> and your <code>roth</code> be writing? <code>a = tt</code>?</p>",
        "id": 263737454,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638660029
    },
    {
        "content": "<p>there are coercions both ways and simp lemmas every which way, so you don't have to acknowledge the difference for the most part</p>",
        "id": 263737472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638660090
    },
    {
        "content": "<p>So something like <code>salem_spencer _ ↔ three_free _ </code> will do?</p>",
        "id": 263737528,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638660175
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">roth_number_nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 263737537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638660210
    },
    {
        "content": "<p>Is it better in lean 4?</p>",
        "id": 263737542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1638660235
    },
    {
        "content": "<p>Yeah sure, but what about <code>three_free</code>? I will ned to prove that <code>three_free</code> is equivalent to <code>add_salem_spencer</code> to prove correctness of the algorithm.</p>",
        "id": 263737669,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638660413
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">↔</span> <span class=\"n\">three_free</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 263737738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638660502
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">list.chain'</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">α.length</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"n\">roth_aux</span> <span class=\"o\">((</span><span class=\"n\">list.range</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">roth_number_nat</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">β</span> <span class=\"bp\">→</span>\n    <span class=\"n\">add_salem_spencer</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">nat.card</span> <span class=\"n\">β</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 263738289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638661435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263736300\">said</a>:</p>\n<blockquote>\n<p>That's already much better than we what we currently have! Ours times out at 15.</p>\n</blockquote>\n<p>This is more awkward than I expected; our original one computes via #eval at 17 (maybe 18); but <code>:= rfl</code> or <code>:= dec_trivial</code> times out instead, similarly <code>(roth 40).1 = 15 := dec_trivial</code> doesn't work either :/</p>",
        "id": 263743109,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638668704
    },
    {
        "content": "<p>Nonetheless the new version does get further than my crappy version in both metrics</p>",
        "id": 263743148,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638668763
    },
    {
        "content": "<p>Is there any way to reuse calculations from one lemma for another? This would clearly come in handy here.</p>",
        "id": 263758509,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638695523
    },
    {
        "content": "<p>If there were a lemma which stated the result of some calculations, then a later lemma wouldn't need to repeat them since they'd been proved</p>",
        "id": 263776215,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638721739
    },
    {
        "content": "<p>Yes of course, but I was fearing that the results would be too long to state.</p>",
        "id": 263776494,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638722103
    },
    {
        "content": "<p>While I was under the Channel I figured out that Mario's version is compact enough for this.</p>",
        "id": 263776608,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638722217
    },
    {
        "content": "<p>Okay, I managed to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">three_free_spec</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">three_free</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>This was Not So Fun.  Also, why is <code>add_salem_spencer {n | n ∈ l}</code> needed?</p>",
        "id": 263821660,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638780509
    },
    {
        "content": "<p>This is becoming big, so I'm gonna get rid of the <code>explicit_values</code> bit of the PR.</p>",
        "id": 263821864,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638780650
    },
    {
        "content": "<p>because <code>add_salem_spencer</code> is about sets while <code>three_free</code> is about lists. Alternatively, you could coerce the list to a finset and then to a set, but there isn't a coercion from lists directly to sets at the moment.</p>",
        "id": 263833989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788310
    },
    {
        "content": "<p>I'm curious what your proof was, because it seems like it wouldn't be <em>that</em> bad</p>",
        "id": 263834034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788339
    },
    {
        "content": "<p>In fact, it might help to have a theorem about <code>add_salem_spencer (insert a s)</code> and apply it here</p>",
        "id": 263834118,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788381
    },
    {
        "content": "<p>I did add a theorem <code>add_salem_spencer_insert</code> to reduce the number of cases to check from 3 (new element on the left of the LHS, on the right of the LHS, on the RHS) to 2 (on the LHS, on the RHS).</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>The proof</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\"><pre><span></span><code>lemma three_free_spec (hl : chain (&gt;) a l) (h₁ : add_salem_spencer {n | n ∈ l}) :\n  three_free a l ↔ add_salem_spencer {n | n ∈ a :: l} :=\nbegin\n  induction l with d l ih,\n  { refine iff_of_true rfl _,\n    simp_rw [mem_singleton, set.set_of_eq_eq_singleton],\n    exact add_salem_spencer_singleton a },\n  have : {n : ℕ | n ∈ a :: d :: l} = insert d {n : ℕ | n ∈ a :: l},\n  { ext,\n    simp only [set.mem_insert_iff, mem_cons_iff, set.mem_set_of_eq],\n    exact or.left_comm },\n  rw [this, three_free, bool.band_comm, band_coe_iff, bool.coe_all,\n    ih (hl.mono $ sublist_cons _ _) (h₁.mono $ l.subset_cons _), add_salem_spencer_insert],\n  simp_rw bool.coe_to_bool,\n  refine and_congr_right (λ hl&#39;, ⟨λ hs, ⟨_, _⟩, _⟩),\n  { rintro b c (rfl | hb) (rfl | hc),\n    { exact add_right_cancel },\n    { rintro h,\n      cases hl with _ _ _ _ hdb hl,\n      have hcd : c &lt; d := hl.rel hc,\n      exact ((add_lt_add hcd $ hcd.trans hdb).ne&#39; h).elim },\n    { exact λ h, ((add_lt_add (rel_of_chain_cons hl : c &gt; d) $\n        hl.rel $ mem_cons_of_mem _ hb).ne h).elim },\n    { exact h₁ (mem_cons_self _ _) (mem_cons_of_mem _ hb) (mem_cons_of_mem _ hc) } },\n  { rintro b c (rfl | hb) (rfl | hc),\n    { exact λ _, rfl },\n    { exact λ h, (hs _ hc h).elim },\n    { exact λ h, (hs _ hb $ (add_comm _ _).trans h).elim },\n    { exact h₁ (mem_cons_of_mem _ hb) (mem_cons_of_mem _ hc) (mem_cons_self _ _) } },\n  { rintro ⟨_, hs⟩ b hb h,\n    have hab : a = b := hs (mem_cons_self _ _) (or.inr hb) h,\n    rw hab at hl h,\n    have hbd : b &gt; d := rel_of_chain_cons hl,\n    exact (add_lt_add hbd hbd).ne&#39; h }\nend\n</code></pre></div>\n</div></div>",
        "id": 263834552,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638788560
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263833989\">said</a>:</p>\n<blockquote>\n<p>because <code>add_salem_spencer</code> is about sets while <code>three_free</code> is about lists.</p>\n</blockquote>\n<p>That explains the notation <code>{n | n ∈ l}</code>, but not why we need the hypothesis, unless you mean because of the order in the list?</p>",
        "id": 263834666,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638788640
    },
    {
        "content": "<p>Also, is this supposed to be true?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">three_free.of_cons'</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">three_free</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">three_free</span> <span class=\"n\">b</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 263834827,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638788720
    },
    {
        "content": "<p>no</p>",
        "id": 263834985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788826
    },
    {
        "content": "<p><code>three_free</code> is checking only whether adding <code>a</code> to <code>l</code> keeps it three-free</p>",
        "id": 263835033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788852
    },
    {
        "content": "<p>Yeah okay that's what I thought. You never check for <code>b</code> on the LHS.</p>",
        "id": 263835132,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638788895
    },
    {
        "content": "<p>also the ordering relation is used to ensure that the only thing we have to check is <code>a + c = b + b</code> and not other permutations of that</p>",
        "id": 263835173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788930
    },
    {
        "content": "<p>but I guess you figured that out already</p>",
        "id": 263835179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638788938
    },
    {
        "content": "<p>Yeah, that's what I was trying to get to before Bhavik sent the paper.</p>",
        "id": 263835213,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638788960
    },
    {
        "content": "<p>do you have an <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> version of that proof? I pulled the PR but I don't have <code>add_salem_spencer_singleton</code>, <code>bool.coe_all</code> and possibly others</p>",
        "id": 263835775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638789267
    },
    {
        "content": "<p>Let me 5min. I'll remove the <code>explicit_values</code> off the PR and put that on a new branch <code>small_roth</code>.</p>",
        "id": 263835829,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638789309
    },
    {
        "content": "<p>I suspect that a lot of the work can be reduced to things like <code>list.pairwise_iff_chain</code> for sorted lists, and expressing the salem spencer property as <code>pairwise</code> of something</p>",
        "id": 263836220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638789556
    },
    {
        "content": "<p>although it's a ternary property which makes it harder</p>",
        "id": 263836242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638789578
    },
    {
        "content": "<p>Pushed!</p>",
        "id": 263836372,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638789652
    },
    {
        "content": "<p>I thought about that, but decided it wasn't worth changing because the list appearing in <code>list.chain</code> (<code>d :: l</code>) has one <code>cons</code> while the one in <code>list.pairwise</code> (<code>a :: d :: l</code>) has two, so you spend more time just looking into it.</p>",
        "id": 263836457,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638789708
    },
    {
        "content": "<p>It's still missing <code>coe_all</code> and <code>list.chain.mono</code>. (BTW for the second one I've inferred the theorem statement</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.chain.mono</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"n\">l'</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">l'</span> <span class=\"bp\">&lt;+</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l.chain</span> <span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">l'.chain</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>but I would have preferred this name to be dealing with monotonicity wrt <code>R</code>.)</p>",
        "id": 263837820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638790653
    },
    {
        "content": "<p><code>bool.coe_all</code> and <code>list.chain.mono</code> are in namespaces at lines 53 and 83 respectively.</p>",
        "id": 263838008,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638790794
    },
    {
        "content": "<p>i'll be happy to rename <code>list.chain.mono</code> into <code>list.chain.sublist</code> because it's also clearer that it's monotonicity wrt <code>list.sublist</code>, not <code>list.prefix</code> or <code>list.suffix</code>.</p>",
        "id": 263838124,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638790858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263838008\">said</a>:</p>\n<blockquote>\n<p><code>bool.coe_all</code> and <code>list.chain.mono</code> are in namespaces at lines 53 and 83 respectively.</p>\n</blockquote>\n<p>in the <code>salem_spencer</code> PR? I don't see it.</p>",
        "id": 263838340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638791000
    },
    {
        "content": "<p>No, in <a href=\"https://github.com/leanprover-community/mathlib/tree/small_roth\">branch#small_roth</a></p>",
        "id": 263838460,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638791062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263835829\">said</a>:</p>\n<blockquote>\n<p>Let me 5min. I'll remove the <code>explicit_values</code> off the PR and put that on a new branch <code>small_roth</code>.</p>\n</blockquote>\n<p>Sorry you must've missed that</p>",
        "id": 263838480,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638791084
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263737537\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">list.range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">roth_number_nat</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This is missing a <code>reverse</code>. <code>list.range</code> goes the wrong way.</p>",
        "id": 263843218,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638794199
    },
    {
        "content": "<p><code>list.iota</code> might work then</p>",
        "id": 263844370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638794812
    },
    {
        "content": "<p>it might be off by one</p>",
        "id": 263844416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638794834
    },
    {
        "content": "<p>What is each variable in <code>roth_aux</code> supposed to represent?</p>",
        "id": 263847652,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638796539
    },
    {
        "content": "<p>Here's a shorter proof for <code>three_free_spec</code> making more use of <code>pairwise</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">list.forall_of_forall_of_pairwise_flip</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₂</span> <span class=\"o\">:</span> <span class=\"n\">pairwise</span> <span class=\"n\">R</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H₃</span> <span class=\"o\">:</span> <span class=\"n\">pairwise</span> <span class=\"o\">(</span><span class=\"n\">flip</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">three_free_spec</span> <span class=\"o\">(</span><span class=\"n\">hl</span> <span class=\"o\">:</span> <span class=\"n\">chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n  <span class=\"n\">three_free</span> <span class=\"n\">a</span> <span class=\"n\">l</span> <span class=\"bp\">↔</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">transitivity</span> <span class=\"n\">list.pairwise</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">≠</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">clear</span> <span class=\"n\">hl</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">l</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">three_free</span><span class=\"o\">,</span> <span class=\"n\">list.pairwise.nil</span><span class=\"o\">,</span> <span class=\"n\">list.pairwise.cons</span><span class=\"o\">,</span> <span class=\"n\">bool.coe_all</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">set.mem_insert_iff</span><span class=\"o\">,</span> <span class=\"n\">mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">set.mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">add_salem_spencer_insert</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">forall_of_forall_of_pairwise_flip</span> <span class=\"n\">_</span> <span class=\"n\">H</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">hc</span> <span class=\"n\">_</span> <span class=\"n\">hb</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">add_lt_add_right</span> <span class=\"o\">(</span><span class=\"n\">hl.rel</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">transitive</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">lt_trans</span> <span class=\"n\">h2</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"o\">(</span><span class=\"n\">pairwise_cons.1</span> <span class=\"o\">((</span><span class=\"n\">chain_iff_pairwise</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hl</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">imp_of_mem</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">add_lt_add</span> <span class=\"o\">(</span><span class=\"n\">hl.rel</span> <span class=\"n\">hc</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">ne_of_lt</span> <span class=\"o\">(</span><span class=\"n\">add_lt_add</span> <span class=\"o\">(</span><span class=\"n\">hl.rel</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hl.rel</span> <span class=\"n\">hc</span><span class=\"o\">))</span> <span class=\"n\">e</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">pairwise.imp_mem.2</span> <span class=\"o\">(</span><span class=\"n\">pairwise_of_forall</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">hc</span> <span class=\"n\">hb</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)),</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">hl.rel</span> <span class=\"n\">hb</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H.2.1</span> <span class=\"n\">hb</span> <span class=\"n\">hc</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 263849034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638797197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span></p>\n<ul>\n<li><code>sz</code> is the list of previous roth values, but only up to a bound <code>s</code> satisfying <code>s + m = n + 1</code>.</li>\n<li><code>n</code> is a constant, and does not actually appear in <code>roth_aux</code>, but <code>s</code> goes down as <code>m</code> goes up.</li>\n<li>In the paper, <code>m</code> corresponds to <code>|α|</code>.</li>\n<li><code>d</code> corresponds to <code>roth n - #α</code>; we're trying to find out if <code>roth (n+1) = roth n</code> or <code>roth (n+1) = roth n + 1</code>, so if <code>d</code> underflows then we're done.</li>\n<li><code>α</code> is the bitstring <code>α</code> from the paper, except that it is represented as a list of nat instead of a 0-1 string, so <code>α.length</code> is <code>#α</code> and <code>|α|</code> has to be tracked separately (that's <code>m</code>).</li>\n</ul>",
        "id": 263850070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638797641
    },
    {
        "content": "<p>You can read a lot of this from the statement of <code>roth_aux_spec</code></p>",
        "id": 263850185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638797684
    },
    {
        "content": "<p>Oh, the statement of <code>roth_aux_spec</code> is wrong, the <code>n</code> at the end should be <code>roth_number_nat n</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">list.chain'</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hm</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">α.length</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">¬</span> <span class=\"n\">roth_aux</span> <span class=\"o\">((</span><span class=\"n\">list.range</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">roth_number_nat</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"bp\">↔</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">β</span> <span class=\"bp\">→</span>\n    <span class=\"n\">add_salem_spencer</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">nat.card</span> <span class=\"n\">β</span> <span class=\"bp\">≤</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 263852601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638798895
    },
    {
        "content": "<p>Here's another way to write <code>roth_aux</code> in terms of a set of lemmas which expresses a nondeterministic computation along the lines of <code>roth_aux</code>. <span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> Do you think it would be easier to prove these lemmas instead of <code>roth_aux_spec</code>? The nondeterminism is a boon, because it means that many things don't have to be checked: any branches of the search that turned out not to matter are not explored.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">list.chain'</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">⊆</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">add_salem_spencer</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">nat.card</span> <span class=\"n\">β</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">α.length</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">d</span> <span class=\"bp\">≥</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">¬</span> <span class=\"n\">three_free</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">d'</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">d'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_succ</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₁_left</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₁_right</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inr</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₂_left</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">three_free</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₂_right</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">::</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_out</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"n\">d</span> <span class=\"o\">[])</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 263853984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638799510
    },
    {
        "content": "<p>This set of lemmas is tuned for proving that <code>roth (n+1) = roth n</code>, because that's the hard case; you can also skip a row of roth numbers that are all the same and only work on the last case before it increases. When the number goes up, it's easy because you just need a counterexample</p>",
        "id": 263854525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638799788
    },
    {
        "content": "<p>What do you mean by \"nondeterministic computation\"? I'm a bit lost by what you're trying to do, I think.</p>",
        "id": 263884441,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638811362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263853984\">said</a>:</p>\n<blockquote>\n<p>Here's another way to write <code>roth_aux</code> in terms of a set of lemmas which expresses a nondeterministic computation along the lines of <code>roth_aux</code>. <span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> Do you think it would be easier to prove these lemmas instead of <code>roth_aux_spec</code>? The nondeterminism is a boon, because it means that many things don't have to be checked: any branches of the search that turned out not to matter are not explored.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∀</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">s</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β.filter</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.to_finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span>\n<span class=\"n\">add_salem_spencer</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">β.card</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">α.length</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_zero</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"mi\">0</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">d</span> <span class=\"bp\">≥</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">¬</span> <span class=\"n\">three_free</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">d'</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">d'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_succ</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₁_left</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">s</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₁_right</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₁</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inr</span> <span class=\"n\">h</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₂_left</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">three_free</span> <span class=\"n\">m</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inl</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux₂_right</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">::</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux₂</span> <span class=\"n\">s</span> <span class=\"n\">m</span> <span class=\"o\">(</span><span class=\"n\">d</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">or.inr</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">roth_ub_aux_out</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"n\">d</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">roth_ub_aux</span> <span class=\"n\">n</span> <span class=\"mi\">0</span> <span class=\"n\">d</span> <span class=\"o\">[])</span> <span class=\"o\">:</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This looks very promising!</p>",
        "id": 263887160,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1638812479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Computing.20Roth.20numbers/near/263884441\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"nondeterministic computation\"? I'm a bit lost by what you're trying to do, I think.</p>\n</blockquote>\n<p>The set of lemmas mentioned there can be used to construct a proof of <code>roth_number_nat n &lt;= d</code> in a fairly obvious way: first apply <code>roth_ub_aux_out</code>, then <code>roth_ub_aux_succ</code>, then for each subgoal apply <code>roth_ub_aux[₁,₂]_left</code> or <code>roth_ub_aux[₁,₂]_right</code>, and keep going until you reach a leaf where you apply <code>roth_ub_aux_zero</code>. This exactly mimics the evaluation of the boolean expression in <code>roth_aux</code>, assuming that it evaluates to <code>ff</code>.</p>\n<p>The part that is nondeterministic here is that unlike <code>roth_aux</code>, there is no \"order of evaluation\" here. In each of the two disjunctions you have a choice of two proofs, but for a boolean function <code>a &amp;&amp; b = ff</code> you have to first evaluate <code>a = ff</code>, or else <code>a = tt</code> and then <code>b = ff</code>. With the nondeterministic version you either evaluate <code>a = ff</code> or <code>b = ff</code>, so the computation of <code>a = tt</code> is saved (a significant win in the case <code>a := three_free a l</code>).</p>\n<p>Furthermore, we also have an advantage in the first conjunct. Evaluating <code>d &lt; s</code> is cheap, so it's not that important to skip it, but in the revised lemmas that is actually a <code>roth_number_nat s ≤ d</code> assumption, which can be a reference to a previously proved theorem. But more powerfully, we can choose to use <code>roth_ub_aux₁_right</code> even when <code>roth_number_nat s ≤ d</code> is true. This is a bunch of extra work so at first it might seem counterproductive, but this can be used in order to skip steps in the Roth sequence.</p>\n<p>For example, <code>roth 9 = 5</code> while <code>roth 5 .. 8 = 4</code>, so to prove all the values in this neighborhood it suffices to give bounds like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">roth</span> <span class=\"mi\">4</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">3</span>\n<span class=\"mi\">4</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">roth</span> <span class=\"mi\">5</span>\n<span class=\"n\">roth</span> <span class=\"mi\">8</span> <span class=\"bp\">&lt;=</span> <span class=\"mi\">4</span>\n<span class=\"mi\">5</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">roth</span> <span class=\"mi\">9</span>\n<span class=\"bp\">...</span>\n</code></pre></div>\n<p>Now consider the proof of <code>roth 8 &lt;= 4</code>, assuming we have the previous lines as lemmas. We don't have a proof that <code>roth 7 &lt;= 4</code> because we are skipping steps, so if it comes up that we need <code>roth 7 &lt;= 4</code> or <code>roth 6 &lt;= 4</code> when evaluating <code>roth_ub_aux₁_left</code>, we can just take the <code>roth_ub_aux₁_right</code> branch instead.</p>",
        "id": 263904866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638819283
    },
    {
        "content": "<p>So you don't mean to actually compute here? But rather to skip branches of the actual computation?</p>",
        "id": 263906091,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1638819471
    },
    {
        "content": "<p>Depends on what you mean by \"actual computation\". The proof term encodes a witness for a nondeterministic computation, while the tactic that produces the proof term executes a deterministic computation (in a significantly more efficient machine model). Depending on how things go even the tactic computation might skip some steps if we choose to evaluate it only at certain values or seed it with witnesses from the paper or some other data constructed e.g. in a CAS. Putting these approaches together you can get significantly further than you would otherwise</p>",
        "id": 263918091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638821878
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, are you sure you didn't make an off by one error in the set of lemma? I think <code>roth_aux_succ</code> is false for <code>a = 0</code>, <code>m = 0</code>, <code>d = 0</code>, <code>l = [0]</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">roth_aux_succ</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">roth_aux₁</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">roth_aux₂</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">roth_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 271704827,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644693044
    },
    {
        "content": "<p>Update: I'm not so sure anymore, but I still fail to understand what made you choose those definitions.</p>",
        "id": 271705926,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644694478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> The idea behind <code>roth_aux</code> deferring to <code>roth_aux₁</code> and <code>roth_aux₂</code> is that the successor case (that is, <code>roth_aux (a+1)</code>) for <code>roth_aux</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">roth_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"bp\">≥</span> <span class=\"n\">roth_number_nat</span> <span class=\"n\">a</span> <span class=\"bp\">∨</span> <span class=\"n\">roth_aux</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n  <span class=\"o\">(</span><span class=\"bp\">¬</span> <span class=\"n\">three_free</span> <span class=\"n\">m</span> <span class=\"n\">l</span> <span class=\"bp\">∨</span> <span class=\"bp\">∃</span> <span class=\"n\">d'</span><span class=\"o\">,</span> <span class=\"n\">d</span> <span class=\"bp\">=</span> <span class=\"n\">d'</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">roth_aux</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">d'</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">::</span> <span class=\"n\">l</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 271709587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644699746
    },
    {
        "content": "<p>How immediate is it to rewrite it as such?</p>",
        "id": 271709611,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644699806
    },
    {
        "content": "<p>In the original algorithm, this was by definition and the hard part with proving that the algorithm's result is in fact constraining the roth number; in this version the result is correct by definition but this equality (actually we only need one direction of implication here) is the hard part</p>",
        "id": 271709692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644699952
    },
    {
        "content": "<p>But it shouldn't be too hard, assuming I got the definition of <code>roth_aux</code> (the algorithm's invariant) correct</p>",
        "id": 271709738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644699996
    },
    {
        "content": "<p>My draft proof is getting longer and longer... and mostly I do not see this head <code>∧</code> in what I'm doing.</p>",
        "id": 271709821,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700113
    },
    {
        "content": "<p>I forget all the details, but I believe that we are trying to prove something about all bit sequences starting with <code>l</code>, and one part of the <code>/\\</code> is proving stuff about the <code>ff::l</code> sequences and the other part is <code>tt::l</code> sequences</p>",
        "id": 271709842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700178
    },
    {
        "content": "<p>So I should case on whether <code>m ∈ l</code> or something.</p>",
        "id": 271709907,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700247
    },
    {
        "content": "<p>er, I guess we encoded them as strictly decreasing lists of numbers instead of bit strings, hence by the second part has <code>m::l</code> and the other has <code>l</code></p>",
        "id": 271709914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700264
    },
    {
        "content": "<p>Currently, I'm casing on <code>roth_aux₁ a m d l</code> and <code>roth_aux₂ a m d l</code>, which yields four cases looking quite distinctly different.</p>",
        "id": 271709929,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700292
    },
    {
        "content": "<p>what's in the context?</p>",
        "id": 271709932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700298
    },
    {
        "content": "<p>Here's the context before casing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">l</span><span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">adm</span><span class=\"o\">:</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">h₁</span><span class=\"o\">:</span> <span class=\"n\">roth_aux₁</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span>\n<span class=\"n\">h₂</span><span class=\"o\">:</span> <span class=\"n\">roth_aux₂</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"n\">l</span>\n<span class=\"n\">hl</span><span class=\"o\">:</span> <span class=\"n\">chain</span> <span class=\"n\">gt</span> <span class=\"n\">m</span> <span class=\"n\">l</span>\n<span class=\"n\">s</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">hs₀</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"n\">m</span>\n<span class=\"n\">hs₁</span><span class=\"o\">:</span> <span class=\"n\">finset.filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">_x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">l.to_finset</span>\n<span class=\"n\">hs₂</span><span class=\"o\">:</span> <span class=\"n\">add_salem_spencer</span> <span class=\"bp\">↑</span><span class=\"n\">s</span>\n<span class=\"n\">hl₃</span><span class=\"o\">:</span> <span class=\"n\">l.nodup</span>\n<span class=\"n\">hls</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">⦄,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span>\n<span class=\"bp\">⊢</span> <span class=\"o\">(</span><span class=\"n\">finset.filter</span> <span class=\"o\">(</span><span class=\"n\">not</span> <span class=\"bp\">∘</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">_x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 271709940,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700319
    },
    {
        "content": "<p>Note that I simplified the definition of <code>roth_aux</code> because the first assumption was redundant.</p>",
        "id": 271709998,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700360
    },
    {
        "content": "<p>?</p>",
        "id": 271710010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700388
    },
    {
        "content": "<p>which assumption did you drop</p>",
        "id": 271710018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700406
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">old_roth_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">add_salem_spencer</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">l</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l.to_finset</span> <span class=\"bp\">→</span>\n    <span class=\"n\">add_salem_spencer</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s.card</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">l.length</span>\n<span class=\"c1\">-- VS</span>\n<span class=\"kd\">def</span> <span class=\"n\">roth_aux</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ℕ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s.filter</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">l.to_finset</span> <span class=\"bp\">→</span>\n  <span class=\"n\">add_salem_spencer</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s.card</span> <span class=\"bp\">≤</span> <span class=\"n\">d</span> <span class=\"bp\">+</span> <span class=\"n\">l.length</span>\n</code></pre></div>",
        "id": 271710024,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700424
    },
    {
        "content": "<p>I think you still need to know <code>add_salem_spencer {n | n ∈ l}</code> because it's used in the correctness proof for three_free</p>",
        "id": 271710075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700474
    },
    {
        "content": "<p>it's fine if you derive it from the other hypotheses, although I can't tell if it's shorter than having the redundant assumption and using <code>three_free_spec</code> to extend it</p>",
        "id": 271710142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644700575
    },
    {
        "content": "<p>Yes, I can derive it</p>",
        "id": 271710162,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644700639
    },
    {
        "content": "<p>Yes, I think you want to case on <code>m ∈ l</code>. If it is true, then you case on <code>roth_aux₂</code> and ignore <code>roth_aux₁</code>, and vice versa if it is false</p>",
        "id": 271710443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644701091
    },
    {
        "content": "<p>That makes more sense. I was deriving <code>m ∈ l</code> from casing on <code>roth_aux₁</code> and <code>roth_aux₂</code>.</p>",
        "id": 271710455,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644701137
    },
    {
        "content": "<p>It works much better when you understand what's happening. Who would have thought <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 271712325,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644703991
    },
    {
        "content": "<p>Aaand, it's done!</p>",
        "id": 271715053,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644707885
    },
    {
        "content": "<p>When I started with lean I'd just leap into every proof on the basis that I was a good puzzle-solver so I should just be able to follow my nose and do everything first try. I soon learnt that this wasn't always the case. I remember trying Scott Morrison's category theory exercises in LFTCM20 and realising very quickly that paper and pencil was going to be essential :-)</p>",
        "id": 271715972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644709316
    },
    {
        "content": "<p>People keep asking me whether Lean requires rather maths or programming, and the answer is clear, unless you get into metaprogramming or the typeclass hierarchy.</p>",
        "id": 271716120,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644709543
    }
]
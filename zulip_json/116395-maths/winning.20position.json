[
    {
        "content": "<p>How does one define a winning position for a game (not the math game, just a type of positions along with sets of allowed moves and a set of winning positions) that might not end? Is it some kind of minimal fixed point and well-foundedness stuff? I suspect Mario knows how to do these things.</p>",
        "id": 249528505,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1629058233
    },
    {
        "content": "<p>Can you do it inductively? Finishing positions that are winning are winning, and any other position is winning for player 1 if there is a winning move if it's player 1's turn, or if it's the other player's move, when every possible move leads to a losing position.</p>",
        "id": 249533904,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1629067223
    },
    {
        "content": "<p>Are you talking about this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"c1\">-- r x y means there is a move from position x to position y</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">accessible_from</span> <span class=\"o\">(</span><span class=\"n\">a₀</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">start</span> <span class=\"o\">:</span> <span class=\"n\">accessible_from</span> <span class=\"n\">a₀</span>\n<span class=\"bp\">|</span> <span class=\"n\">move</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">accessible_from</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">accessible_from</span> <span class=\"n\">y</span>\n\n<span class=\"sd\">/-- Is there a sequence of moves starting from `a₀` that can reach the `terminate` set? -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">can_end_from</span> <span class=\"o\">(</span><span class=\"n\">a₀</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">terminate</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">accessible_from</span> <span class=\"n\">r</span> <span class=\"n\">a₀</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">terminate</span> <span class=\"bp\">≠</span> <span class=\"bp\">∅</span>\n</code></pre></div>\n<p>(I'm just trying to understand the setup -- I'm not saying this is how to formalize it.)</p>",
        "id": 249534283,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629067867
    },
    {
        "content": "<p>The mathlib construction for the reflexive transitive closure of a relation is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/relation.refl_trans_gen\">docs#relation.refl_trans_gen</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">can_end_from</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a₀</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">terminate</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">relation.refl_trans_gen</span> <span class=\"n\">r</span> <span class=\"n\">a₀</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"n\">terminate</span> <span class=\"bp\">≠</span> <span class=\"bp\">∅</span>\n</code></pre></div>",
        "id": 249534424,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1629068149
    },
    {
        "content": "<p>Something like this is what I had in mind</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">position</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">win_for_me</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">position</span><span class=\"o\">)</span> <span class=\"c1\">-- A finishing position that is a win for me</span>\n  <span class=\"o\">(</span><span class=\"n\">legal_moves</span> <span class=\"o\">:</span> <span class=\"n\">position</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">position</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">my_turn</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">position</span><span class=\"o\">)</span> <span class=\"c1\">-- Set of positions where it is my turn to move</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">winning_for_me</span> <span class=\"o\">:</span> <span class=\"n\">position</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">finish</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">position</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">win_for_me</span> <span class=\"bp\">→</span> <span class=\"n\">winning_for_me</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">my_move</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">position</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∈</span> <span class=\"n\">my_turn</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">legal_moves</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">winning_for_me</span> <span class=\"n\">q</span> <span class=\"bp\">→</span> <span class=\"n\">winning_for_me</span> <span class=\"n\">p</span>\n<span class=\"bp\">|</span> <span class=\"n\">opponents_move</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">position</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"bp\">∉</span> <span class=\"n\">my_turn</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">q</span> <span class=\"bp\">∈</span> <span class=\"n\">legal_moves</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">winning_for_me</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">winning_for_me</span> <span class=\"n\">p</span>\n</code></pre></div>",
        "id": 249534624,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1629068448
    },
    {
        "content": "<p>I would go for something like <span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> 's version, but I wanted to mention that in some infinite game theory there is the concept of a winning game where the play itself is not finite (i.e. it's not like you played for finitely many rounds and reached the end, but rather you play countably many rounds and \"looking back\" determine that the whole play sequence was a win). This is used in the axiom of determinacy IIRC, and it can be formalized as a predicate on move sequences, or in the simple binary tree case, a coloring of 2^nat.</p>",
        "id": 249549995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629090964
    },
    {
        "content": "<p>For example, imagine where you and the opponent both play 0 or 1 in alternation to create a sequence, and you win if the sequence of zeros and ones has a natural density and the opponent wins if it doesn't</p>",
        "id": 249550079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629091085
    },
    {
        "content": "<p>Right, in the axiom of determinacy stuff a game goes on forever with both players choosing digits and then looking at the resulting infinite string at the end. If you assume AC then there are games for which neither player has a winning strategy, which some logicians might argue is evidence against AC</p>",
        "id": 249574606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1629112025
    }
]
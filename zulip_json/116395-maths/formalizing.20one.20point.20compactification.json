[
    {
        "content": "<p>Hello, I've formalized a few things about one-point compactifications. My code is available <a href=\"https://github.com/justadzr/Lean_2021/blob/complex-diff/src/alexandroff.lean\">here</a>. The statements and proofs I wrote are super naive, but I couldn't find a neater way to define the natural topology on <code>option</code>. Therefore, I am not sure if the things I've done here meet mathlib's standards. Please let me know if there is something in mathlib I should be using.</p>\n<p>I proved that the one-point compactification is a compact topological space, and it inherits properties such as t1 from a t1 X, connectedness from a noncompact, preconnected X, and t2 from a locally compact, t2 X. The names I gave to those lemmas are quite generic; I am grateful for any suggestion on them. </p>\n<p>Thanks in advance! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 248652935,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628275937
    },
    {
        "content": "<p>When working on a <code>z : option X</code>, it's easier to say <code>cases z</code> than</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">by_cases</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>  <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 248654213,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628276452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248654213\">said</a>:</p>\n<blockquote>\n<p>When working on a <code>z : option X</code>, it's easier to say <code>cases z</code> than</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">by_cases</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">none</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>  <span class=\"o\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Will change that.</p>",
        "id": 248655499,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628277070
    },
    {
        "content": "<p>In fact, you can say</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"o\">⟩,</span>\n</code></pre></div>",
        "id": 248666605,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628282947
    },
    {
        "content": "<p>That's longer and harder to type than <code>cases z</code> though</p>",
        "id": 248667320,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628283332
    },
    {
        "content": "<p>Some points for discussion (I have to go now, so will check in later):</p>\n<ul>\n<li>is it better to use the type synonym or to make this a topology directly on <code>option X</code>?</li>\n<li>can you prove the characterization \"smallest compactification of X\", or even arrange things so that that is the definition?</li>\n</ul>",
        "id": 248667768,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1628283589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248667320\">said</a>:</p>\n<blockquote>\n<p>That's longer and harder to type than <code>cases z</code> though</p>\n</blockquote>\n<p>That's <code>rintro</code>, so it's being used to replace <code>intro z, cases z</code></p>",
        "id": 248668034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628283705
    },
    {
        "content": "<p>although I think the syntax there is wrong, it should be <code>rintro (_|z),</code></p>",
        "id": 248668146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628283748
    },
    {
        "content": "<p>either works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">univ_eq_union_none</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 248669963,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628284805
    },
    {
        "content": "<p>I suspect that if X is compact then the one point compactification is the second smallest compactification :-) Is there a universal property? There is for Stone-Cech I think but I'm less sure about this one...</p>",
        "id": 248675658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628288773
    },
    {
        "content": "<p>Here is some golf. It's important to have the right API simp lemmas early, makes trivial proofs trivial.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">alexandroff</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">option</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_base</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">some</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_base_apply</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">of_base</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">of_base</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_some_eq_of_base</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_ne_none</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"n\">none</span> <span class=\"bp\">.</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_base_eq_coe</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">of_base</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_base</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_mem_set_base</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set_base</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">univ_eq_union_none</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">none_not_mem_set_base</span> <span class=\"o\">:</span> <span class=\"n\">none</span> <span class=\"bp\">∉</span> <span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set_base</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">coe_some_eq_of_base</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">not_mem_set_base_iff</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inter_none_eq_empty</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_base_preimage_none</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_open</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">none</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">is_compact</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">is_open_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_inter</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"n\">h'</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">]</span> <span class=\"n\">using</span>\n        <span class=\"n\">and.intro</span> <span class=\"o\">(</span><span class=\"n\">hs.left.union</span> <span class=\"n\">ht.left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs.right.inter</span> <span class=\"n\">ht.right</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.inter</span> <span class=\"n\">ht.right</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.right.inter</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.inter</span> <span class=\"n\">ht</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_sUnion</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"bp\">⋃₀</span><span class=\"n\">S</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)),</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">ha'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_sUnion.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">specialize</span> <span class=\"n\">ht</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">if_pos</span> <span class=\"n\">ha'</span> <span class=\"n\">at</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">compact_of_is_closed_subset</span> <span class=\"n\">ht.left</span> <span class=\"n\">this.is_closed_compl</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">compl_subset_compl</span><span class=\"o\">,</span> <span class=\"n\">preimage_subset_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n     <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_forall_mem_open</span><span class=\"o\">,</span>\n     <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">mem_Union</span><span class=\"o\">,</span> <span class=\"n\">preimage_sUnion</span><span class=\"o\">,</span> <span class=\"n\">mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">of_base_eq_coe</span><span class=\"o\">,</span>\n                <span class=\"n\">exists_imp_distrib</span><span class=\"o\">],</span>\n     <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n     <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">of_base</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">subset_subset_Union</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subset_subset_Union</span> <span class=\"n\">hs</span> <span class=\"o\">(</span><span class=\"n\">subset.refl</span> <span class=\"n\">_</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">mem_preimage.mpr</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n     <span class=\"n\">specialize</span> <span class=\"n\">ht</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n     <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n     <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ht.right</span> <span class=\"o\">},</span>\n     <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ht</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 248675835,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628288899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I'm a little rusty, but there's a universal property stated here:<br>\n<a href=\"https://ncatlab.org/nlab/show/one-point+compactification#UniversalProperty\">https://ncatlab.org/nlab/show/one-point+compactification#UniversalProperty</a></p>",
        "id": 248675869,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1628288934
    },
    {
        "content": "<p>And there's a reference here to the \"smallest compactification\" property:<br>\n<a href=\"https://math.stackexchange.com/questions/201964/the-smallest-compactification\">https://math.stackexchange.com/questions/201964/the-smallest-compactification</a></p>",
        "id": 248675998,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1628289018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248675835\">said</a>:</p>\n<blockquote>\n<p>Here is some golf. It's important to have the right API simp lemmas early, makes trivial proofs trivial.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">alexandroff</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">option</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_base</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">some</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_base_apply</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">of_base</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">of_base</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_some_eq_of_base</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_ne_none</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"n\">none</span> <span class=\"bp\">.</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_base_eq_coe</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">of_base</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">set_base</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">coe</span> <span class=\"bp\">''</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_mem_set_base</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set_base</span><span class=\"o\">]</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">univ_eq_union_none</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">})</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">le_antisymm</span> <span class=\"o\">(</span><span class=\"n\">subset_univ</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">⟩</span><span class=\"bp\">;</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">none_not_mem_set_base</span> <span class=\"o\">:</span> <span class=\"n\">none</span> <span class=\"bp\">∉</span> <span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">set_base</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">coe_some_eq_of_base</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">not_mem_set_base_iff</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">x</span> <span class=\"bp\">∉</span> <span class=\"n\">set_base</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">none</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">inter_none_eq_empty</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">set_base</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">∩</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"bp\">|</span><span class=\"n\">x</span><span class=\"o\">⟩</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_base_preimage_none</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">∅</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span>  <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_open</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">none</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">is_compact</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">∧</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"k\">else</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n  <span class=\"n\">is_open_univ</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_inter</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h'</span> <span class=\"n\">h'</span> <span class=\"n\">h'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">,</span> <span class=\"n\">compl_inter</span><span class=\"o\">]</span> <span class=\"n\">using</span>\n        <span class=\"n\">and.intro</span> <span class=\"o\">(</span><span class=\"n\">hs.left.union</span> <span class=\"n\">ht.left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs.right.inter</span> <span class=\"n\">ht.right</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.inter</span> <span class=\"n\">ht.right</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.right.inter</span> <span class=\"n\">ht</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hs.inter</span> <span class=\"n\">ht</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_sUnion</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">of_base</span><span class=\"bp\">⁻¹'</span> <span class=\"bp\">⋃₀</span><span class=\"n\">S</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">split_ifs</span> <span class=\"k\">with</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)),</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">ha'</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">mem_sUnion.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n        <span class=\"n\">specialize</span> <span class=\"n\">ht</span> <span class=\"n\">a</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">if_pos</span> <span class=\"n\">ha'</span> <span class=\"n\">at</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">compact_of_is_closed_subset</span> <span class=\"n\">ht.left</span> <span class=\"n\">this.is_closed_compl</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">⟩,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">compl_subset_compl</span><span class=\"o\">,</span> <span class=\"n\">preimage_subset_iff</span><span class=\"o\">],</span>\n        <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n        <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"n\">hy</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n     <span class=\"n\">rw</span> <span class=\"n\">is_open_iff_forall_mem_open</span><span class=\"o\">,</span>\n     <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">mem_Union</span><span class=\"o\">,</span> <span class=\"n\">preimage_sUnion</span><span class=\"o\">,</span> <span class=\"n\">mem_preimage</span><span class=\"o\">,</span> <span class=\"n\">of_base_eq_coe</span><span class=\"o\">,</span>\n                <span class=\"n\">exists_imp_distrib</span><span class=\"o\">],</span>\n     <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n     <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">of_base</span> <span class=\"bp\">⁻¹'</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">subset_subset_Union</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">subset_subset_Union</span> <span class=\"n\">hs</span> <span class=\"o\">(</span><span class=\"n\">subset.refl</span> <span class=\"n\">_</span><span class=\"o\">)),</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n        <span class=\"n\">mem_preimage.mpr</span> <span class=\"n\">hy</span><span class=\"o\">⟩,</span>\n     <span class=\"n\">specialize</span> <span class=\"n\">ht</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n     <span class=\"n\">split_ifs</span> <span class=\"n\">at</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n     <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ht.right</span> <span class=\"o\">},</span>\n     <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">ht</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p></div></div><br>\n</p>\n</blockquote>\n<p>Thank you so much for the modifications! One question: what does the dot at the end of the lemma <code>coe_ne_none (x : X) : (x : alexandroff X) ≠ none  .</code> do?</p>",
        "id": 248677887,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628290601
    },
    {
        "content": "<p>That the proof is so trivial you don't even need to give a term proof. It's based on the fact that <code>some x \\ne none</code> by the definition of the inductive type.</p>",
        "id": 248681337,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628293854
    },
    {
        "content": "<p>I would have been tempted to call it <code>infty</code> not <code>none</code></p>",
        "id": 248706514,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1628327702
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248706514\">said</a>:</p>\n<blockquote>\n<p>I would have been tempted to call it <code>infty</code> not <code>none</code></p>\n</blockquote>\n<p>But in that case, would tactics like <code>cases</code> and <code>rintro &lt;_|x&gt;</code> still be neat to use?</p>",
        "id": 248708233,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628330617
    },
    {
        "content": "<p>I can't help feeling it would be easier to just <em>define</em> the topology on <code>option</code>, and then only introduce the type alias for the purpose of making the <code>instance</code></p>",
        "id": 248708381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628330823
    },
    {
        "content": "<p>Otherwise you end up rewriting tonnes of option API.</p>",
        "id": 248708398,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628330848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248708381\">said</a>:</p>\n<blockquote>\n<p>I can't help feeling it would be easier to just <em>define</em> the topology on <code>option</code>, and then only introduce the type alias for the purpose of making the <code>instance</code></p>\n</blockquote>\n<p>Do you mean I should define <code>alexandroff X</code> after constructing the topology of <code>option X</code>?</p>",
        "id": 248708647,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628331136
    },
    {
        "content": "<p>I'm suggesting that might at least be easier, yes - although I can't advise on whether it's actually better. Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- see note [reducible non-instances] -/</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">one_point_compaction</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">alexandroff</span> <span class=\"o\">:=</span> <span class=\"n\">option</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">one_point_compaction</span>\n</code></pre></div>",
        "id": 248709677,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628332570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248709677\">said</a>:</p>\n<blockquote>\n<p>I'm suggesting that might at least be easier, yes - although I can't advise on whether it's actually better. Something like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- see note [reducible non-instances] -/</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">one_point_compaction</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">alexandroff</span> <span class=\"o\">:=</span> <span class=\"n\">option</span> <span class=\"n\">X</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">alexandroff</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">one_point_compaction</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This looks very neat. Suppose I define aliases <code>of := some, infty := none</code> like Prof. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> suggested and take some <code>x : alexdroff X</code>.  I was wondering if it is possible to do something like  <code>cases x</code> and produce two goals with <code>of x</code> and <code>infty</code>.</p>",
        "id": 248713286,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628337978
    },
    {
        "content": "<p>No, unfortunately you can't make cases do that. The best you can do is something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_bot.rec_bot_coe\">docs#with_bot.rec_bot_coe</a></p>",
        "id": 248716562,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628343045
    },
    {
        "content": "<p>Which you'd use as <code>induction x with alexdroff.rec_of_infty</code></p>",
        "id": 248716583,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628343087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248716583\">said</a>:</p>\n<blockquote>\n<p>Which you'd use as <code>induction x with alexdroff.rec_of_infty</code></p>\n</blockquote>\n<p>Thank you!</p>",
        "id": 248718455,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628345837
    },
    {
        "content": "<p>Oops, I meant <code>using</code> not <code>with</code></p>",
        "id": 248719611,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628347536
    },
    {
        "content": "<p>Eric, why should option get that topology as opposed to, let's say, the introduced point being near every other point?</p>",
        "id": 248745652,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628386279
    },
    {
        "content": "<p>I think that's a good point. It's probably a good idea to define <code>alexandroff</code> first and construct the topology, instead of doing it on <code>option</code>. There are only about 4-5 super trivial lemmas from <code>option</code> we need to prove, similar to those in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/with_bot\">docs#with_bot</a>. The other trivial lemmas are about sets in the extension, so they must be there regardless of the name we use.</p>",
        "id": 248746131,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628387104
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span>, option doesn't \"get\" that topology, it's a def not an instance. My snippet just says \"it is possible to construct this topology on option\", not \"this is the canonical topology on option\"</p>",
        "id": 248757830,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628408103
    },
    {
        "content": "<p>Ah, I see. Makes sense!</p>",
        "id": 248757886,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1628408175
    },
    {
        "content": "<p>Having the definition available on option makes it easier (or at least, more discoverable) to apply locally to with_top and with_bot if needed</p>",
        "id": 248758214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628408834
    },
    {
        "content": "<p>(do those have a topology in mathlib already?)</p>",
        "id": 248758215,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628408859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/formalizing.20one.20point.20compactification/near/248758214\">said</a>:</p>\n<blockquote>\n<p>Having the definition available on option makes it easier (or at least, more discoverable) to apply locally to with_top and with_bot if needed</p>\n</blockquote>\n<p>Thank you for this excellent point! Suppose I define <code>topological_space (option X)</code> first. Should I define the other instances, say <code>t2_space (option X)</code> for a locally compact, t2 <code>X</code> in the same way? Or should I do that on <code>alexandroff X</code> as an instance instead?</p>",
        "id": 248777649,
        "sender_full_name": "Yourong Zang",
        "timestamp": 1628439531
    },
    {
        "content": "<p>Surprisingly you can actually just make the t2 space an instance on option I think</p>",
        "id": 248788468,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628456109
    },
    {
        "content": "<p>Because it doesn't contain any data</p>",
        "id": 248788471,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628456124
    },
    {
        "content": "<p>Or from another viewpoint, it is really an instance on <code>one_point_compaction</code> rather than <code>option X</code>.</p>",
        "id": 248788840,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1628456643
    },
    {
        "content": "<p>It might be worth distinguishing the two topologies on <code>option X</code> (I'm not sure if I've followed what the consensus has been on this).  If I got this right:</p>\n<ul>\n<li>The forgetful functor from the category of pointed topological spaces to topological spaces has a left adjoint (call it <code>option</code>) that introduces a basepoint with the disjoint union topology.</li>\n<li>The forgetful functor from the category of pointed locally compact T2 spaces to locally compact T2 spaces (morphisms are proper maps) has a left adjoint (call it <code>alexandroff</code>) that introduces a basepoint with the one-point compactification topology.</li>\n</ul>\n<p>A relationship between them is that the identity function gives a continuous map <code>option X -&gt; alexandroff X</code> of pointed spaces.</p>\n<p>Though, I'm not sure if I've ever seen the first construction in use.  It seems that usually, if you have nice enough connected spaces, you care about homotopy classes of pointed spaces, so you can choose an arbitrary basepoint.</p>",
        "id": 248790241,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1628458786
    },
    {
        "content": "<p>The first construction does get used in homotopy theory,  and is usually denoted by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>↦</mo><msub><mi>X</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">X \\mapsto X_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69433em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>, though it might be considered largely as a notational device. For example, the unreduced homology of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is the reduced homology of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>X</mi><mo>+</mo></msub></mrow><annotation encoding=\"application/x-tex\">X_+</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.25833100000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 248835729,
        "sender_full_name": "Reid Barton",
        "timestamp": 1628510724
    }
]
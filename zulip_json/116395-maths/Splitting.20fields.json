[
    {
        "content": "<p>So I thought I'd revive the splitting fields branch on community mathlib. So far I've just updated it to work with current mathlib. This is my definition of splitting fields. It's a bit unusual to write a recursive function like this returning a Type; is this a good approach? Also my definition of <code>of_field</code> the embedding from the base field gives me the error <code>rec_fn_macro only allowed in meta definitions</code>. What is this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">splitting_field&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hn</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">nat_degree</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">irr_factor</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)))</span> <span class=\"bp\">/</span>\n    <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">root</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">splitting_field&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">irr_factor</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hn</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">dec_trivial</span><span class=\"o\">)))</span> <span class=\"bp\">/</span>\n    <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">root</span><span class=\"o\">))</span> <span class=\"n\">hf</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_field&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">nat_degree</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">),</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">splitting_field&#39;</span> <span class=\"n\">f</span> <span class=\"n\">hf</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"mi\">1</span>     <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">of_field&#39;</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">adjoin_root</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 151535820,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544631417
    },
    {
        "content": "<p>Okay I still get the error <code>rec_fn_macro only allowed in meta definitions</code> even if I make it <code>meta</code></p>",
        "id": 151536840,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544632346
    },
    {
        "content": "<p>Could you rearrange the arguments so that <code> {α : Type u} [discrete_field α]</code> are left of the colon? If nothing else it will let you get rid of the <code>exactI</code>s.</p>",
        "id": 151536970,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632481
    },
    {
        "content": "<p>That error sounds like something funny in the equation compiler, so simplifying its job might help.</p>",
        "id": 151536981,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632495
    },
    {
        "content": "<p>Not without changing my method significantly. I use a different type when I recursively call it.</p>",
        "id": 151537095,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544632612
    },
    {
        "content": "<p>Oh, yeah, sorry. I misread that.</p>",
        "id": 151537161,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632682
    },
    {
        "content": "<p>Where is <code>adjoin_root</code> defined?</p>",
        "id": 151537354,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632813
    },
    {
        "content": "<p>In the splitting field branch on community, I take it.</p>",
        "id": 151537395,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632859
    },
    {
        "content": "<p>Think I'm having trouble reading today.</p>",
        "id": 151537405,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1544632869
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> I think this is exactly the approach that we had in mind when <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, you and me were hacking on this in Orsay. Too bad it's giving troubles.</p>",
        "id": 151537835,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544633204
    },
    {
        "content": "<p>I'm always tempted to package everything I care about together in a single recursive definition--here the type, its field instance, the map from the base field, the factorization of f</p>",
        "id": 151538608,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544633870
    },
    {
        "content": "<p>using a big sigma or a structure</p>",
        "id": 151538615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544633876
    },
    {
        "content": "<p>I found a work around by using <code>nat.rec_on</code> instead of the equation compiler. Seems like it has something to do with this <a href=\"https://github.com/leanprover/lean/issues/1890\" target=\"_blank\" title=\"https://github.com/leanprover/lean/issues/1890\">https://github.com/leanprover/lean/issues/1890</a></p>",
        "id": 151541456,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544636299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> I think that this thread should know about this thread: <a href=\"#narrow/stream/116395-maths/topic/simple.20field.20theory\" title=\"#narrow/stream/116395-maths/topic/simple.20field.20theory\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/simple.20field.20theory</a></p>",
        "id": 151552987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544639575
    },
    {
        "content": "<p>I've had a new problem, and it's taken me most of the day to figure out what's going on. I think the trouble is that I have an expression where <code>f : polynomial α</code> is mentioned and also some stuff of type <code>adjoin_root f</code>. When I try to rewrite with <code>f = _</code> It tries to rewrite all the types that mention <code>f</code> and hangs. I solved it using <code>conv</code> but I thought there might be a better way to do this.</p>",
        "id": 151806515,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544822843
    },
    {
        "content": "<p>Isn't this what <code>conv</code> is meant for? I think there's nothing wrong with using it here.</p>",
        "id": 151831239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544867946
    },
    {
        "content": "<p>So I've some up against a more serious problem. I've defined something of this type</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">splitting_field_aux</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n  <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"err\">Σ&#39;</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_field_hom</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">splits</span> <span class=\"n\">i</span> <span class=\"n\">f</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_field_hom</span> <span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hj</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">exactI</span> <span class=\"n\">splits</span> <span class=\"n\">j</span> <span class=\"n\">f</span><span class=\"o\">),</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">is_field_hom</span> <span class=\"n\">k</span>\n</pre></div>\n\n\n<p>I bundled everything we needed to know together in one definition because I didn't want to have to deal with <code>eq.rec</code> and non definitional equation lemmas. The only trouble with this approach is that the homomorphism from the splitting field into any field that splits only goes into fields in the same universe. The only way around this that I can see is to unbundle the definition, and deal with nasty equation lemmas. Is there any easier way around this?</p>",
        "id": 151868222,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544942713
    },
    {
        "content": "<p>I'm inclined to say that we shouldn't worry about universes here. If universe issues show up, I hope <code>ulift</code> will help.</p>",
        "id": 151868598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544943518
    },
    {
        "content": "<p>good luck transporting everything to <code>ulift</code> :P</p>",
        "id": 151868614,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1544943588
    },
    {
        "content": "<p>what is the problem with unbundling exactly?</p>",
        "id": 151868620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943598
    },
    {
        "content": "<p>I guess that would be much more convenient to use if it were unbundled, although maybe you need this for the construction?</p>",
        "id": 151868667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943637
    },
    {
        "content": "<p>I think you should try to stay away from \"universal definitions\" of universal objects, because they are never universe polymorphic enough</p>",
        "id": 151868675,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943680
    },
    {
        "content": "<p>Then I'd have to unfold the definition to prove things about it. And the equation lemmas are not definitional, so I'd need eq.rec to turn it into <code>adjoin_root whatever </code> and eq.rec is hard to use.</p>",
        "id": 151868679,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544943709
    },
    {
        "content": "<p>What do you mean by stay away from universal definitions?</p>",
        "id": 151868720,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544943753
    },
    {
        "content": "<p>right, we definitely want to avoid that. But I'm still not following. Could you show a bit of how you get to this point?</p>",
        "id": 151868721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943759
    },
    {
        "content": "<p>For example, you can define <code>nat := \\forall X, {X -&gt; (X -&gt; X) -&gt; X // naturality property}</code> but it's not a good definition because <code>X</code> only lives in one universe</p>",
        "id": 151868729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943816
    },
    {
        "content": "<p><a href=\"https://github.com/ChrisHughes24/mathlib/blob/5efef7b26f78b5bcbcbc43d4d3ae32be7aa6018b/field_theory/splitting_field.lean\" target=\"_blank\" title=\"https://github.com/ChrisHughes24/mathlib/blob/5efef7b26f78b5bcbcbc43d4d3ae32be7aa6018b/field_theory/splitting_field.lean\">https://github.com/ChrisHughes24/mathlib/blob/5efef7b26f78b5bcbcbc43d4d3ae32be7aa6018b/field_theory/splitting_field.lean</a></p>",
        "id": 151868774,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544943876
    },
    {
        "content": "<p>instead you want some kind of \"intrinsic\" characterization of the object that implies the universal property, in any universe</p>",
        "id": 151868775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544943884
    },
    {
        "content": "<p>So in this example, maybe the fact that any proper subfield does not split?</p>",
        "id": 151868790,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544943936
    },
    {
        "content": "<p>I'll have to think about whether that approach is much harder.</p>",
        "id": 151868793,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544943954
    },
    {
        "content": "<p>In this case, it looks like that is indeed the right \"smallness\" property</p>",
        "id": 151868957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544944246
    },
    {
        "content": "<p>another way to express it is to start from the theorem you just proved, and show that splitting in one universe implies splitting in all the rest</p>",
        "id": 151868963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544944274
    },
    {
        "content": "<p>by taking a special choice of gamma, namely the subfield isomorphic to the gamma in another universe</p>",
        "id": 151868966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544944307
    },
    {
        "content": "<p>Proving that such a subfield exists is hard though, unless I'm missing a trick?</p>",
        "id": 151869580,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544945345
    },
    {
        "content": "<p>This is a general fact about fields</p>",
        "id": 151869584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945375
    },
    {
        "content": "<p>Every field hom is injective, so when you restrict to the range you get an isomorphism</p>",
        "id": 151869631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945410
    },
    {
        "content": "<p>(the isomorphism is not constructive in the reverse direction)</p>",
        "id": 151869647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945465
    },
    {
        "content": "<p>I still don't understand. Given a field, which subfield do I choose?</p>",
        "id": 151869788,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544945717
    },
    {
        "content": "<p>oh wait I had it backwards, you need a field <em>into</em> the large universe</p>",
        "id": 151869922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945896
    },
    {
        "content": "<p>for that you can take a subfield of gamma sufficiently large to contain all the action from beta</p>",
        "id": 151869945,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945973
    },
    {
        "content": "<p>like the subfield generated by polynomials in alpha</p>",
        "id": 151869949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544945997
    },
    {
        "content": "<p>this subfield will be isomorphic to a quotient of a polynomial ring etc etc which is in <code>Type u</code></p>",
        "id": 151870003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946075
    },
    {
        "content": "<p>I see.</p>",
        "id": 151870007,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544946098
    },
    {
        "content": "<p>and so your lemma applies and the polynomial splits there</p>",
        "id": 151870008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946104
    },
    {
        "content": "<p>you should double check with <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , I walked him through this a few months ago and I think he did almost exactly the same thing in the perfectoid project</p>",
        "id": 151870059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946183
    },
    {
        "content": "<p>as an alternative, returning to the unbundling problem: I assume the reason it isn't definitional is because you are using wf recursion</p>",
        "id": 151870110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946269
    },
    {
        "content": "<p>If you define one step of the induction as a lemma, then it will be definitional there</p>",
        "id": 151870112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946300
    },
    {
        "content": "<p>That sounds easier.</p>",
        "id": 151870163,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544946367
    },
    {
        "content": "<p>so you have something like <code>F : (A : Type u) (h : P.{u} A), Type u</code> and <code>prop : (A : Type u) (h : P.{u} A), P.{v} (F A)</code></p>",
        "id": 151870166,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946389
    },
    {
        "content": "<p>and then you have an induction proof putting it together, which does <code>F /\\ P.{u} F</code>, and a cases proof doing the same thing with conclusion <code>P.{v} F</code></p>",
        "id": 151870228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946549
    },
    {
        "content": "<p>It's also not definitional because I've got an <code>ite</code> on <code>degree f \\le 1</code></p>",
        "id": 151870287,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544946678
    },
    {
        "content": "<p>Also, before I forget: a very general way of avoiding problems with types defined by complicated rules is to use an inductive type instead</p>",
        "id": 151870289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946700
    },
    {
        "content": "<p>for example, simulating <code>if x &lt; 2 then nat else unit</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">my_cases</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">my_cases</span>\n<span class=\"bp\">|</span> <span class=\"n\">unit</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;=</span> <span class=\"mi\">2</span> <span class=\"bp\">→</span> <span class=\"n\">unit</span> <span class=\"bp\">→</span> <span class=\"n\">my_cases</span>\n</pre></div>",
        "id": 151870347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946786
    },
    {
        "content": "<p>You can do similar stuff with crazy well founded definitions</p>",
        "id": 151870352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946832
    },
    {
        "content": "<p>in the inductive case you don't even have to worry about well foundedness</p>",
        "id": 151870393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544946855
    },
    {
        "content": "<p>The other major issue I have is that making it a def gives me the error <code>rec_fn_macro</code> only allowed in meta definitions.</p>",
        "id": 151870896,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544947850
    },
    {
        "content": "<p>that means there is probably a tactic referencing one of the <code>_match</code> type variables in the context by accident</p>",
        "id": 151871212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544948487
    },
    {
        "content": "<p>you can fix this by <code>clear</code>ing it when you have used it, or even using it right at the start and clearing it then (or if its random junk then just remove it)</p>",
        "id": 151871259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544948534
    },
    {
        "content": "<p>Will <code>resetI</code> cause problems with that?</p>",
        "id": 151871614,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1544949315
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 151871616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544949330
    },
    {
        "content": "<p>At some version of <code>resetI</code> I recall it deleting the recursive function variable as a side effect, not sure if that's still the case but I think not</p>",
        "id": 151871661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1544949405
    },
    {
        "content": "<p>I've only just seen this thread. Chris I'll dig out the universe conversation Mario and I had when I'm at a pc</p>",
        "id": 151874009,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544954076
    },
    {
        "content": "<p>All done and sorry free. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> are you happy for me to push all of this to the splitting fields branch in community?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">splitting_field</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">splitting_field</span><span class=\"bp\">.</span><span class=\"n\">type_aux</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">splitting_field</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">discrete_field</span> <span class=\"o\">(</span><span class=\"n\">splitting_field</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">splitting_field</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">splitting_field</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">mk_aux</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_field_hom</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">mk</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">splitting_field_splits</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">splits</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">splitting_field_aux</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_field_hom</span> <span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">splits</span> <span class=\"n\">i</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">splitting_field</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"n\">exists_hom</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span> <span class=\"n\">i</span> <span class=\"n\">hβ</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">hom_is_field_hom</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_field_hom</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">splits</span> <span class=\"n\">i</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_field_hom</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">i</span> <span class=\"n\">f</span> <span class=\"n\">hβ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_hom</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span> <span class=\"n\">i</span> <span class=\"n\">hβ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">hom_fixes</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_field_hom</span> <span class=\"n\">i</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">splits</span> <span class=\"n\">i</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hom</span> <span class=\"n\">i</span> <span class=\"n\">f</span> <span class=\"n\">hβ</span> <span class=\"o\">(</span><span class=\"n\">mk</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"o\">(</span><span class=\"n\">exists_hom</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"n\">rfl</span> <span class=\"n\">i</span> <span class=\"n\">hβ</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">hom</span> <span class=\"n\">splitting_field</span> <span class=\"n\">splitting_field</span><span class=\"bp\">.</span><span class=\"n\">field</span> <span class=\"n\">splitting_field</span><span class=\"bp\">.</span><span class=\"n\">mk</span>\n</pre></div>",
        "id": 152018880,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545044252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> so how did you extract an element from <code>factor_set</code>?</p>",
        "id": 152018894,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545044279
    },
    {
        "content": "<p>I proved the irreducible factor lemma for a noetherian domain.</p>",
        "id": 152018952,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545044327
    },
    {
        "content": "<p>see <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> this is problematic</p>",
        "id": 152018963,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545044344
    },
    {
        "content": "<p>I don't think it's problematic. You shouldn't use UFD for that anyway since it's true in greater generality.</p>",
        "id": 152019049,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545044422
    },
    {
        "content": "<p>Looks good to me, although I would call <code>hom</code> <code>lift</code> instead</p>",
        "id": 152019448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545044969
    },
    {
        "content": "<p>what's problematic?</p>",
        "id": 152019459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545044985
    },
    {
        "content": "<p>that <code>factor_set</code> is hard to use</p>",
        "id": 152019463,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545044996
    },
    {
        "content": "<p>demo? what's <code>factor_set</code> doing here</p>",
        "id": 152019540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045067
    },
    {
        "content": "<p>well could you prove that the factor set of a non-unit non-zero element is nonempty?</p>",
        "id": 152019543,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045101
    },
    {
        "content": "<p>what is <code>factor_set</code></p>",
        "id": 152019546,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045122
    },
    {
        "content": "<p><code>associates.factor_set</code></p>",
        "id": 152019590,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045135
    },
    {
        "content": "<p>Kenny, you shouldn't be so negative</p>",
        "id": 152019591,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1545045138
    },
    {
        "content": "<p>it's not in the mathlib version, remind me what it does</p>",
        "id": 152019604,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045165
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">associates</span><span class=\"bp\">.</span><span class=\"n\">factors</span> <span class=\"o\">:</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">integral_domain</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">unique_factorization_domain</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_3</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"o\">(</span><span class=\"n\">associates</span> <span class=\"n\">α</span><span class=\"o\">)],</span> <span class=\"n\">associates</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">associates</span><span class=\"bp\">.</span><span class=\"n\">factor_set</span> <span class=\"n\">α</span>\n</pre></div>",
        "id": 152019613,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> well played</p>",
        "id": 152019624,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045190
    },
    {
        "content": "<p>If it was empty the product would be one. Seems like it's probably not that hard.</p>",
        "id": 152019637,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545045219
    },
    {
        "content": "<p>oh it's a ufd thing</p>",
        "id": 152019643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045235
    },
    {
        "content": "<p>how about that any non-zero non-unit is divisible by an irreducible</p>",
        "id": 152019646,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045239
    },
    {
        "content": "<p>how do we convert from factors to divisibility</p>",
        "id": 152019685,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045250
    },
    {
        "content": "<p><code>dvd_eq_le</code></p>",
        "id": 152019697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045295
    },
    {
        "content": "<p>Prove that a UFD is noetherian, and use the lemma I proved.</p>",
        "id": 152019698,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545045300
    },
    {
        "content": "<p>and <code>factors_le</code></p>",
        "id": 152019702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045303
    },
    {
        "content": "<p>I see <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 152019721,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545045338
    },
    {
        "content": "<p>it's a bit cumbersome to state, but it looks like the lemmas are there</p>",
        "id": 152019761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045364
    },
    {
        "content": "<p>Anyway I think you could certainly push this</p>",
        "id": 152019840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045483
    },
    {
        "content": "<p>next stop algebraic closure?</p>",
        "id": 152019848,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045495
    },
    {
        "content": "<p>I guess that's another messy induction like this</p>",
        "id": 152019851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1545045503
    },
    {
        "content": "<p>Before going towards algebraic closure, I would like to have this PR'd. This is going to be a very useful tool in the theory if finite extensions. I think it makes sense to start defining <code>separable</code> and <code>normal</code> extensions now. We're pretty close to finite Galois extensions.</p>",
        "id": 152022286,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545048328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> What are your plans now?</p>",
        "id": 152022370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545048471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> I merged master into this branch and pushed.</p>",
        "id": 152023539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545049906
    },
    {
        "content": "<p>This branch does now depend on unmerged PRs that I have made.</p>",
        "id": 152023867,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545050339
    },
    {
        "content": "<p>The one on multiplicities?</p>",
        "id": 152023951,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545050426
    },
    {
        "content": "<p>And some others. I have three open to do with polynomials right now I think.</p>",
        "id": 152023975,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545050495
    },
    {
        "content": "<p>Yes, I see. Ok, let's hope those get merged soon.</p>",
        "id": 152024033,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545050566
    },
    {
        "content": "<p>Do you want to do more with this branch? I mean, it's name is <code>splitting_fields</code>, so maybe new stuff should happen on a new branch?</p>",
        "id": 152024064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545050608
    },
    {
        "content": "<p>I think new stuff should happen on a new branch. I think it's best to not make PRs too big.</p>",
        "id": 152024628,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1545051207
    },
    {
        "content": "<p>So, if I'm not mistaken... the first 10 points of <a href=\"https://github.com/kckennylau/Lean/blob/master/algebraic-closure-roadmap.md\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/algebraic-closure-roadmap.md\">https://github.com/kckennylau/Lean/blob/master/algebraic-closure-roadmap.md</a> have now been done. (Although not everything is in mathlib yet.)</p>",
        "id": 152025969,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545052699
    },
    {
        "content": "<p>Kenny, do you mind if I copy-paste that roadmap to the github wiki of the community repo? Then we can start ticking of things that we've done.</p>",
        "id": 152026250,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545052997
    },
    {
        "content": "<p>might want to replace the whole discriminant business with just GCD? ah the beauty of impredicativity</p>",
        "id": 152026341,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545053094
    },
    {
        "content": "<p>According to wiki, a polynomial is separable if it has just as many roots in its splitting field as its degree. So a square of a separable polynomial is not separable... choices...</p>",
        "id": 152026448,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545053192
    },
    {
        "content": "<p>I don't think we're talking about the same thing</p>",
        "id": 152026483,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545053237
    },
    {
        "content": "<p>No, indeed. I was asking if we should copy your roadmap to the github wiki...</p>",
        "id": 152026504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545053260
    },
    {
        "content": "<p>and I was asking if you might want to change 11-14 to just 14</p>",
        "id": 152027091,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545053779
    },
    {
        "content": "<p>That seems like a good plan.</p>",
        "id": 152027295,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545053981
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and my only objection would be predicativity</p>",
        "id": 152027590,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545054236
    },
    {
        "content": "<p>which I'm sure less people care about, compared to constructivity...</p>",
        "id": 152027650,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1545054261
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/wiki/Algebraic-closure-roadmap\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/wiki/Algebraic-closure-roadmap\">https://github.com/leanprover-community/mathlib/wiki/Algebraic-closure-roadmap</a></p>",
        "id": 152033427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1545058726
    }
]
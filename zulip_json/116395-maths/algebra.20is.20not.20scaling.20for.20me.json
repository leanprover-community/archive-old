[
    {
        "content": "<p><a href=\"/user_uploads/3121/42b3M-T1ZUAXFzFvAt-PKkGP/artintate1.png\" target=\"_blank\" title=\"artintate1.png\">artintate1.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/42b3M-T1ZUAXFzFvAt-PKkGP/artintate1.png\" target=\"_blank\" title=\"artintate1.png\"><img src=\"/user_uploads/3121/42b3M-T1ZUAXFzFvAt-PKkGP/artintate1.png\"></a></div><p><a href=\"/user_uploads/3121/HNdBiVdjAPg9PWrjsdT9W7nD/artintate2.png\" target=\"_blank\" title=\"artintate2.png\">artintate2.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/3121/HNdBiVdjAPg9PWrjsdT9W7nD/artintate2.png\" target=\"_blank\" title=\"artintate2.png\"><img src=\"/user_uploads/3121/HNdBiVdjAPg9PWrjsdT9W7nD/artintate2.png\"></a></div><p>There's a proof from Atiyah--Macdonald. There are three rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and during the proof a fourth ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is introduced. All the fast and loose playing with elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> makes me want to write this entire proof using subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> (i.e. <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is a big ring and everything else is a subset). However the following concepts are also used: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is finitely-generated as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is finitely-generated as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-module, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is finitely-generated as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-module, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a Noetherian ring, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is finitely-generated as a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-module, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is finitely-generated as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra, and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is finitely-generated as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra, and this makes me want to write the proof using four different rings and lots of <code>[algebra X Y]</code> instances. Whichever option I choose will then cause me pain in the parts of the argument which work far more nicely with the other option. What am I supposed to be doing here?</p>",
        "id": 188403964,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581970198
    },
    {
        "content": "<p>This seems like a really nice test case.</p>",
        "id": 188405617,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581972304
    },
    {
        "content": "<p>I completely agree that things like this are an enormous pain in the back at the moment. And we have to find a way to make it go smoother.</p>",
        "id": 188405636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1581972343
    },
    {
        "content": "<p>We can ask <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> and <span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> how that would be handled in math-comp.</p>",
        "id": 188406193,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1581972966
    },
    {
        "content": "<p>I wonder whether this is the sort of situation (when doing finite groups, say) which makes people want to work in some big underlying group like they do in Feit-Thompson?</p>\n<p>Having thought about this more on the way home though, without touching Lean, I am beginning to think that actually the approach with everything a different type might work fine, after some sort of interface is written. Maybe I'm being naive. I guess one thing that will come up is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is defined later on, and probably at this stage <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra, but I'm going to need to make <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> a <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>-algebra and hope that everything works out with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> now being an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>-algebra in two ways (actually maybe it isn't even an algebra in two ways, as that instance is not there I guess).</p>",
        "id": 188408482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1581975838
    },
    {
        "content": "<p>Hi, sorry for this answer one month later, and many thanks <span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> for inviting me in this discussion. I will try to write a mockup, mathcomp style, draft one of these days. (NB: this might well be outrageous wishful thinking, as the complete lockdown in France has considerably deteriorated my working conditions.) I would say that such a mockup would rely on two ingredients:</p>\n<ul>\n<li>Having <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> as (carrier) sets of a same  type</li>\n<li>Attaching different algebraic structures to a same carrier set via the definition of different, convertible copies of the same carrier.</li>\n</ul>\n<p>But I have been told at several occasion that this is considered as too brittle in mathlib (or in Lean?). I would love to understand better why so.</p>",
        "id": 191346381,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584798400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> Cool! (And good luck with the tough situation.)<br>\nIn this example, the maps <code>A → B → C</code> are injective, so we can regard them as subrings of some ambient ring. But in other situations the maps need not be injective. And then you can use sets in an ambient type...</p>",
        "id": 191346640,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584798730
    },
    {
        "content": "<p>This is my main reason why I think the \"subsets of ambient type\" cannot work for the general commutative algebra problem</p>",
        "id": 191346665,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584798786
    },
    {
        "content": "<p>We use this trick in a few places in mathlib, notably in <code>additive</code> and <code>multiplicative</code>. In other places, like <code>opposite</code>, we have moved from the \"defeq newtype\" approach to a more locked down \"irreducible defeq newtype\" which still gives you <code>up</code> and <code>down</code> functions satisfying <code>up (down x) = x</code> and <code>down (up x) = x</code> definitionally. But it seems in lean 4 that these have been abolished in favor of singleton structures, which loses one of those two defeqs for the coercions.</p>",
        "id": 191346678,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584798815
    },
    {
        "content": "<p>One issue you can run into if you use types like <code>multiplicative nat</code> is that it becomes easy to get confused since the notations are all wrong: <code>0</code> is actually <code>1</code> and if you aren't careful your goal might end up saying <code>1 * 1 = 2</code> where the <code>1</code> is carrying the instance from <code>nat</code> and <code>*</code> is carrying the instance from <code>multiplicative nat</code>.</p>",
        "id": 191346846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584799002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> many thanks for your answers! This is really helpful. Note that I am not advocating this  as an all-purpose solution, just trying to think about Kevin's problem, which is stated on paper using set inclusions. I am just suggesting to formalize these inclusions as, well, inclusions. Also, I am used to a different, more bundled approach to notations, and in any case I agree that the notation problem mentioned by Mario is of a different nature.</p>",
        "id": 191347937,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584800524
    },
    {
        "content": "<p>The statement and proof of the lemma work fine if A -&gt; B -&gt; C are maps of rings. I was surprised! One proof is \"replacing A and B by their images in C, we can assume <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi><mo>⊆</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B\\subseteq C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span>...\"</p>",
        "id": 191348029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584800676
    },
    {
        "content": "<p>The intermediate construction B_0 really does seem to be a subset of B though.</p>",
        "id": 191348062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584800745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> ah ok! Then it is the same as what I was suggesting. Working with subsets when possible does not mean that one does not generalize statement afterwards. Thanks for this additional comment.</p>",
        "id": 191348195,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584800907
    },
    {
        "content": "<p>My problem was that I didn't know if I wanted [B : subring C] or [algebra B C]. In mathematics they're kind of the same</p>",
        "id": 191348229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584800976
    },
    {
        "content": "<p>Does it make a different when you need to <em>apply</em> this lemma? I mean, in Lean of course.</p>",
        "id": 191348294,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584801042
    },
    {
        "content": "<p>But with this B_0 it really was built as a subring of B. So I just want to painlessly switch between the two concepts really. Maybe it just means writing a bunch of interface to enable me to do this. And then I will need things like \"B is integral over A\" which will have two definitions depending on whether B is an A-algebra or A is a subring of B, and we need that one is true if and only if the other is etc.</p>",
        "id": 191348321,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801095
    },
    {
        "content": "<p>Yes I'm sure that applying it will be hopeless with the subring definition</p>",
        "id": 191348330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801113
    },
    {
        "content": "<p>so then everything has to be an algebra over everything else. But in the proof I really make B_0 a subring of B, and the map from A to B lands in B_0, so now I have to decide whether I want to make a new type B_0 with B_0 an A-algebra and B a B_0-algebra or whether to have some hybrid approach with some subrings and some algebras</p>",
        "id": 191348415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I am lost : I though that in the proof <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> are subsets, so what it is the problem with the \"map\" from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>?</p>",
        "id": 191348640,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584801493
    },
    {
        "content": "<p>So I do not really know what I am supposed to be proving here. If I prove the subset version, then I can deduce the version with A -&gt; B -&gt; C. This is what I'd say to a mathematician.</p>",
        "id": 191348666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801549
    },
    {
        "content": "<p>But the subset version is probably not so easy to apply in practice because <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span> is not a subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> even though mathematicians think it is.</p>",
        "id": 191348693,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801586
    },
    {
        "content": "<p>Exactly, and that's the route I would go for in type theory as well.</p>",
        "id": 191348694,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584801587
    },
    {
        "content": "<p>The problem is that if I have a morphism of rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> then there are various common predicates, such as \"the morphism is integral\"</p>",
        "id": 191348739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801627
    },
    {
        "content": "<p>and if I have a subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> then we get the same predicates</p>",
        "id": 191348747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801647
    },
    {
        "content": "<p>because there's an induced morphism</p>",
        "id": 191348751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801657
    },
    {
        "content": "<p>and some of these predicates are defined for subrings and some are defined for morphisms</p>",
        "id": 191348761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801679
    },
    {
        "content": "<p>and some are perhaps defined for both, and then you need some theorem saying that one is true iff the other is true</p>",
        "id": 191348771,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801704
    },
    {
        "content": "<p>but actually the problem is much worse</p>",
        "id": 191348821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801741
    },
    {
        "content": "<p>because if A and B are both subsets of C in the sense that they are terms of type <code>set C</code></p>",
        "id": 191348826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801756
    },
    {
        "content": "<p>then A is not a subset of B, at least in Lean</p>",
        "id": 191348831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801770
    },
    {
        "content": "<p>in the sense that A doesn't have type <code>set B</code></p>",
        "id": 191348834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801779
    },
    {
        "content": "<p>so now I need another predicate: if A and B are both subsets of C then one can ask that the inclusion A -&gt; B is integral as well</p>",
        "id": 191348844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801808
    },
    {
        "content": "<p>so this is now three ways of saying exactly the same thing</p>",
        "id": 191348846,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801816
    },
    {
        "content": "<p>aren't they all the same though?</p>",
        "id": 191348849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801826
    },
    {
        "content": "<p>sure</p>",
        "id": 191348852,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801832
    },
    {
        "content": "<p>and of course I could hack through some proof</p>",
        "id": 191348882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801842
    },
    {
        "content": "<p>like in lean that would just be one predicate and various kinds of coercion arrows</p>",
        "id": 191348893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584801845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> , in the first version of the lemma, the one about inclusions, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> are all sets of a same, larger type. Which does not even need to be equiped with a ring structure.</p>",
        "id": 191348901,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584801872
    },
    {
        "content": "<p>Right -- so in the odd order paper this is the way of thinking.</p>",
        "id": 191348923,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801918
    },
    {
        "content": "<p>Make everything a subset of a large object, and then put the predicates on inclusions of subsets</p>",
        "id": 191348928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801936
    },
    {
        "content": "<p>But Mario is saying the exact opposite, he's saying put the predicate on A a ring and B an A-algebra</p>",
        "id": 191348935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584801951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348928\" title=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191348928\">said</a>:</p>\n<blockquote>\n<p>Make everything a subset of a large object, and then put the predicates on inclusions of subsets</p>\n</blockquote>\n<p>And afterwards, when needed and possible, prove alternate versions for items with a different carrier type, images under an appropriate morphism.</p>",
        "id": 191349012,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802028
    },
    {
        "content": "<p>so you're saying that I should define the concepts for A and B both subrings of some large X, and then if I happen to have a map of rings R -&gt; S then the image of R is a subset of the universal subset of S</p>",
        "id": 191349097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802124
    },
    {
        "content": "<p>Yes</p>",
        "id": 191349113,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802150
    },
    {
        "content": "<p>I think she wants <code>A</code> <code>B</code> and <code>C</code> subrings of large <code>R</code>.</p>",
        "id": 191349120,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584802160
    },
    {
        "content": "<p>but now if I have R -&gt; S and S -&gt; T and I get an induced map R -&gt; T then aren't I in big trouble?</p>",
        "id": 191349122,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802164
    },
    {
        "content": "<p>because my integrality predicate on R -&gt; S is about an inclusion (image of R) -&gt; (universal subset of S) in S</p>",
        "id": 191349184,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802221
    },
    {
        "content": "<p>but I now want to talk about the image of R and the image of S in T which is a different thing</p>",
        "id": 191349199,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802249
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, in general the supertype does not need to have a very strong structure. The carrier type of finite groups in the odd order theorem formal development is not necessarily a group itself.</p>",
        "id": 191349209,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802266
    },
    {
        "content": "<p>Isn't the issue here that if I define the predicate for two subsets A and B of a large ring X, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, if I define integrality for this, then if I have rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">B'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> subsets of a large ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>B</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">B'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and the diagram commuting, I can't deduce integrality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>A</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>→</mo><msup><mi>B</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">A'\\to B'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> from integrality of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span></p>",
        "id": 191349282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802340
    },
    {
        "content": "<p>Assia, are those lemmas stated in terms of an amorphous ambient type meant to be part of the public API, or are they hidden? (And thanks for joining us!)</p>",
        "id": 191349295,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584802362
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> sorry you lost me. We are no more talking about the same lemma, are we?</p>",
        "id": 191349307,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802379
    },
    {
        "content": "<p>I am trying to work out how to define 100 predicates on a situation where I have an injective map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> of rings.</p>",
        "id": 191349334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802418
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> ! My pleasure, again, thank you!</p>",
        "id": 191349335,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802418
    },
    {
        "content": "<p>I can model this situation in three ways. (1) I can define a structure <code>algebra A B</code> to mean that A and B are rings and we have a map A -&gt; B (2) I can consider A as a subset of B or (3) I can consider both A and B as subsets of a larger structure.</p>",
        "id": 191349396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802474
    },
    {
        "content": "<p>It is not completly amorphous: it is equipped with a signature, which fixes the laws common to all sub-stuff under consideration (here, ring operations I guess).</p>",
        "id": 191349400,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802477
    },
    {
        "content": "<p>I want to define 100 predicates and prove 100 lemmas about these predicates</p>",
        "id": 191349413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802502
    },
    {
        "content": "<p>and the lemmas are of the form \"if A -&gt; B has property P, and B -&gt; C has property Q, then A -&gt; C has property R\"</p>",
        "id": 191349429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802530
    },
    {
        "content": "<p>or \"if A -&gt; B and B -&gt; C are ring homomorphisms and if A -&gt; B has property P and A -&gt; C has property Q then B -&gt; C has property R\"</p>",
        "id": 191349445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802546
    },
    {
        "content": "<p>and all of these predicates make sense for general ring homomorphisms A -&gt; B, but they only depend on the image of A in B</p>",
        "id": 191349504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802610
    },
    {
        "content": "<p>so we can imagine that they are predicates on a ring B and a subring A</p>",
        "id": 191349516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802639
    },
    {
        "content": "<p>The idea of making everything a subset of a big Type, is basically just the assumption that everything lives inside some big commutative diagram where the maps are injective. What do you lose by just assuming something like this, where there are no injectivity assumptions?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">j</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">i</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 191349581,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1584802693
    },
    {
        "content": "<p>I forgot the commutativity assumption but you get the idea.</p>",
        "id": 191349589,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1584802718
    },
    {
        "content": "<p>But yes, it is part of the public API. The formal statement of the odd order theorem proved by our proof is</p>\n<div class=\"codehilite\"><pre><span></span>Theorem Feit_Thompson (gT : finGroupType) (G : {group gT}) : odd #|G| -&gt; solvable G.\n</pre></div>\n\n\n<p>where <code>finGroupType</code> is the ambiant type, equipped with a distinguished element, a binary law, etc. and <code>G</code> is a subset thereof, equipped with a true structure of group. So yes, one quantifier more than expected on paper.</p>",
        "id": 191349590,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802720
    },
    {
        "content": "<p>But what happens in practice is that when you are working with rings, sometimes you have two rings and a map between them, sometimes you have a ring and a subring, and sometimes you have two subrings of a ring, so I need all my theorems in all three situations and I also need them in \"mixed\" situations where A is a subring of B and there's a map from B to C</p>",
        "id": 191349594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> sorry I am not fast enough to answer all the messages. I am trying in order.</p>",
        "id": 191349699,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802850
    },
    {
        "content": "<p>First I would like  to make a disclaimer: I am still not quite sure about how to do commutative algebra right.</p>",
        "id": 191349745,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584802900
    },
    {
        "content": "<p>Yes, as a mathematician I was very surprised when I started to learn about this area that these issues, which simply do not exist in mathematics, are very subtle and perhaps not completely understood in this community.</p>",
        "id": 191349825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584802982
    },
    {
        "content": "<p>Can you apply the odd order theorem? If I create just an abstract group by putting a group structure on some type with precisely one term, can you prove that it is solvable using Feit-Thompson?</p>",
        "id": 191349902,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803089
    },
    {
        "content": "<p>some people might say that this is using a sledgehammer to crack a nut I guess</p>",
        "id": 191349918,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803123
    },
    {
        "content": "<p>Things are currently broken in mathcomp (which you can guess from <a href=\"https://github.com/math-comp/math-comp/blob/14e28e78155e3e6cfbe78aee0964569283f04d7d/mathcomp/algebra/ssralg.v#L903\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/blob/14e28e78155e3e6cfbe78aee0964569283f04d7d/mathcomp/algebra/ssralg.v#L903\">this line</a> in the definition of a ring structure in the hierarchy).</p>",
        "id": 191349926,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803128
    },
    {
        "content": "<p>Ooooh, that's bad</p>",
        "id": 191349978,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191349902\" title=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191349902\">said</a>:</p>\n<blockquote>\n<p>Can you apply the odd order theorem? If I create just an abstract group by putting a group structure on some type with precisely one term, can you prove that it is solvable using Feit-Thompson?</p>\n</blockquote>\n<p>Of course you can.</p>",
        "id": 191349982,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803183
    },
    {
        "content": "<p>Why not stating the expected version of Feit-Thompson after your weird statement?</p>",
        "id": 191349990,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803205
    },
    {
        "content": "<p>but my type is nothing to do with <code>finGroupType</code>?</p>",
        "id": 191349998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803219
    },
    {
        "content": "<p>At least it would make it easier to read for mathematicians.</p>",
        "id": 191350006,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> you will define the instance of group carrier type from your singleton type, and then the group you want to work with is the trivial group on this group type (yes, the library has defined this for you).</p>",
        "id": 191350069,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> What is the expected version?</p>",
        "id": 191350076,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803308
    },
    {
        "content": "<p>The expected version doesn't have the carrier type</p>",
        "id": 191350088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803324
    },
    {
        "content": "<p>Only one type, equipped with a group structure.</p>",
        "id": 191350091,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803333
    },
    {
        "content": "<p>Because it is stated in set theory.</p>",
        "id": 191350094,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350091\" title=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350091\">said</a>:</p>\n<blockquote>\n<p>Only one type, equipped with a group structure.</p>\n</blockquote>\n<p>I am not sure. My feeling is that mathematicians do not speak about types, just about sets.</p>",
        "id": 191350157,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803408
    },
    {
        "content": "<p>I mean <code>Theorem Feit_Thompson  (G : Group) : odd #|G| -&gt; solvable G.</code> (assuming bundled groups).</p>",
        "id": 191350158,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803410
    },
    {
        "content": "<p>or <code>Theorem Feit_Thompson (G : Type*) [group G] [finite G] : odd #|G| -&gt; solvable G.</code> if unbundled.</p>",
        "id": 191350177,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803454
    },
    {
        "content": "<p>That was the question I was trying to ask with my group of order 1 question.</p>",
        "id": 191350191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803497
    },
    {
        "content": "<p>I am trying to prove theorems about rings in this thread, and I am just beginning to understand that the statement of Feit-Thompson above is not in some sense a statement about the most general concept of a group</p>",
        "id": 191350248,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803567
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  In fact, you would apply the statement to the singleton <em>set</em>. And then inference of implicit stuff does the rest.</p>",
        "id": 191350251,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803571
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350248\" title=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350248\">said</a>:</p>\n<blockquote>\n<p>I am trying to prove theorems about rings in this thread, and I am just beginning to understand that the statement of Feit-Thompson above is not in some sense a statement about the most general concept of a group</p>\n</blockquote>\n<p>Why not?</p>",
        "id": 191350262,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803594
    },
    {
        "content": "<p>oops, I have to go offline, sorry.</p>",
        "id": 191350269,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584803608
    },
    {
        "content": "<p>thank you very much!</p>",
        "id": 191350272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803615
    },
    {
        "content": "<p>Maybe you shouldn't care, but if you tell a mathematician \"I've formalized Feit-Thompson, the statement is <code>Theorem Feit_Thompson  (G : Group) : odd #|G| -&gt; solvable G</code>\" they agree this is the expected statement, even without having ever heard of type theory, whereas <code>Theorem Feit_Thompson (gT : finGroupType) (G : {group gT}) : odd #|G| -&gt; solvable G.</code> looks alien.</p>",
        "id": 191350277,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584803630
    },
    {
        "content": "<p>So <code>solvable</code> here is a predicate on subsets of some ambient type. We can prove what Patrick and I would think of as the \"normal\" version by <em>defining</em> <code>solvable G</code> to be <code>solvable (set.univ G)</code></p>",
        "id": 191350330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584803686
    },
    {
        "content": "<p>I am only guessing at what is happening with Assia's link above, but here is some observation. If we have finitely many groups and for some technical type theory reason we want them all to be subgroups of a big object with a <code>1</code> and a <code>*</code> and an <code>inv</code>, we can just take the product of the groups and then each group naturally embeds as a subset.</p>",
        "id": 191350640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804087
    },
    {
        "content": "<p>it doesn't even have to be a finite set of groups</p>",
        "id": 191350694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804145
    },
    {
        "content": "<p>But this same trick cannot work with rings. If you have finitely many rings then each has a <code>0</code> and a <code>1</code> and a <code>+</code>, and if you want them all to be subsets of a big object with a universal <code>0</code> and <code>1</code> and <code>+</code>, then you're in trouble, because maybe <code>1 + 1 = 0</code> in some of the rings, but not in others, and if they all have the same <code>0</code> and the same <code>1</code> and the same <code>+</code> then they all have the same <code>2</code></p>",
        "id": 191350701,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804154
    },
    {
        "content": "<p>and the zero ring has <code>0=1</code></p>",
        "id": 191350715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804189
    },
    {
        "content": "<p>although possibly the big not-a-group in F-T is actually finite; I'm not sure whether it gets enforced there or on the groups themselves</p>",
        "id": 191350720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804194
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350640\" title=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/191350640\">said</a>:</p>\n<blockquote>\n<p>I am only guessing at what is happening with Assia's link above, but here is some observation. If we have finitely many groups and for some technical type theory reason we want them all to be subgroups of a big object with a <code>1</code> and a <code>*</code> and an <code>inv</code>, we can just take the product of the groups and then each group naturally embeds as a subset.</p>\n</blockquote>\n<p>I don't think that really works particularly well, because they also have to embed in a way such that all the maps you care about between these groups become inclusions</p>",
        "id": 191350772,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1584804243
    },
    {
        "content": "<p>But Kevin, the big object is not a group/ring/whatever structure</p>",
        "id": 191350777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804254
    },
    {
        "content": "<p>This doesn't matter</p>",
        "id": 191350784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804263
    },
    {
        "content": "<p>and the inclusions are not ring homs</p>",
        "id": 191350788,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804271
    },
    {
        "content": "<p>Oh this matters</p>",
        "id": 191350797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804284
    },
    {
        "content": "<p>My understanding was that they were all inheriting the structure from the big type</p>",
        "id": 191350801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804300
    },
    {
        "content": "<p>oh wait, they are not ring homs but they are +,*,0,1 homs</p>",
        "id": 191350816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804319
    },
    {
        "content": "<p>Mario, concretely I'm saying that there is no big object with 0,1,+,* such that Z/2Z and Z/3Z are both subsets containing the 0 and 1 and closed under + and *</p>",
        "id": 191350872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804389
    },
    {
        "content": "<p>Z/2Z * Z/3Z?</p>",
        "id": 191350880,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584804411
    },
    {
        "content": "<p>It doesn't work</p>",
        "id": 191350882,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804417
    },
    {
        "content": "<p>they have different 1's</p>",
        "id": 191350887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804425
    },
    {
        "content": "<p>Z/2Z x Z/3Z = Z/6Z and Z/2Z ={0,3} and Z/3Z={0,2,4}</p>",
        "id": 191350891,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804441
    },
    {
        "content": "<p>However I'm not sure that this is a problem. So what if the big not-a-ring fixes the characteristic? All rings in the commutative diagram will have compatible characteristics anyway</p>",
        "id": 191350892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804441
    },
    {
        "content": "<p>Oh yes, you're right.</p>",
        "id": 191350897,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584804452
    },
    {
        "content": "<p>It's not true that the rings will have the same characteristic. There is a perfectly good map Z/6Z -&gt; Z/3Z</p>",
        "id": 191350940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804493
    },
    {
        "content": "<p>compatible meaning divisible</p>",
        "id": 191350946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804503
    },
    {
        "content": "<p>This is weird. In the A-M situation it's a question about inclusions <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> but there is a more general statement about maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span></p>",
        "id": 191350965,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804560
    },
    {
        "content": "<p>this trick is only for inclusion maps, right?</p>",
        "id": 191350967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804567
    },
    {
        "content": "<p>and in the more general statement you certainly can't embed everything into an ambient type, but in the inclusion situation you can</p>",
        "id": 191350972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804586
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  suggestion is really interesting. It feels like a much more Lean-idiomatic way to do things.</p>",
        "id": 191351035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804703
    },
    {
        "content": "<p>I think this trick is not generally applicable. It's good for groups, but I can't possibly see this generalizing to all the other interesting algebraic objects, given the constraints already in rings</p>",
        "id": 191351038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804716
    },
    {
        "content": "<p>Yes that is my guess too.</p>",
        "id": 191351076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804728
    },
    {
        "content": "<p>I don't understand what properties groups have that make the technique so powerful for them</p>",
        "id": 191351082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804746
    },
    {
        "content": "<p>for it to be generally applicable, it needs to put basically no restrictions on the \"mathematical content\". If the embeddings were more unstructured, for example if they each pick their own 0,1,+,* operations, then this could work, but then you are basically just doing set theory</p>",
        "id": 191351101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804804
    },
    {
        "content": "<p>I feel like I am very interested in one structure consisting of three rings A, B, C and a commuting triangle A -&gt; B -&gt; C (in the maths sense, i.e. maps A -&gt; B and B -&gt; C)</p>",
        "id": 191351107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804820
    },
    {
        "content": "<p>and I am not at all sure that I want to assume that the image of A in B is isomorphic to the image of A in C</p>",
        "id": 191351168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584804861
    },
    {
        "content": "<p>I think what makes groups work is just what you said earlier: you can product a bunch of groups together to embed whatever you want. The category of groups has coproducts</p>",
        "id": 191351263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584804997
    },
    {
        "content": "<p>the category of rings has coproducts too but the maps aren't in general injective</p>",
        "id": 191351285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584805034
    },
    {
        "content": "<p>the coproduct of Z/2 and Z/3 is 0</p>",
        "id": 191351298,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584805050
    },
    {
        "content": "<p>if R is a ring and I have a map Z/2Z -&gt; R and a map Z/3Z -&gt; R (ring homs) then 2=0 and 3=0 in R so 1=0</p>",
        "id": 191351312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584805076
    },
    {
        "content": "<p>how about we refactor <code>algebra</code> in terms of <code>ring_hom</code> like <a href=\"https://github.com/leanprover-community/mathlib/blob/a130c73a36a15ae2b98933e31ffb49a83c7f7420/src/field_theory/splitting_field.lean\">https://github.com/leanprover-community/mathlib/blob/a130c73a36a15ae2b98933e31ffb49a83c7f7420/src/field_theory/splitting_field.lean</a></p>",
        "id": 199853767,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591349793
    },
    {
        "content": "<p>like define <code>is_noetherian : ring_hom A B \\to Prop</code></p>",
        "id": 199853788,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591349810
    },
    {
        "content": "<p>hmm maybe this doesn't solve the problem</p>",
        "id": 199853955,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591349917
    },
    {
        "content": "<p>Another possibiilty is to do it all in the concrete category of rings</p>",
        "id": 199858161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591352865
    },
    {
        "content": "<p>They made that now</p>",
        "id": 199858163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591352871
    },
    {
        "content": "<p>so you have all the flexibility of category theory notation and your ring stuff too</p>",
        "id": 199858215,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591352885
    },
    {
        "content": "<p>The reasom <code>algebra</code> is so interesting is because it is a bundled mophism</p>",
        "id": 199858253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591352918
    },
    {
        "content": "<p>It's \"Hom(A,B)\"</p>",
        "id": 199858274,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591352935
    },
    {
        "content": "<p>and in some sense  category theory or not category theory is the question about whether we want to do abstract homs (\"sure you can compose them, here's the answer\") or concrete homs (\"this is a functional programming language, I will compose the functions\")</p>",
        "id": 199858370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591353000
    },
    {
        "content": "<p>The issue with <code>algebra</code> is that it gives rise to a module structure so it kind of has to be a class. If you've got some diagram of rings, then you have a ton of modules lying around, and it's quite difficult to synthesise the instances.</p>",
        "id": 199858700,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591353209
    },
    {
        "content": "<p>\"I am a morphism of rings\" is a troublesome concept. There seem to be several ways of setting up <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>R</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(A,R)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mclose\">)</span></span></span></span>.. <code>algebra A R</code> is one way (bundled homs and <code>coe_to_fun</code>, which there are apparently problems with) or  <code> A \\to R</code>  plus a huge amount of typeclass inference (\"Yes of course a division ring is a semimonoid, stop wasting my time\" -- the curse of the invisible maps) or do you want to try some category theory  <code>A \\hom B</code> now <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> has made it a concrete category?</p>",
        "id": 199859037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591353451
    },
    {
        "content": "<p>bundled all the way! :-)</p>",
        "id": 199859126,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591353500
    },
    {
        "content": "<p>It seems to me that if the typeclass system is completely refactored in Lean 4 then perhaps it is worth attempting unbundled classes for ring homs again</p>",
        "id": 199859225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591353592
    },
    {
        "content": "<p>Scott -- if you think everything should be bundled, then are you suggesting that category theory is a solution which will somehow avoid all the issues involved with carrying around boilerplate?</p>",
        "id": 199859341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591353657
    },
    {
        "content": "<p>We want to pick one term of <code>algebra R A</code> (aka <code>R →* A</code>) and say: Hey, this one is special.<br>\nLean is bad at composing special maps.</p>",
        "id": 199859471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591353750
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"c1\">-- algebra.comap A B C is defeq to C</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_noetherian_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">hac</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span><span class=\"o\">)</span>\n<span class=\"n\">include</span> <span class=\"n\">hac</span> <span class=\"n\">hbc</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">Artin_Tate</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 199859521,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591353806
    },
    {
        "content": "<p>let's say this is the statement</p>",
        "id": 199859527,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591353811
    },
    {
        "content": "<p>then I think I should be able to prove this</p>",
        "id": 199859537,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591353826
    },
    {
        "content": "<p>But will you be able to use it?</p>",
        "id": 199859632,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591353878
    },
    {
        "content": "<p>I think Chris pointed out some time ago that we shouldn't have <code>comap</code> in theorem statements.</p>",
        "id": 199859652,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591353899
    },
    {
        "content": "<p>oh well oh no</p>",
        "id": 199859732,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591353944
    },
    {
        "content": "<p>is there just no way to state the theorem then?</p>",
        "id": 199859748,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591353959
    },
    {
        "content": "<p>How about you have an <code>A</code>-algebra structure on <code>C</code> and an <code>A</code>-alg-hom from <code>B</code> to <code>C</code> as argument?</p>",
        "id": 199860021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354103
    },
    {
        "content": "<p>Then you need to think about how you turn <code>C</code> into a <code>B</code>-module...</p>",
        "id": 199860048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354119
    },
    {
        "content": "<p>yeah...</p>",
        "id": 199860058,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591354127
    },
    {
        "content": "<p>and then we would need to define algebras on top of algebra</p>",
        "id": 199860073,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591354141
    },
    {
        "content": "<p>and then hence the title of this post</p>",
        "id": 199860080,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591354145
    },
    {
        "content": "<p>Yup... it hasn't been scaling for me either</p>",
        "id": 199860093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354159
    },
    {
        "content": "<p>I think that there has been almost no commutative algebra getting into mathlib for quite a long time. And it's mostly because of this issue, I think.</p>",
        "id": 199860131,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354186
    },
    {
        "content": "<p>how did the ZFC people never realize this problem?</p>",
        "id": 199860204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1591354214
    },
    {
        "content": "<p>Because it isn't?</p>",
        "id": 199860219,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354226
    },
    {
        "content": "<p>Mathematicians are only interested in what can be done in theory, not in what can be done in practice.</p>",
        "id": 199860283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591354292
    },
    {
        "content": "<p>Just add an instance <code>algebra A C</code> to your statement, and drop the comap stuff. Then add <code>H : the_diagram_commutes</code></p>",
        "id": 199860360,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354324
    },
    {
        "content": "<p>And maybe this is the way to go...</p>",
        "id": 199860375,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354338
    },
    {
        "content": "<p>Just have lots of explicit <code>the_diagram_commutes</code> hypothesis. And hope that we can build and API (and automation) around that.</p>",
        "id": 199860401,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354365
    },
    {
        "content": "<p>But I feel like we need something better than <code>function.comp</code> for such machinery.</p>",
        "id": 199860440,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354405
    },
    {
        "content": "<p>I think this is definitely the way to go. Just have functors from preorders, and a bunch of standard diagram shapes, and we'll use <code>ring_hom.comp</code>. For the standard shapes you'd be able to synthesize module instances as well, i.e., if the diagram in <code>fin3</code> with the usual order, then <code>field 2</code> is a module over <code>field 0</code> and so on.</p>",
        "id": 199860702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591354598
    },
    {
        "content": "<p>Kenny I never made it to the end of NSS :-( and I was really into that for a while, when I was teaching alg geom for the first time and trying to formalise it as well (just backing up Johan's claim that algebra has slowed down).</p>",
        "id": 199860705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591354600
    },
    {
        "content": "<p>On the other hand, Amelia has completely refactored localisations, so progress is still being made.</p>",
        "id": 199860806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591354677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/199860702\">said</a>:</p>\n<blockquote>\n<p>I think this is definitely the way to go. Just have functors from preorders, and a bunch of standard diagram shapes, and we'll use <code>ring_hom.comp</code>.</p>\n</blockquote>\n<ol>\n<li>I would like to abstract over<code>ring_hom.comp</code>. So use category theory.</li>\n<li>You need the diagrams to glue in an unobtrusive way. Whatever approach I think of with these diagrams... it always seems to lead to something really ugly and unreadable.</li>\n</ol>",
        "id": 199861043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> Can your diagram machinery help us here?</p>",
        "id": 199861065,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354830
    },
    {
        "content": "<p>That is another problem actually. You want the fact that the corresponding diagram of polynomial rings commutes and all this stuff.</p>",
        "id": 199861214,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591354938
    },
    {
        "content": "<p>Ideally, I would like to be able to write (in 95% of the cases):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">blabla</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">obvious_diagram_commutes</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 199861241,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591354964
    },
    {
        "content": "<p><code>by obvious_diagram_commutes</code> should spit out some data structure that can be as ugly and complex as it wants, as long as I don't have to see it or write it!</p>",
        "id": 199861294,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355021
    },
    {
        "content": "<p>And then whenever we have to prove such a hypothesis, another tactic steps in, and eats up all these complex data structures, and spits out the proof that is needed.</p>",
        "id": 199861370,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355063
    },
    {
        "content": "<p>But this becomes quite complicated quite quickly. You also want the fact that <code>ideal.quotient (I.map (ring_hom.of C)) \\~- polynomial (ideal.quotient I)</code> and there are hundreds of these little things.</p>",
        "id": 199861377,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591355067
    },
    {
        "content": "<p>This requires something quite powerful, I think it's probably possible but a big job.</p>",
        "id": 199861493,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591355162
    },
    {
        "content": "<p>But we need it.</p>",
        "id": 199861542,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355188
    },
    {
        "content": "<p>Of course we can just do everything by hand. But that feels like admitting defeat to me.</p>",
        "id": 199861562,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355208
    },
    {
        "content": "<p>Also, we'll never reach a proof of the big theorems in alg.geom / number theory if we have to do everything by hand.</p>",
        "id": 199861609,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355254
    },
    {
        "content": "<p>Agreed.</p>",
        "id": 199861625,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591355264
    },
    {
        "content": "<p>The <code>le/lt</code> vs <code>ge/gt</code> issue already feels like defeat to me. But I can see past it. This one, I can't.</p>",
        "id": 199861692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355294
    },
    {
        "content": "<p>I have to do a fourth year project, and I was thinking about potentially doing something related to this. I have a lot of time, but maybe not enough</p>",
        "id": 199861702,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591355304
    },
    {
        "content": "<p>At some point someone said that Lean was \"bad at carrying around a canonical instance\". Type class inference seems to carry around the canonical 0, but we sometimes want to carry around the canonical map (and most definitely we do not want to do this all the time). How about an <code>is_canonical</code> typeclass for whatever <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(R,A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span></span></span></span> turns out to be?</p>",
        "id": 199861751,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355346
    },
    {
        "content": "<p>What are the laws?</p>",
        "id": 199861843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591355402
    },
    {
        "content": "<p>Many A-strutures are R-structures, but it's always comapping along the canonical map from R to A so we don't even bother noting that they're R-structures eplicitly</p>",
        "id": 199861868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355413
    },
    {
        "content": "<p>it's certainly transitive</p>",
        "id": 199861888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355432
    },
    {
        "content": "<p>it's most definitely never a global instance</p>",
        "id": 199861910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355450
    },
    {
        "content": "<p>because sometimes the identity is canonical but sometimes I'm checking that some diagram commutes under some explicit change of convention</p>",
        "id": 199861972,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355506
    },
    {
        "content": "<p>e,g, once you picked a basis, the map from the vector space to the lists of real numbers is now canonical</p>",
        "id": 199862040,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355527
    },
    {
        "content": "<p>Maybe canonicality is a purely local notion, which is why the global attempt to define it in Wikipedia is so atrocious.</p>",
        "id": 199862096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355564
    },
    {
        "content": "<p>I need a badge saying <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mo>↦</mo><mo stretchy=\"false\">(</mo><mi>f</mi><mo>↦</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">v\\mapsto(f\\mapsto(-f(v)))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 199862157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355625
    },
    {
        "content": "<p>The canonical map from a vector space to its double dual</p>",
        "id": 199862168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355636
    },
    {
        "content": "<p>There are two canonical maps from an idele group to the abelianisation of an absolute Galois group of Q, you choose which one you want (Artin or Deligne) and then all the maps between the objects will be the canonical ones under that normalisation in your paper on Shimura varieties.</p>",
        "id": 199862296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591355742
    },
    {
        "content": "<p><code>canonical</code> should mean a \"flat section\" of a functor <code>C ⥤  Type</code>. That is, a function <code>f : Π X : C, F.obj X</code>, with the property that for any iso <code>i : X ≅ Y</code>, we have <code>F.map (i.hom) (f x) = f y</code>.</p>",
        "id": 199862429,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591355860
    },
    {
        "content": "<p>(and you get to design the morphisms in <code>C</code> appropriately to make this fit examples)</p>",
        "id": 199862485,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591355884
    },
    {
        "content": "<p>as trivial examples, <code>(λ R : Ring, (0 : R))</code> is a flat section of the forgetful functor <code>Ring ⥤  Type</code>, and hence \"<code>0</code> is <code>canonical</code>\"</p>",
        "id": 199862533,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591355936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> But will this help with <code>Artin_Tate</code> that Kenny posted above?</p>",
        "id": 199862642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356010
    },
    {
        "content": "<p>How would you write the statement of that result?</p>",
        "id": 199862655,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356020
    },
    {
        "content": "<p>No idea :-)</p>",
        "id": 199862666,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591356027
    },
    {
        "content": "<p>I just want people to stop hoping <code>canonical</code> means something magical. :-)</p>",
        "id": 199862675,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591356042
    },
    {
        "content": "<p>I'm pretty sure the \"canonical\" map V to V-double-dual is canonical in this sense.</p>",
        "id": 199862705,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591356079
    },
    {
        "content": "<p>I am just explaining the specification, I don't know anything about the implementation :-)</p>",
        "id": 199862713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356089
    },
    {
        "content": "<p>Yes, the canonical map from V to its double-dual is also canonical, that's the point</p>",
        "id": 199862732,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356108
    },
    {
        "content": "<p>The definition of canonical is part of the specification.</p>",
        "id": 199862735,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591356112
    },
    {
        "content": "<p>The definition is just that I want it to spit out the term I ask for.</p>",
        "id": 199862794,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356147
    },
    {
        "content": "<p>And then you let me train it while I prove the Artin-Tate lemma with rings A,B,C  and canonical maps between them</p>",
        "id": 199862821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356182
    },
    {
        "content": "<p>If A -&gt; B is injective, and c is the canonical element of B, and it is in the image of A, then we just got a canonical element of A</p>",
        "id": 199862865,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356225
    },
    {
        "content": "<p>They'll just come up as I think of them I think</p>",
        "id": 199862879,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356234
    },
    {
        "content": "<p>Or maybe these rings A, B and C are somehow only rings up to isomorphism or up to canonical isomorphism perhaps</p>",
        "id": 199862968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1591356296
    },
    {
        "content": "<p>From the thesis of <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">meta</span> <span class=\"kn\">structure</span> <span class=\"n\">chase_data</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">morphisms</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">morphism</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">comm_lemmas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">commutativity_lemma</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">elem_lemmas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">element_lemma</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">exact_lemmas</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">exactness_lemma</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 199863084,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356378
    },
    {
        "content": "<p>Maybe we need a similar data structure. And some tactics to prove commutativity diagrams.</p>",
        "id": 199863108,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356403
    },
    {
        "content": "<p>It could even use <code>coe_to_fun</code> maybe.</p>",
        "id": 199863128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356420
    },
    {
        "content": "<p>Here's a concrete question: can you write me a tactic that collects all terms in the context that can be coerced to a function?</p>",
        "id": 199863283,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356489
    },
    {
        "content": "<p>And then another one that asserts that any two possible paths with the same endpoints (via those collected functions) are propositionally equal.</p>",
        "id": 199863345,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356573
    },
    {
        "content": "<p>Actually, I'm fine with providing all the maps in the diagram, for now.</p>",
        "id": 199863431,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356646
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">[</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">algebra_map</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">])</span>\n</code></pre></div>\n\n\n<p>The problem is that this doesn't type check, because <code>algebra_map A B</code> doesn't have the same type as <code>algebra_map B C</code>.</p>",
        "id": 199863599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591356779
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/199863345\">said</a>:</p>\n<blockquote>\n<p>And then another one that asserts that any two possible paths with the same endpoints (via those collected functions) are propositionally equal.</p>\n</blockquote>\n<p>I think this is essentially a finite problem, there are only finitely many (and not that many) ways of composing the paths together, and you can compute the transitive closure of a relation on a finite type, so I would say yes.</p>",
        "id": 199863923,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591357050
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">adjoin</span>\n\n<span class=\"kn\">universe</span> <span class=\"kn\">variables</span> <span class=\"n\">u</span>\n\n<span class=\"n\">def</span> <span class=\"n\">list_of_functions</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list_of_functions</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">test</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_noetherian_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">hac</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span><span class=\"o\">)</span>\n<span class=\"n\">include</span> <span class=\"n\">hac</span> <span class=\"n\">hbc</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">artin_tate</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">[</span><span class=\"bp\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n                          <span class=\"bp\">⟨</span><span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n                          <span class=\"bp\">⟨</span><span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">algebra_map</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"bp\">⟩</span><span class=\"o\">])</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">test</span>\n</code></pre></div>",
        "id": 199864291,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357357
    },
    {
        "content": "<p>Ideally this would become</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">artin_tate</span>\n  <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">duh</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"err\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 199864353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357406
    },
    {
        "content": "<p>For some value of <code>duh</code></p>",
        "id": 199864372,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357414
    },
    {
        "content": "<p>What information do you want to give the <code>duh</code> tactic?</p>",
        "id": 199864479,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591357486
    },
    {
        "content": "<p>It could just look through the context for assumptions that are arrow like: <code>→</code>, <code>→+</code>, <code>→*</code>, <code>algebra A B</code>, etc...</p>",
        "id": 199864554,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357544
    },
    {
        "content": "<p>Do you want it to use things like <code>polynomial.map_map</code>?</p>",
        "id": 199864623,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591357577
    },
    {
        "content": "<p>No, it should just collect morphisms from the context</p>",
        "id": 199864658,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357610
    },
    {
        "content": "<p>The smart tactics are the ones that consume <code>diagram_commutes</code></p>",
        "id": 199864768,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591357625
    },
    {
        "content": "<p>I see. I'm not sure the smart tactics should consume <code>diagram_commutes</code>. Just like you can't prove equalities of ring expressions using <code>simp [ring_axioms]</code> you need something smarter to prove equality of expressions in categories that use standard category theory things like functors.</p>",
        "id": 199865665,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1591358208
    },
    {
        "content": "<p>Hmm, I see</p>",
        "id": 199866064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591358470
    },
    {
        "content": "<p>Nevertheless... it might work in most cases?</p>",
        "id": 199866119,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591358516
    },
    {
        "content": "<p>I mean... <code>obviously</code> can prove a lot of stuff in the category library.</p>",
        "id": 199866187,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591358546
    },
    {
        "content": "<p>and <code>rewrite_search</code> is very good at commutative diagrams...</p>",
        "id": 199868852,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1591360281
    },
    {
        "content": "<p>So the solution (as of the current state of mathlib) is to have three maps between A, B, and C, and a claim that they commute?</p>",
        "id": 202394874,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593491715
    },
    {
        "content": "<p>(this thread has become kinda long for me to scroll through it)</p>",
        "id": 202394881,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593491731
    },
    {
        "content": "<p>That's whay I would like to have.<br>\nPlus automation to figure out why diagrams commute.</p>",
        "id": 202394890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593491759
    },
    {
        "content": "<p>or maybe <code>[algebra A B] [algebra B C] [algebra A C]</code>?</p>",
        "id": 202394943,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593491798
    },
    {
        "content": "<p>(and then a fact that they commute)</p>",
        "id": 202394948,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593491807
    },
    {
        "content": "<p>Exactly</p>",
        "id": 202395033,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593491980
    },
    {
        "content": "<p>That's what I was thinking of somewhere upstairs</p>",
        "id": 202395037,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593491990
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">integral_closure</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">is_commute₃</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"err\">•</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 202395559,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593492822
    },
    {
        "content": "<p>how does this look?</p>",
        "id": 202395561,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593492824
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">integral_closure</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">is_commute₃</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"err\">•</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_commute₃</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">is_integral_trans&#39;</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">},</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">B</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 202396458,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593494127
    },
    {
        "content": "<p>I will try (and maybe livestream on discord) to prove this after 30 minutes from now</p>",
        "id": 202396518,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593494165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I'm not sure whether <code>is_commute3</code> should be a class.</p>",
        "id": 202397536,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593495832
    },
    {
        "content": "<p>why not?</p>",
        "id": 202397579,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593495855
    },
    {
        "content": "<p>I don't think tc is the correct sort of automation to take 5 <code>is_commute</code> instances and prove number 6</p>",
        "id": 202397582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593495864
    },
    {
        "content": "<p>I want a solution that will also work in the statement of the snake lemma</p>",
        "id": 202397588,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593495885
    },
    {
        "content": "<p>In particular, my gut feeling is that we should state the condition in terms of composition of ordinary functions.</p>",
        "id": 202397598,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593495917
    },
    {
        "content": "<p>And probably a dedicated tactic can build proofs of <code>is_commute</code> by looking through the context for other terms of <code>is_commute</code> and then doing some elementary chase through the diagram.</p>",
        "id": 202397653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593495981
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">integral_closure</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">is_commute₃</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"err\">•</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_commute₃</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- I hope this will never be used.</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">ext</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">clear</span> <span class=\"n\">h2</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"err\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">h1</span> <span class=\"bp\">=</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfreezingI</span> <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">h1</span> <span class=\"k\">with</span> <span class=\"n\">f1</span> <span class=\"n\">g1</span> <span class=\"n\">h11</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">h2</span> <span class=\"k\">with</span> <span class=\"n\">f2</span> <span class=\"n\">g2</span> <span class=\"n\">h21</span> <span class=\"n\">h22</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"n\">congr&#39;</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">ext</span> <span class=\"n\">r</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n  <span class=\"n\">ext</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">g1</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"err\">←</span> <span class=\"n\">h12</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">mul_one</span> <span class=\"o\">(</span><span class=\"n\">g2</span> <span class=\"n\">r</span><span class=\"o\">),</span> <span class=\"err\">←</span> <span class=\"n\">h22</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">],</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- I hope this will never be used.</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">is_commute₃</span><span class=\"bp\">.</span><span class=\"n\">comap_eq</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">comap</span><span class=\"bp\">.</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"n\">inst_6</span> <span class=\"o\">:=</span>\n<span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n<span class=\"k\">calc</span>  <span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">z</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">algebra_map_eq_smul_one</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">is_commute₃</span><span class=\"bp\">.</span><span class=\"n\">smul_assoc</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">one_smul</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">is_integral_trans&#39;</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">},</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hz</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">B</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">A</span> <span class=\"n\">z</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">convert</span> <span class=\"n\">is_integral_trans</span> <span class=\"bp\">@</span><span class=\"n\">hab</span> <span class=\"n\">z</span> <span class=\"n\">hz</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">is_commute₃</span><span class=\"bp\">.</span><span class=\"n\">comap_eq</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 202398201,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593496932
    },
    {
        "content": "<p>hey this worked like a charm!</p>",
        "id": 202398204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593496936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 202398220,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593496987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/202397588\">said</a>:</p>\n<blockquote>\n<p>I want a solution that will also work in the statement of the snake lemma</p>\n</blockquote>\n<p>I guess at this moment I'm only interested at formalizing a C/B/A situation</p>",
        "id": 202398233,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497021
    },
    {
        "content": "<p>Will there be <code>D/C/B/A</code> situations?</p>",
        "id": 202398236,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497040
    },
    {
        "content": "<p>Yes, but tomorrow</p>",
        "id": 202398283,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593497101
    },
    {
        "content": "<p>then I can have (if I still remember my combinatorics) four <code>is_commute\\3</code> instances</p>",
        "id": 202398292,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497119
    },
    {
        "content": "<p>That might be like asking whether there will be a quotient.induction_on4 function one day</p>",
        "id": 202398306,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593497154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Well, you do care about the snake lemma, do you?</p>",
        "id": 202398373,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497230
    },
    {
        "content": "<p>Sure. But I also care about this Artin Tate lemma</p>",
        "id": 202398456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593497390
    },
    {
        "content": "<p>Artin--Tate is false!</p>",
        "id": 202398656,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497619
    },
    {
        "content": "<p>Take A any Noetherian ring, B = A[x1, x2, ...], C = A, where B -&gt; C sends each xi to 0</p>",
        "id": 202398670,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497641
    },
    {
        "content": "<p>then C/A is algebra-finite and C/B is module-finite but B/A is not algebra-finite</p>",
        "id": 202398716,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497655
    },
    {
        "content": "<p>So we need some injective hypothesis...? If so then why don't we just assume B is a subring of C to begin with?</p>",
        "id": 202398849,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497848
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">section</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">is_commute</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">is_commute</span><span class=\"bp\">.</span><span class=\"n\">apply_apply</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_commute</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">comm</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kn\">abbreviation</span> <span class=\"n\">is_commute_alg</span> <span class=\"o\">:=</span> <span class=\"n\">is_commute</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">A</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">is_commute_alg</span><span class=\"bp\">.</span><span class=\"n\">smul_assoc</span> <span class=\"o\">(</span><span class=\"n\">hc</span> <span class=\"o\">:</span> <span class=\"n\">is_commute_alg</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"err\">•</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">smul_def</span><span class=\"o\">,</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"bp\">.</span><span class=\"n\">apply_apply</span><span class=\"o\">,</span> <span class=\"n\">mul_assoc</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 202398868,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497881
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> How about that?</p>",
        "id": 202398909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497887
    },
    {
        "content": "<p>what's the difference?</p>",
        "id": 202398918,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497904
    },
    {
        "content": "<p>That the base structure would mix with group homs and ring homs etc...</p>",
        "id": 202398929,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497921
    },
    {
        "content": "<p>It's not tying itself down to algebras</p>",
        "id": 202398934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497933
    },
    {
        "content": "<p>I care about commutative diagrams of modules</p>",
        "id": 202398949,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497957
    },
    {
        "content": "<p>I've never seen a statement involving a tower of group extensions</p>",
        "id": 202398956,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497963
    },
    {
        "content": "<p>oh ok</p>",
        "id": 202398962,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593497971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/202398956\">said</a>:</p>\n<blockquote>\n<p>I've never seen a statement involving a tower of group extensions</p>\n</blockquote>\n<p>Snake lemma</p>",
        "id": 202398972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593497992
    },
    {
        "content": "<p>no no no this is all wrong</p>",
        "id": 202399288,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498318
    },
    {
        "content": "<p>the correct definition of a diagram is a functor from a small category on <code>fin n</code> to the category of rings/modules/whatever</p>",
        "id": 202399297,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498335
    },
    {
        "content": "<p>this doesn't mean we have to use the category theory library</p>",
        "id": 202399307,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/199864291\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">list_of_functions</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list_of_functions</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n</blockquote>",
        "id": 202399360,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498405
    },
    {
        "content": "<p>This won't work because we would have to use type equality</p>",
        "id": 202399376,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498424
    },
    {
        "content": "<p>and then the workaround would be just to index the types with natural numbers</p>",
        "id": 202399384,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498438
    },
    {
        "content": "<p>hence what I said about <code>fin n</code></p>",
        "id": 202399398,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498456
    },
    {
        "content": "<p>Again, when I say \"category\", I just mean a concrete implementation of category into Lean</p>",
        "id": 202399446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498489
    },
    {
        "content": "<p>Yes I think A can be anything but B to C has to be injective</p>",
        "id": 202399614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593498717
    },
    {
        "content": "<p>There's an intermediate A-algebra  B0 in the AM proof which has to be a subring of B (and of C)</p>",
        "id": 202399722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593498806
    },
    {
        "content": "<p>so what's the point of using this if B is always a subring of C</p>",
        "id": 202399784,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498847
    },
    {
        "content": "<p>anyway, I'm trying to make commutative diagrams, and I would like to know what it means for f1, f2: A -&gt; B to commute</p>",
        "id": 202399795,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593498874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/202399360\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/algebra.20is.20not.20scaling.20for.20me/near/199864291\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">list_of_functions</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"err\">Σ</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">diagram_commutes</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list_of_functions</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n</blockquote>\n</blockquote>\n<p>Yup, I proposed something like that higher up in the thread... and I agree that we should generalise <code>is_commute3</code>.</p>",
        "id": 202399934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593499059
    },
    {
        "content": "<p>But it's not obvious how to get it right. Because type equality, like you said.</p>",
        "id": 202400001,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593499103
    },
    {
        "content": "<p>And I want to take unions of diagrams, and add a vertex, etc...</p>",
        "id": 202400019,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593499120
    },
    {
        "content": "<p>I think this is an interesting nontrivial problem</p>",
        "id": 202400072,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593499201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> come to my livestream to find out!</p>",
        "id": 202400176,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593499266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> I'm on my way</p>",
        "id": 202400276,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593499338
    },
    {
        "content": "<p>I'll be there once I've got my daughter off to school</p>",
        "id": 202401346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593500403
    },
    {
        "content": "<p>A question that has arisen from the livestream is whether <code>algebra A B</code> or <code>A \\to+* B</code> should be the \"simp-normal form\"</p>",
        "id": 202404285,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593503333
    },
    {
        "content": "<p>Oooh, I thought the question was which side of <code>algebra.smul_def</code> should be SNF</p>",
        "id": 202404308,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593503370
    },
    {
        "content": "<p>what do we do with situations where the map is the Frobenius map? Then we would have two <code>[algebra R R]</code> instances</p>",
        "id": 202557766,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593603227
    },
    {
        "content": "<p>What are reasons preferring one over the other?</p>",
        "id": 202557808,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1593603248
    },
    {
        "content": "<p>Usually in maths when one considers an R-module M as an R-module via the Frobenius there is some kind of notational indication of this, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>M</mi><mrow><mo stretchy=\"false\">(</mo><mi>σ</mi><mo stretchy=\"false\">)</mo></mrow></msup></mrow><annotation encoding=\"application/x-tex\">M^{(\\sigma)}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8879999999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span></span></span></span> or something</p>",
        "id": 202558004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1593603416
    },
    {
        "content": "<p>aka a type synonym (-;</p>",
        "id": 202559351,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593604509
    },
    {
        "content": "<p>Sometimes the algebra type class is used when the module structure isn't really being considered, but maybe it was considered somewhere in a proof. I'm not sure it should be, I think perhaps the algebra type-class should only be used when you are really stating something about the algebra structure, i.e. the statement uses the module structure.</p>",
        "id": 202562142,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1593606569
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4282\">#4282</a></p>",
        "id": 211403399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1601191901
    },
    {
        "content": "<p>So the problem I ran into has been solved with <code>is_scalar_tower</code>. To summarise this thread, if you're proving things about three rings A subset B subset C then ideally you would have A a subring of B, B a subring of C, A a subring of C, B an A-algebra, C a B-algebra and C an A-algebra all at once. With the current set up in mathlib it doesn't even make sense to say all of these things at once. In the odd order work for groups this is fixed by making A,B,C all subgroups of a big group but this trick can't be done in general and one world rather work with types than terms anyway. This is a proof of concept that <code>is_scalar_tower</code> can be used instead.</p>",
        "id": 211404876,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1601194680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112165\">rss-bot</span> <a href=\"#narrow/stream/116290-rss/topic/Recent.20Commits.20to.20mathlib.3Amaster/near/211585013\">said</a>:</p>\n<blockquote>\n<p><strong><a href=\"https://github.com/leanprover-community/mathlib/commit/0bb5e5d94d688bdbde8615d924742315cbe19def\">feat(ring_theory/algebra_tower): Artin--Tate lemma (#4282)</a></strong><br>\nfeat(ring_theory/algebra_tower): Artin--Tate lemma (<a href=\"https://github.com/leanprover-community/mathlib/issues/4282\">#4282</a>)</p>\n<p>Co-authored-by: Rob Lewis &lt;<a href=\"mailto:Rob.y.lewis@gmail.com\">Rob.y.lewis@gmail.com</a>&gt;<br>\n<a href=\"https://github.com/leanprover-community/mathlib/commit/0bb5e5d94d688bdbde8615d924742315cbe19def\">https://github.com/leanprover-community/mathlib/commit/0bb5e5d94d688bdbde8615d924742315cbe19def</a></p>\n</blockquote>",
        "id": 211589330,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1601365301
    }
]
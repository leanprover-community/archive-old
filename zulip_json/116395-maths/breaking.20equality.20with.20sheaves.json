[
    {
        "content": "<p>A sheaf of types <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"script\">F</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span></span> on a topological space <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> is, for every open set <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">V\\subseteq X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, a type <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"script\">F</mi></mrow><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}(V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span>, plus some extra data and some axioms.</p>\n<p>As part of the schemes project we would like to glue sheaves on open subsets. In short, given an open cover <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> and sheaves on each <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> which are compatible in some precise way, one can glue the sheaves together to get a sheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>. I tried to formalise this the naive way, and formalising the compatibility was a real nightmare, because a sheaf is on a topological space so I had to really work with types <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and I had to constantly be moving between the type <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i\\cap U_j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">∩</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span>, the open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i\\cap U_j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">∩</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, the open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i\\cap U_j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">∩</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> of $U_j$$ and the open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i\\cap U_j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">∩</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>; all of these four objects show up. One of the compatibilities one needs is a \"cocycle identity\" which involves three subsets <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, and it was pretty horrible.</p>\n<p>Kenny suggested a completely insane way around this. He defined a sheaf on an open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> to simply be a sheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>! It is true that given a sheaf on an open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">U\\subseteq X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> one can push it forward to get a sheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, given a sheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> one can pull it back to get a sheaf on an open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, but it is also true that two sheaves on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> which are not equal (resp isomorphic), can become equal (resp isomorphic) when restricted to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span>. </p>\n<p>In short, Kenny has proposed a definition of a sheaf on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> for which Lean's <code>=</code> type is <em>wrong</em> -- it does not correctly capture the notion of equality of sheaves. </p>\n<p>Kenny went on to define morphisms of sheaves-on-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> (using his definition) and a notion of <code>equiv</code> which is the correct definition. So we do have the correct notion of isomorphism, and the sheaves-on-<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> form a category which is equivalent to the correct category. This category has the extraordinary (to me) property that the notion of equality on it is incorrect. However I have just formalised the statement of the universal property which the glued sheaf has to satisfy (its restriction to the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">U_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> should be isomorphic to the sheaf <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"script\">F</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> we started with -- <em>not</em> equal to it) and at least the statement looks fine.</p>\n<p>Am I going to run into trouble later?</p>\n<p>One way of thinking about this is that a sheaf is a functor, so we have made some functor category, and we are interested in restricting this functor to a subcategory to get a new functor category, and I want to define it to be the actual restriction, but Kenny has just defined it to be the original functor and has basically said screw equality.</p>",
        "id": 168696896,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561135626
    },
    {
        "content": "<p>we don't ever want to say that two (at least set-valued-) sheaves are equal right</p>",
        "id": 168701236,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561139260
    },
    {
        "content": "<p>I guess that's my question. They are two terms of some type so I thought that equality was ok. But they involve some dependent type so maybe it's not ok</p>",
        "id": 168701920,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139760
    },
    {
        "content": "<p>You can prove that if two sheaves are equal when restricted to an open subset then they are equal. This is very counterintuitive to me</p>",
        "id": 168701997,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139823
    },
    {
        "content": "<p>Perhaps your argument is that equality of sheaves is never ok</p>",
        "id": 168702026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139859
    },
    {
        "content": "<p>that is indeed my argument</p>",
        "id": 168702043,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561139877
    },
    {
        "content": "<p>It is not true that if two sheaves are the same when restricted to an open subset then they are the same</p>",
        "id": 168702102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139904
    },
    {
        "content": "<p>But I have become more and more confused about what \"the same\" means recently</p>",
        "id": 168702120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139927
    },
    {
        "content": "<p>I find this very surprising. Here we have an equality on a type which is literally not correct -- it is too weak</p>",
        "id": 168702163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561139993
    },
    {
        "content": "<p>My rule of thumb was that <code>x = y</code> was not good if <code>x : Sort u</code> but <code>x = y</code> was OK if <code>x : T</code> with <code>T : Type u</code>. This is a counterexample.</p>",
        "id": 168702383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561140162
    },
    {
        "content": "<p>I encountered a similar situation with manifolds. The basic objects is charts, i.e., local homeomorphisms (defined on their source), that one keeps composing (thereby restricting the sources by taking the intersection of the source of the first guy and the preimage of the source of the second guy). There are (at least) three ways to formalize them:</p>\n<ul>\n<li>(1) use a homeomorphism defined on a subtype</li>\n<li>(2) use a map taking values in <code>option ...</code>, which is none outside of the source</li>\n<li>(3) use a map defined on all the space, that happens to be a homeomorphism on a subset of the space that you call <code>source</code>, and do not care about what this map does outside of <code>source</code>.</li>\n</ul>\n<p>(1) is a nightmare from the point of view of intersections of subtypes just as what you have for sheaves. (2) is a nightmare when you want to define regularity classes because you always need to distinguish between points in the genuine space and points in <code>option</code>. (3) looks crazy, but in fact it works very well. The only drawback is that you want to say that two local homeomorphisms are \"equal\" if they have the same source and coincide there. This is an <code>equiv</code>, that I introduced. But in fact it turns out that in 99% of the proofs I don't need to talk about equality of local homeomorphisms, I just need to compose them. So it works fine. And I think it more or less corresponds to Kenny's suggestion for sheaves.</p>\n<p>There was already a discussion on the chat where people told me to use (1) or (2) instead. And I agree that from a mathematical point of view this is the right thing to do, but from an implementation point of view (3) simply works better. Yesterday, I asked Assia Mahboubi , who has done way more formalization using DTT than anyone on this chat, about what to choose between (1), (2), (3), and her reaction was: (3) is clearly better.</p>",
        "id": 168704673,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1561141827
    },
    {
        "content": "<p>OK I'm convinced :-)</p>",
        "id": 168704742,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561141897
    },
    {
        "content": "<p>In fact I was already half-convinced when I realised that I could formalise the glueing lemma and the statement of its universal property. I guess what I am half-worried about is rewriting. If we lose the true meaning of <code>=</code> then we lose the ability to rewrite.</p>\n<p>I will try and formalise the proof of the glueing lemma over the weekend, this will be a very good test case I think.</p>",
        "id": 168704862,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561141991
    },
    {
        "content": "<p>Yes, you can not rewrite. But if you have enough lemmas saying that, under the assumption that two objects are \"equivalent\", then some property holds, then you can rewrite using these lemmas.</p>",
        "id": 168705381,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1561142349
    },
    {
        "content": "<p>I do not yet have a feeling as to how much of a handicap this will be.</p>",
        "id": 168705484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561142410
    },
    {
        "content": "<p>I think it will be very interesting to hear how your proof of the glueing lemma goes.</p>",
        "id": 168705546,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1561142471
    },
    {
        "content": "<p>There is a way to recover equality while still using sheaves on X. There is a condition you can put on your sheaf such that pushing back to U and then forward to X recovers the same sheaf</p>",
        "id": 168716480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561151009
    },
    {
        "content": "<p>Yes you're right; I discussed this privately with Kenny. The condition is that for all V open in X, the restriction map from F(V) to F(V intersect U) is an isomorphism (in the appropriate category). Here are several comments about this idea.</p>\n<p>Firstly, we have a restriction map from F(V) to F(V intersect U), but we have no inverse, so one would have to make a choice about either just saying it's a bijection, or demanding an inverse. This seemed a bit weird.</p>\n<p>Secondly, if we do this then sheaves on U are a subtype of sheaves on X, so we get the right equality but we'd have to constantly be carrying round and checking these proofs. </p>\n<p>Thirdly, I can see that my philosophy is wrong. If <code>x, y : T</code> with <code>T : Type u</code> then sometimes it's fine to talk about <code>x = y</code> (e.g. if T=nat). If <code>x, y : Type u</code> then in general I can see that it is not really the right thing to do in dependent type theory, and I am quite happy with the weaker concept of being isomorphic, although I still think that there should be a whole bunch of automation which is not currently in Lean which will enable me to rewrite along isomorphisms in certain cases, with auto-generated proofs. However I do see that equality of two types is a bit weird. With the sheaf setting, equality really does look weird, because here <code>x, y : T</code> and <code>T : Type u</code> but T is a structure which has a dependent type as a field, and equality of x and y would imply equality of those dependent functions, which by functional extensionality boils down to equality of types again. This does not seem to be a good idea in type theory. If we go with the philosophy that equality of types is to be avoided, then equality of these particular terms should also I think be avoided.</p>\n<p>Another way to recover equality is simply to quotient out by the correct notion. Whether this comes out nicer or more nastily than the subtype approach Mario is suggesting -- who knows. But currently my plan is to go with Kenny's crazy idea, because Sebastian and Assia seem to think that it's not so crazy after all, and I am open to the suggestion that losing the ability to rewrite will not hurt me. After all, if I have sheaves F_i on U_i and glue them together to get a sheaf F on X, the universal property really is <em>not</em> the statement that the restriction of F to U_i equals F_i, it is the data of an isomorphism.</p>",
        "id": 168717921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561152288
    },
    {
        "content": "<p>I agree that equality of sheafs should be avoided. What I want to avoid is \"random\" data inside a sheaf</p>",
        "id": 168719290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561153553
    },
    {
        "content": "<p>So currently we have random data. I agree that there are several ways of getting rid of the randomness, including replacing sheaves on X by either a sub or a quotient. But each of these is more inconvenient to work with.</p>",
        "id": 168719373,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153623
    },
    {
        "content": "<p>I thought that randomness was everywhere in topology in Lean, with functions being randomly extended. Even 1/ 0  = 0 is a random choice.</p>",
        "id": 168719416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153680
    },
    {
        "content": "<p>A similar sort of example is subfilters. A filter on X is not the same as a filter on a subset S, but given a filter on a subset there is a canonical way to extend it to a filter, and restrict any filter to a subset, and the filters that are extended subset filters are exactly those such that <code>S \\in F</code></p>",
        "id": 168719417,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561153680
    },
    {
        "content": "<p>random meaning not uniquely defined</p>",
        "id": 168719486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561153711
    },
    {
        "content": "<p>If I was buying into your idea I think I would go with the subtype. But then there's the question of how you say that the map F(V) -&gt; F(U intersect V) is an isomorphism. Do you just state that there exists an inverse, or do you give it?</p>",
        "id": 168719552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153792
    },
    {
        "content": "<p>Another alternative is extension by zero. You just define F(V) to be zero if V is not a subset of U, or whatever the appropriate initial object is</p>",
        "id": 168719630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153848
    },
    {
        "content": "<p>You said there is a way to go from a sheaf on U to one on X and back. How does that work? what map F(V) -&gt; F(U \\cap V) does it give you?</p>",
        "id": 168719664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561153870
    },
    {
        "content": "<p>There is more than one way.</p>",
        "id": 168719680,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153889
    },
    {
        "content": "<p>You don't know about the 6 functor formalism? ;-)</p>",
        "id": 168719688,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153900
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Six_operations\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Six_operations\">https://en.wikipedia.org/wiki/Six_operations</a></p>",
        "id": 168719703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153920
    },
    {
        "content": "<p>mathematician naming at its best</p>",
        "id": 168719748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561153929
    },
    {
        "content": "<p>At least there are 6 of them.</p>",
        "id": 168719754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153939
    },
    {
        "content": "<p>You can see how to get from a sheaf on X to a sheaf on U, right? This is just some kind of forgetful functor.</p>",
        "id": 168719769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153960
    },
    {
        "content": "<p>Well guess what: in many situations this has both a left and a right adjoint, which typically do not agree.</p>",
        "id": 168719785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561153975
    },
    {
        "content": "<p>If G is the sheaf on X, then it is defined by G(V) = F(U cap V), yes?</p>",
        "id": 168719816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154004
    },
    {
        "content": "<p>That's one of the ways of going from sheaves on U to sheaves on X, yes.</p>",
        "id": 168719830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154023
    },
    {
        "content": "<p>oh it's backwards?</p>",
        "id": 168719849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154038
    },
    {
        "content": "<p>The other way is G(V)=0 if V is not a subset of U, and G(V)=F(V)otherwise.</p>",
        "id": 168719850,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154038
    },
    {
        "content": "<p>I want the original one you said, sheaf on U -&gt; sheaf on X</p>",
        "id": 168719913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154070
    },
    {
        "content": "<p>That one is just G(V)=F(V)</p>",
        "id": 168719921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154087
    },
    {
        "content": "<p>wait, notation</p>",
        "id": 168719930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154102
    },
    {
        "content": "<p>There are two ways of going from U to X. There is one way of going from X to U. There are two theorems that say something is adjoint to something else.</p>",
        "id": 168719963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154134
    },
    {
        "content": "<p>The trivial thing is going from X to U. U is a subset of X here.</p>",
        "id": 168719975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154147
    },
    {
        "content": "<p>But if G is the newly defined sheaf on X, shouldn't it take an open set in X? so F(V) doesn't necessarily work</p>",
        "id": 168719978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154150
    },
    {
        "content": "<p>The non-trivial things are going from sheaves on U to sheaves on X. One way is G(V)=F(V intersect U). The other way is G(V)=F(V) if this makes sense and 0 otherwise</p>",
        "id": 168720050,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154200
    },
    {
        "content": "<p>I am so used to thinking about etale sheaves, I am not even sure if this is right for sheaves on a top space.</p>",
        "id": 168720073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154230
    },
    {
        "content": "<p>i might need to go and check the sheaf axiom. If it doesn't work, I might have to sheafify :-/</p>",
        "id": 168720077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154251
    },
    {
        "content": "<p>where 0 is an empty type?</p>",
        "id": 168720108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154282
    },
    {
        "content": "<p>0 is an initial object.</p>",
        "id": 168720142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154293
    },
    {
        "content": "<p>I'm thinking about sheaves taking values in some arbitrary category really.</p>",
        "id": 168720149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154311
    },
    {
        "content": "<p>so we can't really avoid some variation here</p>",
        "id": 168720156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154323
    },
    {
        "content": "<p>I'm thinking about sheaves taking values in the category of abelian groups, truth be told.</p>",
        "id": 168720158,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154328
    },
    {
        "content": "<p>I think the extension by 0 is OK.</p>",
        "id": 168720200,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154376
    },
    {
        "content": "<p>It looks like the sort of thing you computer scientists would really like. \"Don't know the answer? Try zero!\"</p>",
        "id": 168720245,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154402
    },
    {
        "content": "<p>I think that it would be best to have the actual definition be the one you started with, using subtypes, but then build an API to see them as sheafs on X</p>",
        "id": 168720275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154415
    },
    {
        "content": "<p>If I wanted to build an API I'd just define them as sheaves on U and then go through all the pain ;-)</p>",
        "id": 168720300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154463
    },
    {
        "content": "<p>is all this pain just to build the API?</p>",
        "id": 168720311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154481
    },
    {
        "content": "<p>Kenny built an API for sheaves on U just being sheaves on X.</p>",
        "id": 168720333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154500
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">sheaves</span><span class=\"bp\">.</span><span class=\"n\">sheaf</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"n\">u₁</span> <span class=\"n\">v₁</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">sheaf</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">sheaf_on_opens</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span> <span class=\"o\">:=</span>\n<span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">sheaf</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"n\">V</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">HWU</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">W</span> <span class=\"n\">HWU</span> <span class=\"o\">:=</span>\n<span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">HWV</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"n\">X</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">F</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">morphism</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">V</span> <span class=\"n\">H</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"n\">V</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">commutes</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HW</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"n\">W</span> <span class=\"n\">HW</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">W</span> <span class=\"n\">HW</span> <span class=\"n\">HWV</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">W</span> <span class=\"n\">HW</span> <span class=\"n\">HWV</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">morphism</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">W</span> <span class=\"n\">HW</span> <span class=\"n\">HWV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">W</span> <span class=\"n\">HW</span> <span class=\"n\">HWV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">commutes</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">commutes</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">η</span> <span class=\"bp\">=</span> <span class=\"n\">ξ</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">η</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">ξ</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">id_comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">η</span> <span class=\"bp\">=</span> <span class=\"n\">η</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_id</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">η</span> <span class=\"o\">:=</span>\n<span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_assoc</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">H</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">ξ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">χ</span> <span class=\"bp\">=</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res_subset</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">),</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">S</span> <span class=\"n\">HSV</span> <span class=\"n\">T</span> <span class=\"n\">HTV</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">HSV</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"n\">T</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">HTV</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_res_subset</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">morphism</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">ξ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">id_res_subset</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span> <span class=\"bp\">=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">morphism</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">G</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">inv_fun</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">to_fun</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">inv_fun</span> <span class=\"bp\">=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">equiv</span>\n\n<span class=\"n\">def</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">F</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">symm</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">G</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">trans</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">e₁</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e₂</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp_assoc</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id_comp</span><span class=\"o\">,</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"o\">],</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp_assoc</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">comp_assoc</span><span class=\"o\">,</span> <span class=\"n\">e₁</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id_comp</span><span class=\"o\">,</span> <span class=\"n\">e₂</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res_subset</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp_res_subset</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">3</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id_res_subset</span><span class=\"o\">],</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp_res_subset</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"mi\">4</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id_res_subset</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">equiv</span>\n\n<span class=\"c1\">-- should be in mathlib</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">opens</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Union</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">is_open_Union</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">subset_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"err\">⊆</span> <span class=\"n\">Union</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- why does lattice.le_supr need complete lattice?</span>\n<span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_Union</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"bp\">⟩</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Other things I might need about this Union</span>\n\n<span class=\"cm\">@[simp] theorem mem_Union {x : β} {s : ι → set β} : x ∈ Union s ↔ ∃ i, x ∈ s i :=</span>\n<span class=\"cm\">⟨assume ⟨t, ⟨⟨a, (t_eq : s a = t)⟩, (h : x ∈ t)⟩⟩, ⟨a, t_eq.symm ▸ h⟩,</span>\n<span class=\"cm\">  assume ⟨a, h⟩, ⟨s a, ⟨⟨a, rfl⟩, h⟩⟩⟩</span>\n<span class=\"cm\">/- alternative proof: dsimp [Union, supr, Sup]; simp -/</span>\n<span class=\"cm\">  -- TODO: more rewrite rules wrt forall / existentials and logical connectives</span>\n<span class=\"cm\">  -- TODO: also eliminate ∃i, ... ∧ i = t ∧ ...</span>\n\n<span class=\"cm\">theorem Union_subset {s : ι → set β} {t : set β} (h : ∀ i, s i ⊆ t) : (⋃ i, s i) ⊆ t :=</span>\n<span class=\"cm\">-- TODO: should be simpler when sets&#39; order is based on lattices</span>\n<span class=\"cm\">@supr_le (set β) _ set.lattice_set _ _ h</span>\n\n<span class=\"cm\">theorem Union_subset_iff {α : Sort u} {s : α → set β} {t : set β} : (⋃ i, s i) ⊆ t ↔ (∀ i, s i ⊆ t):=</span>\n<span class=\"cm\">⟨assume h i, subset.trans (le_supr s _) h, Union_subset⟩</span>\n\n<span class=\"cm\">theorem subset_Union : ∀ (s : ι → set β) (i : ι), s i ⊆ (⋃ i, s i) := le_supr</span>\n\n<span class=\"cm\">theorem Union_const [inhabited ι] (s : set β) : (⋃ i:ι, s) = s :=</span>\n<span class=\"cm\">ext $ by simp</span>\n\n<span class=\"cm\">theorem inter_Union_left (s : set β) (t : ι → set β) :</span>\n<span class=\"cm\">  s ∩ (⋃ i, t i) = ⋃ i, s ∩ t i :=</span>\n<span class=\"cm\">ext $ by simp</span>\n\n<span class=\"cm\">theorem inter_Union_right (s : set β) (t : ι → set β) :</span>\n<span class=\"cm\">  (⋃ i, t i) ∩ s = ⋃ i, t i ∩ s :=</span>\n<span class=\"cm\">ext $ by simp</span>\n\n<span class=\"cm\">theorem Union_union_distrib (s : ι → set β) (t : ι → set β) :</span>\n<span class=\"cm\">  (⋃ i, s i ∪ t i) = (⋃ i, s i) ∪ (⋃ i, t i) :=</span>\n<span class=\"cm\">ext $ by simp [exists_or_distrib]</span>\n\n<span class=\"cm\">theorem union_Union_left [inhabited ι] (s : set β) (t : ι → set β) :</span>\n<span class=\"cm\">  s ∪ (⋃ i, t i) = ⋃ i, s ∪ t i :=</span>\n<span class=\"cm\">by rw [Union_union_distrib, Union_const]</span>\n\n<span class=\"cm\">theorem union_Union_right [inhabited ι] (s : set β) (t : ι → set β) :</span>\n<span class=\"cm\">  (⋃ i, t i) ∪ s = ⋃ i, t i ∪ s :=</span>\n<span class=\"cm\">by rw [Union_union_distrib, Union_const]</span>\n\n<span class=\"cm\">theorem diff_Union_right (s : set β) (t : ι → set β) :</span>\n<span class=\"cm\">  (⋃ i, t i) \\ s = ⋃ i, t i \\ s :=</span>\n<span class=\"cm\">inter_Union_right _ _</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">opens</span>\n\n<span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">//</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n        <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HUV</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"bp\">_</span> <span class=\"n\">HUV</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n      <span class=\"k\">begin</span> <span class=\"n\">sorry</span>\n\n      <span class=\"kn\">end</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">locality</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">gluing</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">universal_property</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">Hφ1</span> <span class=\"n\">Hφ2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">sheaf_on_opens</span>\n</pre></div>",
        "id": 168720351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154522
    },
    {
        "content": "<p>If I fill in the sorries then I've proved that Kenny's random idea works out. The alternative is to use a subtype, but then I need \" F(V) -&gt; F(U intersect V) is an isomorphism\" to be a Prop, so things might get noncomputable.</p>",
        "id": 168720434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154604
    },
    {
        "content": "<p>wait so you still have a separate definition? This seems like a lot of duplication</p>",
        "id": 168720438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154610
    },
    {
        "content": "<p>Not that I care, but you might.</p>",
        "id": 168720439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154611
    },
    {
        "content": "<p>We have a wrapper:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">sheaf</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span>\n</pre></div>",
        "id": 168720452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154641
    },
    {
        "content": "<p>Remind me the original definitions, I will show how to do this without all the proof obligations</p>",
        "id": 168720496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154650
    },
    {
        "content": "<p>The <code>res</code> function need not take a proof arg, nor <code>eval</code></p>",
        "id": 168720552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561154696
    },
    {
        "content": "<p>Right!</p>",
        "id": 168720572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154715
    },
    {
        "content": "<p><a href=\"https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean\" target=\"_blank\" title=\"https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean\">https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean</a></p>",
        "id": 168720575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154720
    },
    {
        "content": "<p>That's the definition of a sheaf.</p>",
        "id": 168720593,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154744
    },
    {
        "content": "<p>It uses the file presheaf.lean in the same directory, plus epsilon about open coverings.</p>",
        "id": 168720658,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561154785
    },
    {
        "content": "<p>I will come back to this later, but here's the first pass:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span>     <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">res</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hid</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hcomp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"err\">∘</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">presheaf</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- Simplification lemmas for Hid and Hcomp.</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">Hcomp&#39;</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hcomp</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">Hid&#39;</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hid</span> <span class=\"n\">U</span><span class=\"bp\">;</span> <span class=\"n\">simp</span>\n\n<span class=\"n\">def</span> <span class=\"n\">total</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">Σ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">U</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_t</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">sigma</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">elab_as_eliminator</span><span class=\"o\">]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">total</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span> <span class=\"bp\">→</span> <span class=\"n\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res&#39;</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span>\n<span class=\"bp\">|</span> <span class=\"bp\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_def</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_val</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">have</span> <span class=\"bp\">∀</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">W</span> <span class=\"bp\">=</span> <span class=\"n\">V</span> <span class=\"bp\">→</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"n\">H</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n  <span class=\"k\">by</span> <span class=\"n\">rintro</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">rfl</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"n\">this</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">inf_of_le_right</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_eq_inf</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res&#39;_def</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">res&#39;_val</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_left</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_eq_left</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span> <span class=\"bp\">=</span> <span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">W</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res&#39;_eq_inf</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">res&#39;_eq_inf</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_id</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">U</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res&#39;_val</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hid</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">res&#39;_comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">total</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">total</span><span class=\"bp\">.</span><span class=\"n\">cases_on</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">W</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res&#39;_def</span><span class=\"o\">,</span> <span class=\"n\">res&#39;_def</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hcomp&#39;</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">res&#39;_val</span><span class=\"o\">,</span> <span class=\"n\">res&#39;_eq_left</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n   <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">inf_left_comm</span><span class=\"o\">,</span> <span class=\"n\">inf_comm</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">locality</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">U</span> <span class=\"n\">S</span><span class=\"o\">}},</span> <span class=\"n\">is_lub</span> <span class=\"n\">S</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">}},</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n\n<span class=\"n\">def</span> <span class=\"n\">gluing</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}}</span> <span class=\"o\">{{</span><span class=\"n\">S</span><span class=\"o\">}},</span> <span class=\"n\">is_lub</span> <span class=\"n\">S</span> <span class=\"n\">U</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">HV</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HW</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">),</span>\n  <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">V</span> <span class=\"n\">HV</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">W</span> <span class=\"n\">HW</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">HV</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">V</span> <span class=\"n\">HV</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">presheaf</span>\n</pre></div>",
        "id": 168723312,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561157554
    },
    {
        "content": "<p>I think your definition of presheaf is essentially the definition of a functor</p>",
        "id": 168724242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158413
    },
    {
        "content": "<p>To Type</p>",
        "id": 168724260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158433
    },
    {
        "content": "<p>it had better be!</p>",
        "id": 168724267,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561158448
    },
    {
        "content": "<p>more or less; it's a preorder category on the left too, and I use the existence of infima a lot</p>",
        "id": 168724270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158451
    },
    {
        "content": "<p>which I think means products?</p>",
        "id": 168724277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158459
    },
    {
        "content": "<p>However this generalization is basically zero cost, while I'm not sure that generalizing to functor is also zero cost</p>",
        "id": 168724352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158520
    },
    {
        "content": "<p>it's not really even relevant, it's just sort of an obvious generalization the way it's been written</p>",
        "id": 168724382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158580
    },
    {
        "content": "<p>But functors are already there. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> and I had talked about this being a very good use case for the category theory library.</p>",
        "id": 168724387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158593
    },
    {
        "content": "<p>the point I want to make involves <code>res'</code></p>",
        "id": 168724391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158598
    },
    {
        "content": "<p>And this <code>total</code> trick</p>",
        "id": 168724439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158610
    },
    {
        "content": "<p>once again, untyped to the rescue</p>",
        "id": 168724444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158629
    },
    {
        "content": "<p>there is still some unpacking to do with the definition of <code>locality</code> and <code>gluing</code>; one wants the statement to be in terms of families not sets</p>",
        "id": 168724497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158717
    },
    {
        "content": "<p>There seem to be several approaches to this. I remember Scott saying that presheaves were fine but the sheaf axiom got a bit grotty in the sense that he wasn't happy with his attempts to formalise it. The sheaf axiom is <code>gluing \\and locality</code></p>",
        "id": 168724547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158738
    },
    {
        "content": "<p>You can make them into one axiom by changing that exists in the conclusion of glueing to exists unique, but Ramon found it nicer to keep them separate.</p>",
        "id": 168724559,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158781
    },
    {
        "content": "<p>Oh, this is epsilon nicer:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">gluing</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}}</span> <span class=\"o\">{{</span><span class=\"n\">S</span><span class=\"o\">}},</span> <span class=\"n\">is_lub</span> <span class=\"n\">S</span> <span class=\"n\">U</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">W</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n<span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">V</span>\n</pre></div>",
        "id": 168724634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158884
    },
    {
        "content": "<p>So what is the advantage of this approach over Kenny's, given that I decided I didn't care about equality being broken? <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> does this approach have an analogue in your chart world?</p>",
        "id": 168724646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158899
    },
    {
        "content": "<p>Axiomatically, this is equivalent to the very first definition we started with when we first looked at it</p>",
        "id": 168724659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158934
    },
    {
        "content": "<p>All I'm doing is layering a more convenient API on top</p>",
        "id": 168724665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158946
    },
    {
        "content": "<p>In the schemes project we need sheaves of rings, and then sheaves of modules over the rings.</p>",
        "id": 168724667,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561158952
    },
    {
        "content": "<p>You can change <code>Type</code> to a category here without changing anything</p>",
        "id": 168724714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561158977
    },
    {
        "content": "<p>I'm not sure there's a category of modules over the category of rings, as it were</p>",
        "id": 168724720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159005
    },
    {
        "content": "<p>well that's not exactly true; I'm using  a sigma type which needs the underlying space to be a type</p>",
        "id": 168724721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159007
    },
    {
        "content": "<p>In the perfectoid project we need sheaves of topological rings, and there's an extra subtlety there</p>",
        "id": 168724747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159033
    },
    {
        "content": "<p>The sheaf axiom says that a certain map is an equalizer, and we're writing it as \"there exists unique x\" but in the category of topological spaces there's more to it than that.</p>",
        "id": 168724784,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159082
    },
    {
        "content": "<p>We need two topologies on a ring to coincide as well. This seems like a good excuse to go full category with the target</p>",
        "id": 168724820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159126
    },
    {
        "content": "<p>Eh, I'm not really sure about the quality of any remarks I make here. Show me the code and we can talk</p>",
        "id": 168724823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159132
    },
    {
        "content": "<p>Make this definition in the generality that you actually need</p>",
        "id": 168724882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159181
    },
    {
        "content": "<p>I'm just thinking of all the \"extreme\" notions of sheaves which I've encountered so far in my Lean work.</p>",
        "id": 168724884,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159185
    },
    {
        "content": "<blockquote>\n<p>Make this definition in the generality that you actually need</p>\n</blockquote>\n<p>That's not the right approach, because the generality we actually need is sheaves of categories on a site.</p>",
        "id": 168724933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159204
    },
    {
        "content": "<p>That's what we'll need when we start doing etale cohomology.</p>",
        "id": 168724944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159218
    },
    {
        "content": "<p>So now you won't be able to get away with lattices, there is a category with a Grothendieck topology.</p>",
        "id": 168724960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159251
    },
    {
        "content": "<p>The whole \"work in the correct generality\" thing might work for basic Lean stuff but in maths things get so absurdly general sometimes that it's really not that clear that you want to work in the fullest 2019 generality.</p>",
        "id": 168725044,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159334
    },
    {
        "content": "<p>Not least because you might be out of date in 5 years anyway.</p>",
        "id": 168725047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159344
    },
    {
        "content": "<p>I don't mean the possible generality that exists, I mean the generality that suffices for the short to mid term future</p>",
        "id": 168725077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159404
    },
    {
        "content": "<p>like \"what we need for the current major milestone\"</p>",
        "id": 168725128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159454
    },
    {
        "content": "<p>For all I know they're doing sheaves on infinity,1 categories nowadays.</p>",
        "id": 168725135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159467
    },
    {
        "content": "<p>always have a concrete application in mind that is not in danger of being pushed off to the infinite future</p>",
        "id": 168725153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159505
    },
    {
        "content": "<p>The reason I'm thinking about gluing sheaves is that we have a nice theory of affine schemes, and then to make general schemes you have to glue affine schemes together. We can glue topological spaces together, so all we have to do is to glue sheaves together and we can make general schemes. That would be a cool milestone. To do that we would need to be able to glue sheaves of commutative rings together.</p>",
        "id": 168725268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159639
    },
    {
        "content": "<p>Okay, so you need to have more than sheaves on Type then. Do you need more than lattices?</p>",
        "id": 168725279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561159671
    },
    {
        "content": "<p>A sheaf of commutative rings is just a sheaf of types but all the res maps are ring homs. We're still talking about sheaves on topological spaces here, so if opens X is a lattice then we don't need more than lattices.</p>",
        "id": 168725333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159701
    },
    {
        "content": "<p>I've been thinking about the next few things which it would be fun to formalise (and looking for students to do them). I should perhaps post them as issues, as per Scott's suggestion.</p>",
        "id": 168725375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561159763
    },
    {
        "content": "<p>something like this then?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">sheaf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">locality</span> <span class=\"o\">:</span> <span class=\"n\">to_presheaf</span><span class=\"bp\">.</span><span class=\"n\">locality</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">gluing</span>   <span class=\"o\">:</span> <span class=\"n\">to_presheaf</span><span class=\"bp\">.</span><span class=\"n\">gluing</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">sheaf_of_rings</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">sheaf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"n\">ring_hom</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span><span class=\"o\">)]</span>\n</pre></div>",
        "id": 168725662,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561160110
    },
    {
        "content": "<p>you can't prove that <code>res'</code> is a ring_hom because it has the wrong type, but you could either use a different total space that is a ring, like Reid suggested in the CDGA thread, or you could just prove concretely that it preserves addition and so on modulo a coercion</p>",
        "id": 168725820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561160286
    },
    {
        "content": "<p>Ah, actually neither of those options works. Apparently rings don't have a very nice indexed coproduct; it can be trivial because of characteristic constraints. And it's not really easy to talk about addition and so on over a coercion unless the total space has an addition</p>",
        "id": 168726652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561161391
    },
    {
        "content": "<p>But this definition is so higher order that perhaps you aren't really doing actual algebra on the rings anymore, and knowing that the res maps are abstractly a ring hom is sufficient</p>",
        "id": 168726762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561161539
    },
    {
        "content": "<p>Yes, you really don't want to be making all the objects subtypes of a large object, this can't be done in general (and in particular it can't be done with commutative rings, which are an important case). In the CDGA thread we had abelian groups (or more generally R-modules for a fixed R), where it can be done. As far as I know nobody has formalised sheaves of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>-modules, where <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is the traditional name for the standard sheaf of rings on a scheme, the structure sheaf (namely the sheaf of functions on the scheme). </p>\n<p>I am unclear about why Mario is unhappy about the definition containing random junk.</p>",
        "id": 168740744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561188654
    },
    {
        "content": "<p>It can always be done, but you get some thing that's not in the category in general</p>",
        "id": 168740862,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561188934
    },
    {
        "content": "<p>which is not actually a problem in most cases</p>",
        "id": 168740902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561188967
    },
    {
        "content": "<p>I don't know if I can explain the issue I have with \"random junk\" clearly, which is worrisome</p>",
        "id": 168740907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561189023
    },
    {
        "content": "<p>Although I don't suggest the use of = on these objects, I do want the shape of the types to reflect the structure of the type</p>",
        "id": 168740917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561189070
    },
    {
        "content": "<p>I will grant that consistently using a \"weird equiv\" will mostly make this decision invisible</p>",
        "id": 168740959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561189101
    },
    {
        "content": "<p>maybe I'm still hoping for that HoTT style transfer tactic, where equivs are magicked up from the definition of the type</p>",
        "id": 168740969,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561189156
    },
    {
        "content": "<p>It can always be done -- ah yes sorry, I was sticking within the category. I see you can always make the sigma type, and doing Reid's CDGA exercise the naive way showed me clearly how it can be advantageous to make the type. I haven't seen the point of it here yet but presumably we're just waiting for the analogue of Reid's challenge questions to show up. </p>\n<p>Random junk -- I am going to press ahead with the bad <code>=</code> type just out of interest, although apparently I have to go and be social this weekend, which rather spoils my fun plans. Sheaves and schemes have turned out to be a really good test case for teaching me about the subtleties of type theory. Part of me is still amazed that there weren't mathematicians doing this stuff in Coq 10 years ago.</p>",
        "id": 168741031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561189288
    },
    {
        "content": "<blockquote>\n<p>maybe I'm still hoping for that HoTT style transfer tactic, where equivs are magicked up from the definition of the type</p>\n</blockquote>\n<p>Aah! I see that this will definitely fail with Kenny's approach!</p>",
        "id": 168741035,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561189316
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"bp\">//</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n        <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HUV</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"bp\">_</span> <span class=\"n\">HUV</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n      <span class=\"k\">begin</span>\n        <span class=\"n\">intros</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"c1\">--        cases f with f hf,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">res_comp</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">res_comp</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">answer</span> <span class=\"o\">:=</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"bp\">_</span> <span class=\"n\">HUV</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">property</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">),</span>\n        <span class=\"n\">rw</span> <span class=\"n\">res_comp</span> <span class=\"n\">at</span> <span class=\"n\">answer</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span><span class=\"n\">answer</span><span class=\"o\">,</span>\n        <span class=\"n\">clear</span> <span class=\"n\">answer</span><span class=\"o\">,</span>\n        <span class=\"k\">let</span> <span class=\"n\">XXX</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"bp\">_</span> <span class=\"n\">HUV</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_left</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))),</span>\n<span class=\"c1\">--        simp only [eval_res_subset] at XXX,</span>\n<span class=\"c1\">--        rw eval_res_subset at XXX,</span>\n<span class=\"c1\">--          rw XXX,</span>\n<span class=\"c1\">--        convert XXX,</span>\n<span class=\"c1\">--        simp [XXX],</span>\n        <span class=\"c1\">--rw ←res_comp (F i) (S i ∩ U) _ (S i ∩ S j ∩ U)</span>\n        <span class=\"c1\">--  (set.subset.trans (set.inter_subset_left _ _) (set.inter_subset_left _ _))</span>\n        <span class=\"c1\">--  (S i ∩ S j ∩ V) _ (set.inter_subset_inter_left _ (set.inter_subset_left _ _)) (set.inter_subset_inter_right _ HUV),</span>\n<span class=\"c1\">--        rw ←(F i : sheaf X).F.Hcomp&#39;,</span>\n<span class=\"c1\">--        rw (φ i j).to_fun.commutes _ _ _ _ _, -- (V : opens X) (HV : V ⊆ U) (W : opens X) (HW : W ⊆ U) (HWV : W ⊆ V) (x : eval F V HV)</span>\n<span class=\"n\">sorry</span><span class=\"o\">,</span>\n      <span class=\"kn\">end</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">locality</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">gluing</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Glueing sheaves is quite interesting <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> . There are all sorts of things to think about. I am not sure I fully understand the power of <code>Hφ2</code> yet. Do you know a better way of understanding it? Is it a 1-cocycle of some sort?</p>",
        "id": 168749542,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206553
    },
    {
        "content": "<p>it's the cocycle condition right</p>",
        "id": 168749548,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561206588
    },
    {
        "content": "<p><a href=\"https://github.com/anca797/group-cohomology\" target=\"_blank\" title=\"https://github.com/anca797/group-cohomology\">https://github.com/anca797/group-cohomology</a></p>",
        "id": 168749600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202902\">@Anca Ciobanu</span> 's definition of a 1-cocycle is in that link.</p>",
        "id": 168749607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206658
    },
    {
        "content": "<p>She's doing 3rd year project with me.</p>",
        "id": 168749616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206669
    },
    {
        "content": "<p>We're just trundling along learning about cocycles.</p>",
        "id": 168749618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206695
    },
    {
        "content": "<p>So can you make a cocycle from something which people call the cocycle condition?</p>",
        "id": 168749621,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206717
    },
    {
        "content": "<p>Anca is going to prove the long exact sequence of terms of low degree coming from the spectral sequence of group cohomology.</p>",
        "id": 168749674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206820
    },
    {
        "content": "<p>We're nearly there.</p>",
        "id": 168749677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206828
    },
    {
        "content": "<p>People always call it the cocycle condition when gluing sheaves and things like that, but it actually becomes one if you imagine gluing vector bundles, say, on a topological space, each of which is trivial so we can call it <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span>, and then the transition functions <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding=\"application/x-tex\">\\phi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">ϕ</span></span></span></span> can be seen as taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi><mi>L</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">GL(n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">G</span><span class=\"mord mathit\">L</span><span class=\"mopen\">(</span><span class=\"mord mathit\">n</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 168749728,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561206916
    },
    {
        "content": "<p>So there's your homework <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span></p>",
        "id": 168749765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561206965
    },
    {
        "content": "<p>It's not group cohomology though, it's some kind of nonabelian Cech cohomology (<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup></mrow><annotation encoding=\"application/x-tex\">H^1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span></span></span>)</p>",
        "id": 168749771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561207004
    },
    {
        "content": "<p>Unless your space happens to be the classifying space of a group in which case it might also be group cohomology</p>",
        "id": 168749772,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561207022
    },
    {
        "content": "<p>Working with group cohomology H^1 as 1-cocycles over 1-coboundaries has been really interesting. I had not realised that the boundary map from H^0 to H^1 was non-computable until recently.</p>",
        "id": 168749823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561207086
    },
    {
        "content": "<p>I'm sure there's some crazy spectral sequence way to do all this, but having the really explicit cocycle stuff was still an interesting exercise, and quite a concrete way of doing it.</p>",
        "id": 168749837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561207138
    },
    {
        "content": "<p>For the purposes of this exercise, can I make subset inclusion a typeclass and make all the lemmas I'm using again and again equal to instances?</p>",
        "id": 168759646,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561226390
    },
    {
        "content": "<p>You can certainly do that locally, I guess.</p>",
        "id": 168760813,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561228883
    },
    {
        "content": "<p>But can you glue the local instances into global instances?</p>",
        "id": 168761026,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561229260
    },
    {
        "content": "<p>They need to satisfy a cocycle condition, I guess (-;</p>",
        "id": 168761721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561230511
    },
    {
        "content": "<p>Fortunately I think that cocycle condition is vacuous for some reason, possibly proof irrelevance</p>",
        "id": 168763611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561234143
    },
    {
        "content": "<p>It's somehow the statement that the direct proof that W is a subset of U is the same as the proof that says that W is a subset of V which is a subset of U</p>",
        "id": 168763668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561234227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span>     <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">res</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hid</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hcomp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"err\">∘</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>So you really do not care that there is a <code>Type v</code> mentioned in a structure field, where <code>v</code> is a universe not mentioned before the colon?</p>",
        "id": 168765089,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237196
    },
    {
        "content": "<p>I thought you one told Patrick that he would get into trouble with this, and there would be annoying universe issues everywhere. Am I just being too paranoid here? I still don't understand this issue. I have been led to suspect that your definition is asking for trouble later down the line.</p>",
        "id": 168765146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> what do you think of all these universes? Is Mario's way the correct way to do it or just a waste of time?</p>",
        "id": 168765190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237328
    },
    {
        "content": "<p>I am unclear about this foundational issue.</p>",
        "id": 168765194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237367
    },
    {
        "content": "<p>this one is fine; the one that bugs me is when you want to quantify over all sets in ZFC, but there isn't an equivalent in type theory, i.e. you can only quantify over all types in Type w</p>",
        "id": 168765204,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561237423
    },
    {
        "content": "<p>I guess I might have defined something like a glueing of a presheaf of types using Kenny's API. I will try and write this up in a coherent manner right now.</p>",
        "id": 168765258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237508
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/xena/blob/master/Examples/sheaf_on_opens_total_glueing.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/master/Examples/sheaf_on_opens_total_glueing.lean\">Me trying to glue presheaves</a></p>",
        "id": 168765375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561237743
    },
    {
        "content": "<p>I'm trying to remove all dependency on the schemes project and just make this a little \"glueing sheaves\" project of its own without all the Spec A stuff. Kenny I'm porting what you wrote to Mario's foundations. It's quite interesting.</p>",
        "id": 168766047,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561239142
    },
    {
        "content": "<p>I can use regexps to help with the porting. It's pretty cool. VS Code good for this sort of thing.</p>",
        "id": 168766596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561240292
    },
    {
        "content": "<p>I find emacs Lean easier to use than VS Code Lean for this stuff. I just know how to do stuff like \"search and replace from this point on\" in emacs. This is the first time I've used Lean in emacs for ages.</p>",
        "id": 168766840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561240765
    },
    {
        "content": "<p>This file only depends on mathlib.</p>\n<p><a href=\"https://github.com/kbuzzard/xena/blob/e524026fa8db94b228b99fe8d500a530de1bf14e/Examples/sheaf_on_opens_total_glueing.lean#L138\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/e524026fa8db94b228b99fe8d500a530de1bf14e/Examples/sheaf_on_opens_total_glueing.lean#L138\">https://github.com/kbuzzard/xena/blob/e524026fa8db94b228b99fe8d500a530de1bf14e/Examples/sheaf_on_opens_total_glueing.lean#L138</a></p>\n<p>I have my first universe issue <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span></p>",
        "id": 168767068,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241163
    },
    {
        "content": "<p>I really don't care about universes. Can someone just tell me the regex to fix all universe issues?</p>",
        "id": 168767087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241272
    },
    {
        "content": "<p>change <code>universes u v</code> to <code>universes v u</code> on L10</p>",
        "id": 168767091,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561241282
    },
    {
        "content": "<p>Many thanks Kenny.</p>",
        "id": 168767128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241315
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span><span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span><span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">is_open_Union</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> how do I translate that into this semilattice language?</p>",
        "id": 168767381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241862
    },
    {
        "content": "<p>I mean it doesn't compile right</p>",
        "id": 168767424,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561241900
    },
    {
        "content": "<p>That's right. I need to take infinite unions at this point.</p>",
        "id": 168767432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241925
    },
    {
        "content": "<p>But I only have <code>[semilattice_inf]</code></p>",
        "id": 168767442,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561241953
    },
    {
        "content": "<p>I need more than this to make sense of glueing presheaves. I definitely want my parameter to be <code>{I : Type*} (s : I → α)</code> and I want to take some kind of sup, which has all the properties of sup which I'll need later.</p>",
        "id": 168767560,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242160
    },
    {
        "content": "<p>which is this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">subset_Union</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">Union</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">constructor</span> <span class=\"n\">or</span> <span class=\"n\">other</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 168767588,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242228
    },
    {
        "content": "<p>What mathematical object is that called in Lean?</p>",
        "id": 168767635,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242250
    },
    {
        "content": "<p>I need <code>Union</code> and <code>subset_Union</code>. I'm assuming someone has already discovered this object. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> any ideas? <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> if you're out there?</p>",
        "id": 168767659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242323
    },
    {
        "content": "<p>How close is this to a topological space?</p>",
        "id": 168767703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242397
    },
    {
        "content": "<p>Is it some sort of bundled topological space?</p>",
        "id": 168767717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242450
    },
    {
        "content": "<p>Oh, is it precisely <code>opens X</code> or something?</p>",
        "id": 168767768,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242532
    },
    {
        "content": "<p>I could even try and prove this!</p>",
        "id": 168767773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561242557
    },
    {
        "content": "<p>Not at a computer but is it just about being able to form sups of arbitrary families?</p>",
        "id": 168768695,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561244422
    },
    {
        "content": "<p>Sounds like you just have a complete lattice</p>",
        "id": 168768706,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561244485
    },
    {
        "content": "<p>Yes I think that's it. Many thanks Reid. I should be able to literally check this in Lean in quite a formulaic way.</p>",
        "id": 168768752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561244566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> is there this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">37</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p>?</p>",
        "id": 168769224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245566
    },
    {
        "content": "<p>I don't know offhand whether it already exists, but you can define it as the sup of the <code>range</code> of the <code>(I → α)</code></p>",
        "id": 168769308,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561245642
    },
    {
        "content": "<p>For glueing presheaves I really do not want to restrict myself to glueing on a set of subsets. I believe want to allow these more general unions. This is not a universe issue (at least as far as I'm concerned -- a topological space has a set of subsets). Before I press on, can I check that I have named this function correctly? <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> ?</p>",
        "id": 168769322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245701
    },
    {
        "content": "<p>I'm not very sure what you want to do. Isn't this just supr?</p>",
        "id": 168769363,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561245751
    },
    {
        "content": "<p>This is a situation where I would just let I and alpha be in the same universe.</p>",
        "id": 168769364,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245755
    },
    {
        "content": "<p>I don't know anything about lattices.</p>",
        "id": 168769365,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245768
    },
    {
        "content": "<p>The API is huge and I've never looked at it.</p>",
        "id": 168769370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245775
    },
    {
        "content": "<p>Lattices are just weird computer science things that people like <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> enjoy. They're not proper maths ;-)</p>",
        "id": 168769380,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245812
    },
    {
        "content": "<p>That's why I'm happy to call my types <code>\\alpha</code> in this development. I don't think a complete lattice deserves a name in maths mode -- a \"maths name\".</p>",
        "id": 168769385,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245840
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span> <span class=\"c1\">-- unknown</span>\n</pre></div>",
        "id": 168769441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245922
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span>\n</pre></div>",
        "id": 168769446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561245948
    },
    {
        "content": "<p>Is <code>complete_lattice.supr</code> a hole in mathlib? <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ?</p>",
        "id": 168769488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561245978
    },
    {
        "content": "<p>Just thinking abstractly about the concept of what setting we need in order to do glueing of sheaves, has led me to a type which has grown organically. It would be interesting if it was precisely <code>complete_lattice</code> or maybe it will be some other known type. It gives some sort of insight into the correct way to think about glueing sheaves. We throw in axioms as we need them and see what we end up growing.</p>",
        "id": 168769547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561246084
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span>\n<span class=\"n\">supr</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"n\">α</span><span class=\"o\">],</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p>Is that order preferred to</p>\n<div class=\"codehilite\"><pre><span></span>supr : Π {α : Type u_1} [_inst_1 : has_Sup α] {ι : Sort u_2}, (ι → α) → α\n</pre></div>\n\n\n<p>? Is there some convention?</p>",
        "id": 168770164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561247434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 168770165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561247443
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n  <span class=\"bp\">@</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span> <span class=\"n\">α</span> <span class=\"n\">I</span> <span class=\"bp\">_</span> <span class=\"c1\">-- Grumpy old mathematician observes that stupid polymorphism</span>\n                      <span class=\"c1\">-- makes me have to fill in more stuff</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">supr</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>There's a conjecture for you complete_latticeists.</p>",
        "id": 168770367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561247965
    },
    {
        "content": "<p>I need to learn your language.</p>",
        "id": 168770369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561247987
    },
    {
        "content": "<p>Oh I guess I know exactly where to look in the mathlib API.</p>",
        "id": 168770429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561248023
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">le_supr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"err\">?</span><span class=\"n\">M_2</span> <span class=\"bp\">→</span> <span class=\"err\">?</span><span class=\"n\">M_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"err\">?</span><span class=\"n\">M_2</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">supr</span> <span class=\"n\">s</span>\n</pre></div>\n\n\n<p>Porting this code is really interesting. I'm trying to see if I can do it in a completely algorithmic way. I think I'm nearly there.</p>",
        "id": 168770501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561248220
    },
    {
        "content": "<p>I think the order of implicit and type class arguments is usually arbitrary and depends on how it was convenient to organize the <code>variable</code> declarations</p>",
        "id": 168770760,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561248790
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">le_supr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n  <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">supr</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">α : Type u,</span>\n<span class=\"cm\">ι : Sort v,</span>\n<span class=\"cm\">_inst_1 : complete_lattice α,</span>\n<span class=\"cm\">s : ι → α,</span>\n<span class=\"cm\">i : ι</span>\n<span class=\"cm\">⊢ has_le α</span>\n<span class=\"cm\">sheaf_on_opens_total_glueing.lean:15:8: error</span>\n<span class=\"cm\">failed to synthesize type class instance for</span>\n<span class=\"cm\">α : Type u,</span>\n<span class=\"cm\">ι : Sort v,</span>\n<span class=\"cm\">_inst_1 : complete_lattice α,</span>\n<span class=\"cm\">s : ι → α,</span>\n<span class=\"cm\">i : ι</span>\n<span class=\"cm\">⊢ has_Sup α</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>What have I done to deserve this??</p>",
        "id": 168770808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561248891
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span>\n\n<span class=\"c1\">-- #check lattice.le -- unknown identifier</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"c1\">-- but this works??</span>\n</pre></div>\n\n\n<p>Is that a poorly-named function in mathlib?</p>",
        "id": 168771022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561249296
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">failed to synthesize instance name, name should be provided explicitly</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>What should this be instance be called?</p>",
        "id": 168771223,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561249695
    },
    {
        "content": "<p>Why is this happening?</p>",
        "id": 168771226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561249714
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span>\n\n<span class=\"c1\">-- #check lattice.le -- unknown identifier</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"c1\">-- should this work?</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lattice</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">le</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">I_DONT_KNOW_WHY_I_NEED_TO_NAME_THIS_INSTANCE</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">WHAT_IS_GOING_ON</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_Sup</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"n\">def</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">le_supr</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"n\">Sort</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span>\n  <span class=\"bp\">@</span><span class=\"n\">has_le</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">I_DONT_KNOW_WHY_I_NEED_TO_NAME_THIS_INSTANCE</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">supr</span> <span class=\"n\">α</span> <span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">WHAT_IS_GOING_ON</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">resetI</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span><span class=\"o\">)))</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"bp\">#</span><span class=\"kn\">exit</span>\n</pre></div>\n\n\n<p>This is not going well. What am I doing wrong?</p>",
        "id": 168771614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561250596
    },
    {
        "content": "<p>You put the <code>[complete_lattice \\a]</code> to the right of the colon</p>",
        "id": 168771739,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561250879
    },
    {
        "content": "<p>bleurgh thanks. I am sort-of generating the code algorithmically, you're just finding bugs in my algorithm.</p>",
        "id": 168771785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561250925
    },
    {
        "content": "<p>I am writing some completely mechanical code, made possible because of excellent naming conventions <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 168771912,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251196
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"o\">[</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"bp\">≤</span> <span class=\"n\">supr</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">le_supr</span> <span class=\"n\">s</span> <span class=\"n\">i</span>\n</pre></div>\n\n\n<p>There's some sort of dictionary going between subset land and lattice land. <code>subset_Union</code> becomes <code>le_supr</code>.</p>",
        "id": 168772005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251417
    },
    {
        "content": "<p>When I manipulate terms of type <code>opens X</code>, is the canonical way to manipulate them using the language of complete lattices?</p>",
        "id": 168772012,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251461
    },
    {
        "content": "<p>Is that the language that the <code>simp</code> lemmas will be in?</p>",
        "id": 168772013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251472
    },
    {
        "content": "<p>Oh my goodness I just found <code>lattice.complete_lattice.le</code>. What's it doing down there? Complete lattices are actually called <code>lattice.complete_lattice</code></p>",
        "id": 168772241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251961
    },
    {
        "content": "<p>Is that how it works? Who decided that lattice was a top level thing but complete_lattice wasn't?</p>",
        "id": 168772280,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561251996
    },
    {
        "content": "<p>this is a naming bug which we haven't done anything about yet</p>",
        "id": 168772398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252313
    },
    {
        "content": "<p>the <code>lattice.lattice</code> thing is obviously not good</p>",
        "id": 168772435,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252325
    },
    {
        "content": "<p>I think far too much stuff ended up in the lattice namespace, including <code>lattice</code> itself</p>",
        "id": 168772440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252350
    },
    {
        "content": "<p>Is the naming bug because <code>lattice.complete_lattice</code> is a class which is doesn't have a top level name?</p>",
        "id": 168772447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561252370
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">has_le</span>\n  <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">has_le</span>\n  <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>? Why? And should it be an explicit instance or should it just remain undefined?</p>",
        "id": 168772509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561252521
    },
    {
        "content": "<p>I feel like if I ever had to mention this name then something had gone wrong, because there's only one le on a complete lattice.</p>",
        "id": 168772511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561252548
    },
    {
        "content": "<p>What are you doing?</p>",
        "id": 168772611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252744
    },
    {
        "content": "<p>you shouldn't need to write anything remotely close to either of those</p>",
        "id": 168772615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252760
    },
    {
        "content": "<p>you should write <code>&lt;=</code> and be done with it</p>",
        "id": 168772616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252770
    },
    {
        "content": "<p>I'm just learning about complete lattices. I've never heard of them. I'm learning the language of complete lattices.</p>",
        "id": 168772623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561252797
    },
    {
        "content": "<p><code>lattice</code> is a top level namespace like <code>category_theory</code></p>",
        "id": 168772665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252810
    },
    {
        "content": "<p>it encloses most of the lattice-related constants</p>",
        "id": 168772667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252828
    },
    {
        "content": "<p>but like I said, I think it should be removed</p>",
        "id": 168772670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252841
    },
    {
        "content": "<p>Most of the time people <code>open lattice</code> for this reason</p>",
        "id": 168772672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252854
    },
    {
        "content": "<p>I'm amused you think complete lattices are a CS thing</p>",
        "id": 168772682,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561252894
    },
    {
        "content": "<p>They're being called alpha in the repo. That is an insult as far as I am concerned</p>",
        "id": 168772736,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561252992
    },
    {
        "content": "<p>They don't deserve a maths name</p>",
        "id": 168772739,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253012
    },
    {
        "content": "<p>Huh? that's pretty standard in mathlib</p>",
        "id": 168772740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253023
    },
    {
        "content": "<p>I know but I tell my undergraduates to use maths notation for mathsy stuff</p>",
        "id": 168772781,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253050
    },
    {
        "content": "<p>what notation are you going to give <code>complete_lattice</code>? That's plain text in maths</p>",
        "id": 168772794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253103
    },
    {
        "content": "<p>That group cohomology repo is all done with $$G$$s and $$M$$s just like in the maths books. No alphas at all</p>",
        "id": 168772803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253114
    },
    {
        "content": "<p>I will never have to mention complete lattices in maths texts. They are beneath mathematicians. They are just some tool that people like Johannes like</p>",
        "id": 168772845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253171
    },
    {
        "content": "<p>I'm sure if you had written complete lattices it would use L as well</p>",
        "id": 168772846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253176
    },
    {
        "content": "<p>That's an interesting suggestion</p>",
        "id": 168772847,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253205
    },
    {
        "content": "<p>I tend to use the notation that mathematicians use you see</p>",
        "id": 168772855,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253238
    },
    {
        "content": "<p>I would say that mathlib had a convention for this, and you and others didn't like it, and now we have inconsistency re: variable names</p>",
        "id": 168772856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253264
    },
    {
        "content": "<p>and I don't care enough to do anything about it</p>",
        "id": 168772857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253272
    },
    {
        "content": "<p>But I've never seen a mathematician talking about compete lattices in the number theory seminar</p>",
        "id": 168772859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253273
    },
    {
        "content": "<p>The maths stuff gets maths names and the weird stuff can have computer science names.</p>",
        "id": 168772901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253312
    },
    {
        "content": "<p>Maybe the maths conventions should just have one universe too</p>",
        "id": 168772903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253331
    },
    {
        "content": "<p>:-)</p>",
        "id": 168772910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561253347
    },
    {
        "content": "<p>I don't know why we are on this again, but the only difference is lattices were written before the rebellion</p>",
        "id": 168772912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253361
    },
    {
        "content": "<p>I can't be bothered to tell the difference between types, so I call types of things alpha and index types iota and that's about it</p>",
        "id": 168772965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253428
    },
    {
        "content": "<p>I have no idea what letter is preferred for these things, I'm not a group theorist</p>",
        "id": 168772973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253479
    },
    {
        "content": "<p>I just want library-wide consistency</p>",
        "id": 168772975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253510
    },
    {
        "content": "<p>But since variable names don't affect the applicability of a theorem, I don't really care what names are chosen, so if you want to call it G in your own files then go ahead</p>",
        "id": 168773023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561253592
    },
    {
        "content": "<p>I can't appeal to alpha-equivalence? ;-)</p>",
        "id": 168773231,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254076
    },
    {
        "content": "<p>Anyway, that's got nothing to do with what I'm doing, what I'm doing is wondering whether the natural domain for glueing sheaves of types is complete lattices.</p>",
        "id": 168773271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254126
    },
    {
        "content": "<p>based solely on your statements, yes</p>",
        "id": 168773283,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254236
    },
    {
        "content": "<p>I used a <code>semilattice_inf</code> for the definitions I showed because I didn't actually need a union operator, only a axiom that quantifies over lubs</p>",
        "id": 168773326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254295
    },
    {
        "content": "<p>but if you want to actually take some arbitrary subset and \"take its union\" then you need a <code>complete_lattice</code></p>",
        "id": 168773334,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254333
    },
    {
        "content": "<p>I might be able to get away with just the predicate \"the sup of this set is the max\"</p>",
        "id": 168773381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254397
    },
    {
        "content": "<p>I did something like that in the sheaf axioms</p>",
        "id": 168773383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254418
    },
    {
        "content": "<p>but I sort-of feel that Assia would be frowning.</p>",
        "id": 168773389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254444
    },
    {
        "content": "<p>The question is whether this compromises the meaning of the statement in the case that no lub exists</p>",
        "id": 168773390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254475
    },
    {
        "content": "<p>i think that in the odd order project the idea was to just ignore the big ambient group</p>",
        "id": 168773392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254477
    },
    {
        "content": "<p>Let's call it 37 in that case.</p>",
        "id": 168773432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254505
    },
    {
        "content": "<p>that will definitely compromise the meaning of the statement</p>",
        "id": 168773433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254521
    },
    {
        "content": "<p>only in your mind</p>",
        "id": 168773434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254537
    },
    {
        "content": "<p>We know what we're doing in the maths department</p>",
        "id": 168773439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254546
    },
    {
        "content": "<p>I'm not talking about totalizing a function, I'm talking about statements that require a lub</p>",
        "id": 168773443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254548
    },
    {
        "content": "<p>like <code>gluing</code></p>",
        "id": 168773444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254555
    },
    {
        "content": "<p>OK just make it to option.</p>",
        "id": 168773448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254579
    },
    {
        "content": "<p>sure, but again I'm not talking about totalization</p>",
        "id": 168773450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254593
    },
    {
        "content": "<p>what does the theorem <em>say</em> if you apply it to a set with no lub?</p>",
        "id": 168773494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254611
    },
    {
        "content": "<p>I do not care because I will always supply a proof that the lub exists in practice.</p>",
        "id": 168773497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254636
    },
    {
        "content": "<p>what if there is no lub?</p>",
        "id": 168773500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254646
    },
    {
        "content": "<p>I promise there is a lub</p>",
        "id": 168773501,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254656
    },
    {
        "content": "<p>if it's a semilattice_inf there may not be a lub</p>",
        "id": 168773502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254660
    },
    {
        "content": "<p>well there are lubs in the only model I'm interested in, which is <code>opens</code></p>",
        "id": 168773512,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254689
    },
    {
        "content": "<p>the question of whether to \"upgrade\" to <code>complete_lattice</code> lies in whether the statements break down in the absence of lubs</p>",
        "id": 168773515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254710
    },
    {
        "content": "<p>And I say that that's your problem</p>",
        "id": 168773556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254744
    },
    {
        "content": "<p>because I promise I will never run that code in the absence of an upper bound</p>",
        "id": 168773557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254753
    },
    {
        "content": "<p>like I promise I will never take the square root of a negative number, even though you let me.</p>",
        "id": 168773564,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561254789
    },
    {
        "content": "<p>this is more the opposite problem - you don't have the language to say something that you want to say</p>",
        "id": 168773598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561254843
    },
    {
        "content": "<p>I'm not sure why you are so against contemplating such a simple generalization of sheaves when apparently you have much more complicated generalizations in mind</p>",
        "id": 168773659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561255006
    },
    {
        "content": "<p>I can't answer this question because I don't know what sheaves are beyond the definitions I've seen</p>",
        "id": 168773672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561255059
    },
    {
        "content": "<p>You just have to wait for me to catch up Mario :-) I'll get there in the end. I don't know how to steer complete lattices, and I am running into Lean issues which I don't understand. For example</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at field &#39;le_sup_left&#39;\n  sorry\nhas type\n  ∀ (a b : α), semilattice_inf.le a (?m_1 a b)\nbut is expected to have type\n  ∀ (a b : α), a ≤ a ⊔ b\n</pre></div>\n\n\n<p>I hate it when <code>sorry</code> is underlined in red.</p>",
        "id": 168774715,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561257295
    },
    {
        "content": "<p>One thing I'm not a big fan of in the lattice theorems is the large number of implicit parameters</p>",
        "id": 168775031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561257992
    },
    {
        "content": "<p>it can cause some unification problems</p>",
        "id": 168775032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258009
    },
    {
        "content": "<p>but I can't diagnose that problem based on the error alone. What's the context?</p>",
        "id": 168775043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258063
    },
    {
        "content": "<p>I really have no clue about whether to use <code>{}</code> or <code>()</code>. I used to think it was \"use <code>{}</code> if and only if you can work it out from all the <code>()</code> stuff, but that's not always the rule. Probably you Mario know some examples of this.</p>",
        "id": 168775046,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258072
    },
    {
        "content": "<p>that is the rule, and the lattice theorems don't follow it</p>",
        "id": 168775086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258095
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/xena/blob/1284a71aa327040494f13babb336c73d41680787/Examples/sheaf_on_opens_total_glueing.lean#L274\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/1284a71aa327040494f13babb336c73d41680787/Examples/sheaf_on_opens_total_glueing.lean#L274\">https://github.com/kbuzzard/xena/blob/1284a71aa327040494f13babb336c73d41680787/Examples/sheaf_on_opens_total_glueing.lean#L274</a></p>",
        "id": 168775097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258183
    },
    {
        "content": "<blockquote>\n<p>that is the rule, and the lattice theorems don't follow it</p>\n</blockquote>\n<p>Is this a bug? What is the name for this issue? They don't follow it for a good reason, right?</p>",
        "id": 168775144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258218
    },
    {
        "content": "<p>Should one just force the unconventional functions to have a <code>'</code> in their name, like the <code>quotient'</code> stuff?</p>",
        "id": 168775152,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258251
    },
    {
        "content": "<p>what the heck is going on in your file? What is <code>thing</code>?</p>",
        "id": 168775204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258334
    },
    {
        "content": "<blockquote>\n<p>You just have to wait for me to catch up Mario :-) I'll get there in the end. I don't know how to steer complete lattices, and I am running into Lean issues which I don't understand. For example</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">field</span> <span class=\"err\">&#39;</span><span class=\"n\">le_sup_left&#39;</span>\n  <span class=\"n\">sorry</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"err\">⊔</span> <span class=\"n\">b</span>\n</pre></div>\n\n\n<p>I hate it when <code>sorry</code> is underlined in red.</p>\n</blockquote>\n<p>For some reason, Lean believes the sorry is an inequality taking place in <code>semilattice_inf</code> land, which doesn't have a <code>sup</code> instance</p>\n<p>maybe because earlier you filled in some holes with things in <code>semilattice_inf</code> land</p>",
        "id": 168775205,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1561258336
    },
    {
        "content": "<p>This issue comes up sometimes when you have a large hierarchical class where you fill everything in with underscores</p>",
        "id": 168775216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258386
    },
    {
        "content": "<p>If you fill everything with <code>sorry</code> instead it should work</p>",
        "id": 168775220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258404
    },
    {
        "content": "<p>but if you fill early stuff with underscore and later stuff with sorry then it will fail</p>",
        "id": 168775224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258436
    },
    {
        "content": "<blockquote>\n<p>what the heck is going on in your file? What is <code>thing</code>?</p>\n</blockquote>\n<p>I'm just exploring. This is all your fault. You said \"what generality do you want to do glueing in to create a milestone\". For me the milestone is a construction of glueing sheaves.</p>",
        "id": 168775262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258445
    },
    {
        "content": "<p>So you said \"ok I'll write it all properly, will topological spaces do?\" and I said \"yeah\" and then next thing you know we have bloody lattices.</p>",
        "id": 168775266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258471
    },
    {
        "content": "<p>For your reference, if you have a partial order with a supr function, then you can prove it has a complete lattice structure</p>",
        "id": 168775267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258478
    },
    {
        "content": "<p>So you dragged me here and now you have to wait around until I've finished exploring.</p>",
        "id": 168775269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258484
    },
    {
        "content": "<blockquote>\n<p>For your reference, if you have a partial order with a supr function, then you can prove it has a complete lattice structure</p>\n</blockquote>\n<p>I am using the stupidest constructors imaginable.</p>",
        "id": 168775276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258516
    },
    {
        "content": "<p>which is to say, your definitions are provable. It won't be that much fun to do</p>",
        "id": 168775281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258559
    },
    {
        "content": "<p>I am trying to write the code algorithmically, and my algorithm says \"just do what the lean hole structure command thing says\"</p>",
        "id": 168775282,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258561
    },
    {
        "content": "<p>You and I have different ideas about fun.</p>",
        "id": 168775321,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258581
    },
    {
        "content": "<p>If you really want to do this you should break up the proof into the different parts of the hierarchy</p>",
        "id": 168775323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258619
    },
    {
        "content": "<p>I'm just trying to understand how much work it is to make mathlib's definition of <code>lattice.complete_lattice</code> from scratch, in some sense.</p>",
        "id": 168775329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258631
    },
    {
        "content": "<p>I think this might be proven in the complete_lattice.lean file</p>",
        "id": 168775331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258657
    },
    {
        "content": "<blockquote>\n<p>If you really want to do this you should break up the proof into the different parts of the hierarchy</p>\n</blockquote>\n<p>I'm still learning things about the structure which I am building. How should I be ordering things? There are two files in the Xena project.</p>",
        "id": 168775333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258667
    },
    {
        "content": "<blockquote>\n<p>I think this might be proven in the complete_lattice.lean file</p>\n</blockquote>\n<p>Hey, why is that file not called <code>lattice/complete_lattice.lean</code>?</p>",
        "id": 168775378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258715
    },
    {
        "content": "<p>I think there are several questions I've raised in this thread that are still not really answered.</p>",
        "id": 168775381,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258731
    },
    {
        "content": "<p>some of this is architectural stuff you should ask Johannes</p>",
        "id": 168775399,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258791
    },
    {
        "content": "<p>I recall the entire thing being committed in one huge block that gave us filters and complete lattices and topology, and I wasn't super happy about all the design decisions but I didn't want to bikeshed forever so I merged it</p>",
        "id": 168775461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258864
    },
    {
        "content": "<p>so you are asking me a lot of hard questions about stuff where I mostly agree with you. Don't assume everything in mathlib is optimal</p>",
        "id": 168775509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258929
    },
    {
        "content": "<p>I really like learning about this stuff. I got rid of the red sorry :-) Thanks for all your help this evening. I find this very interesting stuff.</p>",
        "id": 168775513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258964
    },
    {
        "content": "<p>First you want to prove it's a lattice</p>",
        "id": 168775519,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561258990
    },
    {
        "content": "<p>golly it's 4am</p>",
        "id": 168775520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561258993
    },
    {
        "content": "<p>then you prove it's a complete lattice</p>",
        "id": 168775521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259006
    },
    {
        "content": "<blockquote>\n<p>First you want to prove it's a lattice</p>\n</blockquote>\n<p>How did you know that?</p>",
        "id": 168775524,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561259012
    },
    {
        "content": "<p>My algorithm is buggy here.</p>",
        "id": 168775528,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561259019
    },
    {
        "content": "<p>because that's the way the hierarchy is set up</p>",
        "id": 168775529,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259031
    },
    {
        "content": "<p>But how can I work that out for myself?</p>",
        "id": 168775568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561259044
    },
    {
        "content": "<p>it's actually broken up into quite a few more pieces than that</p>",
        "id": 168775571,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259052
    },
    {
        "content": "<p>look at the <code>extends</code> clauses</p>",
        "id": 168775573,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259060
    },
    {
        "content": "<p>I want to learn how to write good structures. I am a really bad structure-writer, and I am now indicating that I am also a really bad structure-maker.</p>",
        "id": 168775575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561259081
    },
    {
        "content": "<p>Ignoring the notation typeclasses, you have <code>complete_lattice &lt;- bounded_lattice &lt;- lattice, order_top, order_bot</code> and <code>lattice &lt;- semilattice_sup, semilattice_inf &lt;- partial order</code></p>",
        "id": 168775587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259160
    },
    {
        "content": "<p>So to keep it organized, you should try to first show <code>partial_order foo</code>, then <code>semilattice_inf foo</code> and <code>semilattice_sup foo</code>, then <code>lattice foo</code> and <code>order_top foo</code> and <code>order_bot foo</code>, then <code>bounded_lattice foo</code>, then <code>complete_lattice foo</code></p>",
        "id": 168775673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259297
    },
    {
        "content": "<p>In practice you can skip some of those steps by proving them simultaneous with other steps, but you should realize that when a later typeclass has an axiom that uses a notation provided by an earlier typeclass, the proof that you are in that typeclass appears as an argument</p>",
        "id": 168775683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259401
    },
    {
        "content": "<p>Had to fix the errors before bed :-) </p>\n<p><a href=\"https://github.com/kbuzzard/xena/blob/master/Examples/sheaf_on_opens_total_glueing.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/master/Examples/sheaf_on_opens_total_glueing.lean\">https://github.com/kbuzzard/xena/blob/master/Examples/sheaf_on_opens_total_glueing.lean</a></p>\n<p>Challenge 1: glue presheaves of types on opens<br>\nChallenge 2 : glue sheaves of types on opens.<br>\nChallenge 3 : glue sheaves of rings on opens.</p>",
        "id": 168775775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561259575
    },
    {
        "content": "<p>For example, consider the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero_ne_one</span> <span class=\"o\">:</span> <span class=\"n\">zero</span> <span class=\"bp\">≠</span> <span class=\"n\">one</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">A</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one_pos</span> <span class=\"o\">:</span> <span class=\"n\">pos</span> <span class=\"n\">one</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"n\">nat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span> <span class=\"n\">zero_ne_one</span><span class=\"o\">,</span>\n  <span class=\"n\">pos</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">one_pos</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Notice that I've proven both <code>A nat</code> and <code>B nat</code> in one go. The printed type of <code>pos_one</code> is <code>A.one ℕ &gt; 0</code>, but how could it say <code>A.one ℕ</code> if <code>A nat</code> hasn't been proven yet? The truth is that if you look at the typeclass args, you find that the provided instance is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span> <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span> <span class=\"n\">zero_ne_one</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>that is, the full proof that you just wrote above it</p>",
        "id": 168775857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259762
    },
    {
        "content": "<p>This happens every time one axiom references a parent instance, and it's even worse the deeper the nesting you prove in one go</p>",
        "id": 168775892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259850
    },
    {
        "content": "<p>this can lead to serious performance problems if you aren't careful (plus the <code>pp.all</code> size grows exponentially which isn't great either)</p>",
        "id": 168775937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561259919
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at field &#39;inf_le_left&#39;\n  complete_lattice.inf_le_left\nhas type\n  ∀ (a b : α),\n    @has_le.le α\n      (@preorder.to_has_le α\n         (@partial_order.to_preorder α\n            (@partial_order.mk α (@lattice.complete_lattice.le α X) (@lattice.complete_lattice.lt α X) _ _ _ _)))\n      (@lattice.has_inf.inf α (@lattice.has_inf.mk α (@lattice.complete_lattice.inf α X)) a b)\n      a\nbut is expected to have type\n  ∀ (a b : α),\n    @has_le.le α\n      (@preorder.to_has_le α\n         (@partial_order.to_preorder α\n            (@partial_order.mk α\n               (λ (a a_1 : α), @has_le.le α (@has_le.mk α (@lattice.complete_lattice.le α X)) a a)\n               (@partial_order.lt._default α\n                  (λ (a a_1 : α), @has_le.le α (@has_le.mk α (@lattice.complete_lattice.le α X)) a a))\n               _\n               ?m_1\n               ?m_2\n               ?m_3)))\n      (@lattice.has_inf.inf α (@lattice.has_inf.mk α ?m_4) a b)\n      a\n</pre></div>\n\n\n<p>Why am I in this mess? :-/</p>",
        "id": 168776345,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561260848
    },
    {
        "content": "<p><a href=\"https://github.com/kbuzzard/xena/blob/99cd50f01ca068d0e8796a7900f6e1a16fa8ff35/Examples/sheaf_on_opens_total_glueing.lean#L289\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/99cd50f01ca068d0e8796a7900f6e1a16fa8ff35/Examples/sheaf_on_opens_total_glueing.lean#L289\">https://github.com/kbuzzard/xena/blob/99cd50f01ca068d0e8796a7900f6e1a16fa8ff35/Examples/sheaf_on_opens_total_glueing.lean#L289</a></p>\n<p>why u hate me Lean</p>",
        "id": 168776408,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561261078
    },
    {
        "content": "<p>Oh I just have to fill in random fields and hope.</p>",
        "id": 168776456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561261149
    },
    {
        "content": "<p>All I know is that Lean wants me to prove <code>?m_1</code> etc</p>",
        "id": 168776460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561261166
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>1 goal\nα : Type u,\n_inst_2 : bounded_lattice α,\n_inst_3 : has_Sup α,\n_inst_4 : has_Inf α,\nX : complete_lattice α,\n_inst : has_inf α := semilattice_inf.to_has_inf α,\n_inst_1 : partial_order α := order_bot.to_partial_order α\n⊢ (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) ↔ ∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c\n</pre></div>\n\n\n<p><code>by refl</code> doesn't work. Presumably I have got my instances wrong?</p>",
        "id": 168777111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561262632
    },
    {
        "content": "<p>I genuinely don't know how I am supposed to make one of these lattice classes. I'm in all sorts of trouble.</p>",
        "id": 168777155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561262666
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">ext_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">A</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">⊓</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"err\">⊓</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">eq_of_forall_le_iff</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_inf_iff</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">le_inf_iff</span> <span class=\"n\">α</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>That's in mathlib, in <code>order/lattice.lean</code>. What's going on there?</p>",
        "id": 168777271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561262906
    },
    {
        "content": "<p>Oh I get it, I just look at the constructor <em>duh</em>. It would be cool if that hole command which spat out structure fields which need to be made, could take this sort of thing into account. I'm all for automation, I'm always using that hole command. Oh I'm back on track now.</p>",
        "id": 168777448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561263280
    },
    {
        "content": "<p>This is what I mean by proving them one step at a time rather than all in one go</p>",
        "id": 168777932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561264331
    },
    {
        "content": "<p>if you try to prove them in the wrong order, your goals make no sense</p>",
        "id": 168777934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561264346
    },
    {
        "content": "<p>but lean and the hole command make it look like order doesn't matter, which is only true after you are done proving everything</p>",
        "id": 168777940,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561264379
    },
    {
        "content": "<p>What's the trick to do all of the semilattice fields at once?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">canonical2</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">bounded_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_Sup</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_Inf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">thing</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"c1\">--let this : semilattice_inf α := by apply_instance,</span>\n<span class=\"n\">refine</span> <span class=\"o\">{</span> <span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">exact</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">inf</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n         <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le</span><span class=\"o\">,</span>\n         <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_refl</span><span class=\"o\">,</span>\n         <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span><span class=\"o\">,</span>\n         <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"c1\">--       inf_le_inf := semilattice_inf.inf_le_inf,</span>\n         <span class=\"n\">inf_le_left</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">inf_le_left</span><span class=\"o\">,</span>\n         <span class=\"n\">inf_le_right</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n         <span class=\"n\">le_inf</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_inf</span><span class=\"o\">,</span>\n          <span class=\"c1\">-- the rest are not from semilattice namespace</span>\n         <span class=\"n\">le_supr</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ι</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">begin</span> <span class=\"n\">convert</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">le_supr</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">sorry</span> <span class=\"kn\">end</span><span class=\"o\">,</span>\n         <span class=\"n\">supr</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">ι</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">lattice</span><span class=\"bp\">.</span><span class=\"n\">complete_lattice</span><span class=\"bp\">.</span><span class=\"n\">supr</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n         <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>And have I got my typeclasses right? Still not entirely confident on these things.</p>",
        "id": 168778907,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266408
    },
    {
        "content": "<blockquote>\n<p>if you try to prove them in the wrong order, your goals make no sense</p>\n</blockquote>\n<p>How do I work out the correct order to prove them?</p>",
        "id": 168778908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266408
    },
    {
        "content": "<p>Look at the definition of <code>complete_lattice</code>, it extends <code>bounded_lattice</code> so you should prove stuff about bounded lattice before you do stuff involving Sup and Inf</p>",
        "id": 168779007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266605
    },
    {
        "content": "<p>You should not have <code>[bounded_lattice α] [has_Sup α] [has_Inf α] [lattice.complete_lattice α]</code> because <code>complete_lattice</code> contains another copy of the first three</p>",
        "id": 168779017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266693
    },
    {
        "content": "<p>That direction should be relatively easy, if you <code>open lattice</code> then the proof should just be <code>supr := supr</code> and <code>le_supr := le_supr</code></p>",
        "id": 168779062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266775
    },
    {
        "content": "<p>I have a universe issue.</p>\n<div class=\"codehilite\"><pre><span></span>kernel failed to type check declaration &#39;canonical2.to_fun&#39; this is usually due to a buggy tactic or a bug in the builtin elaborator\nelaborated type:\n  Π (α : Type u) [_inst_1 : complete_lattice α], thing α\nelaborated value:\n  λ (α : Type u) [_inst_1 : complete_lattice α],\n    {to_semilattice_inf := {inf := semilattice_inf.inf (semilattice_inf_bot.to_semilattice_inf α),\n                            le := semilattice_inf.le (semilattice_inf_bot.to_semilattice_inf α),\n                            lt := partial_order.lt._default semilattice_inf.le,\n                            le_refl := _,\n                            le_trans := _,\n                            lt_iff_le_not_le := _,\n                            le_antisymm := _,\n                            inf_le_left := _,\n                            inf_le_right := _,\n                            le_inf := _},\n     supr := λ (ι : Sort v) (s : ι → α), complete_lattice.supr s,\n     le_supr := _}\nnested exception message:\ninvalid reference to undefined universe level parameter &#39;v&#39;\n</pre></div>",
        "id": 168779065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266783
    },
    {
        "content": "<p>oh right, <code>thing</code> has a universe issue in its definition because v is free</p>",
        "id": 168779069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266809
    },
    {
        "content": "<p><code>thing.{v} α</code></p>",
        "id": 168779070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266814
    },
    {
        "content": "<p>got it</p>",
        "id": 168779072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266821
    },
    {
        "content": "<p>You should either use <code>u</code> in place of <code>v</code> , or do the same thing as complete_lattice and axiomatize Sup instead of supr</p>",
        "id": 168779112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266850
    },
    {
        "content": "<p>You can't properly axiomatize supr because of the required existential universe variables</p>",
        "id": 168779117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561266903
    },
    {
        "content": "<p>I don't really understand what is going on here, as my code probably indicates.</p>",
        "id": 168779124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561266938
    },
    {
        "content": "<p>My original claim that <code>thing</code> is equivalent to <code>complete_lattice</code> is actually false with <code>v</code> used the way it currently is</p>",
        "id": 168779175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267048
    },
    {
        "content": "<p>If <code>v</code> is less than <code>u</code> then you are actually claiming only the existence of \"small suprema\"</p>",
        "id": 168779177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267069
    },
    {
        "content": "<p>Because I am universe-monomorphic I do not recognise this issue.</p>",
        "id": 168779217,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267087
    },
    {
        "content": "<p>As a simpler analogue, it's as if you are only asking for countable suprema</p>",
        "id": 168779221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267116
    },
    {
        "content": "<p>That's an interesting analogue</p>",
        "id": 168779222,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267138
    },
    {
        "content": "<p>if the set itself is not countable it should not be a surprise that this isn't the same as being complete</p>",
        "id": 168779227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267152
    },
    {
        "content": "<p>But another observation is presumably that if <code>Type u</code> and <code>Sort v</code> are just <code>Type</code> then the problem goes away?</p>",
        "id": 168779279,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267220
    },
    {
        "content": "<p>More specifically, if you set <code>v = u</code> then the problem goes away</p>",
        "id": 168779281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267245
    },
    {
        "content": "<p>Is that right? That would be really nice. I thought the Sort stuff might mess things up.</p>",
        "id": 168779286,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267274
    },
    {
        "content": "<p>or like I said, if you restrict the indexing set to be subsets of the original space</p>",
        "id": 168779287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267275
    },
    {
        "content": "<blockquote>\n<p>or like I said, if you restrict the indexing set to be subsets of the original space</p>\n</blockquote>\n<p>I can't do that for glueing schemes.</p>",
        "id": 168779290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267290
    },
    {
        "content": "<p>sure you can</p>",
        "id": 168779291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267296
    },
    {
        "content": "<p>do you have an example?</p>",
        "id": 168779333,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267347
    },
    {
        "content": "<p>You think that the set-valued version of glueing implies the Union version?</p>",
        "id": 168779338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267378
    },
    {
        "content": "<p>Yes</p>",
        "id": 168779341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267384
    },
    {
        "content": "<p>I had not realised this</p>",
        "id": 168779344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267391
    },
    {
        "content": "<p>The definition I gave of <code>gluing</code> and <code>locality</code> uses subsets</p>",
        "id": 168779346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267394
    },
    {
        "content": "<p>The set-valued version will only use one universe, right?</p>",
        "id": 168779348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267402
    },
    {
        "content": "<p>it actually only uses one type, which is in the same universe as the original</p>",
        "id": 168779351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267422
    },
    {
        "content": "<p>I know that <code>gluing</code> and <code>locality</code> use subsets, but they are conceptually simpler than gluing sheaves. They are gluing sections.</p>",
        "id": 168779391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267452
    },
    {
        "content": "<p>okay you are going to have to give me a code snippet to back that statement up</p>",
        "id": 168779393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267476
    },
    {
        "content": "<p>what are the types of the relevant objects?</p>",
        "id": 168779400,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267506
    },
    {
        "content": "<p>This is the thing I want:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">universal_property</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">Hφ1</span> <span class=\"n\">Hφ2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 168779403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267520
    },
    {
        "content": "<p>If you can make the type of an analogous \"set version\" of this term which mentions no <code>I</code> and no <code>Sort v</code> and replaces <code>S</code> with some kind of <code>set</code> thing, sorry it, and then prove the universal property I want from your set one, then I will understand why the set one suffices.</p>",
        "id": 168779450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267618
    },
    {
        "content": "<p>This is a theorem, though, right?</p>",
        "id": 168779455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267637
    },
    {
        "content": "<p>I don't know.</p>",
        "id": 168779458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267654
    },
    {
        "content": "<p>you wrote <code>:= sorry</code> so I assume so</p>",
        "id": 168779460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267668
    },
    {
        "content": "<p>this is supposed to follow from the axioms of sheaves</p>",
        "id": 168779501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267689
    },
    {
        "content": "<p>I don't know if it's true. It's a conjecture.</p>",
        "id": 168779502,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267693
    },
    {
        "content": "<p>Assuming Kenny and I have formalised it correctly, that should be true. It's an exercise in Hartshorne.</p>",
        "id": 168779561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267820
    },
    {
        "content": "<p>Exercise 1.22 of one of the early chapters.</p>",
        "id": 168779568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267869
    },
    {
        "content": "<p>the proof args make me weep</p>",
        "id": 168779569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267872
    },
    {
        "content": "<p>Just tell me how to do it.</p>",
        "id": 168779570,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267882
    },
    {
        "content": "<p>I don't have a clue what I'm doing. I know enough Lean to be able to solve problems I run into, and I just blunder on.</p>",
        "id": 168779571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267899
    },
    {
        "content": "<p>Probably chapter 2, I think section 2.1 is sheaves.</p>",
        "id": 168779612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561267927
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Did you just pull an all-nighter gluing sheaves <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 168779614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561267962
    },
    {
        "content": "<p>There are two ways forward: the way I've been championing that tries to hide proof args, or the category theory way that makes the proof args the only thing and hides the objects</p>",
        "id": 168779615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561267962
    },
    {
        "content": "<p>And another conjecture is that if T is a type with the discrete topology, and if F(U) is defined to be the continuous maps from U to T, then the cocycle condition should give us a 1-cocycle with values in Aut(T) or something. This might be nonabelian sheaf cohomology though, which we didn't formalise yet. Anca only did abelian group H1.</p>",
        "id": 168779668,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561268062
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> Did you just pull an all-nighter gluing sheaves <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>\n</blockquote>\n<p>My partner is away :-)</p>",
        "id": 168779672,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561268078
    },
    {
        "content": "<p>There will be an easier universal property just for presheaves of types. I might have done this one.</p>",
        "id": 168779728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561268208
    },
    {
        "content": "<p>In the <code>opens</code> case, not in the lattice case.</p>",
        "id": 168779729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561268218
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"n\">has_sup</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_sup</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">sup</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">thing</span><span class=\"bp\">.</span><span class=\"n\">supr</span> <span class=\"n\">α</span> <span class=\"n\">Y</span> <span class=\"n\">bool</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">bool</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)}</span>\n</pre></div>\n\n\n<p>Will this instance never trigger?</p>",
        "id": 168780754,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561270318
    },
    {
        "content": "<p>I rolled my own <code>sup</code> from <code>supr</code></p>",
        "id": 168780795,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561270348
    },
    {
        "content": "<p>and now I have universe issues :-(</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  thing.has_sup α Y\nterm\n  Y\nhas type\n  thing.{u_1 u} α : Type (max u u_1)\nbut is expected to have type\n  thing.{1 u} α : Type (max u 1)\nstate:\nα : Type u,\nH : semilattice_inf α,\nY : thing α\n⊢ Sort ?\n</pre></div>\n\n\n<p>stupid bool. Did I need a ubool or something?</p>",
        "id": 168780806,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561270404
    },
    {
        "content": "<p>you can use <code>ulift bool</code></p>",
        "id": 168781098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561271069
    },
    {
        "content": "<p>I don't understand the universe combinatorics well enough to know which universe I should be lifting to.</p>",
        "id": 168781099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561271099
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  thing.has_sup α Y\nterm\n  Y\nhas type\n  thing.{u_1 u} α : Type (max u u_1)\nbut is expected to have type\n  thing.{?l_1+1 u} α : Type (max u (?l_1+1))\nstate:\nα : Type u,\nH : semilattice_inf α,\nY : thing α\n⊢ Sort ?\n</pre></div>\n\n\n<p>I can't even solve the equations.</p>",
        "id": 168781107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561271132
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">thing</span><span class=\"bp\">.</span><span class=\"n\">to_semilattice_inf</span> <span class=\"n\">Y</span>\n<span class=\"c1\">-- example (α : Type u) (Y : thing α) : semilattice_inf α := by apply_instance -- fails</span>\n</pre></div>\n\n\n<p>I can't get this instance to fire. Do I have to make <code>thing</code> a class to proceed more smoothly?</p>",
        "id": 168781469,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561271914
    },
    {
        "content": "<p>Why does <code>thing</code> still take two universe args?</p>",
        "id": 168781595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272152
    },
    {
        "content": "<p>I'm scared Mario</p>",
        "id": 168781599,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272175
    },
    {
        "content": "<p>I'm still not clear on exactly what the goal is</p>",
        "id": 168781607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272195
    },
    {
        "content": "<p>I am not sure that sets are enough for glueing</p>",
        "id": 168781608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272198
    },
    {
        "content": "<p>You aren't using sets</p>",
        "id": 168781611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272206
    },
    {
        "content": "<p>I managed to prove that sheaf has a comap operation, will show</p>",
        "id": 168781614,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272226
    },
    {
        "content": "<p>I'll formalise the thing I'm not sure whether to believe.</p>",
        "id": 168781616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272232
    },
    {
        "content": "<p><a href=\"https://gist.github.com/digama0/2ee44987e8613b41c24536ddcde86d35\" target=\"_blank\" title=\"https://gist.github.com/digama0/2ee44987e8613b41c24536ddcde86d35\">https://gist.github.com/digama0/2ee44987e8613b41c24536ddcde86d35</a></p>",
        "id": 168781661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272282
    },
    {
        "content": "<p>That's equivalent to the theorem that you can make a sheaf on a subset</p>",
        "id": 168781674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272331
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">infixr</span> <span class=\"bp\">`</span> <span class=\"err\">↪⊓⨆</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">semilattice_inf_lub_emb</span>\n</pre></div>\n\n\n<p>I'm liking that.</p>",
        "id": 168781779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272562
    },
    {
        "content": "<p>I cannot formalise the \"can sheaf glueing be done on subsets WLOG\" goal until someone has ported Kenny's work on glueing to Mario's framework.</p>",
        "id": 168781839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272685
    },
    {
        "content": "<p>That's the goal</p>",
        "id": 168781881,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561272729
    },
    {
        "content": "<p>It seems to me that half of that file is duplicating things that we have in <code>category_theory/</code> already...</p>",
        "id": 168781896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561272827
    },
    {
        "content": "<p>It's normally <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> who says that. I don't know too much about the category theory library either.</p>",
        "id": 168781938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561272872
    },
    {
        "content": "<p>In fact, we already have the definition of presheaf in mathlib + a bunch of other abstract generalities. I think it would make a lot of sense to build the sheaf condition on top of that.</p>",
        "id": 168782067,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561273169
    },
    {
        "content": "<p>But is it a presheaf over a complete lattice?</p>",
        "id": 168782379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561273805
    },
    {
        "content": "<p>Oh it's some category definition, right? It's a functor. I think it would be an interesting question to see how much fun it was to formalise sheaf glueing in that language. I think it would be more difficult than what Mario is doing.</p>",
        "id": 168782389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561273865
    },
    {
        "content": "<p>One thing that the category formulation will give you is a much easier way to do this stuff</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n</pre></div>\n\n\n<p>with diagrams</p>",
        "id": 168782441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561273982
    },
    {
        "content": "<p>You can still just work over complete lattices.</p>",
        "id": 168782445,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561274002
    },
    {
        "content": "<p>So do the sheafy part the way you've been doing it. But just use the existing presheaves, instead of rolling your own.</p>",
        "id": 168782446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561274024
    },
    {
        "content": "<p>The definition of presheaf and functor or defeq up to eta for records...</p>",
        "id": 168782485,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561274045
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"err\">⊓</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n  <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">mono</span> <span class=\"n\">h</span><span class=\"o\">),</span>\n  <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hid</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">bc</span> <span class=\"n\">ab</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">Hcomp</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>This is much harder for sheaves; one might need some extra assumptions on alpha to make it work.</p>",
        "id": 168782773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274720
    },
    {
        "content": "<p>You have to \"sheafify\".</p>",
        "id": 168782775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274735
    },
    {
        "content": "<p>Apply the adjoint functor to the forgetful functor from sheaves to presheaves.</p>",
        "id": 168782814,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274763
    },
    {
        "content": "<p>Here's presheaves:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">Top</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span>\n\n<span class=\"n\">def</span> <span class=\"n\">presheaf&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">Top</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span> <span class=\"n\">C</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">presheaf&#39;</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒞</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⟶</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span> <span class=\"err\">⟶</span> <span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">presheaf&#39;</span>\n</pre></div>\n\n\n<p>Not sure how to state the sheaf axioms without elements of the category</p>",
        "id": 168782822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274817
    },
    {
        "content": "<p>I don't know why <code>presheaf</code> is stated using a <code>Top</code> argument</p>",
        "id": 168782832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274861
    },
    {
        "content": "<p>You can't make sheaves on an arbitrary category.</p>",
        "id": 168782834,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274866
    },
    {
        "content": "<p>You need a notion of covering. This is what a site is.</p>",
        "id": 168782836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274881
    },
    {
        "content": "<p>okay, how's that work?</p>",
        "id": 168782875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274894
    },
    {
        "content": "<p><a href=\"https://en.wikipedia.org/wiki/Grothendieck_topology\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Grothendieck_topology\">https://en.wikipedia.org/wiki/Grothendieck_topology</a></p>",
        "id": 168782877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274916
    },
    {
        "content": "<p>Wait, this is about the domain category</p>",
        "id": 168782883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274943
    },
    {
        "content": "<p>If you work with categories then that is the correct thing to use.</p>",
        "id": 168782886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274947
    },
    {
        "content": "<p>mathlib presheaves are on top spaces</p>",
        "id": 168782887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274956
    },
    {
        "content": "<p>To say what a sheaf is, you have to know what a covering of an open set by open sets is</p>",
        "id": 168782888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561274967
    },
    {
        "content": "<p>The category here is the target, replacing Type</p>",
        "id": 168782889,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561274971
    },
    {
        "content": "<p>If you want to define sheaves of types on an arbitrary category, you need the extra structure of a site on that category.</p>",
        "id": 168782895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275000
    },
    {
        "content": "<p>I don't</p>",
        "id": 168782935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275006
    },
    {
        "content": "<p>No?</p>",
        "id": 168782940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275011
    },
    {
        "content": "<p>I'm just considering top spaces for now, because that's what mathlib presheaves are</p>",
        "id": 168782943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275025
    },
    {
        "content": "<p>I just want to know why it's bundled</p>",
        "id": 168782944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275036
    },
    {
        "content": "<p>mathlib presheaves could also be generalized to preorder categories, but that's work for another day</p>",
        "id": 168782953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275088
    },
    {
        "content": "<p>or general categories, and then you have this site business</p>",
        "id": 168782954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275105
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">sheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">sheaf</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">α</span>\n</pre></div>\n\n\n<p>How are you going to port that line to your library?</p>",
        "id": 168782999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275130
    },
    {
        "content": "<p>It might be best to do <code>presheaf_on_opens</code> first</p>",
        "id": 168783004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275158
    },
    {
        "content": "<p><code>sheaf_on_opens U := sheaf {V // V &lt;= U}</code></p>",
        "id": 168783005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275172
    },
    {
        "content": "<p>or more generally a sheaf on some object isomorphic to that</p>",
        "id": 168783013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275188
    },
    {
        "content": "<p>So you really want to carry the subtype around?</p>",
        "id": 168783019,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275205
    },
    {
        "content": "<p>That's why I defined <code>comap</code>, because <code>subtype.val</code> is an inf_sup_emb</p>",
        "id": 168783022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275226
    },
    {
        "content": "<p>But the theory starts to look very categorical at that point, because you need products in the category to replace intersection of subsets</p>",
        "id": 168783074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275312
    },
    {
        "content": "<p>And you think that (a) this will make the gluing of presheaves go better and (b) you will be able to prove the universal property from a set-valued one.</p>",
        "id": 168783080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275336
    },
    {
        "content": "<p>We can just stick to gluing of presheaves. I want to see this trick of going from the set to the parametrised set.</p>",
        "id": 168783126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275393
    },
    {
        "content": "<p>I'm not sure I want to actually define <code>sheaf_on_opens U := sheaf {V // V &lt;= U}</code> because then it won't apply cleanly to <code>opens</code>, since <code>opens U</code> (using U as a subset of the topological space as a top space in its own right) is isomorphic but not defeq to <code>{V : opens alpha // V &lt;= U}</code></p>",
        "id": 168783133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275447
    },
    {
        "content": "<p>So you can use something like <code>comap</code> to avoid having to prescribe a particular representation for the type, but at some point you just want to say \"intersect these subsets and give me the result\" without having to assume the result exists in the first place</p>",
        "id": 168783183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275536
    },
    {
        "content": "<p>And this is especially important for the gluing axiom, because it's kind of the whole point that you don't know the glued sheaf exists until you construct it</p>",
        "id": 168783193,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275576
    },
    {
        "content": "<p>But I'm not sure how to state these axioms in the categorical presentation:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">locality</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">U</span> <span class=\"n\">S</span><span class=\"o\">}},</span> <span class=\"n\">is_lub</span> <span class=\"n\">S</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">}},</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n\n<span class=\"n\">def</span> <span class=\"n\">gluing</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}}</span> <span class=\"o\">{{</span><span class=\"n\">S</span><span class=\"o\">}},</span> <span class=\"n\">is_lub</span> <span class=\"n\">S</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res&#39;</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">W</span><span class=\"o\">))</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span><span class=\"o\">:</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res&#39;</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">V</span>\n</pre></div>",
        "id": 168783238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275625
    },
    {
        "content": "<p>they are too pointed</p>",
        "id": 168783241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561275635
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>failed to synthesize type class instance for\nα : Type u,\n_inst_1 : semilattice_inf α,\nU : α\n⊢ semilattice_inf {V // V ≤ U}\n</pre></div>",
        "id": 168783416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561275993
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lattice</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"n\">def</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">presheaf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 168783428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276059
    },
    {
        "content": "<p>there's that too</p>",
        "id": 168783541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561276304
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilattice_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>:-(</p>",
        "id": 168783606,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276440
    },
    {
        "content": "<p>it's not hard to prove</p>",
        "id": 168783710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561276618
    },
    {
        "content": "<p>I just thought it would happen by magic</p>",
        "id": 168783720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276635
    },
    {
        "content": "<p>I am really not good at making any instances of anything with the word lattice in the name.</p>",
        "id": 168783721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276652
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails</span>\n</pre></div>",
        "id": 168783724,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276669
    },
    {
        "content": "<p>but <code>semilattice_inf</code> extends <code>has_inf</code></p>",
        "id": 168783761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561276685
    },
    {
        "content": "<p>you have to define that too</p>",
        "id": 168784007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561277050
    },
    {
        "content": "<p>aha, this typechecks:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">locality</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">α</span><span class=\"o\">)}}</span> <span class=\"o\">{{</span><span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">{{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Sup</span> <span class=\"n\">S</span><span class=\"o\">)}},</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⟶</span> <span class=\"n\">Sup</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">s</span> <span class=\"err\">≫</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"err\">≫</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span>\n\n<span class=\"n\">def</span> <span class=\"n\">gluing</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf&#39;</span> <span class=\"n\">α</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">α</span><span class=\"o\">)}}</span> <span class=\"o\">{{</span><span class=\"n\">X</span><span class=\"o\">}}</span> <span class=\"o\">{{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">V</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">}},</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">hV</span> <span class=\"n\">W</span> <span class=\"n\">hW</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span> <span class=\"err\">⟶</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span> <span class=\"err\">⟶</span> <span class=\"n\">W</span><span class=\"o\">),</span>\n    <span class=\"n\">s</span> <span class=\"n\">V</span> <span class=\"n\">hV</span> <span class=\"err\">≫</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">W</span> <span class=\"n\">hW</span> <span class=\"err\">≫</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">Sup</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">hV</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⟶</span> <span class=\"n\">Sup</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"err\">≫</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">V</span> <span class=\"n\">hV</span>\n</pre></div>",
        "id": 168784008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561277066
    },
    {
        "content": "<p>the main drawback seems to be that you have to specify the morphism all the time, even though it's unique</p>",
        "id": 168784039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561277112
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">mario_sheaf</span> <span class=\"c1\">-- Mario&#39;s gist</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">lattice</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variable</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"c1\">--#print notation →⊓</span>\n<span class=\"c1\">--#check @semilattice_inf_hom</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">class semilattice_inf (α : Type u) extends has_inf α, partial_order α :=</span>\n<span class=\"cm\">(inf_le_left : ∀ a b : α, a ⊓ b ≤ a)</span>\n<span class=\"cm\">(inf_le_right : ∀ a b : α, a ⊓ b ≤ b)</span>\n<span class=\"cm\">(le_inf : ∀ a b c : α, a ≤ b → a ≤ c → a ≤ b ⊓ c)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">--#where</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">opens</span>\n\n<span class=\"c1\">--#print has_inf.inf</span>\n\n<span class=\"n\">def</span> <span class=\"n\">inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"err\">⊓</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">has_inf</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">inf</span> <span class=\"n\">U</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">partial_order</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilattice_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">inf_le_left</span> <span class=\"c1\">--: ∀ a b : α, a ⊓ b ≤ a</span>\n      <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">exact</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">inf_le_left</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n    <span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"err\">⊓</span><span class=\"o\">),</span>\n    <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n    <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_refl</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n    <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_trans</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n    <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"k\">begin</span>\n      <span class=\"n\">convert</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_antisymm</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n      <span class=\"n\">convert</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">propext</span><span class=\"o\">,</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n        <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span>\n        <span class=\"n\">apply</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n      <span class=\"n\">intros</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">inf_le_right</span> <span class=\"c1\">--: ∀ a b : α, a ⊓ b ≤ b</span>\n      <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">inf_le_right</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span><span class=\"c1\">--sorry,</span>\n    <span class=\"n\">le_inf</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">le_inf</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n  <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">presheaf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">&lt;=</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">morphism</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}),</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">commutes</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">morphism</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">commutes&#39;</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">F</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">W</span> <span class=\"o\">((</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"o\">((</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HVW</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"kn\">end</span>\n\n<span class=\"n\">def</span> <span class=\"n\">commutes&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">),</span>\n  <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">W</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"err\">∘</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">:=</span> <span class=\"k\">begin</span> <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HVW</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"kn\">end</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">}</span>\n\n\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">H</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">),</span>\n  <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">commutes&#39;</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"n\">ξ</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">commutes&#39;</span> <span class=\"n\">U</span> <span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"n\">η</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">}</span>\n\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">η</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ξ</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">V</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">η</span> <span class=\"bp\">=</span> <span class=\"n\">ξ</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">η</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">ξ</span><span class=\"bp\">;</span> <span class=\"n\">congr</span><span class=\"bp\">;</span> <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">H</span>\n\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">id_comp</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">U</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"n\">η</span> <span class=\"bp\">=</span> <span class=\"n\">η</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_id</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">η</span> <span class=\"o\">(</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">U</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">η</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">comp_assoc</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">H</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ξ</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">χ</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">η</span> <span class=\"n\">ξ</span><span class=\"o\">)</span> <span class=\"n\">χ</span> <span class=\"bp\">=</span> <span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">η</span> <span class=\"o\">(</span><span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">ξ</span> <span class=\"n\">χ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">morphism</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">F</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_fun</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span> <span class=\"n\">U</span> <span class=\"n\">G</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">left_inv</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">inv_fun</span> <span class=\"n\">to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">U</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">right_inv</span> <span class=\"o\">:</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">U</span> <span class=\"n\">to_fun</span> <span class=\"n\">inv_fun</span> <span class=\"bp\">=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">U</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">exit</span>\n\n<span class=\"n\">def</span> <span class=\"n\">universal_property</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">presheaf_on_opens</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n<span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">glue</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">Hφ1</span> <span class=\"n\">Hφ2</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n\n<span class=\"kn\">end</span> <span class=\"n\">semilattice_inf</span><span class=\"bp\">.</span><span class=\"n\">opens</span>\n</pre></div>\n\n\n<p>That's the equiv in Mario's non-category language, using Kenny's trick. Now I can start to formalise the universal property for glueing.</p>",
        "id": 168786796,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282633
    },
    {
        "content": "<p>This is with <code>def presheaf_on_opens (U : α) := presheaf {V // V &lt;= U}</code></p>",
        "id": 168786844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282698
    },
    {
        "content": "<p>Why do you have a proof of <code>partial_order</code> and then not use it for <code>semilattice_inf</code>?</p>",
        "id": 168786860,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561282759
    },
    {
        "content": "<p>Because I don't know what I'm doing.</p>",
        "id": 168786864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282779
    },
    {
        "content": "<p>I'm behaving quite algorithmically still, I'm not thinking much.</p>",
        "id": 168786866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282796
    },
    {
        "content": "<p>I think that if you leave off the fields they get inferred automatically</p>",
        "id": 168786910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561282818
    },
    {
        "content": "<p>I was having trouble getting this to work.</p>",
        "id": 168786914,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282843
    },
    {
        "content": "<p>Which lines do you think I can delete?</p>",
        "id": 168786917,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561282850
    },
    {
        "content": "<p>if not, you can use <code>..(by apply_instance : partial_order {V // V ≤ U})</code> at the end</p>",
        "id": 168786922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561282859
    },
    {
        "content": "<p>the ones associated to partial_order, so le, le_trans, le_antisymm etc</p>",
        "id": 168786935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561282887
    },
    {
        "content": "<p>you can do the same thing with <code>has_inf</code>, although that doesn't save a whole lot</p>",
        "id": 168786977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561282924
    },
    {
        "content": "<p>Here's the current state of my work:</p>\n<p><a href=\"https://github.com/kbuzzard/xena/blob/master/Examples/mario_glueing.lean\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/master/Examples/mario_glueing.lean\">https://github.com/kbuzzard/xena/blob/master/Examples/mario_glueing.lean</a></p>\n<p>I just can't get the deleting to work. I don't understand structure field inheritence well enough and I can never remember the tricks; there are a couple of cool idioms which I'm sure will help me.</p>",
        "id": 168787186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561283394
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">order</span><span class=\"bp\">.</span><span class=\"n\">lattice</span>\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kn\">open</span> <span class=\"n\">lattice</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semilattice_inf</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilattice_inf</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"bp\">//</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">inf_le_left</span><span class=\"o\">,</span>\n  <span class=\"n\">inf</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">⊓</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">inf_le_right</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n  <span class=\"n\">le_inf</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">le_inf</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">partial_order</span> <span class=\"bp\">_</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 168787507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561283870
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 168787557,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561283900
    },
    {
        "content": "<blockquote>\n<p>Anyway, that's got nothing to do with what I'm doing, what I'm doing is wondering whether the natural domain for glueing sheaves of types is complete lattices.</p>\n</blockquote>\n<p>Probably it is <a href=\"https://ncatlab.org/nlab/show/locale#definitions\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/locale#definitions\">frames</a>, though as noted there a frame is also a complete lattice. I see you two already have something called <code>semilattice_inf_lub_emb</code>, which is an embedding that's a frame homomorphism.<br>\nAlso see \"Relation to topological spaces\", and Definition 4.9 and following.</p>",
        "id": 168788041,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561284829
    },
    {
        "content": "<p>Do we have frames in mathlib?</p>",
        "id": 168788085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561284879
    },
    {
        "content": "<p>can we glue sheaves on sites?</p>",
        "id": 168788179,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561285052
    },
    {
        "content": "<p>We can't glue anything on anything right now</p>",
        "id": 168788186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561285069
    },
    {
        "content": "<p>But in maths land I should think you can glue sheaves on sites.</p>",
        "id": 168788226,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561285085
    },
    {
        "content": "<p>Even type-v-indexed sheaves, I should think.</p>",
        "id": 168788235,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561285113
    },
    {
        "content": "<p>Maybe it might help to actually try using this thing rather than working so much to state an axiom</p>",
        "id": 168788322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561285322
    },
    {
        "content": "<p>I still have no idea if this is the best way to glue things when we have choice</p>",
        "id": 168788356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561285352
    },
    {
        "content": "<blockquote>\n<p>Do we have frames in mathlib?</p>\n</blockquote>\n<p>no, but they would be easy to define</p>\n<p>a caveat: <code>complete_lattice</code> bundles together <code>Sup</code> and <code>Inf</code>, and <code>complete_distrib_lattice</code> bundles together distributivity of sup over Inf and inf over Sup, so we might have to refine the hierarchy before implementing frames</p>",
        "id": 168792688,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1561293589
    },
    {
        "content": "<p>So I've done a bunch of Kenny's API, but stopped just short of defining the glued sheaf.</p>\n<p><a href=\"https://github.com/kbuzzard/xena/blob/b4994ccfa949a1586e9119ce8fefdd2b656647f9/Examples/mario_glueing.lean#L197\" target=\"_blank\" title=\"https://github.com/kbuzzard/xena/blob/b4994ccfa949a1586e9119ce8fefdd2b656647f9/Examples/mario_glueing.lean#L197\">https://github.com/kbuzzard/xena/blob/b4994ccfa949a1586e9119ce8fefdd2b656647f9/Examples/mario_glueing.lean#L197</a></p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I didn't use <code>res'</code> at all. How should I have done this better?</p>",
        "id": 168793081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561294299
    },
    {
        "content": "<p>if there is a nontrivial proof in a statement, the answer is yes</p>",
        "id": 168793138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561294335
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">opens</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">S</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">U</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">inter_subset_left</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">inter_subset_right</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">subset_inter</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"err\">∩</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">inter_subset_inter_left</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">W</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"err\">∩</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_left</span> <span class=\"n\">W</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">inter_subset_inter_right</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">W</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">V</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">W</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">U</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">inter_subset_inter</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">S</span> <span class=\"err\">⊆</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"n\">U</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"err\">⊆</span> <span class=\"n\">V</span> <span class=\"err\">∩</span> <span class=\"n\">T</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">opens</span>\n\n<span class=\"n\">def</span> <span class=\"n\">glue</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">W</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"bp\">//</span>\n      <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n        <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">∩</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n      <span class=\"k\">calc</span>  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n              <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                    <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n                    <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n                    <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n          <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n              <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n                <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n                <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n                <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                      <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n        <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n              <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n                <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)</span>\n                      <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n                  <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n        <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n      <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_inter</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n                <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_right</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_left</span>\n                <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">inter_subset_inter_right</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">∩</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">∩</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"n\">locality</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">gluing</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 168794153,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561296290
    },
    {
        "content": "<p>I have |no idea| what I was doing</p>",
        "id": 168794154,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561296300
    },
    {
        "content": "<p>I should extract defs/lemmas</p>",
        "id": 168794352,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561296703
    },
    {
        "content": "<p>Why are you using the <code>\\cap</code> and <code>\\cup</code> notation? Isn't it a lot easier to use the lattice notation? Saves you all those little lemmas at the top as well.</p>",
        "id": 168802279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561312495
    },
    {
        "content": "<p>Kenny I refactored your code so that it works for complete lattices</p>",
        "id": 168802821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561313498
    },
    {
        "content": "<p>That's quite some <code>calc</code> by the way!</p>",
        "id": 168802864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561313533
    },
    {
        "content": "<p>I didn't read code in this thread, but I just want to tell Kevin: Johannes explained countless times why there are lattices all other mathlib. This is category theory that actually works and helps. Up to now nobody managed to make category theory usable in Lean. In Edinburgh I asked Scott and Reid to show me how to define the category of uniform spaces, the subcategory of complete separated uniform spaces, and the completion functor (all of this is already in mathlib, unbundled and without using category theory). They couldn't. Defining categories was ok, but then they hit the weirdest kinds of bugs, with Lean randomly unfolding things beyond recognition. </p>\n<p>Also when I changed the order on <code>topological_space</code> and <code>uniform_space</code> last week, I had to change 16 files. After setting up the change correctly in the first file it was a smooth ride all along except for <code>topology/Top/limits.lean</code> which got me amazingly confused, because the statements and intermediate goals were undecipherable to me. </p>\n<p>Now there is one kind of category that works in Lean: posets. Setting up is easy, functor work (monotone maps) adjunctions work (the Galois connection thing), limits and colimits work (<code>infi</code> and <code>supr</code>). And many many lemmas in <code>topology</code> are really proven in a categorical way using this trick. If you think complete lattices is computer science (as I also did before Johannes explained it) then category theory is computer science.</p>",
        "id": 168831876,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561365670
    },
    {
        "content": "<p><code>category theory is computer science.</code> I think that too, kind of.</p>",
        "id": 168831952,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561365729
    },
    {
        "content": "<p>So categories with general type-valued homs are hard to work with in dependent type theory, because the morphism isn't actually a function, so we lose some powerful flexibility. Types and morphisms between them (the category Type) are fine though because these are pi-type-valued homs. Patrick is saying that terms and Prop-valued homs are also a good fit for dependent type theory.</p>",
        "id": 168832144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561365960
    },
    {
        "content": "<p>It's all beginning to make some sense to me. But in some sense this should just be an interface issue, right?</p>",
        "id": 168832790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561366658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I'm sad to hear that story</p>",
        "id": 168833357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561367212
    },
    {
        "content": "<p>I don't know how much is interface and how much is \"Lean could do better\".</p>",
        "id": 168833383,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561367248
    },
    {
        "content": "<p>This is kind of why I was against moving Scott's category library into mathlib to start with. I think it's improved a lot since then, but it still is sorely lacking in applications</p>",
        "id": 168833468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367354
    },
    {
        "content": "<p>Every time we try something it's kind of \"oh well, probably it can be made to work, but let's just do it the easy way because that's all we need\".</p>",
        "id": 168833555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561367416
    },
    {
        "content": "<p>All the work thus far has been to write things as categories, but all the sharing goes one way only. We need to figure out how to prove something that does not directly use categories via category theory</p>",
        "id": 168833575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367457
    },
    {
        "content": "<p>For etale cohomology I am unclear about how much we can get away with.</p>",
        "id": 168833585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561367473
    },
    {
        "content": "<p>Notice that orders and lattices are at the <em>very bottom</em> of the mathlib dependency structure</p>",
        "id": 168833594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367486
    },
    {
        "content": "<p>I think there is a good argument that once you start dealing with 2-categorical notions you should probably use category theory to organize stuff</p>",
        "id": 168833692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367554
    },
    {
        "content": "<p>The moment homs are not Props, basically.</p>",
        "id": 168833713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561367582
    },
    {
        "content": "<p>right</p>",
        "id": 168833727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367588
    },
    {
        "content": "<p>Your <code>glue</code> and <code>universal_property</code> theorems look like that</p>",
        "id": 168833769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367629
    },
    {
        "content": "<p>so I'm hoping that we can maybe use this as a case study for practical use of category theory</p>",
        "id": 168833823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367659
    },
    {
        "content": "<p>Yes, we can do it without category theory, but the current solutions look pretty scary. Let's see what the alternative is</p>",
        "id": 168833850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367705
    },
    {
        "content": "<p>try it both ways and let the best infrastructure win</p>",
        "id": 168833894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561367749
    },
    {
        "content": "<blockquote>\n<p>I didn't read code in this thread, but I just want to tell Kevin: Johannes explained countless times why there are lattices all other mathlib. This is category theory that actually works and helps. Up to now nobody managed to make category theory usable in Lean. In Edinburgh I asked Scott and Reid to show me how to define the category of uniform spaces, the subcategory of complete separated uniform spaces, and the completion functor (all of this is already in mathlib, unbundled and without using category theory). They couldn't. Defining categories was ok, but then they hit the weirdest kinds of bugs, with Lean randomly unfolding things beyond recognition. </p>\n</blockquote>\n<p>I'm pretty surprised by this characterisation. My memory was rather than we stopped defining the adjunction <code>def adj : completion_functor ⊣ forget_to_UniformSpace</code> because we realised there was a lemma about completions that hadn't been proved yet. I haven't looked at this since that afternoon in Edinburgh, but the branch <code>category-of-uniform-spaces</code> seems to have what we did then, with a single sorry at that point.</p>",
        "id": 168838215,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561372530
    },
    {
        "content": "<p>I do remember some problem with Lean being over eager about unfolding. Unfortunately I can't see it still there.</p>",
        "id": 168838309,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561372621
    },
    {
        "content": "<p>The file we wrote that afternoon is <a href=\"https://github.com/leanprover-community/mathlib/blob/category-of-uniform-spaces/src/topology/uniform_space/UniformSpace.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/category-of-uniform-spaces/src/topology/uniform_space/UniformSpace.lean\">here</a>.</p>",
        "id": 168838505,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561372809
    },
    {
        "content": "<p>Patrick can be a bit cynical at times :-) But the point remains. The last time I talked to you about sheaves you said \"we've got presheaves, I just need to figure out a neat way of doing the sheaf condition which is not ugly\". But in this low-level approach here we just write stuff down and it works. There's a trick to finding out a good way to write it down, but once you have a good working basic set of definitions it's really good fun to build an API and then \"prove some lemmas\" (like the \"lemma\" that you can glue sheaves, which I would say to CS people was a definition, but I would call it a theorem to maths people) and watch the API become robust. I guess the theorem is that a universal object exists.</p>\n<p>I am still unclear about whether the problem is having Hom(X,Y) =  inductive type, or whether the problem is that Lean 3 is not very good at categories because of design decisions which we're having to fight against.</p>\n<p>I mentioned issues with categories to Tom Hales at AITP and he said \"well as far as I know Coq doesn't have any issues with them, I believe they have a nice category theory library\" (I'm paraphrasing but that's my memory of what he said). Is this true? Can they do things better than us here? Where is this library? There is all this talk of not knowing how best to implement diagrams -- how do they do it in Coq?</p>",
        "id": 168841185,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561375808
    },
    {
        "content": "<p>This deserves a new thread really.</p>",
        "id": 168841196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561375816
    },
    {
        "content": "<p>I don't think there are any fundamental issues with using categories any more than any other branch of maths</p>",
        "id": 168841542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561376177
    },
    {
        "content": "<p>I think people just aren't doing it, because you and I prefer to work without them and Scott and Reid prefer to work on categories as the endpoint</p>",
        "id": 168841584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561376240
    },
    {
        "content": "<p>stuff like proving that uniform spaces form a category is utterly uninteresting to me. Of course you can do it. It gets interesting when you prove something that's not a triviality in an area that's not category theory using this gigantic library that's being developed. If you can't do that then it just looks like a bridge to nowhere from my point of view</p>",
        "id": 168841709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561376352
    },
    {
        "content": "<p>Categories lead to questions about universes which are not there in other branches of maths (at least when maths is done by mathematicians), and one question is how well Lean solves those issues. </p>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> how would glueing <em>presheaves</em> on open subsets look in the category theory library? Already it was causing us problems down in the land where the objects were terms and the morphisms were in Prop, but we have this workaround now (analogous to what they did in the odd order repo when they worked with subgroups of a big ambient group because it was more convenient). I find this approach rather distasteful in some sense, but then again these CS people seem to prefer computational efficiency to the abstract approach.</p>",
        "id": 168841812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561376454
    },
    {
        "content": "<p>Kenny's code above</p>\n<p><a href=\"#narrow/stream/116395-maths/topic/breaking.20equality.20with.20sheaves/near/168794153\" title=\"#narrow/stream/116395-maths/topic/breaking.20equality.20with.20sheaves/near/168794153\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking.20equality.20with.20sheaves/near/168794153</a></p>\n<p>is the definition of a glued presheaf, but he has not proved the universal property. <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Can you formulate the universal property for a glued presheaf? That's what we have right now.</p>",
        "id": 168841932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561376569
    },
    {
        "content": "<p>oh -- it is probably exactly the same as the universal property for a glued sheaf isn't it.</p>",
        "id": 168841943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561376581
    },
    {
        "content": "<p>Then we will have proved a theorem about glued presheaves, namely that there exists an object having the universal property for glued presheaves. This has turned out to be a great test of various foundational set-ups.</p>",
        "id": 168842002,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561376636
    },
    {
        "content": "<p>People didn't see the nightmares I had because in the main I didn't post them. But I did hint about having to interpret U intersect V as an object of opens U, opens V, opens U intersect V and opens X. With the Kenny/Mario approach there is only one U intersect V. Can this trick be pulled off in the category theory set-up?</p>",
        "id": 168842096,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561376719
    },
    {
        "content": "<p>Just regarding the subject of using category theory. <a href=\"https://github.com/rwbarton/lean-homotopy-theory\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory\">https://github.com/rwbarton/lean-homotopy-theory</a> is over 8000 lines and almost all of it is built on top of category theory: either to do homotopy theory in a general category (with additional structure) or to prove things about Top which are hard to even state without category theory (for example, the pushout of a closed embedding is a closed embedding). For context, it is larger than the amount of category theory in mathlib.</p>",
        "id": 168842458,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561377038
    },
    {
        "content": "<p>Do you have any of presheaves, sheaves, glueing sheaves, sheafification? Or do you not need sheaves at all for this stuff?</p>",
        "id": 168842511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561377109
    },
    {
        "content": "<p>You know how Kevin says everything is CS? That still sounds like category theory to me</p>",
        "id": 168842513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561377110
    },
    {
        "content": "<blockquote>\n<p>Do you have any of presheaves, sheaves, glueing sheaves, sheafification? Or do you not need sheaves at all for this stuff?</p>\n</blockquote>\n<p>No, these didn't come up in what I was doing</p>",
        "id": 168842745,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561377356
    },
    {
        "content": "<blockquote>\n<p>You know how Kevin says everything is CS? That still sounds like category theory to me</p>\n</blockquote>\n<p>This is kind of like saying algebraic geometry is not math but rather French, because EGA is written in French</p>",
        "id": 168842972,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561377573
    },
    {
        "content": "<p>Using the language of category theory to study subject X doesn't make subject X into category theory</p>",
        "id": 168843166,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561377725
    },
    {
        "content": "<p>And maybe it's particularly convenient to apply category theory to algebraic topology (considering that category theory was invented for the purpose of algebraic topology in the first place) but in any case it can be done.</p>",
        "id": 168843268,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561377843
    },
    {
        "content": "<blockquote>\n<p>Scott and Reid prefer to work on categories as the endpoint</p>\n</blockquote>\n<p>I don't think this is true at all, and to tell the truth I'm a bit annoyed at this. I worked on an API for limits because it seemed essential for ever doing the basics of sheaf theory, or the basics of homological algebra, or the basics of algebraic topology, without endlessly repeating yourself in slight variations. None of these are subjects that I'm particularly interested in directly, but I was trying to be helpful, because it seemed there was interest in those directions.</p>\n<p>It's true that my \"day job\" research is about things like modular tensor categories. But it is a pretty bad error to think that these things are \"part of category theory\" in the sense of boring 20th category theory that exists in mathlib at the moment and that we are discussing here. Modular tensor categories are mathematical objects more like ... I don't know schemes or something. Everyone will use category theoretic language to describe the axioms, but at the end of the day they are actually pretty alien to \"category theory\". They are completely finitary objects (finitely much algebraic data, over a number field), and to study them you use combinatorics and topology and representation theory and little bits of number theory: far from the abstract nonsense!</p>",
        "id": 168891115,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561415873
    },
    {
        "content": "<p>Regarding the category of uniform spaces, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>, <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, I agree that's completely boring. We did it because Patrick asked to see how it was done. I agree it was annoying that afternoon that we ran into some still-mysterious Lean 'feature' involving unwanted unfolding. But besides that I thought that exercise was mostly a success. Reid and I got distracted at the end of the discussion trying to work out how to use reflective subcategories, but the file at the end was what Patrick had asked for, modulo one sorry (that was actually about uniform spaces).</p>",
        "id": 168891342,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561416108
    },
    {
        "content": "<p>Fair enough. I would hope that these applications are not some giant years-from-now endpoint though; you should be able to give some near term applications as well. Without applications it's far too easy to build things the wrong way and not realize it's useless until you actually get to that application at the end of the road</p>",
        "id": 168891541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561416295
    },
    {
        "content": "<p>But I think you won't be surprised that I can't tell the difference between \"modular tensor categories\" and \"category theory\" :P</p>",
        "id": 168891596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561416360
    },
    {
        "content": "<p>Regarding sheaf-y stuff. I think a great test case is whether the stuff you're building works for sheaves of topological rings. This is not some esoteric corner case: people have to think about these constantly. And they are a great example where you can't just spend all your time thinking about the underlying sheaf of types, because that's not enough! (There are presheaves of topological rings, whose underlying presheaf of types satisfies the sheaf condition, but does not itself.) I'm worried that if you don't attempt to do this at the correct level of generality, then there's going to be endless repetition (sheaves of types, sheaves of rings, sheaves of topological spaces, sheaves of topological rings), and you'll find yourself having to talk about gluing separately and with slight variations in all the cases, and it will turn into a nightmare. But this isn't my subject, so perhaps I'm mistaking the fact that every source for this stuff uses category theoretic language to describe the sheaf condition for necessity.... :-)</p>",
        "id": 168892082,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561416855
    },
    {
        "content": "<p>I still worry a bit that I don't know a math definition which encompasses both this example of sheaves of topological rings (on a topological space or whatever) and also sheaves on a general site.</p>",
        "id": 168892265,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561417025
    },
    {
        "content": "<blockquote>\n<p>But I think you won't be surprised that I can't tell the difference between \"modular tensor categories\" and \"category theory\" :P</p>\n</blockquote>\n<p>Next you'll be telling me you can't tell the difference between \"model categories\" and \"category theory\", sheesh!</p>",
        "id": 168892373,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561417151
    },
    {
        "content": "<p>Unfortunately I'm just as ignorant here. I've only ever had to use the most basic notions of category theory in my day job (representable functors). What's the problem with sheaves of topological rings on a site?</p>",
        "id": 168913759,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561445179
    },
    {
        "content": "<p>That a continuous bijection doesn't need to be a homeomorphism</p>",
        "id": 168917010,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561449388
    },
    {
        "content": "<p>So you can't ask for some equilizer to be an iso in <code>Type</code>. It really has to be an iso in <code>Top</code> or <code>TopRing</code>.</p>",
        "id": 168917035,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561449415
    },
    {
        "content": "<p>I understand that -- my question is what is the problem with sheaves of (insert category here) on a site?</p>",
        "id": 168917149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561449536
    },
    {
        "content": "<p>I guess there is not that much of a problem, but it means yet another variable in the API.</p>",
        "id": 168917314,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561449665
    },
    {
        "content": "<p>Another universe variable? Is that the issue? Why don't we just put everything in the same universe like in normal maths?</p>",
        "id": 168917773,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561450095
    },
    {
        "content": "<p>No, no universe variables. :-)</p>",
        "id": 168917803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450146
    },
    {
        "content": "<p>Johan just meant that it's literally an extra variable to the definition of a sheaf: you have to specify the category the sections live in.</p>",
        "id": 168917822,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450177
    },
    {
        "content": "<p>and you need to ask that the sheaf condition diagram is an equalizer in that category, rather than doing something elementwise.</p>",
        "id": 168917887,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450226
    },
    {
        "content": "<p>I feel like I am always specifying this variable in practice. It was like when the CS people were going \"oh noes, you're going to have to say which ring this is a module over\" and I was just thinking \"that's OK, I know which ring it's a module over\"</p>",
        "id": 168917889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561450236
    },
    {
        "content": "<p>or, alternatively, for every different target category you need to write a different version of the sheaf condition, which includes an extra field effectively spelling out: this bijection of the underlying types is actually an isomorphism.</p>",
        "id": 168917918,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450285
    },
    {
        "content": "<p>I'd assumed way back that everyone would be unhappy with writing out different versions of the sheaf condition for different target categories. (Because then you have to repeat and reprove theorems about sheaves in different target categories.)</p>",
        "id": 168917972,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450334
    },
    {
        "content": "<p>I defined a scheme, and that part was pretty easy. But proving that anything at all was a scheme involved some serious messing around with sheaves (and in particular proving that some explicit presheaf satisfied the sheaf axiom). We now have perfectoid spaces, but proving that anything at all is a perfectoid space will be just the same, except that we will have to prove that something is a sheaf of topological rings. So it's on the horizon.</p>",
        "id": 168917981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561450357
    },
    {
        "content": "<blockquote>\n<p>this bijection of the underlying types is actually an isomorphism.</p>\n</blockquote>\n<p>Yes, I remember you pointing this out when I was moaning about 10 different notations for \"I am an equiv of this kind of structure\"</p>",
        "id": 168918060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561450443
    },
    {
        "content": "<p>That one is easy to fix. :-)</p>",
        "id": 168918246,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450638
    },
    {
        "content": "<p>(As long as you're willing to work in a fixed universe, but I don't think that will be a problem for you. :-)</p>",
        "id": 168918255,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561450657
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">sheaf_glue</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">compat</span> <span class=\"o\">(</span><span class=\"n\">W</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"bp\">//</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n    <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"k\">calc</span>  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n        <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n              <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n              <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n              <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n        <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n          <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n          <span class=\"n\">inf_le_left</span>\n          <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n                <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n          <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n          <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">HVU</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">commutes</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">locality</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OC</span> <span class=\"o\">:</span> <span class=\"n\">covering</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">s</span> <span class=\"bp\">=</span>\n    <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">locality</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">H</span> <span class=\"n\">j</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">this</span> <span class=\"n\">i</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OC</span> <span class=\"o\">:</span> <span class=\"n\">covering</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_right</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"kn\">eval</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">glue</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">),</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"n\">inf_left_comm</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"err\">←</span> <span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"n\">inf_idem</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n<span class=\"k\">from</span> <span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"k\">from</span> <span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">h2</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">h3</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n<span class=\"k\">from</span> <span class=\"n\">congr_fun</span> <span class=\"o\">(</span><span class=\"n\">congr_arg</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n<span class=\"k\">calc</span>  <span class=\"bp\">_</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"n\">h1</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">h2</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">res_res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_right</span> <span class=\"o\">((</span><span class=\"n\">s</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux2</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OC</span> <span class=\"o\">:</span> <span class=\"n\">covering</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_right</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n      <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">inf_assoc</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">locality</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">OC</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n<span class=\"k\">calc</span>  <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n        <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n        <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n          <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span>\n            <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n            <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n    <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n          <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n            <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n            <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">commutes</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span>\n        <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">inf_assoc</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span>\n          <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">res_glue</span><span class=\"o\">,</span> <span class=\"n\">res_glue</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">i</span> <span class=\"n\">j</span>\n<span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux3</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OC</span> <span class=\"o\">:</span> <span class=\"n\">covering</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_right</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux2</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">covering_inf_left</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"n\">OC</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_;</span>\n<span class=\"n\">erw</span> <span class=\"n\">res_glue</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">gluing</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">OC</span> <span class=\"o\">:</span> <span class=\"n\">covering</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">inf_le_right</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">OC</span><span class=\"bp\">.</span><span class=\"n\">Uis</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subset_covering</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨⟨λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux1</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux2</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">gluing</span><span class=\"bp\">.</span><span class=\"n\">aux3</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"n\">U</span> <span class=\"n\">OC</span> <span class=\"n\">s</span> <span class=\"n\">H</span> <span class=\"n\">i</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">sheaf_glue</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sheaf_glue</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span>\n    <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">Union</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">compat</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span><span class=\"o\">,</span>\n    <span class=\"n\">res</span> <span class=\"o\">:=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span><span class=\"o\">,</span>\n    <span class=\"n\">Hid</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">res_self</span><span class=\"o\">,</span>\n    <span class=\"n\">Hcomp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">symmetry</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">res_res</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">},</span>\n  <span class=\"n\">locality</span> <span class=\"o\">:=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">locality</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span><span class=\"o\">,</span>\n  <span class=\"n\">gluing</span> <span class=\"o\">:=</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">gluing</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 168919055,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561451513
    },
    {
        "content": "<p>and I never used the cocycle conditions</p>",
        "id": 168919130,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561451565
    },
    {
        "content": "<p>Maybe you need them to prove the universal property?</p>",
        "id": 168919399,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561451828
    },
    {
        "content": "<p>This is not proved even for presheaves.</p>",
        "id": 168919407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561451838
    },
    {
        "content": "<p>As far as I know, the universal property is simply the data of an isomorphism from the glued sheaf, restricted to an open subset <code>S i</code>, with the sheaf  <code>F i</code>.</p>",
        "id": 168919513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561451967
    },
    {
        "content": "<p>that is indeed what you gave me</p>",
        "id": 168919651,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561452119
    },
    {
        "content": "<p>I guess an isomorphism of sheaves is an isomorphism of presheaves. Maybe you need it for one of the maps. To write down from <code>F i (S i)</code> to the product over j of <code>F j (S i \\cap S j)</code> you can use <code>phi i j</code>, but to prove that these sections are compatible will involve <code>phi j k</code> so that's where it will be.</p>",
        "id": 168919712,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561452150
    },
    {
        "content": "<p>To write down the map the other way I don't see how to do it without using the sheaf axiom.</p>",
        "id": 168919737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561452190
    },
    {
        "content": "<p>So maybe the universal property isn't even true if you glue presheaves naively.</p>",
        "id": 168919753,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561452211
    },
    {
        "content": "<blockquote>\n<p>Regarding the category of uniform spaces, I agree that's completely boring. We did it because Patrick asked to see how it was done. I agree it was annoying that afternoon that we ran into some still-mysterious Lean 'feature' involving unwanted unfolding. But besides that I thought that exercise was mostly a success. Reid and I got distracted at the end of the discussion trying to work out how to use reflective subcategories, but the file at the end was what Patrick had asked for, modulo one sorry (that was actually about uniform spaces).</p>\n</blockquote>\n<p>Scott, I'm sorry my message sounded more aggressive than I intended. But I still claim it doesn't work. I tried to include that file in current mathlib (latest nightly) and the definition of <code>completion_functor</code> doesn't work anymore. It seems that condition <code>map_id'</code> was filled in automatically in Edinburgh but isn't today. And I have no clue how I could try to prove it (although I'm sure it has no mathematical content).   Same applies to one item of the <code>adj</code> definition. I guess a bit part of the issue is documentation of the API</p>",
        "id": 168922749,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561455290
    },
    {
        "content": "<p>And if you want to get back part of the unfolding craziness you can replace the last tactic block by an invocation of the structure skeketon hole command.</p>",
        "id": 168923186,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561455678
    },
    {
        "content": "<p>You'll see <code>subtype uniform_continuous</code> appearing everywhere</p>",
        "id": 168923277,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561455762
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">sheaf_glue_res_val</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">HU</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">HVU</span> <span class=\"n\">s</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">sheaf_glue</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">HU</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">HVU</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">inf_le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">def</span> <span class=\"n\">universal_property</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">→</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"n\">sheaf_on_opens</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">equiv</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">))</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">Hφ2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n      <span class=\"o\">((</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">sheaf_glue</span> <span class=\"n\">S</span> <span class=\"n\">F</span> <span class=\"n\">φ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"n\">opens</span><span class=\"bp\">.</span><span class=\"n\">subset_Union</span> <span class=\"n\">S</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">H</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n    <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">HU</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">HVU</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">res</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue</span><span class=\"bp\">.</span><span class=\"n\">res</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">presheaf</span><span class=\"bp\">.</span><span class=\"n\">Hcomp&#39;</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">},</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">H</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n        <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">s</span><span class=\"o\">),</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n        <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"o\">:=</span> <span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">inf_assoc</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inf_le_right</span><span class=\"o\">,</span>\n        <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span>  <span class=\"o\">[</span><span class=\"n\">inf_comm</span><span class=\"o\">,</span> <span class=\"n\">inf_assoc</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">inf_le_inf</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n        <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_right</span><span class=\"o\">),</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">res_res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">res_subset_apply</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">res_subset_apply</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">k</span> <span class=\"err\">⊓</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">trans_apply</span><span class=\"o\">,</span> <span class=\"n\">Hφ2</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">res_subset_apply</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">],</span>\n        <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">res_res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h4</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">k</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">],</span>\n      <span class=\"kn\">end</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">commutes</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">HU</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">HVU</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">sheaf_glue_res_val</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">res_res_subset</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"err\">←</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span> <span class=\"err\">$</span> <span class=\"n\">funext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">have</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">calc</span>\n      <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">HV</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n            <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_right</span> <span class=\"n\">HV</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span>\n              <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"n\">HV</span> <span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span>\n            <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">res_res</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">j</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span>\n            <span class=\"o\">(((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res_subset</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"bp\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">inf_le_left</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n              <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">inf_assoc</span><span class=\"o\">,</span> <span class=\"n\">inf_left_comm</span><span class=\"o\">,</span> <span class=\"n\">inf_of_le_right</span> <span class=\"n\">HV</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">)</span>\n              <span class=\"o\">((</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">res</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"o\">((</span><span class=\"n\">S</span> <span class=\"n\">i</span> <span class=\"err\">⊓</span> <span class=\"n\">S</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"err\">⊓</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">le_inf</span> <span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"n\">inf_le_left</span> <span class=\"n\">inf_le_left</span><span class=\"o\">)</span> <span class=\"n\">inf_le_right</span><span class=\"o\">)</span>\n                <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">i</span><span class=\"o\">)))</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">]</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[(</span><span class=\"n\">φ</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">res_res_subset</span><span class=\"o\">,</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_self</span><span class=\"o\">],</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span> <span class=\"n\">HV</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">dsimp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">comp</span><span class=\"o\">,</span> <span class=\"n\">morphism</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n    <span class=\"n\">erw</span> <span class=\"o\">[</span><span class=\"n\">Hφ1</span><span class=\"o\">,</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl_apply</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">res_res</span><span class=\"o\">,</span> <span class=\"n\">res_self</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 168924336,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561456890
    },
    {
        "content": "<p>it's computable!</p>",
        "id": 168924338,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561456897
    },
    {
        "content": "<p>I claim that the following would not be computable: if instead of <code>S : I -&gt; opens X</code> we had done everything for <code>s : set (opens X)</code>, and then we wanted to move back to <code>S : I -&gt; opens X</code>, then <code>s</code> would be <code>range S</code> and we would start to have to make choices of a \"canonical\" element of I for every element of s.</p>",
        "id": 168926394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459264
    },
    {
        "content": "<p>This is true. This passing back and forth is necessary if you want to support <code>I</code> in another universe</p>",
        "id": 168926501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561459421
    },
    {
        "content": "<p>You can support <code>I</code> in a lower universe if you use <code>ulift</code>, and maybe that's enough for one-universe man, but for higher universes I don't think it's possible without having some kind of super sheaf property</p>",
        "id": 168926563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561459497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, there were some other files changed in that branch, so just bringing forward the one file wasn't going to work. I've merged master back into that branch, and it works again.</p>",
        "id": 168926586,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561459538
    },
    {
        "content": "<blockquote>\n<p>You can support <code>I</code> in a lower universe if you use <code>ulift</code>, and maybe that's enough for one-universe man, but for higher universes I don't think it's possible without having some kind of super sheaf property</p>\n</blockquote>\n<p>Is there a way of formalising <code>I : Type v &lt;= u</code> in Lean?</p>",
        "id": 168926849,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459840
    },
    {
        "content": "<p>I am definitely one-universe man; I don't want to be ostracised by my ZFC chums.</p>",
        "id": 168926856,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459861
    },
    {
        "content": "<p>use <code>max u v</code> in place of <code>u</code></p>",
        "id": 168926863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561459866
    },
    {
        "content": "<p>You realize that sheafs don't fit in one universe?</p>",
        "id": 168926883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561459901
    },
    {
        "content": "<p>Of course they don't.</p>",
        "id": 168926932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459939
    },
    {
        "content": "<p>We never consider \"the set of sheaves on X\". We know how to treat sheaves.</p>",
        "id": 168926942,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459955
    },
    {
        "content": "<p>so... not really one universe then</p>",
        "id": 168926943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561459956
    },
    {
        "content": "<p>We have sets and classes. Sheaves are a class.</p>",
        "id": 168926948,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459969
    },
    {
        "content": "<p>It just means that you can't do certain things with them. Sets are a class. Groups are a class. This is fine.</p>",
        "id": 168926960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561459985
    },
    {
        "content": "<p>I'm quite familiar with \"large category theory\". It's not fun to do in strict ZFC</p>",
        "id": 168926986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460030
    },
    {
        "content": "<p>I'm not necessarily saying I believe this, but I know lots of people who do, and some of them get upset when people start going on about universes. I just want to make sure that these ZFC people have a voice.</p>",
        "id": 168927034,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561460051
    },
    {
        "content": "<p>In fact, you have to get even more into universes if you are in strict ZFC mode - you just have more notions of universe and almost-universe</p>",
        "id": 168927065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460092
    },
    {
        "content": "<p>To be honest I can quite believe you. I've never had to worry about this though. People in other disciplines might.</p>",
        "id": 168927094,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561460121
    },
    {
        "content": "<p>At the very least, it's hard to do category theory on small and large categories in lean without at least one universe variable and probably two</p>",
        "id": 168927180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460190
    },
    {
        "content": "<p>unless you want two completely separate but parallel theories</p>",
        "id": 168927225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460241
    },
    {
        "content": "<p>Well we're making two completely separate but parallel theories of presheaves.</p>",
        "id": 168927247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561460265
    },
    {
        "content": "<p>I think that's more of a test - I don't see a good reason for both to exist in perpetuity</p>",
        "id": 168927320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460328
    },
    {
        "content": "<p>Unless of course we decide they aren't really the same thing but they are just \"spelled the same in maths\"</p>",
        "id": 168927345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460386
    },
    {
        "content": "<p>Which TBH may very well be the conclusion, especially for the really abstract sheaves on sites</p>",
        "id": 168927410,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561460430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Kenny has shown that it's possible to glue sheaves of types using a wicked trick which started this thread off. Before he did this, I had an absolutely miserable time trying to glue sheaves of types, because porting open sets from one subset to another was painful. Kenny has introduced the idea of defining a sheaf on a subset to be a sheaf on the whole space. Mario has introduced this total space idea which also made stuff easier. In my mind these two shortcuts are decisive; I had a nightmare working with this stuff before these two ideas, and it was much much easier working with them afterwards. They are distinct techniques -- Kenny's stops you from having to move from open set to open set, and Mario's fixes some possible type issues with U intersect V not being defeq to V intersect U.</p>\n<p>What I fear about the \"full category theory approach\" (a presheaf is a functor) is that there will not be an analogue of these tricks, and there will be inevitable pain in making and using the API.</p>\n<p>What I fear about the low-level approach is that we are now going to have to have glueing sheaves of groups extending glueing sheaves of types, then glueing sheaves of topological rings extending 5 other things, and so on. </p>\n<p>There might be a middle approach, where one defines a sheaf to be a map from a complete lattice (or whatever) to the objects of a category, plus some extra data, rather than a functor. If one wants to use functors the question is whether glueing is still viable. Maybe there's just a straightforward analogue of Kenny's trick? Mario's trick would I think involve being able to identify the <em>isomorphic</em> full subcategories <code>opens U \\cap V</code> of <code>opens U</code> and <code>opens U \\cap V</code> of <code>opens X</code>. I don't think an equivalence is enough. Do you believe me or have I made a slip? Maybe you shouldn't take some of these things too seriously. Someone is going to have to sit down and work this stuff out and see if it actually works, or whether Lean 3 is not actually up to the task.</p>\n<p>Given that I want sheaves of topological rings, this for me is an important issue.</p>",
        "id": 168928080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561461142
    },
    {
        "content": "<p>My trick doesn't work if the homs aren't Props</p>",
        "id": 168928216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461274
    },
    {
        "content": "<p>and it's also a bit shaky on general target categories</p>",
        "id": 168928266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461362
    },
    {
        "content": "<p>If you have categories on the domain and codomain, I don't think there is a viable alternative to the category theory approach</p>",
        "id": 168928327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461418
    },
    {
        "content": "<p>So glueing etale sheaves, which is super-important, will be interesting to do in Lean.</p>",
        "id": 168928358,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561461480
    },
    {
        "content": "<p>There's an explicit section about this in Milne when he's dealing with DVRs. I'll dig it up later today.</p>",
        "id": 168928412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561461511
    },
    {
        "content": "<p>Although maybe there's a way to make the etale site work with Props? <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> what do you think?</p>",
        "id": 168928447,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561461569
    },
    {
        "content": "<p>The basic trick is, if there is only one hom between objects, you can typically avoid mentioning it at all (not even enforcing its existence) with the right choice of types</p>",
        "id": 168928533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461656
    },
    {
        "content": "<p>by comparison the category approach has you not mentioning anything except the homs, and leave the objects implicit</p>",
        "id": 168928605,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461724
    },
    {
        "content": "<p>generally this tends to be shorter because the names are shorter (proof names are relatively longer than hom names)</p>",
        "id": 168928627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461766
    },
    {
        "content": "<p>and there are more operations with notation</p>",
        "id": 168928640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561461785
    },
    {
        "content": "<p>It will be much easier for me to understand if I work on examples. This is why I tried Reid's CDGA exercise and this is why I got a student to do group cohomology (she finished last night by the way, we have group cohomology done in the traditional \"hands-on\" way with cocycles and coboundaries plus the proof of the long exact sequence of terms of low degree in the Hochschild-Serre spectral sequence). I'm working up to homological algebra by taking baby steps. I think defining etale cohomology of schemes will be a stress-test for the system. There will be universe issues, there will be this perennial debate about how to do sheaves, there will be CDGA-like issues when doing cohomology, all this stuff that we half-understand and where the community sometimes has more than one opinion on the best way to proceed. This could very naturally turn into a multi-person project which might teach us quite interesting things about how easy it is to do stuff which is crucial to e.g. Deligne's proof of the Weil conjectures, in Lean.</p>",
        "id": 168928970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462160
    },
    {
        "content": "<blockquote>\n<p>Although maybe there's a way to make the etale site work with Props? <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> what do you think?</p>\n</blockquote>\n<p>My intuition says that it doesn't work. If <code>L/K</code> is a separable field extension, then you really don't want the hom-set <code>L → L</code> over <code>K</code> to be a <code>Prop</code>.</p>",
        "id": 168928993,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561462189
    },
    {
        "content": "<p>Aah yes, I was wondering if there was some way to cheat and fix things, but this is a pretty convincing example.</p>",
        "id": 168929384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462543
    },
    {
        "content": "<p>Does anyone here understand the pro-etale site?</p>",
        "id": 168929522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462635
    },
    {
        "content": "<p>[this a new Scholze thing]</p>",
        "id": 168929544,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462650
    },
    {
        "content": "<p>So if I understand it correctly you are talking about a \"restriction map\" that applies a field automorphism without changing the object?</p>",
        "id": 168929549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561462660
    },
    {
        "content": "<p>Yes I guess so.</p>",
        "id": 168929618,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462694
    },
    {
        "content": "<p>Spec(complexes) is a cover of Spec(reals); a cover of one object by one bigger object</p>",
        "id": 168929653,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462738
    },
    {
        "content": "<p>Aah that's not the point.</p>",
        "id": 168929689,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462780
    },
    {
        "content": "<p>The map Spec(complexes) -&gt; Spec(reals) is an etale map, so the analogue of an \"open subset\" in the etale site. And complex conjugation is a perfectly good map which one can restrict along. An example of an etale sheaf on Spec(reals) would be an abelian group A plus an action of Gal(complexes/reals). Its global sections would be the fixed points for the action, the sections on the \"open set\" Spec(complexes) would be A, and the restriction map corresponding to complex conjugation would be the map coming from the non-trivial element of the Galois group.</p>",
        "id": 168929869,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561462951
    },
    {
        "content": "<p>The sheaf axiom says that if I have an element of A which is fixed under complex conjugation then it's a global section, that's why the global sections are the invariants for the action.</p>",
        "id": 168929968,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561463051
    },
    {
        "content": "<p>Open sets having automorphism groups gives rise to their sections having automorphism groups acting on them.</p>",
        "id": 168930016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561463106
    },
    {
        "content": "<p>An etale sheaf of abelian groups on Spec(Q) is the same as an abelian group with an action of Gal(Q-bar/Q).</p>",
        "id": 168930036,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561463140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> For the purpose of clarifying this discussion, I just pushed <a href=\"https://github.com/leanprover-community/mathlib/commit/e4308313b2b992d159d177771bc5ac581a20d331\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/commit/e4308313b2b992d159d177771bc5ac581a20d331\">https://github.com/leanprover-community/mathlib/commit/e4308313b2b992d159d177771bc5ac581a20d331</a> which removes the sorry in the completion adjunction. Is this what I was meant to do? Or should I skip the intermediate lemma I created in the category language?</p>",
        "id": 168930278,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561463368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> should the stalk be def-eq to the stalk or another quotient?</p>",
        "id": 168966622,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561489162
    },
    {
        "content": "<p>We already have stalks in mathlib.</p>",
        "id": 168966892,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561489341
    },
    {
        "content": "<p>where?</p>",
        "id": 168966962,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561489401
    },
    {
        "content": "<p>also what I was asking is: should the stalk [of a \"sheaf on opens\" as I have defined it] be definitionally equal to the stalk of the underlying sheaf, or should I make it another type consisting of a quotient?</p>",
        "id": 168967052,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561489451
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/search?q=stalk&amp;unscoped_q=stalk\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/search?q=stalk&amp;unscoped_q=stalk\">https://github.com/leanprover-community/mathlib/search?q=stalk&amp;unscoped_q=stalk</a></p>",
        "id": 168967177,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561489546
    },
    {
        "content": "<p>How do I access that page from, say, the repo?</p>",
        "id": 168967268,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561489591
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 168967427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561489697
    },
    {
        "content": "<p>never mind, I figured it out</p>",
        "id": 168967492,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1561489747
    },
    {
        "content": "<p>A stalk is only defined up to canonical isomorphism so in some sense it's hard to answer the question. But defeq is good, right?</p>",
        "id": 168978433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561497485
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> </p>\n<blockquote>\n<p>I still worry a bit that I don't know a math definition which encompasses both this example of sheaves of topological rings (on a topological space or whatever) and also sheaves on a general site.</p>\n</blockquote>\n<p>I think <a href=\"https://stacks.math.columbia.edu/tag/00VL\" target=\"_blank\" title=\"https://stacks.math.columbia.edu/tag/00VL\">https://stacks.math.columbia.edu/tag/00VL</a> does it (right at the bottom) --- he uses Yoneda to say a presheaf F of Xs is a sheaf if all the Hom(X, F(-)) presheafs of sets are sheaves.</p>",
        "id": 168984815,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1561503154
    },
    {
        "content": "<p>Hmm, that does sound plausible</p>",
        "id": 168995007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561516870
    },
    {
        "content": "<blockquote>\n<p>Does anyone here understand the pro-etale site?</p>\n</blockquote>\n<p>Mike Shulman and I are having a good discussion about pro-ét(*) by email. We have some ideas, but not clear how helpful they will be in this context. What did you want to know?</p>",
        "id": 169452025,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1562041280
    },
    {
        "content": "<p>How to formalise it</p>",
        "id": 169456761,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562049144
    },
    {
        "content": "<p>0. Formalise the definition of the category of schemes.<br>\n1. Formalise the definition of a site.<br>\n2. Formalise the definition of a pro-étale morphism.<br>\n3. Show that pro-étale morphisms with suitable covers form a site.<br>\nBut certainly you had something more in mind...</p>",
        "id": 169458692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562051800
    },
    {
        "content": "<p>It's all the stuff about Postnikov towers converging in the hypercomplete infinity-topos in Bhatt-Scholze. There are some set-theoretic issues which I've never got my head around.</p>",
        "id": 169462110,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562055746
    },
    {
        "content": "<p>i thought pro-et(*) site was profinite sets with the coherent coverage, which would be easier to do</p>",
        "id": 169468312,
        "sender_full_name": "Jesse Michael Han",
        "timestamp": 1562061980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> I guess that <code>pro-et(k)</code> is <code>G</code>-sets, where <code>G</code> is the profinite absolute Galois group of <code>k</code>. So <code>pro-et(*)</code> depends a bit on what you mean with <code>*</code>. I guess Kevin is interested in <code>pro-et(S)</code> for more general schemes <code>S</code>, and then the connection with profinite sets becomes even less clear. But profinite sets are certainly a good intuition.</p>",
        "id": 169479107,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1562073151
    },
    {
        "content": "<p>It's the fpqc coverings that scare me.</p>",
        "id": 169497537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562086357
    },
    {
        "content": "<p>What on earth is the right way to glue schemes / sheaves?</p>",
        "id": 169656825,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1562254771
    },
    {
        "content": "<p>I've been distracted by writing a proof from first principles that every positive integer is uniquely the product of primes as part of an educational project, but my instinct is that your way is the easiest way to put into Lean but Scott's way via categories is \"the way that mathematicians think it should be done\" because mathematicians prefer the fancy structure. You were lucky here though -- <code>opens X</code> is a set. The class of etale morphisms Y -&gt; X is not a set. The traditional fix is to only use the set of etale morphisms Y -&gt; X where Y has some sort of cardinality constraints on it. I am still not really clear how to do this in Lean.</p>",
        "id": 169658634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562256817
    }
]
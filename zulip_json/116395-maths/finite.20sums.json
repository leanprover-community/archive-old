[
    {
        "content": "<p>The 1st years at Imperial are doing infinite sums in their analysis class. To do infinite sums, one has to be able to have a robust API for finite sums. Here are three possibilities:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">my_sum_to_n</span> <span class=\"o\">(</span><span class=\"n\">summand</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">my_sum_to_n</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">summand</span> <span class=\"n\">n</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">my_sum_to_n&#39;</span> <span class=\"o\">(</span><span class=\"n\">summand</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">((</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">summand</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">my_sum_to_n&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">summand</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">summand</span>\n</pre></div>\n\n\n<p>You can see them in action here:</p>\n<p><a href=\"https://github.com/kckennylau/Lean/blob/master/proofs_by_induction.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/proofs_by_induction.lean\">https://github.com/kckennylau/Lean/blob/master/proofs_by_induction.lean</a></p>\n<p>What is the \"idiomatic\" way to do this? <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> have you worked with this stuff a lot? Note that first two (but not the third) work with <code>add_monoid</code> but I am only interested in <code>R</code> being the real or complex numbers right now.</p>",
        "id": 158874324,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576148
    },
    {
        "content": "<p>I use <code>(range n).sum</code> but I don't like it. I think a better interface needs to be made. <code>(range n).sum</code> definitely gives you the best range of lemmas though.</p>",
        "id": 158874726,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550576614
    },
    {
        "content": "<p>Ooh, I also want to sum from a to b, not just from 0 to n-1. Did we have all this conversation once before, ages ago?</p>",
        "id": 158874730,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576623
    },
    {
        "content": "<p>finset or list?</p>",
        "id": 158874746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576642
    },
    {
        "content": "<p>Are statements such as <code>sum_to_n f N = sum_to_n (\\lam x, f(N-1-x)) N</code> in the library?</p>",
        "id": 158874812,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576721
    },
    {
        "content": "<p>I don't think so. Scott's made a start on this though</p>",
        "id": 158874903,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550576836
    },
    {
        "content": "<p>Does \"a better interface\" mean \"make a completely new file somewhere in mathlib called something like <code>finite_sum.lean</code> and define a new function <code>sum_range f a b</code> or something, and prove basic things about it?</p>",
        "id": 158874919,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576866
    },
    {
        "content": "<p>Oh I remember Mario's suggestion that <code>sum_range f a b</code> should sum f(x) from x=a to x=a+b-1</p>",
        "id": 158874981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576910
    },
    {
        "content": "<p>But is this not yet implemented?</p>",
        "id": 158875001,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550576933
    },
    {
        "content": "<p>No. It means use finset.sum, but have a bunch of lemmas specific to sums over intervals as well, and maybe some nice notation.</p>",
        "id": 158875098,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550577017
    },
    {
        "content": "<p>Do we have the function sending a,b to the finset {a,a+1,...,a+b-1}?</p>",
        "id": 158875130,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577085
    },
    {
        "content": "<p>I think so, it's got Ico in its name I think.</p>",
        "id": 158875177,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550577129
    },
    {
        "content": "<p>Many thanks. It's got nothing but Ico in its name, apparently.</p>",
        "id": 158875191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577181
    },
    {
        "content": "<p>Interval-closed-open</p>",
        "id": 158875266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577256
    },
    {
        "content": "<p>and there's <code>list.Ico</code>, <code>multiset.Ico</code> and <code>finset.Ico</code></p>",
        "id": 158875276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577280
    },
    {
        "content": "<p>Apparently we opted for <code>Ico n m = {n, n+1, ... , m-1}</code></p>",
        "id": 158875378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577370
    },
    {
        "content": "<p>Lines 1654 onwards in finset.lean contain a bunch of stuff. But where are the recursors?</p>",
        "id": 158875605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577617
    },
    {
        "content": "<p>How do I prove that | sum_{i=a}^b f(i) | &lt;= sum_{i=a}^b |f(i)| ??</p>",
        "id": 158875630,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577651
    },
    {
        "content": "<p>(triangle inequality for finite sums)</p>",
        "id": 158875660,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577668
    },
    {
        "content": "<p>Oh -- this is a general finset thing, not a sum from a to b thing.</p>",
        "id": 158875666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577683
    },
    {
        "content": "<p>So I need to find the right recursor for finsets...</p>",
        "id": 158875673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550577698
    },
    {
        "content": "<p>Why is <code>finset.induction</code> tagged <code>@[recursor 6]</code>?</p>",
        "id": 158876206,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550578265
    },
    {
        "content": "<p>I think it must already be there</p>",
        "id": 158876938,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550578982
    },
    {
        "content": "<p>I think all of M1P1 must already be there :-)</p>",
        "id": 158877052,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550579066
    },
    {
        "content": "<p>If I was summing from 0 to n-1 I could do induction on n and use the fact that finset (n +1) = finset n union {n}. But for a general finset I'm going to have to choose a random element. Maybe that's just life.</p>",
        "id": 158877413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550579440
    },
    {
        "content": "<p>Oh I see, I just use <code>finset.induction</code> I think.</p>",
        "id": 158877901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550579929
    },
    {
        "content": "<p>is finset a traversable monad?</p>",
        "id": 158877927,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550579975
    },
    {
        "content": "<p>I don't know what any of that means, but can you explain to me why I might care?</p>",
        "id": 158877983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550580003
    },
    {
        "content": "<p>[I'm open to the idea that I might care]</p>",
        "id": 158877994,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550580013
    },
    {
        "content": "<p>We already had this discussion many times. All those problems have been solved in Coq, and I made a tiny start at porting the solution at <a href=\"https://github.com/PatrickMassot/bigop\" target=\"_blank\" title=\"https://github.com/PatrickMassot/bigop\">https://github.com/PatrickMassot/bigop</a>. But nobody is willing to help because people on this chat think they know better than people who have thought about this for 30 years and formalized the 4 color theorem and Feit-Thompson.</p>",
        "id": 158879273,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550581386
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">field</span> <span class=\"err\">&#39;</span><span class=\"n\">bind&#39;</span>\n  <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">bind</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">decidable_eq</span> <span class=\"n\">β</span><span class=\"o\">],</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">},</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span>\n</pre></div>",
        "id": 158879585,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550581660
    },
    {
        "content": "<p>that's the answer to my question</p>",
        "id": 158879592,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550581665
    },
    {
        "content": "<p>I should build a \"real\" finset</p>",
        "id": 158879653,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550581690
    },
    {
        "content": "<blockquote>\n<p>We already had this discussion many times. </p>\n</blockquote>\n<p>Aah yes that's right -- I somehow fail to unify these finite set questions with the big operators work, and I even have a copy the Coq paper lying around on my desk somewhere.</p>",
        "id": 158887022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550587715
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">def</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L₁</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L₂</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">L</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">H12</span> <span class=\"n\">H23</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">H23</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span>\n\n<span class=\"n\">def</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">L</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_mk</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">has_mem</span><span class=\"bp\">.</span><span class=\"n\">mem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">x</span> <span class=\"err\">⟦</span><span class=\"n\">L</span><span class=\"err\">⟧</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">L</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">L₂</span> <span class=\"n\">H2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">H2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"kn\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mem_mk</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_mk</span><span class=\"o\">])</span> <span class=\"n\">H</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">ext_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"bp\">▸</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">[]</span><span class=\"err\">⟧</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">not_mem_empty</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∉</span> <span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_mk</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span>\n\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"err\">⟧</span>\n\n<span class=\"n\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">L₁</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">L₄</span> <span class=\"n\">H13</span> <span class=\"n\">H24</span><span class=\"o\">,</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">,</span> <span class=\"n\">H13</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H24</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">union</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"err\">⟦</span><span class=\"bp\">_</span><span class=\"err\">⟧</span> <span class=\"bp\">↔</span> <span class=\"bp\">_;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_mk</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">prebind</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">empty</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">prebind_cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"bp\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_prebind</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"n\">L</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">iff_of_false</span> <span class=\"o\">(</span><span class=\"n\">not_mem_empty</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prebind_cons</span><span class=\"o\">,</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">or_and_distrib_right</span><span class=\"o\">,</span> <span class=\"n\">exists_or_distrib</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_left</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monad</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">prebind</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">by</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_prebind</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">finset</span>\n</pre></div>",
        "id": 158888660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550588854
    },
    {
        "content": "<p>done, the real finset is a monad</p>",
        "id": 158888667,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550588861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I agree that it is frustrating that we are having this discussion multiple times, and that we are reinventing the wheel. I haven't thought about this problem (finite sums) myself. I wouldn't mind if this could be turned into a student project; but I fear that there is not enough mathematical meat in it. At the moment I don't have much contact with the CS department here in Freiburg. It's something on my todo list. Maybe they would think that an bachelor thesis titled \"Algorithms and data types for manipulating finite sums and proving identities between them\" is interesting...</p>",
        "id": 158890056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550589931
    },
    {
        "content": "<p>I would like to get better at recruiting people for library development.</p>",
        "id": 158890080,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550589957
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"n\">def</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L₁</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L₂</span><span class=\"o\">,</span>\n  <span class=\"n\">iseqv</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">L</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">H12</span> <span class=\"n\">H23</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">H12</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">H23</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span>\n\n<span class=\"n\">def</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">setoid</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">run_cmd</span> <span class=\"n\">mk_simp_attr</span> <span class=\"s2\">&quot;finset&quot;</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">L</span><span class=\"err\">⟧</span> <span class=\"bp\">=</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_mk</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">has_mem</span><span class=\"bp\">.</span><span class=\"n\">mem</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"n\">x</span> <span class=\"err\">⟦</span><span class=\"n\">L</span><span class=\"err\">⟧</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">L</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">H</span> <span class=\"n\">L₂</span> <span class=\"n\">H2</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">H2</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">H</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">extensionality</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"kn\">lemma</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">mem_mk</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">mem_mk</span><span class=\"o\">])</span> <span class=\"n\">H</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">ext_iff</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span> <span class=\"bp\">▸</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">[]</span><span class=\"err\">⟧</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">not_mem_empty</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∉</span> <span class=\"o\">(</span><span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">mem_mk</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">h</span>\n\n<span class=\"n\">def</span> <span class=\"n\">singleton</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"err\">⟦</span><span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">]</span><span class=\"err\">⟧</span>\n\n<span class=\"n\">def</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">L₁</span> <span class=\"bp\">++</span> <span class=\"n\">L₂</span><span class=\"err\">⟧</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">L₃</span> <span class=\"n\">L₄</span> <span class=\"n\">H13</span> <span class=\"n\">H24</span><span class=\"o\">,</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">,</span> <span class=\"n\">H13</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H24</span> <span class=\"n\">x</span><span class=\"o\">]</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_union</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">union</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on₂</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">change</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"err\">⟦</span><span class=\"bp\">_</span><span class=\"err\">⟧</span> <span class=\"bp\">↔</span> <span class=\"bp\">_;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_append</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">prebind</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">prebind</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n<span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">))</span> <span class=\"n\">empty</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">prebind_cons</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">tl</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">hd</span> <span class=\"bp\">::</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">union</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">hd</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"n\">tl</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_prebind</span> <span class=\"o\">{</span><span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"n\">L</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"n\">L</span> <span class=\"o\">(</span><span class=\"n\">iff_of_false</span> <span class=\"o\">(</span><span class=\"n\">not_mem_empty</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"bp\">_⟩</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">hd</span> <span class=\"n\">tl</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">prebind_cons</span><span class=\"o\">,</span> <span class=\"n\">mem_union</span><span class=\"o\">,</span> <span class=\"n\">ih</span><span class=\"o\">]</span><span class=\"bp\">;</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">or_and_distrib_right</span><span class=\"o\">,</span> <span class=\"n\">exists_or_distrib</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_left</span><span class=\"o\">]</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">prebind</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monad</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">[</span><span class=\"n\">x</span><span class=\"o\">],</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">s</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">prebind</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L₁</span> <span class=\"n\">L₂</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">by</span> <span class=\"n\">ext</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"bp\">_</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_pure</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"o\">:=</span>\n<span class=\"n\">mem_mk</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">mem_singleton</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_bind</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">finset</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on</span> <span class=\"n\">s</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">prebind</span> <span class=\"n\">f</span> <span class=\"n\">L</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_map</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">pure</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n<span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">comp_apply</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">finset</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">mem_seq</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">&lt;*&gt;</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">φ</span> <span class=\"err\">∈</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">φ</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"k\">with</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">is_lawful_monad</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pure_bind</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">x</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_left</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span><span class=\"o\">,</span>\n  <span class=\"n\">bind_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span> <span class=\"n\">s</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">exists_and_distrib_left</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n      <span class=\"n\">exists_and_distrib_right</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"n\">and_assoc</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"n\">exists_swap</span><span class=\"o\">,</span>\n  <span class=\"n\">id_map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">exists_eq_right&#39;</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">finset</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">finset</span>\n</pre></div>",
        "id": 158919577,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550610885
    },
    {
        "content": "<p>it's a lawful monad!</p>",
        "id": 158919579,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550610887
    },
    {
        "content": "<p>Yeah but who is going to rewrite the 1700-line file finset.lean? What advantage does your approach have over the one in mathlib? Do you understand <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> and <span class=\"user-mention\" data-user-id=\"110865\">@Jeremy Avigad</span> and <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> 's approach via qpf's? Is it the same as yours or something else again?</p>",
        "id": 158919770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550611055
    },
    {
        "content": "<p>well I've been told that the current finset in mathlib is faster in terms of computation</p>",
        "id": 158919853,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550611107
    },
    {
        "content": "<p>so it'll probably stay</p>",
        "id": 158919855,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550611110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>, I disagree with your characterisation </p>\n<blockquote>\n<p>because people on this chat think they know better than people who have thought about this for 30 year</p>\n</blockquote>",
        "id": 158921034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1550612049
    },
    {
        "content": "<p>I wanted a quick an dirty solution for reindexing sums by shifting right and left, and had no where near the time available to properly do a big operators library, so I did just that. There are now usable lemmas specifically for using <code>finset.sum</code> with <code>Ico</code>, and of course this is not meant to be a replacement for a good general solution later.</p>",
        "id": 158921107,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1550612126
    },
    {
        "content": "<p>Further, and I suspect Mario will agree here, I don't think it's obvious that Coq's bigop library should be ported verbatim. We started a discussion about this earlier, and one example that came up was not understanding why they wanted to carry around both a domain for the sum, and a predicate selecting out some subset of that domain. To my eye that seems unnecessarily painful, and we should just change the domain to a subset when we want to do so. I couldn't find any explanation of this design decision in their paper, and as far as I can remember no one either justified it here, or wanted to talk about comparing the alternatives. As it didn't seem like there was much enthusiasm for discussion, I moved on to other things.</p>",
        "id": 158921371,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1550612360
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> The QPF stuff isn't presenting a new way to do <code>finset</code>s, it's just providing a way to use <code>finset</code> inside other inductive types, which is something we currently can't do</p>",
        "id": 158928020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617393
    },
    {
        "content": "<p>The difference between Kenny's finsets and mathlib finsets is that Kenny's is a quotient over the multiplicity of an element, while mathlib's is a restriction on multisets so that they have multiplicity 0 or 1 in each element. Computationally it's worse than mathlib's finsets, but mathlib's finsets are already completely impractical and not how you should store finite sets of things anyway for computational purposes. The <code>ordset</code> type was intended to be more computational, and provides O(log n) operations for most things rather than linear time for everything</p>",
        "id": 158928301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617607
    },
    {
        "content": "<p>and my finsets don't need decidable_eq to be a monad :P</p>",
        "id": 158928336,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550617636
    },
    {
        "content": "<p>One thing that Kenny's finsets doesn't support that mathlib's finsets do is <code>card</code></p>",
        "id": 158928356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617653
    },
    {
        "content": "<p>but Kenny's finsets support <code>insert</code> and <code>union</code> without decidable_eq, which is nice</p>",
        "id": 158928420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617687
    },
    {
        "content": "<p>déjà vu</p>",
        "id": 158928446,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550617708
    },
    {
        "content": "<p><code>inter</code> can't be done without decidable eq though</p>",
        "id": 158928450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617710
    },
    {
        "content": "<p>what's the best™ way to do finsets?</p>",
        "id": 158928625,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550617853
    },
    {
        "content": "<p>I recall ZF having 5 inequivalent definitions of finite?</p>",
        "id": 158928642,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550617867
    },
    {
        "content": "<p>metamath has 8 (<a href=\"http://us2.metamath.org/mpeuni/mmtheorems83.html#mm8285s\" target=\"_blank\" title=\"http://us2.metamath.org/mpeuni/mmtheorems83.html#mm8285s\">http://us2.metamath.org/mpeuni/mmtheorems83.html#mm8285s</a>)</p>",
        "id": 158928741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550617935
    },
    {
        "content": "<p>also why isn't <code>multiset</code> a monad?</p>",
        "id": 158928961,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550618128
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">multiset</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">monad</span> <span class=\"n\">multiset</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">pure</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">::</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">map</span><span class=\"o\">,</span>\n  <span class=\"n\">bind</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">multiset</span><span class=\"bp\">.</span><span class=\"n\">bind</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 158929031,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550618193
    },
    {
        "content": "<p>good question</p>",
        "id": 158929037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550618198
    },
    {
        "content": "<p>is it lawful? I think it is</p>",
        "id": 158929043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550618206
    },
    {
        "content": "<p>'course it's lawful, it's even commutative!</p>",
        "id": 158929081,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550618249
    },
    {
        "content": "<p>it's the free commutative monoid over a type</p>",
        "id": 158929092,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1550618257
    },
    {
        "content": "<blockquote>\n<p>Further, and I suspect Mario will agree here, I don't think it's obvious that Coq's bigop library should be ported verbatim.</p>\n</blockquote>\n<p>Of course we cannot port it verbatim. For instance we lack proper support for custom induction principle. We also lack SSReflect's powerful apply tactic. So we need to either first code more powerful tactics (which probably needs Lean 4) or write longer proofs (as I started to do).</p>\n<blockquote>\n<p>We started a discussion about this earlier, and one example that came up was not understanding why they wanted to carry around both a domain for the sum, and a predicate selecting out some subset of that domain. To my eye that seems unnecessarily painful, and we should just change the domain to a subset when we want to do so. I couldn't find any explanation of this design decision in their paper, and as far as I can remember no one either justified it here, or wanted to talk about comparing the alternatives. As it didn't seem like there was much enthusiasm for discussion, I moved on to other things.</p>\n</blockquote>\n<p>I'm not sure I understand what you mean here. Of course we want to be able to sum on various stuff, including using a predicate. Are you denying this happens in maths? There are several examples in the Coq bigop paper. Of course you can put the burden on the user, but this is not my understanding of what is library building. Let's take the simplest example. Say we have a sum indexed by integers, and we want to separate this into two sums: the sum over even integers in the summation range and the sum over odd integers, because you'll then do different manipulation depending on parity of the index. How would you like the interface to look like? Should is look like maths, where you get <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></msub><msub><mi>u</mi><mi>i</mi></msub><mo>=</mo><msub><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">;</mo><mi>i</mi><mtext> even</mtext></mrow></msub><msub><mi>u</mi><mi>i</mi></msub><mo>+</mo><msub><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo separator=\"true\">;</mo><mi>i</mi><mtext> odd</mtext></mrow></msub><msub><mi>u</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{1 \\le i \\le n } u_i = \\sum_{1 \\le i \\le n ; i \\text{ even}} u_i + \\sum_{1 \\le i \\le n ;i \\text{ odd}  } u_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.185818em;vertical-align:-0.43581800000000004em;\"></span><span class=\"base\"><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.39488900000000005em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">=</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16195399999999993em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">n</span><span class=\"mpunct mtight\">;</span><span class=\"mord mathit mtight\">i</span><span class=\"mord text mtight\"><span class=\"mord mathrm mtight\"> even</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mbin\">+</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.18639799999999984em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">1</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">i</span><span class=\"mrel mtight\">≤</span><span class=\"mord mathit mtight\">n</span><span class=\"mpunct mtight\">;</span><span class=\"mord mathit mtight\">i</span><span class=\"mord text mtight\"><span class=\"mord mathrm mtight\"> odd</span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">u</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> after writing something like <code>rw [bigop.split_using_predicate is_even, bigop.predicate_iff odd_iff_not_even</code> or do you want to first prove lemmas about lists until it looks like a concatenation of lists etc? I really think the work should go into the library, and then the user enjoys. Note that the user doesn't need to see anything complicated until needed: you can define notation that do not mention the predicate when you don't need it (this is what bigop is doing, and what I've done right from the beginning).</p>",
        "id": 159012290,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550694971
    },
    {
        "content": "<p>If you are doing something with complicated sums like these, I think the best option is to use finsets. They are much more compositional</p>",
        "id": 159040117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550723572
    },
    {
        "content": "<p>finsets are unordered, hence they cannot be used for a general library.</p>",
        "id": 159047888,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735656
    },
    {
        "content": "<p>huh? That equation you gave doesn't even hold unless you can reorder the elements</p>",
        "id": 159047900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550735707
    },
    {
        "content": "<p>What is the part of \"general\"  that you don't understand?</p>",
        "id": 159047911,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735748
    },
    {
        "content": "<p>The part where finsets are already pretty general</p>",
        "id": 159047954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550735770
    },
    {
        "content": "<p>bigop is a a general library, it handles all use case in a unified way</p>",
        "id": 159047955,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735776
    },
    {
        "content": "<p>Assuming commutativity is extremely restrictive, it's not \"pretty general\"</p>",
        "id": 159047972,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735831
    },
    {
        "content": "<p>I'm saying that if it's not commutative, you have other options but that partition theorem isn't true</p>",
        "id": 159047991,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550735857
    },
    {
        "content": "<p>Can we assume associativity?</p>",
        "id": 159048041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550735895
    },
    {
        "content": "<p>Of course there are lemmas with assumptions, is that what you are trying to teach here?</p>",
        "id": 159048042,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735896
    },
    {
        "content": "<p>At some point you are just folding over the free magma</p>",
        "id": 159048045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550735914
    },
    {
        "content": "<p>We don't have to assume associativity for all lemmas, although many of them will</p>",
        "id": 159048050,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735934
    },
    {
        "content": "<p>I honestly don't understand how you can promote both semi-rings and big operations indexed by finite sets</p>",
        "id": 159048071,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550735985
    },
    {
        "content": "<p>We have <code>list.sum</code> already</p>",
        "id": 159048128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736012
    },
    {
        "content": "<p>I'm not seeing what we are missing</p>",
        "id": 159048132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736023
    },
    {
        "content": "<p>We have an extensive collection of lemmas about ordered lists - that's <code>list</code></p>",
        "id": 159048164,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736070
    },
    {
        "content": "<p><code>list.sum</code> is tied to addition, right?</p>",
        "id": 159048172,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736085
    },
    {
        "content": "<p>or <code>list.prod</code>, or <code>list.foldr</code></p>",
        "id": 159048177,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736105
    },
    {
        "content": "<p>and <code>list.prod</code> is tied to multiplication, so you are still missing a general purpose library</p>",
        "id": 159048289,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736192
    },
    {
        "content": "<p>Of course <code>list.foldr</code> will be used in the implementation, but it doesn't give you the lemmas</p>",
        "id": 159048316,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736215
    },
    {
        "content": "<p>Sure it does</p>",
        "id": 159048328,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736222
    },
    {
        "content": "<p>you can prove lemmas about <code>list.foldr</code></p>",
        "id": 159048345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736231
    },
    {
        "content": "<p>under appropriate assumptions about the function</p>",
        "id": 159048391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736244
    },
    {
        "content": "<p>And then you are finally writing a bigop library!</p>",
        "id": 159048398,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736262
    },
    {
        "content": "<p>assuming you also setup good notations</p>",
        "id": 159048402,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736272
    },
    {
        "content": "<p>It's hard to make a notation for a function with four explicit parameters</p>",
        "id": 159048409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736297
    },
    {
        "content": "<p>And, in order to do that you can save time by having a look at what other did.</p>",
        "id": 159048416,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736303
    },
    {
        "content": "<p>That's why you need several notations</p>",
        "id": 159048424,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736319
    },
    {
        "content": "<p>as in <a href=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean#L28-L69\" target=\"_blank\" title=\"https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean#L28-L69\">https://github.com/PatrickMassot/bigop/blob/master/src/bigop.lean#L28-L69</a></p>",
        "id": 159048434,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736350
    },
    {
        "content": "<p>If I am specializing to <code>+</code>, that's already a function</p>",
        "id": 159048480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736369
    },
    {
        "content": "<p>Using the same function for all of these doesn't make anything easier</p>",
        "id": 159048494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736391
    },
    {
        "content": "<p>The trick is that those notations are used by users, but all lemmas are proved once, in the most general setting</p>",
        "id": 159048496,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736394
    },
    {
        "content": "<p>Of course it does make everything easier, that's what math is about: prove general results and gets many special cases for free</p>",
        "id": 159048515,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736436
    },
    {
        "content": "<p>Yeah but we've already done that</p>",
        "id": 159048517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736445
    },
    {
        "content": "<p>Where?</p>",
        "id": 159048522,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736455
    },
    {
        "content": "<p>Finset has loads of theorems, multiset has loads of theorems, list has loads of theorems, all in maximum generality for the statement</p>",
        "id": 159048541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736479
    },
    {
        "content": "<p>Seriously Mario, did you open that <a href=\"https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/bigop.v\" target=\"_blank\" title=\"https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/bigop.v\">https://github.com/math-comp/math-comp/blob/master/mathcomp/ssreflect/bigop.v</a> or are you waiting for the next time one of your papers will be rejected because you pay no attention to what the rest of the world is doing?</p>",
        "id": 159048621,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736598
    },
    {
        "content": "<p>That is &gt;200 lines of introducing notation. Wow!</p>",
        "id": 159048687,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550736683
    },
    {
        "content": "<p>Yes, those guys are pretty serious about building user interfaces</p>",
        "id": 159048753,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736747
    },
    {
        "content": "<p>Patrick, do you know if that file was written by hand?</p>",
        "id": 159048759,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550736764
    },
    {
        "content": "<p>certainly it was</p>",
        "id": 159048775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736777
    },
    {
        "content": "<p>Parts of it look so regular that you would think one might want to generate it</p>",
        "id": 159048776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1550736779
    },
    {
        "content": "<p>the answer to that question is no 90% of the time</p>",
        "id": 159048787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550736794
    },
    {
        "content": "<p>Remember this is part of the project that proved Feit-Thompson. It's the same game that we play, except that it scales. So, yes, they are pretty rigorous and regular</p>",
        "id": 159048847,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736848
    },
    {
        "content": "<p>I need to go, but I hope you'll think seriously about all that</p>",
        "id": 159048875,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550736925
    },
    {
        "content": "<p>I'm with Patrick here. <code>list.prod</code> doesn't have anywhere near the number of lemmas of <code>finset.prod</code>.</p>",
        "id": 159052949,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1550741773
    },
    {
        "content": "<p>Are there a lot of analogous theorems? I guess the noncommutative story is much simpler since most of the lemmas don't hold</p>",
        "id": 159053603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550742575
    },
    {
        "content": "<ul>\n<li><code>finset.prod_empty</code> -&gt; <code>list.prod_nil</code></li>\n<li><code>finset.prod_insert</code> -&gt; <code>list.prod_cons</code></li>\n<li><code>finset.prod_singleton</code> -&gt; TODO, but provable by simp</li>\n<li><code>finset.prod_const_one</code> -&gt; TODO: <code>list.prod_repeat_one : list.prod (list.repeat 1 n) = 1</code></li>\n<li><code>finset.prod_image</code> -&gt; unnecessary</li>\n<li><code>finset.prod_congr</code> -&gt; unnecessary</li>\n<li><code>finset.prod_union_inter</code> -&gt; inapplicable</li>\n<li><code>finset.prod_union</code> -&gt; <code>list.prod_append</code></li>\n<li><code>finset.prod_sdiff</code> -&gt; inapplicable</li>\n<li><code>finset.prod_bind</code> -&gt; <code>list.prod_join</code>, TODO?</li>\n<li><code>finset.prod_product</code> -&gt; TODO</li>\n<li><code>finset.prod_sigma</code> -&gt; TODO</li>\n<li><code>finset.prod_image'</code> -&gt; ?</li>\n<li><code>finset.prod_mul_distrib</code> -&gt; inapplicable</li>\n<li><code>finset.prod_comm</code> -&gt; inapplicable</li>\n<li><code>finset.prod_hom</code> -&gt; TODO</li>\n<li><code>finset.prod_hom_rel</code> -&gt; TODO</li>\n<li><code>finset.prod_subset</code> -&gt; not sure how to state</li>\n<li><code>finset.prod_eq_single</code> -&gt; not sure how to state</li>\n<li><code>finset.prod_attach</code> -&gt; unnecessary</li>\n<li><code>finset.prod_bij</code> -&gt; inapplicable</li>\n</ul>\n<p>The inapplicable ones only apply in a commutative setting, where I assume the <code>finset</code> notion works better. For some of the others, it may be better to have a version of <code>fold</code> that takes a binary operation and a function, similar to Patrick's <code>apply_bigop</code> but without the predicate</p>",
        "id": 159054367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550743437
    },
    {
        "content": "<blockquote>\n<p>Of course we want to be able to sum on various stuff, including using a predicate. Are you denying this happens in maths?</p>\n</blockquote>\n<p>Of course not...</p>\n<p>I just don't understand why a big operations interface needs to know separately about some domain, and some predicate on it, when you could just use <code>.filter</code> (on whatever sort of object is representing the domain).</p>",
        "id": 159142952,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1550828497
    },
    {
        "content": "<p>I would say something similar about the similarities between <code>sum_(i \\in l) a_i</code> and <code>sum_(i=m..n) a_i</code>. One is literally a special case of the other, so compositionality suggests to factor the definition</p>",
        "id": 159143126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550828630
    },
    {
        "content": "<p>Again, Scott and Mario: of course the implementation uses filter and factor the definition of <code>sum_(i \\in l) a_i</code> and <code>sum_(i=m..n) a_i</code>. But the user interface needs to do its job and  hide all that.</p>",
        "id": 159158657,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1550844423
    },
    {
        "content": "<p>I think that what might be happening here is similar to this whole \"R is Noetherian and S is isomorphic to R so S is Noetherian\" thing.</p>\n<p>Patrick -- we have to remember that Mario is not actually a mathematician. We might see sums broken up into sums over even and odd indices quite a lot (or maybe much more complex things, like breaking sums over modules into sums over isomorphism classes or whatever), but maybe he just never really does. He knows that everything can be done with filter and fold and doesn't really see the problem. I run into issues when doing things like undergraduate analysis and think \"isn't it annoying that this isn't there and I have to use filter and fold\", but nobody actually writes the code which should be there because the mathematicians haven't got around to it and the computer scientists don't really seem to know what we want. It's all well and good saying \"we want what's in Coq\" but somehow in practice what we actually want is the tools necessary to do what we're trying to do right now this instant. I have become convinced that Mario isn't just being obstructive/lazy when he doesn't write me my tactic which will rewrite sensible mathematical statements along isomorphisms of rings, he just can't really see why it's necessary because I've not yet come up with the killer example. I think it's the same here. We occasionally say \"we want to do this\" and it is pointed out to us that this is actually possible and would in fact be easy if we had some CS training, but we want something else. Maybe we haven't formalised exactly what we want.</p>",
        "id": 159252707,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1550969228
    },
    {
        "content": "<p>In metamath I had to do several sums over unusual sets; for example a sum over group elements breaks into a sum over conjugacy classes or cosets, or into sets of size two. Then there are mobius sums, over the divisors of a number, that commute with regular sums in interesting ways. I handled all of these by essentially the same method, which like finset sum. (It was a sum over a general abelian group, so in some ways it's more general than the lean version because it's not as much of a pain to switch between multiplicative and additive.)</p>\n<p>To prove stuff about partitioning a group sum, the proof obligation says that you have an indexed family of finsets which is disjoint (this is a definition on families of sets/finsets that says <code>\\all (i j : I) (z : A), z \\in f i -&gt; z \\in f j -&gt; i = j</code>), then the sum breaks into a two dimensional sum indexed over I and then summing the finsets in f.</p>",
        "id": 159258079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1550979588
    },
    {
        "content": "<p>There's a danger in hiding the fact that it's based on <code>finset.sum</code> in the sense that you lose the interface and theorems you had for <code>finset</code>, or at least make it less obvious that they apply. Take <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>j</mi></msubsup><msub><mi>a</mi><mi>k</mi></msub><msub><mi>b</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msub><mi>a</mi><mi>k</mi></msub><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mi>k</mi></mrow><mi>n</mi></msubsup><msub><mi>b</mi><mrow><mi>j</mi><mo>−</mo><mi>k</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{j=0}^{n} \\sum_{k=0}^j a_k b_{j-k} = \\sum_{k=0}^{n} a_k \\sum_{j=k}^n b_{j-k}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.964564em;\"></span><span class=\"strut bottom\" style=\"height:1.400382em;vertical-align:-0.43581800000000004em;\"></span><span class=\"base\"><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"></span></span></span></span></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.964564em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">0</span></span></span></span><span style=\"top:-3.2029000000000005em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mrel\">=</span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mathrm mtight\">0</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.804292em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.43581800000000004em;\"></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathit\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mbin mtight\">−</span><span class=\"mord mathit mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span></span>. This is hard to prove without using without using lemmas about finsets (and is stated without proof in any textbook). There are probably a few lemmas missing about intervals, but you still very much need the finset ones.</p>",
        "id": 159274620,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1551011808
    },
    {
        "content": "<p>I always justify this in lectures by saying that it's the sum over 0 &lt;= k &lt;= j &lt;= n</p>",
        "id": 159279566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1551021480
    },
    {
        "content": "<p>Exactly. That's the lean proof. But you have to use lemmas about sums over finsets for that. You don't want the finset to be hidden.</p>",
        "id": 159279693,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1551021706
    }
]
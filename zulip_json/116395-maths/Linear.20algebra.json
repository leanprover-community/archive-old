[
    {
        "content": "<p>I need some bits of linear algebra, and I am really struggling. I had forgotten how hard it is to use a part of the library you are not familiar with! Anyway, I am sure everything is already there to get the following statement, but whenever I start with something I begin to unfold and unfold and I am sure I shouldn't (and I guess I am not even writing it in the correct way). </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">pi_apply_eq</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">j</span> <span class=\"bp\">=</span> <span class=\"n\">i</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>Between <code>constr_self (pi.is_basis_fun 𝕜 ι) f</code> or <code>linear_map.std_basis</code>, I don't know where to start!</p>",
        "id": 179882322,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572905375
    },
    {
        "content": "<p>imports?</p>",
        "id": 179884358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572906775
    },
    {
        "content": "<p>No, start with a copyright header</p>",
        "id": 179884508,
        "sender_full_name": "Reid Barton",
        "timestamp": 1572906887
    },
    {
        "content": "<p><code>import apache</code></p>",
        "id": 179884598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572906956
    },
    {
        "content": "<p>More seriously, I think you should first use linearity of <code>f</code> to reduce to the same statement without <code>f</code></p>",
        "id": 179884800,
        "sender_full_name": "Reid Barton",
        "timestamp": 1572907128
    },
    {
        "content": "<p>Then I don't know whether it is an existing lemma. It does seem to be <code>std_basis</code>-related somehow. Anyways, it doesn't look very difficult to prove using <code>sum_mul_boole</code> for example</p>",
        "id": 179885230,
        "sender_full_name": "Reid Barton",
        "timestamp": 1572907512
    },
    {
        "content": "<p>I ended up doing the following, avoiding completely the linear algebra basis framework, which is a little bit sad. I would be very happy to see the proper way to write it, possibly replacing <code>λj, if i = j then 1 else 0</code> by something more idiomatic. Imports and header included :) Thanks for the reference to <code>sum_mul_boole</code>.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"> Nice Zulip header -/</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">pi_eq_sum_univ</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">pi</span><span class=\"bp\">.</span><span class=\"n\">finset_sum_apply</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"n\">x_1</span> <span class=\"bp\">*</span> <span class=\"n\">ite</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">x_1</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_mul_boole</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">x</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n    <span class=\"n\">rwa</span> <span class=\"n\">if_pos</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">mem_univ</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">at</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">l</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_ite</span><span class=\"o\">,</span> <span class=\"n\">pi</span><span class=\"bp\">.</span><span class=\"n\">smul_apply</span><span class=\"o\">],</span>\n  <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">eq_comm</span> <span class=\"o\">},</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">class</span><span class=\"bp\">.</span><span class=\"n\">instance_max_depth</span> <span class=\"mi\">36</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">linear_map</span><span class=\"bp\">.</span><span class=\"n\">pi_apply_eq_sum_univ</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">discrete_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"bp\">→</span><span class=\"err\">ₗ</span><span class=\"o\">[</span><span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"err\">𝕜</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">i</span><span class=\"o\">:</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"err\">•</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"n\">j</span> <span class=\"k\">then</span> <span class=\"mi\">1</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">pi_eq_sum_univ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_sum</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">sum_congr</span> <span class=\"n\">rfl</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">l</span> <span class=\"n\">hl</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">map_smul</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 179919991,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1572950785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I believe Terence Tao is unwittingly giving Lean a shoutout...<br>\n<a href=\"https://twitter.com/InertialObservr/status/1194826080005148672\" target=\"_blank\" title=\"https://twitter.com/InertialObservr/status/1194826080005148672\">https://twitter.com/InertialObservr/status/1194826080005148672</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/InertialObservr/status/1194826080005148672\" target=\"_blank\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/1145827188266033152/ycPVAOee_normal.jpg\"></a><p>Apparently an equivalent result has been used/discovered before, but as Terry Tao states it was never published. \n\n... oops <a href=\"https://t.co/i08oAEjMqW\" target=\"_blank\" title=\"https://t.co/i08oAEjMqW\">https://twitter.com/InertialObservr/status/1194826080005148672/photo/1</a></p><span>- 〈 Berger | Dillon 〉 (@InertialObservr)</span><div class=\"twitter-image\"><a href=\"https://t.co/i08oAEjMqW\" target=\"_blank\" title=\"https://t.co/i08oAEjMqW\"><img src=\"https://pbs.twimg.com/media/EJTf_I2UcAA_Lal.jpg:small\"></a></div></div></div>",
        "id": 180698098,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1573703927
    },
    {
        "content": "<p>More specifically, I guess you are referring to the following comment by Tao on his blog: <a href=\"https://terrytao.wordpress.com/2019/08/13/eigenvectors-from-eigenvalues/#comment-528704\" target=\"_blank\" title=\"https://terrytao.wordpress.com/2019/08/13/eigenvectors-from-eigenvalues/#comment-528704\">https://terrytao.wordpress.com/2019/08/13/eigenvectors-from-eigenvalues/#comment-528704</a> where he writes:</p>\n<blockquote>\n<p>(It’s at times like this that I wish we had a good semantic search engine for mathematics – I am not sure how I would have discovered this preprint other than by publishing our own preprint and waiting for someone to notice the connection.)</p>\n</blockquote>",
        "id": 180700698,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1573707902
    },
    {
        "content": "<p>Yup that same one <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 180774158,
        "sender_full_name": "Miguel Raz Guzmán Macedo",
        "timestamp": 1573765177
    },
    {
        "content": "<p>For a finite dimensional normed vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span>, we could define a linear map from the dual <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">V*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∗</span></span></span></span> to V itself by choosing a specific basis, and this map induce a topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">V*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∗</span></span></span></span>. The topology should not depend on the chosen basis so it is canonical. I wonder if there is any theorem in lean that says about this topology in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi><mo>∗</mo></mrow><annotation encoding=\"application/x-tex\">V*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mord\">∗</span></span></span></span>?</p>",
        "id": 321003595,
        "sender_full_name": "Ruizhe Wan",
        "timestamp": 1673547337
    },
    {
        "content": "<p>The dual itself is a normed space: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual\">docs#normed_space.dual</a></p>\n<p>After a quick look, I didn't see anything about finite dimensional normed spaces beyond <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual.finite_dimensional\">docs#normed_space.dual.finite_dimensional</a> (that the dual is finite dimensional).</p>\n<p>Do you have any particular application for the theorem you're talking about <span class=\"user-mention\" data-user-id=\"552778\">@Ruizhe Wan</span>? If I'm not mistaken, there ought to be a stronger statement that any two finite dimensional normed vector spaces of equal dimension over the same normed field are isometric (at least in characteristic zero).</p>",
        "id": 321008499,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1673548906
    },
    {
        "content": "<p>I am considering defining the dual vector bundle of a finite dimensional vector bundle, and first I need to define the topology on the dual vector bundle by defining a map from the dual vector bundle to the vector bundle, and then induce from it the topology. But to define the map I need to choose a specific basis. And I want to show the induced topology is independent of the basis chosen.</p>",
        "id": 321011475,
        "sender_full_name": "Ruizhe Wan",
        "timestamp": 1673549837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"552778\">@Ruizhe Wan</span>, can you edit your comment above to use <code>$$V*$$</code> instead of <code>V*</code>? The asterisks are turning into italics and being lost.</p>",
        "id": 321015420,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1673551185
    },
    {
        "content": "<p>You can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.to_continuous_linear_equiv\">docs#linear_equiv.to_continuous_linear_equiv</a>, but I think there should be a way to show directly that the topologies on the dual vector spaces are compatible on overlaps of charts if the original vector spaces are, in a basis-free way that generalizes to infinite-dimensional case.<br>\n(see also <a href=\"#narrow/stream/116395-maths/topic/Continuity.20of.20pointwise.20tensor.20product/near/196731565\">thread 1</a>, <a href=\"#narrow/stream/116395-maths/topic/riemannian.20geometry/near/186538511\">thread 2</a>)</p>",
        "id": 321026832,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1673554813
    }
]
[
    {
        "content": "<p>There's no way to upgrade a <code>normed_ring</code> which is also a <code>field</code> to a <code>normed_field</code>, right? I'm asking because I want to say that the quotient of a complete normed ring by a maximal ideal is a normed division ring, but when I created that I gave it a <code>norm_mul</code> field instead of a <code>norm_mul_le</code> field, so I'm not sure I can prove this without changing the definition of <code>normed_division_ring</code>.</p>",
        "id": 297680593,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662588111
    },
    {
        "content": "<p>You can take <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> with the norm <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à•</mi><mi>a</mi><mi mathvariant=\"normal\">‚à•</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">‚à£</mi><mi>a</mi><mi mathvariant=\"normal\">‚à£</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">‚à£</mi><mi>a</mi><msub><mi mathvariant=\"normal\">‚à£</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\| a\\| = max(|a|,|a|_0)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•</span><span class=\"mord mathnormal\">a</span><span class=\"mord\">‚à•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">a</span><span class=\"mord\">‚à£</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">‚à£</span><span class=\"mord mathnormal\">a</span><span class=\"mord\"><span class=\"mord\">‚à£</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mo>‚àí</mo><msub><mi mathvariant=\"normal\">‚à£</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">|-|_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">‚à£</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is the trivial norm (sends every nonzero element to 1) and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à£</mi><mo>‚àí</mo><mi mathvariant=\"normal\">‚à£</mi></mrow><annotation encoding=\"application/x-tex\">|-|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚àí</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à£</span></span></span></span> is the usual absolute value.<br>\nThen <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à•</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mo stretchy=\"false\">)</mo><mo>‚ãÖ</mo><mn>2</mn><mi mathvariant=\"normal\">‚à•</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">\\|(1/3) \\cdot 2 \\| = 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•</span><span class=\"mopen\">(</span><span class=\"mord\">1/3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚ãÖ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2‚à•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">‚à•</mi><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>3</mn><mi mathvariant=\"normal\">‚à•</mi><mo>‚ãÖ</mo><mi mathvariant=\"normal\">‚à•</mi><mn>2</mn><mi mathvariant=\"normal\">‚à•</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">\\| 1/3 \\|\\cdot \\|2 \\|= 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•1/3‚à•</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">‚ãÖ</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">‚à•2‚à•</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">2</span></span></span></span>.</p>",
        "id": 297684282,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662590469
    },
    {
        "content": "<p>These normed ring/field instances are a mess. There is the issue you pointed out, but also the issue that it extends a ring/field structure. Presumably it should be a mixin similar to <code>topological_ring</code>, etc. And maybe the (sub)multiplicative conditions should be mixins as well?</p>",
        "id": 297689453,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1662593806
    },
    {
        "content": "<p>I don't think we need separate mixins for the multiplicative stuff, but I do think that the hierarchy of normed classes should require the relevant algebra classes and not extend them.</p>",
        "id": 297689852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662594085
    },
    {
        "content": "<p>That idea has come up multiple times, and in the past has been rejected due to verbosity.</p>",
        "id": 297689957,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662594175
    },
    {
        "content": "<p>Thanks Adam, I figured there was a simple counterexample. Eric, by verbosity do you mean in the source or term size? Personally, I would be in favor of making normed classes take the algebra classes as arguments.</p>",
        "id": 297702508,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662607543
    },
    {
        "content": "<p>I mean in the source, but perhaps both concerns were expressed</p>",
        "id": 297738654,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662629344
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> was opposed, or at least might remember what the opposition was</p>",
        "id": 297738757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662629387
    },
    {
        "content": "<p>Here is my feeling on this (not backed by any quantitative measurement!). When some classes are ubiquitous and used all the time to build new classes (which will again be used to build new classes), then bundling more stuff in one class (like <code>[normed_field k]</code> instead of <code>[field k] [has_norm k] [is_normed_field k]</code>, say) ensures that there are less parameters in the stuff you build on top of it, making equality checking faster and avoiding exponential blowup when you build things on top of things on top of things.</p>\n<p><code>normed_field</code> is a class that definitely fits this description: it is used to build continuous linear maps, continuous multilinear maps, analytic maps, and so on.</p>\n<p>TLDR: I'd go for completely bundled classes for the main players in the hierarchy, and mixins for less prominent properties.</p>",
        "id": 297739867,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1662629823
    },
    {
        "content": "<p>I had a problem with that exactly once, which forced me to introduce the dumb typeclass <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_linear_ordered_field\">docs#normed_linear_ordered_field</a> (notice there are no compatibility conditions, this is exactly the union of two typeclasses), so it is really a problem but definitely not high priority imho</p>",
        "id": 297741145,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1662630362
    },
    {
        "content": "<p>The problem I have with extending is that it leads to a bunch of extra classes we have to define. For example we have to have separate normed versions of all of the following: ring, comm_ring, non_unital_ring, non_unital_comm_ring, and for division rings I want to be able to consider both ones that satisfy norm_mul_le (for Gelfand-Mazur) and ones that satisfy norm_mul (this is the standard condition for normed_division_ring) and applies to the quaternions, for example.</p>\n<p>Under the current setup, non_unital_normed_comm_ring doesn't even exist yet because I had trouble with timeouts that I have never gotten around to fixing, although I will need to get it working soon. It's currently impossible to have that distinction with division_rings without adding some sort of Prop mixin class is_division_ring analogous to is_field.</p>\n<p>If we switch, then we only need a few norm type classes (subadditive, submultiplicative, multiplicative, and scalar submultiplicative, cstar_ring). All the ring versions collapse into one.</p>\n<p>As a (minor) side benefit, it becomes possible to state certain results that are currently impossible to state in the standard way, e.g., a C-star-algebra has a unique C-star-norm; you can get around this currently by using the alternate version: injective star homomorphisms between C-star-algebras are isometric.</p>\n<p>Now, I had thought that the issue was always one of term-size blowup, but if it's really just about source code, I would definitely prefer to switch for the reasons described above.</p>",
        "id": 297786174,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662644456
    },
    {
        "content": "<p>Did you try whether the timeouts were caused by using new structures rather than old? I think using new structures for the normed hierarchy is an historical accident.</p>",
        "id": 297786578,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1662644615
    },
    {
        "content": "<p>I have not checked that. I'll look into it tomorrow when I have time. Thanks.</p>",
        "id": 297786690,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662644649
    },
    {
        "content": "<p>As I tried to say above, I think only the main players in the hierarchy should be fully bundled. I don't expect <code>non_unital_normed_comm_ring</code> to show up often, so having a mixin version for this one would be perfectly fine. Say that you have a mixin <code>is_normed_semiring</code> or whatever, then you could do <code>[non_unital_comm_ring R] [has_norm R] [is_normed_semiring R]</code>, say. And you could <em>define</em> <code>normed_field k</code> as <code>extends [field k] [has_norm k] [is_normed_semiring k]</code>. I don't see any drawback to this kind of approach.</p>",
        "id": 297788477,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1662645308
    },
    {
        "content": "<p>I don't think that type of extension is legal (at least for old style structures), but instances can be added manually to mean the same thing</p>",
        "id": 297790224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662645923
    },
    {
        "content": "<p>But now you find that you don't actually end up writing many lemmas about <code>normed_field</code> because they hold more generally for a selection from that pile of more fine-grained typeclases</p>",
        "id": 297790382,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662645978
    },
    {
        "content": "<p>Which means that your \"main players\" end up not playing as much as they originally used to</p>",
        "id": 297790463,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662646018
    },
    {
        "content": "<p>(also, I don't think we currently have any motivation to separate <code>has_norm</code> from <code>is_normed_semiring</code>, the separation from the algebra bits seems to be the pain point)</p>",
        "id": 297790722,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662646099
    },
    {
        "content": "<p>To me, the bundling is only useful when you build new definitions on top of it. For lemmas, it is better to have the fine-grained assumptions. Just like lemmas with <code>covariant_class</code> are perfect, but new definitions will rather build on <code>linearly_ordered_field</code> or whatever.</p>",
        "id": 297790960,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1662646198
    },
    {
        "content": "<p>What sort of definition building on top of <code>normed_field</code> do you have in mind?</p>",
        "id": 297791054,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662646233
    },
    {
        "content": "<p>Spaces of continuous linear maps or analytic maps, for instance.</p>",
        "id": 297791138,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1662646264
    },
    {
        "content": "<p>What do you mean by \"spaces of\"? Do you have a concrete existing declaration in mind?</p>",
        "id": 297792492,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1662646780
    },
    {
        "content": "<p>Sebastian, I will be working with <code>non_unital_normed_comm_ring</code>s <em>all the time</em>. Any time you take a normal element in a non-unital C‚ãÜ-algebra, the continuous functional calculus is a map from continuous functions on the spectrum into the commutative and non-unital C‚ãÜ-subalgebra generated by that element. So, for me personally, this is a huge player. That's not to say that <code>normed_field</code>s aren't perhaps a bigger player, only that I don't think the mixin approach makes too much sense. In any case, I'll second Eric's point that really I am interested in separating the analysis classes from the algebra classes; all the <code>normed_X</code> classes should still extend <code>has_norm</code>.</p>",
        "id": 297799021,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662648838
    },
    {
        "content": "<p>Would it be possible, under the alternate paradigm, to simply define <code>normed_field ùïú</code> as simply <code>extends field ùïú, normed_ring' ùïú</code> where <code>normed_ring'</code> is a normed ring where the norm is multiplicative? Would this solve your bundling issue?</p>",
        "id": 297802457,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662649726
    },
    {
        "content": "<p>Or does this not work because <code>normed_ring'</code> will be looking for some existing <code>ring ùïú</code> instance?</p>",
        "id": 297802858,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1662649838
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/normed_field/near/297802457\">said</a>:</p>\n<blockquote>\n<p>Would it be possible, under the alternate paradigm, to simply define <code>normed_field ùïú</code> as simply <code>extends field ùïú, normed_ring' ùïú</code> where <code>normed_ring'</code> is a normed ring where the norm is multiplicative? Would this solve your bundling issue?</p>\n</blockquote>\n<p>Yes, I said two messages above that it seems completely viable to me to have mixins, and bundle some on them in the definition of <code>normed_field</code>. But the best answer would certainly be to try the refactor, and see if it creates a lot of timeouts or not. If it doesn't, them I would be fine with separating the algebra classes and the normed ones!</p>",
        "id": 297808567,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1662651380
    }
]
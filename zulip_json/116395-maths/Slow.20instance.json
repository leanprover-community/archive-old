[
    {
        "content": "<p>The following code is very slow. However, swapping the order of the two <code>letI</code> statements make the code much quicker. What's going on here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">polynomial.is_splitting_field</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normal</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hFE</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.is_splitting_field.finite_dimensional</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">is_integral_of_noetherian</span> <span class=\"n\">hFE</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">q</span> <span class=\"n\">q_irred</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial.aeval</span> <span class=\"n\">H</span><span class=\"o\">)),</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span>\n      <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"n\">E</span> <span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">adjoin_root.root</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">polynomial.eval₂_map</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">,</span> <span class=\"n\">adjoin_root.algebra_map_eq</span><span class=\"o\">,</span> <span class=\"n\">polynomial.eval₂_mul</span><span class=\"o\">,</span>\n                <span class=\"n\">adjoin_root.eval₂_root</span><span class=\"o\">,</span> <span class=\"n\">zero_mul</span><span class=\"o\">],</span> <span class=\"o\">})),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222383512,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610416638
    },
    {
        "content": "<p>I don't really understand what's going wrong. But the final <code>rw</code> seems to be the culprit. It must be having a hard time finding some instance, but I don't see how the <code>algebra C E</code> instance would cause such a problem.<br>\nYou can use</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n</code></pre></div>\n<p>to see how lean is searching for instances.</p>",
        "id": 222448290,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610465930
    },
    {
        "content": "<p>I don't think that it's the <code>rw</code> specifically though, because the same problem occurs with this code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">polynomial.is_splitting_field</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">normal</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hFE</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.is_splitting_field.finite_dimensional</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">is_integral_of_noetherian</span> <span class=\"n\">hFE</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">or.inr</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">rintros</span> <span class=\"n\">q</span> <span class=\"n\">q_irred</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial.aeval</span> <span class=\"n\">H</span><span class=\"o\">)),</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span>\n      <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"n\">E</span> <span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">adjoin_root.root</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222481432,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610479390
    },
    {
        "content": "<p>It seems like the <code>q_irred</code> is causing problems. This code is slow, but commenting out the <code>q_irred</code> line makes the code fast.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span>\n  <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">polynomial.is_splitting_field</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">q_irred</span> <span class=\"o\">:</span> <span class=\"n\">irreducible</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hFE</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">F</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">polynomial.is_splitting_field.finite_dimensional</span> <span class=\"n\">E</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">is_integral</span> <span class=\"n\">F</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">is_integral_of_noetherian</span> <span class=\"n\">hFE</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial</span> <span class=\"n\">H</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">minimal_polynomial.aeval</span> <span class=\"n\">H</span><span class=\"o\">)),</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span>\n      <span class=\"o\">((</span><span class=\"n\">algebra_map</span> <span class=\"n\">E</span> <span class=\"n\">D</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">E</span><span class=\"o\">))</span>\n      <span class=\"o\">(</span><span class=\"n\">adjoin_root.root</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222525437,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610505485
    },
    {
        "content": "<p>The weird thing is that <code>q_irred</code> is not an instance, so I have trouble seeing why it would make things slower</p>",
        "id": 222527041,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610507048
    },
    {
        "content": "<p>Here's a simpler example of the problem. Commenting out either <code>hyp1</code> or <code>hyp2</code> makes the code run fast.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hyp1</span> <span class=\"o\">:</span> <span class=\"n\">irreducible</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hyp2</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">F</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span>\n    <span class=\"o\">(</span><span class=\"n\">adjoin_root.lift</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root.root</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"gr\">sorry</span><span class=\"o\">)),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222663717,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610581796
    },
    {
        "content": "<p>Just to be clear -- the code isn't slow, it's broken. The theorem isn't taking a long time to compile -- it's timing out in the presence of <code>hyp1</code> and <code>hyp2</code>.</p>",
        "id": 222667066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610584232
    },
    {
        "content": "<p>For me, it's just slow (23 seconds), rather than timing out</p>",
        "id": 222667256,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610584372
    },
    {
        "content": "<p>This is not a contradiction -- I might have fiddled with VS code timeout settings</p>",
        "id": 222668118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610585035
    },
    {
        "content": "<p>The debugging output is 47K :-(</p>",
        "id": 222668188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610585064
    },
    {
        "content": "<p>I would be tempted to try and spot which instances are being created in the three runs.</p>",
        "id": 222668804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610585543
    },
    {
        "content": "<p>I can't spot any significant differences between the outputs (using <code>set_option trace.class_instances true</code>, and a diff tool).</p>",
        "id": 222669079,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610585770
    },
    {
        "content": "<p>Here's a more simplified example. Deleting the <code>hyp1</code> line or deleting the <code>hyp2</code> line or deleting <code>: algebra F C</code> makes the code run fast.</p>\n<p>I still have no idea what's going on.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">hyp1</span> <span class=\"o\">:</span> <span class=\"n\">irreducible</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hyp2</span> <span class=\"o\">:</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">F</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">F</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">ring_hom.to_algebra</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 222781378,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610657142
    },
    {
        "content": "<p>If you want to get the experts interested then the next thing to try is removing the dependency on mathlib. I'll take another look at this later.</p>",
        "id": 222783071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1610657930
    },
    {
        "content": "<p>I'll try. Here's something really strange though: swapping <code>hyp1</code> and <code>hyp2</code> makes the code fast.</p>",
        "id": 222785495,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610659060
    },
    {
        "content": "<p>I had a look (setting <code>set_option trace.class_instances true</code> and trying to decipher the output). When you add the fact that <code>q</code> is irreducible, you open a new possibility to get that <code>C</code> is a semiring, because it can deduce that from the fact that <code>C</code> is a field. And when you have several paths in the hierarchy, and Lean can not see for itself that they lead to the same thing, then it is lost. </p>\n<p>A solution (which is not a satisfactory one, normally Lean should not get lost) is to add the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">1001</span><span class=\"o\">]</span> <span class=\"n\">adjoin_root.comm_ring</span>\n</code></pre></div>\n<p>before the lemma.</p>",
        "id": 222786263,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610659398
    },
    {
        "content": "<p>I do think that there is some semiring/field confusion going on. However, the significance of <code>finite_dimensional</code> eludes me.</p>",
        "id": 222787285,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610659865
    },
    {
        "content": "<p>I don't think finite_dimensional is significant, if you change that line to <code>  haveI hyp2 : monoid ℕ := by apply_instance,</code> its still slow, so really its the fact you are resetting the instance cache thats slowing you down.</p>",
        "id": 222788201,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1610660296
    },
    {
        "content": "<p>Yes, it is adding <code>hyp1</code> to the instance cache (note that <code>irreducible</code> is a class!)</p>",
        "id": 222788314,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610660375
    },
    {
        "content": "<p>You can get the same effect with <code>haveI hyp1 : irreducible q := sorry</code>.</p>",
        "id": 222788402,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610660415
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/116395-maths/topic/Slow.20instance/near/222788201\">said</a>:</p>\n<blockquote>\n<p>I don't think finite_dimensional is significant, if you change that line to <code>  haveI hyp2 : monoid ℕ := by apply_instance,</code> its still slow, so really its the fact you are resetting the instance cache thats slowing you down.</p>\n</blockquote>\n<p>That's a relief. I was banging my head searching through mathlib trying to find the weird interaction between noetherian modules and quotient rings.</p>",
        "id": 222788912,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610660722
    },
    {
        "content": "<p>So is there any way to avoid this problem? In my use case, it seems inevitable that I will have a irreducible hypothesis lying around and will eventually write a <code>haveI</code> statement.</p>",
        "id": 222789132,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610660833
    },
    {
        "content": "<p>Debuggued a little bit further. This is a case of a slow <code>rfl</code> between two semiring instances on <code>C</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">slow_theorem</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"n\">hyp1</span> <span class=\"o\">:</span> <span class=\"n\">irreducible</span> <span class=\"n\">q</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.field</span> <span class=\"n\">F</span> <span class=\"n\">_inst_1</span> <span class=\"n\">q</span> <span class=\"n\">hyp1</span><span class=\"o\">)))</span>\n    <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_ring</span> <span class=\"n\">C</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"n\">F</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n    <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>The <code>rfl</code> is taking ages.</p>",
        "id": 222789299,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610660911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Slow.20instance/near/222788314\">said</a>:</p>\n<blockquote>\n<p>Yes, it is adding <code>hyp1</code> to the instance cache (note that <code>irreducible</code> is a class!)</p>\n</blockquote>\n<p>I guess maybe this shouldn't be a class...</p>",
        "id": 222790020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610661257
    },
    {
        "content": "<p>Even if it were not a class, the <code>rfl</code> problem above would show up whenever you would want to use the field structure on an <code>adjoin_root</code> type.</p>",
        "id": 222790282,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610661386
    },
    {
        "content": "<p>I wonder if it's an instance of the performance problem of old type structure (against which Leo has warned us strongly) or if we can do something to improve the situation.</p>",
        "id": 222790376,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610661451
    },
    {
        "content": "<p>A work-around to prevent expansion of structures too far is to add the line</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span><span class=\"o\">]</span> <span class=\"n\">ideal.quotient.comm_ring</span>\n</code></pre></div>\n<p>(or maybe <code>local attribute</code>) before your statement. On my computer, the elaboration time for the lemma goes from 18s to 3s. Still long, but much more manageable.</p>",
        "id": 222791565,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610662032
    },
    {
        "content": "<p>This issue is really frightening me, as this is <em>not</em> a typeclass search issue.  I have already asked this before, and I know <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> is not enthusiastic about the idea, but let me ask it again (since in any case we will need to redesign a little bit the algebraic hierarchy in Lean 4 since it does not support old style structures directly).</p>\n<p>What about having classes that contain the data (zero, one, add, sub, neg, mul, and so on), and then classes taking the first ones as parameters, being Prop-valued (so that defeqness would be automatic) and asserting that the data is well behaved (defining a ring, a field, and so on). One thing to avoid would be having one class for each data (because it would lead to everything depending on a lot of parameters, and create blow-up when defining products for instance), but what about having classes <code>HasZeroOneAddSubNegMul</code> and all the natural variations (there wouldn't be that many, and we would set them up and their inheritance properties by hand -- this one would just be <code>extends HasZero HasOne HasAdd HasSub HasNeg HasMul</code>, and we would record an instance from <code>HasZeroOneAddSubNegMul</code> to <code>HasZeroOneAddMul</code> for example, and even to <code>HasZero</code> since looping is not a problem in Lean 4) and then <code>Ring</code> would take as an instance parameter <code>HasZeroOneAddSubNegMul</code>, while semiring would take <code>HasZeroOneAddMul</code>. </p>\n<p>I have the impression that it would solve all the long <code>rfl</code> problems, and all the diamond issues in the algebraic hierarchy, at a minimal cost. Of course, for this to be usable we would need the syntax <code>[[Ring R]]</code> that declares automatically an instance of <code>HasZeroOneAddSubNegMul R</code> if none can be found, to keep things transparent for the user.</p>",
        "id": 222830890,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610699251
    },
    {
        "content": "<p>The core of my complaint with this design is that you can replace <code>HasZeroOneAddSubNegMul</code> with <code>Ring</code> and everything still works the same</p>",
        "id": 222831099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699405
    },
    {
        "content": "<p>on the assumption that we don't care about instances of <code>HasZeroOneAddSubNegMul</code> that don't satisfy weaker constraints than <code>Ring</code>, otherwise make a class for those weakest assumptions</p>",
        "id": 222831134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699445
    },
    {
        "content": "<p>With that modification, the main difference from the current approach would be in classes with no new data, for example <code>integral_domain</code>, which would become parameterized over <code>ring</code></p>",
        "id": 222831181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699512
    },
    {
        "content": "<p>That said, I haven't looked into the problem in this thread</p>",
        "id": 222831307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699589
    },
    {
        "content": "<p>One thing I think is a contributing factor if not main factor in long <code>rfl</code> proofs of typeclass diamonds is that with the old structure approach every instance has to be unfolded to see all of its fields, and then these have to be compared pairwise with the fields in the other structure for defeq</p>",
        "id": 222831513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699717
    },
    {
        "content": "<p>I'm not even sure the new structure command will solve this (even in the cases where it applies), you still have to unfold a bunch of things. What we need is a way to prove defeqs as lemmas and get them to be used automatically when they come up. In principle unification hints can help with the second part, and it's not clear to me if they solve the first part</p>",
        "id": 222831692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699859
    },
    {
        "content": "<p>(Even better would be if we could prove equalities that <em>aren't</em> defeqs and get the typeclass system to use them. Alas, I don't think DTT can handle it...)</p>",
        "id": 222831838,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610699990
    },
    {
        "content": "<p>Here is the problem I see with adding Prop fields to basic data structures. For instance, instead of <code>HasZeroOneAddSubNegMulInvDiv</code>, you would like to have just <code>Field</code>. But then you have long paths from <code>Field</code> to <code>EuclideanDomain</code> to <code>IntegralDomain</code> to <code>Ring</code> to <code>Semiring</code>, keeping the data but removing props one afther the other. If the fields in <code>Field</code> are complicated, all the data has to be copied several times along the path. If there is just a basic path <code>Field -&gt; Ring -&gt; SemiRing</code> and all the others are mixins, I agree this issue disappears (and also we don't need any old style structure command to implement this). Looks like a good solution to me.</p>",
        "id": 222832404,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610700451
    },
    {
        "content": "<p>Something that we might be able to achieve along the lines of the old/new structure design, is if all instances are of the form <code>ring.mk &lt;semiring&gt; &lt;neg&gt; &lt;ring_mixin&gt;</code> where <code>&lt;ring_mixin&gt;</code> is either a conjunction or a list of props, then checking defeq here means checking the semirings (and if we're lucky and these are the syntactically equal then we're done), the neg, and then the ring mixin part is trivial because it's props (unless lean checks that the types match and then this could be quite expensive)</p>",
        "id": 222832993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610700843
    },
    {
        "content": "<p>This seems to be the main idea behind the new structure command, where by additional levels of bundling you increase your odds of getting lucky and happening on a syntactically equal segment before you have to unfold another layer, rather than having one big <code>ring.mk &lt;add&gt; &lt;one&gt; &lt;zero&gt; &lt;mul&gt; &lt;prop&gt; &lt;prop&gt; &lt;neg&gt; &lt;prop (with a type involving the previous)&gt;</code></p>",
        "id": 222833189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610700979
    },
    {
        "content": "<p>However, the new structure command doesn't support diamonds, and this is an issue. As Leo et al have said, it's not hard to implement a diamond manually and/or automate them, but this doesn't solve this underlying problem, these diamond instances are still going to have to splat out all the fields and put them back together, meaning that defeq problems involving them will have to compare all the fields, we don't ever get lucky</p>",
        "id": 222833347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701108
    },
    {
        "content": "<p>If we just have a flat inheritance structure for data (<code>Field -&gt; Ring -&gt; Semiring</code>) and Prop mixins that may involve as many diamonds as you want, I don't see why you would get a problem since Props are automatically defeq.</p>",
        "id": 222833560,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610701238
    },
    {
        "content": "<p>Is the data diamond free? I don't see why it would be</p>",
        "id": 222833585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701261
    },
    {
        "content": "<p>For example OrderedRing is going to be involved in a data diamond with OrderedAddGroup and Ring</p>",
        "id": 222833644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701310
    },
    {
        "content": "<p>I want a flat inheritance structure for algebraic data, a flat inheritance structure for orders (in fact there should just be <code>preorder</code>) and mixins.</p>",
        "id": 222833825,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610701413
    },
    {
        "content": "<p>I mean it might not be horrible but there will need to be some unpacking and repacking any way you have it</p>",
        "id": 222834020,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701551
    },
    {
        "content": "<p>so in the ordered ring example when you build one you need <code>OrderedRing.mk &lt;order&gt; &lt;ring&gt;</code> which is fine, but then the \"diamond instance\" will be <code>OrderedRing -&gt; OrderedAddGroup </code> since it's not a field in this arrangement, which has to be defined as <code>OrderedAddGroup.mk R.to_order R.to_ring.to_group</code>, and then when you get defeq problems about this instance you will have to unfold projections and so on</p>",
        "id": 222834267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Slow.20instance/near/222831134\">said</a>:</p>\n<blockquote>\n<p>on the assumption that we don't care about instances of <code>HasZeroOneAddSubNegMul</code> that don't satisfy weaker constraints than <code>Ring</code>, otherwise make a class for those weakest assumptions</p>\n</blockquote>\n<p>Note that ring homs don't need the prop fields... in the Witt vector project we had to build <code>some_fun</code> and prove that it preserves the ring data on <code>Witt (R)</code>, after that, we used it to check the ring axioms for <code>Witt (R)</code>, making it into an actual <code>ring</code>, and finally we could bundle <code>some_fun</code> into a <code>ring_hom</code>.<br>\nIf we have \"lawless rings\", such code would also become easier. But of course this is only one data point, and admittedly a rare one.</p>",
        "id": 222834316,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1610701775
    },
    {
        "content": "<p>There is something I don't know about the inner workings, and that would be important for this discussion.  Suppose you have a class <code>foo</code> (with data) and a Prop class <code>bar</code> taking an argument <code>[foo]</code>, maybe involving ten times the operation <code>foo</code> with different arguments. And then you have two instances of <code>bar</code>, depending on two instances of <code>foo</code> (that are defeq, but not obviously). Will Lean unfold everything in <code>bar</code> (i.e., unfold ten times the <code>foo</code>) to check that the two instances of <code>bar</code> are defeq, or will it be clever and say: I know it's enough to check that the two <code>foo</code> instances coincide, so let's not expand <code>bar</code> and just work on <code>foo</code>.</p>",
        "id": 222834417,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610701829
    },
    {
        "content": "<p>It will try the first, but very often the two instances of <code>foo</code> <em>aren't</em> defeq, only all their fields are, and in the latter case lean will have to unfold <code>bar</code> (and any other derived functions <code>bar</code> uses...) to discover that in fact only fields off <code>foo</code> and not <code>foo</code> itself are used</p>",
        "id": 222834615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610701996
    },
    {
        "content": "<p>For example, if you have a <code>ring</code> variable and destructure it and put it back together you will end up with something that isn't defeq to the variable you started with</p>",
        "id": 222834673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610702043
    },
    {
        "content": "<p>and this is exactly what happens in parent instances</p>",
        "id": 222834719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610702055
    },
    {
        "content": "<p>(which, by the way, is a very good argument for \"eta for structures\")</p>",
        "id": 222834766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610702103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> ,  I'd be interested in your diagnosis on what is happening in the example that started this thread.</p>",
        "id": 222835959,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610702941
    },
    {
        "content": "<p>I narrowed it down to the same refl problem as you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">F</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">hyp1</span> <span class=\"o\">:</span> <span class=\"n\">irreducible</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.field</span> <span class=\"n\">F</span> <span class=\"n\">_inst_1</span> <span class=\"n\">q</span> <span class=\"n\">hyp1</span><span class=\"o\">)))</span>\n<span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"n\">F</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span> <span class=\"n\">q</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>\n<p>But the next question is: why is this particular refl problem hard? Presumably it has something to do with <code>adjoin_root</code>, since this is the type that is producing all the fields. On the one hand we have <code>adjoin_root.field</code> and on the other we have <code>adjoin_root.comm_ring</code>, so let's look at those:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ideal.quotient.comm_ring</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">ideal.quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>Uh oh. Those instances aren't obviously related at all! We have to go unfold a bunch more things to find out that the ring instance extends the field instance.</p>\n<p>Let's make it a bit more manifest:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">ideal.quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>And now the <code>rfl</code> example at the start is instant.</p>",
        "id": 222839607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610705586
    },
    {
        "content": "<p>By the way, one reason why using <code>ideal.quotient.field</code> directly is a bad idea here is because it's a (semireducible) <code>def</code>, meaning that when lean is trying to prove instances are equal it will unfold things with instance reducibility but stop at defs, which is usually a good thing but means here that it's first going to unfold <em>everything</em> else, the entire ring hierarchy on the other side, before it reluctantly unfolds <code>ideal.quotient.field</code> when it has no other options</p>",
        "id": 222842568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610707766
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Is there a way to mark definitions as instance reducible without making them instances? I don't know any keyword combination for doing so</p>",
        "id": 222842668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610707846
    },
    {
        "content": "<p>No, the definition of instance reducible is literally \"has attribute <code>instance</code>\".</p>",
        "id": 222842704,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610707877
    },
    {
        "content": "<p>dang</p>",
        "id": 222842710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610707886
    },
    {
        "content": "<p>Luckily instance reducibility is gone in <span aria-label=\"four leaf clover\" class=\"emoji emoji-1f340\" role=\"img\" title=\"four leaf clover\">:four_leaf_clover:</span> .</p>",
        "id": 222842735,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610707911
    },
    {
        "content": "<p>I wonder if we should have a general (lintable?) rule that all instances should start with a structure constructor or another instance. That should make these situations much less likely</p>",
        "id": 222842956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708048
    },
    {
        "content": "<p>I believe we have some helper definitions to construct instances like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice_of_Inf\">docs#complete_lattice_of_Inf</a> that violate this rule.</p>",
        "id": 222843035,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610708136
    },
    {
        "content": "<p>The idea is that in such cases you use <code>{..constructor}</code></p>",
        "id": 222843065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708160
    },
    {
        "content": "<p>Should we also do this for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice.copy\">docs#complete_lattice.copy</a>?</p>",
        "id": 222843139,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610708198
    },
    {
        "content": "<p>This is often used directly.</p>",
        "id": 222843157,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1610708214
    },
    {
        "content": "<p>actually in that particular case it would be <code>{inf := inf, ..CL_of_inf}</code></p>",
        "id": 222843180,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708236
    },
    {
        "content": "<p>and similarly for <code>copy</code></p>",
        "id": 222843192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708245
    },
    {
        "content": "<p>you write explicitly all the data fields that you have something interesting to say about, and use <code>..struct</code> for the rest</p>",
        "id": 222843222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708272
    },
    {
        "content": "<p>We could make <code>complete_lattice.copy</code> <code>@[reducible]</code> to make it possible to do this setup inside the definition itself</p>",
        "id": 222843337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708342
    },
    {
        "content": "<p>in fact maybe that's sufficient for this kind of problem: \"instances\" that are <code>def</code> should always be marked <code>@[reducible]</code></p>",
        "id": 222843424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708401
    },
    {
        "content": "<p>that sounds a little dangerous as a general rule though</p>",
        "id": 222843504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610708447
    },
    {
        "content": "<p>Does it mean that the instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_Lp.emetric_space\">docs#pi_Lp.emetric_space</a> is a code smell, for instance? Or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_Lp.metric_space\">docs#pi_Lp.metric_space</a>, for what it's worth?</p>",
        "id": 222853751,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1610715675
    },
    {
        "content": "<p>As long as you don't care about the particular values the instance provides, it's okay... but since I see a <code>replace_uniformity</code> I assume you at least care about the uniformity</p>",
        "id": 222854773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610716287
    },
    {
        "content": "<p>The second one is constructing data by tactics, which is also not good. I would suggest putting these in an auxiliary <code>def</code> and then using the trick I showed to extract the parts you care about in the <code>instance</code></p>",
        "id": 222854925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610716367
    },
    {
        "content": "<p>Also FWIW it doesn't surprise me that there are many instances of this in mathlib, I'm sure I've written plenty. It's only just now coming to light as a pattern we should try to avoid</p>",
        "id": 222855217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610716525
    },
    {
        "content": "<p>and I'm not even sure my recommendations above are correct; splatting all the fields has some downsides (we're deliberately making the term bigger) and it remains to be seen if this is useful for lean</p>",
        "id": 222855382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610716615
    },
    {
        "content": "<p>Just saw this thread. Should I PR this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">ideal.quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 222907064,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610737092
    },
    {
        "content": "<p>(It does speed things up. I have a big proof which takes 20 seconds with <code>local attribute [irreducible] ideal.quotient.comm_ring</code> and 4 seconds with the above change)</p>",
        "id": 222907815,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610737349
    },
    {
        "content": "<p>I think it's good to PR this. And we should probably try to do this systematically in mathlib for similar definitions.</p>\n<p>One interesting thing I noticed it that it makes a huge difference whether the arguments are provided in the example, or as variables beforehand. Making them variables is much faster.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.normal</span>\n\n\n<span class=\"c1\">-- slow</span>\n<span class=\"kd\">example</span>  <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.field</span> <span class=\"n\">K</span> <span class=\"n\">_inst_1</span> <span class=\"n\">f</span> <span class=\"n\">_inst_2</span><span class=\"o\">)))</span>\n<span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"n\">K</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">irreducible</span> <span class=\"n\">f</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- fast</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">division_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_division_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.field</span> <span class=\"n\">K</span> <span class=\"n\">_inst_1</span> <span class=\"n\">f</span> <span class=\"n\">_inst_2</span><span class=\"o\">)))</span>\n<span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">ring.to_semiring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">comm_ring.to_ring</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">adjoin_root.comm_ring</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">euclidean_domain.to_comm_ring</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">field.to_euclidean_domain</span> <span class=\"n\">K</span> <span class=\"n\">_inst_1</span><span class=\"o\">))</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 222914555,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1610740031
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5759\">#5759</a></p>",
        "id": 222917878,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1610741291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Slow.20instance/near/222914555\">said</a>:</p>\n<blockquote>\n<p>And we should probably try to do this systematically in mathlib for similar definitions.</p>\n</blockquote>\n<p>Is this something a linter could catch?</p>",
        "id": 222918364,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1610741493
    },
    {
        "content": "<p>I'm not sure, since I don't know what exactly is bad and what is good.</p>\n<p>For example, <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> proposed the rule</p>\n<blockquote>\n<p>I wonder if we should have a general (lintable?) rule that all instances should start with a structure constructor or another instance.</p>\n</blockquote>\n<p>However, the following is bad (has worse <code>rfl</code> performance for me than the current instance), but satisfies Mario's rule:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">instance</span> <span class=\"n\">field</span> <span class=\"o\">:</span> <span class=\"n\">field</span> <span class=\"o\">(</span><span class=\"n\">adjoin_root</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"bp\">..</span><span class=\"n\">ideal.quotient.field</span> <span class=\"o\">(</span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">f</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">K</span><span class=\"o\">))</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 222936107,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1610750459
    },
    {
        "content": "<p>What's bad about that is that it adds new fields on top of a diamond without restating them. The lint would make you think twice about this but it doesn't know which fields you care about or what defeq expression you want to exhibit</p>",
        "id": 222936404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1610750587
    },
    {
        "content": "<p>Lean times out on the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">field_theory.splitting_field</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">polynomial</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">K</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">splitting_field</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">splitting_field</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">splits</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">F</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">splitting_field</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">splitting_field.lift</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">^</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">))</span> <span class=\"n\">key</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">f.to_ring_hom.to_algebra</span><span class=\"o\">,</span>\n  <span class=\"c1\">--haveI := is_scalar_tower.of_ring_hom f,</span>\n  <span class=\"c1\">--haveI : is_scalar_tower F K L := sorry,</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">F</span> <span class=\"n\">K</span> <span class=\"n\">L</span> <span class=\"o\">:=</span> <span class=\"n\">is_scalar_tower.of_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>However, Lean is fine with either of the two commented lines of code. Does anyone know what's going on?</p>",
        "id": 225878681,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1612979238
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"298851\">@Patrick Lutz</span></p>",
        "id": 227313406,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1614018187
    }
]
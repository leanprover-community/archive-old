[
    {
        "content": "<p>For those using Lean for teaching mathematics, how do you treat the notion of function?</p>\n<p>Until this year, I've taught my beginning undergraduates that a function is a triple <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi><mo separator=\"true\">,</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(A, B, C)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span>  of sets where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>⊆</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">C \\subseteq A \\times B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> with the properties:</p>\n<ol>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∃</mi><mi>b</mi><mo>∈</mo><mi>B</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">\\forall a \\in A, \\exists b \\in B, (a,b) \\in C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∃</span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> and</p>\n</li>\n<li>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mi>a</mi><mo>∈</mo><mi>A</mi><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>∈</mo><mi>B</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>C</mi><mo>∧</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo separator=\"true\">,</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>C</mi><mo>→</mo><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\forall a \\in A, \\forall b_1 b_2 \\in B, (a,b_1) \\in C \\land (a,b_2) \\in C \\to b_1 = b_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.73354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∀</span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∧</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>\n</li>\n</ol>\n<p>The type-theoretic notion of a function as a named lambda abstraction does away with the distinction between functions that have the same 'map' but different domains or codomains. I see that <code>data.set.function</code> provides, for example, <code>inj_on</code> to define what it means for a (type-theoretic) function to be injective on a set. But  this moves the notion of domain of a function to the definition of injectivity, rather than treating it as part of the definition of the function. That's fine, but it isn't the <em>same notion</em> of function as that given above.</p>\n<p>My question to those teaching undergraduate maths with Lean is: do you just work with the type-theoretic definition? If not, do you use <code>inj_on</code> to define injectivity, or do you do something else entirely?</p>",
        "id": 213659893,
        "sender_full_name": "Gihan Marasingha",
        "timestamp": 1602953100
    },
    {
        "content": "<p>In Lean each function knows its domain: <code>f : α → β</code> has domain <code>α</code>.</p>",
        "id": 213659994,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602953226
    },
    {
        "content": "<p>If we want to study this function on a subset of its domain, then we introduce an auxiliary <code>s : set α</code> and define <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.inj_on\">docs#set.inj_on</a> etc</p>",
        "id": 213660007,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602953267
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/function.injective\">docs#function.injective</a> does not use any <code>set</code>s</p>",
        "id": 213660046,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602953284
    },
    {
        "content": "<p>OK, so is the best solution not to worry about the distinction between sets and types?</p>\n<p>When we use <code>inj_on</code> to look at a function on a subset of its domain, then the new domain is not part of the function, but has been moved into the position of being an argument of <code>inj_on</code>. To me, this is a different definition of function than that which I'm used to, but I accept that it's the most natural definition as far as Lean is concerned.</p>\n<p>My view would be that <code>α</code> and <code>β</code> aren't domains and codomains in the traditional sense, as they aren't sets. Rather, to reconcile with the set-theoretic notion of function, a function would consist of a triple <code>A : set α</code>, <code>B : set β</code>, <code>C : set α × β</code> with the above properties, but this seems overly complicated and hard to work with in Lean.</p>",
        "id": 213661070,
        "sender_full_name": "Gihan Marasingha",
        "timestamp": 1602954669
    },
    {
        "content": "<p>For most (math) purposes the correct mapping is \"set\" = <code>Type</code>, \"subset\" = <code>set</code></p>",
        "id": 213661085,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602954722
    },
    {
        "content": "<p>When I explain functions, I like to explain that a function is a mathematical procedure that takes a certain class of inputs to an output. A function \"knows\" what its inputs can be (its domain), and what its potential outputs can be (its codomain). </p>\n<p>The definition you gave is an <em>encoding</em> of that idea in set theory. I don't think what you wrote has to be the definition, it just the most convenient encoding of the mathematical idea of a function in set theory. In type theory there is a different encoding (which is hardly an encoding, since functions are a primitive notion in type theory).</p>\n<p>The idea that functions have the same 'map' but different domains and codomains looks a little different in type theory than in set theory, but you can find analogues of everything in one theory in the other theory. In type theory, two maps cannot be \"the same\" without having the same domain and codomain, but I don't think that is an essential feature of function. <br>\nIf you have <code>A → B</code> and <code>C ⊆ A</code> you can still restrict your function to <code>C</code> in both set theory and type theory. In set theory, the \"map\" of your new function will be a subset, in type theory it will use <code>subtype.rec</code>, if we encode <code>C</code> as a subtype of <code>A</code>.</p>",
        "id": 213661123,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1602954736
    },
    {
        "content": "<p>e.g. \"A group is a set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> equipped with a binary operation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>:</mo><mi>G</mi><mo>×</mo><mi>G</mi><mo>→</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">m : G \\times G \\to G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> and ...\" -&gt; <code>(G : Type) (m : G -&gt; G -&gt; G)</code><br>\n\"A subgroup <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span></span></span></span> of a group <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> is a subset <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mo>⊂</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">H \\subset G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊂</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span> such that ...\" -&gt; <code>(H : set G) ...</code></p>",
        "id": 213661155,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602954809
    },
    {
        "content": "<p>(This works better with a \"structural\" idea of what a set is, e.g., \"an object of the category of sets\", rather than a \"material\" one as in a set theory like ZFC)</p>",
        "id": 213661295,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602955006
    },
    {
        "content": "<p>Thanks everyone. That makes sense and will save a lot of faffing about. I suspect students will find the type-theoretic notion to be more natural that the set-theoretic one anyway.</p>",
        "id": 213661391,
        "sender_full_name": "Gihan Marasingha",
        "timestamp": 1602955140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"233737\">@Gihan Marasingha</span> did you have a look at the <a href=\"https://github.com/leanprover-community/tutorials\">tutorials project</a>? It's almost only a translation into English of the Lean files I use with first year undergrads (double major in math and computer science). The only differences are a couple of efficiency optimizations (saving a couple of lines of Lean code using <code>rintros</code> instead of <code>intros</code> followed by <code>cases</code>, things like that). The question you asked here simply do not arise. Functions in (dependent) type theory is just way closer to actual mathematical intuition that the set theory bullshit we sometimes have to pretend to believe when teaching.</p>",
        "id": 213662558,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1602956824
    },
    {
        "content": "<p>E.g., the type-theoretic notion corresponds to function types in programming languages:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">double</span> <span class=\"nf\">sqr</span> <span class=\"p\">(</span><span class=\"kt\">double</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n</code></pre></div>\n\n<p>corresponds to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sqr</span> <span class=\"o\">:</span> <span class=\"n\">double</span> <span class=\"bp\">→</span> <span class=\"n\">double</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 213662570,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1602956868
    },
    {
        "content": "<p>Floris said</p>\n<blockquote>\n<p>When I explain functions, I like to explain that a function is a mathematical procedure that takes a certain class of inputs to an output. A function \"knows\" what its inputs can be (its domain), and what its potential outputs can be (its codomain).</p>\n</blockquote>\n<p>I shy away from saying exactly what kind of procedure it is -- if I prove that for all f :R -&gt; R, if f is differentiable then it is continuous, the f in that argument is not something defined by a mathematical procedure</p>",
        "id": 213664612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1602959620
    },
    {
        "content": "<p>But just to add to the chorus Gihan -- the A and B you have in your definition are definitely types in Lean. All the intuition goes through.</p>",
        "id": 213664767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1602959769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> yes, I really enjoyed the tutorial project! I learned much about Lean (including <code>rintros</code>) from it. Fortunately, my high-school French was sufficient to understand the only text that remained untranslated: \"Ce n'est pas cela. Essayez encore\".</p>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>: according to Liebeck, 'A function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span> is a rule that assigns to each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">s \\in S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> a single element of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span></span>'. Is 'rule' different from 'procedure' or has M1F changed since the 1990s? ;)</p>\n<p>All: I like the type-theoretic approach and I agree that it's more natural in many ways (the definition of function being a case in point) than the set-theoretic approach. I'm lucky to have the freedom to try this, but not all of my colleagues are sold on teaching mathematics formally (one said 'Buzzard can do this at Imperial, but...'). That's one of the reasons for raising the set / type issue as it relates to functions.</p>\n<p>I hope others will come round eventually. This is reminiscent of the Bourbaki-influenced changes in teaching last century.</p>",
        "id": 213666460,
        "sender_full_name": "Gihan Marasingha",
        "timestamp": 1602961950
    },
    {
        "content": "<p>People are still bashing Bourbaki, right?</p>",
        "id": 213666697,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1602962359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233737\">Gihan Marasingha</span> <a href=\"#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666460\">said</a>:</p>\n<blockquote>\n<p>yes, I really enjoyed the tutorial project! I learned much about Lean (including <code>rintros</code>) from it. Fortunately, my high-school French was sufficient to understand the only text that remained untranslated: \"Ce n'est pas cela. Essayez encore\".</p>\n</blockquote>\n<p>Good catch! I just translated it. But really, the message is that good (but not elite) first year students can handle those exercises.</p>",
        "id": 213669152,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1602966055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"233737\">Gihan Marasingha</span> <a href=\"#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666460\">said</a>:</p>\n<blockquote>\n<p>I'm lucky to have the freedom to try this, but not all of my colleagues are sold on teaching mathematics formally (one said 'Buzzard can do this at Imperial, but...'). </p>\n</blockquote>\n<p>You can tell them \"Massot can do that at Orsay too\".</p>",
        "id": 213669178,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1602966111
    },
    {
        "content": "<p>Actually I use Lean for teaching much more than Kevin since I have 50 students each year which have a <em>mandatory</em> mathematics course using Lean.</p>",
        "id": 213669237,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1602966206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Teaching.20functions/near/213666697\">said</a>:</p>\n<blockquote>\n<p>People are still bashing Bourbaki, right?</p>\n</blockquote>\n<p>Some people like to do that, but they will never undo the effect that Bourbaki had on mathematics.</p>",
        "id": 213669290,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1602966257
    }
]
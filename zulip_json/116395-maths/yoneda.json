[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110524\">@Scott Morrison</span> Is there a reason why <code>yoneda</code> takes the category as explicit argument? Now we have to write <code>yoneda C X</code> instead of just <code>yoneda X</code>.</p>",
        "id": 136033284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539859310
    },
    {
        "content": "<p>Try it: you still wouldn't be able to write <code>yoneda X</code>. The problem is that <code>yoneda C X</code> has a coercion, converting it to <code>(yoneda C).obj X</code>, and the coercion mechanism isn't clever enough to handle <code>yoneda X</code> by filling in <code>C</code> as an implicit argument before using the coercion.</p>",
        "id": 136047539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539873481
    },
    {
        "content": "<p>I guess <code>yoneda.obj X</code> would work then, if the category argument was implicit?</p>",
        "id": 136047790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539873708
    },
    {
        "content": "<p>This coercion stuff has turned out to be a lot more frustrating than expected--it's lovely when it works but Lean's reluctance to use coercions in the presence of metavariables means that they're often a lot more awkward than just writing <code>F.obj X</code>, but then you have the burden of supporting both <code>F X</code> and <code>F.obj X</code> which are different expressions.</p>",
        "id": 136047957,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539873874
    },
    {
        "content": "<p><em>\"and the coercion mechanism isn't clever enough\"</em> <span class=\"emoji emoji-2639\" title=\"sad\">:sad:</span></p>",
        "id": 136047972,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539873899
    },
    {
        "content": "<p>I guess this is why Scott didn't use any coercions a couple of months ago...</p>",
        "id": 136047999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539873935
    },
    {
        "content": "<p>If <code>F X</code> and <code>F.obj X</code> were the same expression, one could forgive the elaborator for being picky about where it is willing to insert a coercion</p>",
        "id": 136048072,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539873970
    },
    {
        "content": "<p>I think this thing with <code>yoneda C</code> is the same issue I ran into whenever I had to deal with cylinders in my homotopy theory library. There I had a functor <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">I : C \\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">:</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span></span></span></span> which was attached to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">C</span></span></span></span> by a type class, but I think that detail doesn't matter.</p>",
        "id": 136048215,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874111
    },
    {
        "content": "<p>Could we choose a fancy bracket that looks like <code>(</code> and <code>)</code>, and turn that into notation for <code>has_apply</code>?</p>",
        "id": 136048220,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539874117
    },
    {
        "content": "<p>And then I also had natural transformations <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.65952em;\"></span><span class=\"strut bottom\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>:</mo><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>→</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">i_1 : \\mathrm{id} \\to I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">:</span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi><mo>:</mo><mi>I</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow></mrow><annotation encoding=\"application/x-tex\">p : I \\to \\mathrm{id}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span><span class=\"mrel\">:</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">→</span><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>v</mi><mo>:</mo><mi>I</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">v : I \\to I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">v</span><span class=\"mrel\">:</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, all of which had the same issue...</p>",
        "id": 136048261,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874168
    },
    {
        "content": "<p>I think wouldn't mind write <code>F(X)</code> with some fancy <code>()</code>. But maybe this is abusing notation and type classes too much.</p>",
        "id": 136048366,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539874233
    },
    {
        "content": "<p>I think this could then replace <code>coe_to_fun</code>.</p>",
        "id": 136048387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539874252
    },
    {
        "content": "<p>It's not clear to me that we would not just end up back in the same situation</p>",
        "id": 136048509,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874340
    },
    {
        "content": "<p>We would still have two things, <code>F.obj X</code> and <code>apply F X</code>. I guess the question is whether we could avoid ever having to write <code>F.obj X</code>. But it would be so much simpler if there was just one thing in the first place.</p>",
        "id": 136048567,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874418
    },
    {
        "content": "<p><code>apply F X</code> would be <code>F.obj X</code> by definition.</p>",
        "id": 136048684,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539874507
    },
    {
        "content": "<p>It's possible if I had built my homotopy theory library on top of a category theory version with coercions from the start, I could have found a more convenient way to set things up</p>",
        "id": 136048696,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874517
    },
    {
        "content": "<p>But \"by definition\" is not good enough for <code>simp</code>, <code>rw</code> etc.</p>",
        "id": 136048781,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874565
    },
    {
        "content": "<p>I had a hard time porting a lot of proofs over the transition to use coercions in category theory</p>",
        "id": 136048801,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874585
    },
    {
        "content": "<p>because I had to be careful about the difference between <code>F X</code> and <code>F.obj X</code></p>",
        "id": 136048815,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874604
    },
    {
        "content": "<p>If I could actually write <code>F X</code> consistently then that might be okay, but I couldn't because of the issues with coercions and metavariables</p>",
        "id": 136048831,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874627
    },
    {
        "content": "<p>In the end I think I wrote some explicit type ascriptions in the statements of the simp lemmas I had defined, so that they could work on the <code>F X</code> version</p>",
        "id": 136048875,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874681
    },
    {
        "content": "<p>If we can agree that the coercion mechanism is broken, I would very happily rip them back out of the <code>category_theory/</code>.</p>",
        "id": 136048943,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539874728
    },
    {
        "content": "<p>For example <a href=\"https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548\">https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-6931c0d6d9d8dda133a6b3ed34b290d5L548</a></p>",
        "id": 136048952,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874740
    },
    {
        "content": "<p>The saving of not having to write <code>.obj</code> most of the time is far outweighed by the confusion of sometimes mysteriously having to do so.</p>",
        "id": 136048993,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539874772
    },
    {
        "content": "<p><a href=\"https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129\">https://github.com/rwbarton/lean-homotopy-theory/commit/e98dd6f51cd46653bf30c610e60573318443466c#diff-f49cdebfeaf5ac27e5bea99a12ad4ca9L129</a> -- sometimes I needed to help Lean out with the types and other times I didn't; it was hard to predict</p>",
        "id": 136049015,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874798
    },
    {
        "content": "<p>There's also the issue of why <code>category_theory/</code> requires so much use of <code>erw</code> rather than <code>rw</code>. This stinks, and I don't have a clear idea of why it happens, but fear that coercions are sometimes to blame.</p>",
        "id": 136049175,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539874913
    },
    {
        "content": "<p>I changed a bunch of <code>rw</code> to <code>erw</code> in that commit too, precisely because of the coercion thing. But there are some other situations where you need <code>erw</code> as well.</p>",
        "id": 136049245,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539874953
    },
    {
        "content": "<p>Do you think you can explain any of the others? I unfortunately just try <code>erw</code> and get on with it, and haven't invested the time in seeing what was going wrong.</p>",
        "id": 136049299,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539875014
    },
    {
        "content": "<p>I suspect that most of my cases are because I still use the explicit version (<code>nat_trans.app</code> in this case) in my definitions: <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cylinder/homotopy.lean#L17</a><br>\nand I frequently want to rewrite using the conditions Hi\\0, Hi\\1</p>",
        "id": 136049412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875103
    },
    {
        "content": "<p>It was quite unclear to me at first whether the easiest way forward was to use coercions everywhere or to use coercions nowhere or something in between</p>",
        "id": 136049503,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875168
    },
    {
        "content": "<p>Oh you mean the other situations, not related to coercions.</p>",
        "id": 136049546,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875225
    },
    {
        "content": "<p>I think for me they come from things like: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.65952em;\"></span><span class=\"strut bottom\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> is a natural transformation <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">d</mi></mrow><mo>→</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{id} \\to I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">i</span><span class=\"mord mathrm\">d</span></span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">I</span></span></span></span>. So the naturality law for <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">i_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.65952em;\"></span><span class=\"strut bottom\" style=\"height:0.80952em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">i</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> contains stuff like <code>(functor.id C) X</code> in the types and I need it to be <code>X</code> to continue with a subsequent rewrite, and that's why I need <code>erw</code>.</p>",
        "id": 136049640,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875319
    },
    {
        "content": "<p>I don't remember more details off-hand, sorry</p>",
        "id": 136049645,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875328
    },
    {
        "content": "<p>But I know that at least some cases had to do with this specific issue of applying the identity functor</p>",
        "id": 136049665,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875347
    },
    {
        "content": "<p>Like I might want to rewrite using associativity where I have three maps <code>A -&gt; B</code>, <code>B -&gt; X</code>, <code>(functor.id C) X -&gt; (functor.id C) Y</code></p>",
        "id": 136049757,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875427
    },
    {
        "content": "<p>and then <code>rw</code> says \"nope\"</p>",
        "id": 136049770,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875443
    },
    {
        "content": "<p>I guess my suggestion might be to rip out coercions for now and then suggest as a wishlist item for <span class=\"emoji emoji-1f340\" title=\"four leaf clover\">:four_leaf_clover:</span> to replace <code>has_coe_to_fun</code> by what I was calling in Orsay \"type-indexed notation\"</p>",
        "id": 136049818,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875521
    },
    {
        "content": "<p>what is that?</p>",
        "id": 136049869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539875541
    },
    {
        "content": "<p>The idea is if <code>F X</code> was actually <strong>notation</strong> for <code>F.obj X</code> then coercion and non-coercion syntax could all live happily forever.</p>",
        "id": 136049899,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875591
    },
    {
        "content": "<p>Currently, when Lean tries to elaborate <code>F X</code> it sees that the type of <code>F</code> is not a Pi type and then it maybe inserts a coercion</p>",
        "id": 136049909,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875615
    },
    {
        "content": "<p>So I presume this involves reducing the type of <code>F</code> to WHNF at least?</p>",
        "id": 136049921,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875638
    },
    {
        "content": "<p>Then the idea is, allow the user to specify another interpretation of <code>F X</code> as <em>notation</em> which depends on the head of the type of <code>F</code>, or something like that.</p>",
        "id": 136049969,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875671
    },
    {
        "content": "<p>rather than the rule being \"if the type of <code>F</code> is a Pi type then produce an application <code>F X</code>, otherwise produce <code>coe_fun_t F X</code>\" or whatever it is today</p>",
        "id": 136050000,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875722
    },
    {
        "content": "<p>give the user the chance to add additional rules \"if the type of <code>F</code> looks like [...], then produce [...]\"</p>",
        "id": 136050010,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875745
    },
    {
        "content": "<p>In this case, <code>functor.obj F X</code></p>",
        "id": 136050092,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539875819
    },
    {
        "content": "<p>By the way, the <code>equiv</code> coercion to fun is another one which has given me a lot of problems, which again is annoying because there are simp rules written in terms of the coercion like <code>e.symm (e x) = x</code></p>",
        "id": 136050430,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539876143
    },
    {
        "content": "<p>I guess the usability of these coercions depends upon the usage patterns. Once the <code>equiv</code>s you are working with are not ones which were passed as arguments to your lemma, but things like the equivalence Hom(FX, Y) = Hom(X, GY) induced by an adjunction, then I guess more of these metavariables crop up</p>",
        "id": 136050577,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539876319
    },
    {
        "content": "<p>I think this can be solved by a simp lemma like <code>e.to_fun = \\u e</code> and <code>e.inv_fun = \\u e.symm</code></p>",
        "id": 136050684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539876429
    },
    {
        "content": "<p>Yes, probably; then the next problem is that I might want to define my own simp lemmas whose statements involve applying equivs as functions</p>",
        "id": 136050894,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539876609
    },
    {
        "content": "<p>and then I don't know how to write the statement of the lemma in simp normal form except by writing some bulky type ascriptions</p>",
        "id": 136050915,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539876637
    },
    {
        "content": "<p>I have found that coercions between different function(like) types is a bad idea for this reason</p>",
        "id": 136050937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539876684
    },
    {
        "content": "<p>By the way, when bumping dependencies of your project across a substantial change, I can highly recommend having a separate checkout of the project built against the old version of the deps so that you can figure out how the heck any of your proofs used to work <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 136051838,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539877621
    },
    {
        "content": "<p>ah, that brings me back to metamath days</p>",
        "id": 136052379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1539878226
    },
    {
        "content": "<p>On the topic of coercions in category theory: would it make sense to use coercions to turn specialised shapes (like <code>fork</code> and <code>square</code> and <code>fan</code>) into the general shape <code>cone</code>? Of course we should also prove that have limits means having equalizers, pullbacks, products, etc... Then we might be able to prove a lot of stuff about general limits and use those results on specialised shapes. Or is this wishful thinking?</p>",
        "id": 136105758,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539949273
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I really like your idea about type indexed notation! Because then we could also have very clean notation for applying a functor to a morphism.</p>",
        "id": 136106147,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539949792
    },
    {
        "content": "<p>Yes, I was just thinking of that as well--it would be nice to have both <code>F X</code> for <code>F.obj X</code> and <code>F f</code> for <code>F.map f</code>. I'm not sure that comes for free with the exact setup I had in mind, where the interpretation of juxtaposition depends only on the type of <code>F</code>, but maybe some slightly different design could handle it.</p>",
        "id": 136108963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539953638
    },
    {
        "content": "<p>I think we may indeed want to arrange things so that equalizers and so on are actually defined as special cases of limits, and then wrap that in a nicer interface (which doesn't involve manually constructing a diagram/functor). The body of facts we have about limits is just going to keep increasing, and duplicating the results for each special shape of limit doesn't make sense.</p>",
        "id": 136109281,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539953956
    },
    {
        "content": "<p>You say \"actually defined as\". Do you mean defeq? I was suggesting a coercion. But maybe that is not good enough.</p>",
        "id": 136110360,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539955117
    },
    {
        "content": "<p>I do think that these are issues that should be sorted out soon. Because otherwise the refactoring will become a big pain if there is already too much code depending on the current setup.</p>",
        "id": 136110402,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539955169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I suppose the parser could also look at the \"token\" just following <code>F</code> to see whether it is an object or a hom. (And I assume the parser is smart enough to guess the right \"token\".)</p>",
        "id": 136112654,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539957179
    },
    {
        "content": "<p>I meant defeq but I haven't thought that much about what exact condition we would want.<br>\nHere is an example statement: if I have a limit cone in a diagram category then evaluation on any object yields a limit cone. Now we want the same statement for equalizers. If equalizers are defeq to a special case of limits, then we just apply the original statement. If equalizers are only <code>equiv</code> to a special shape of limit, then we need to transport across the equiv on both sides.</p>",
        "id": 136112698,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539957195
    },
    {
        "content": "<p>So all the current machinery should be replaced by constructors yielding a nice API?</p>",
        "id": 136112828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539957263
    },
    {
        "content": "<p>It's really weird that these definitions are so non-trivial. Why are we so good at unifying concepts, and why can't we teach that trick to a computer?</p>",
        "id": 136112977,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539957417
    },
    {
        "content": "<p>I’d love to be able to do something like this, but at the moment I really don’t see a good option. We can work on constructing diagrams (with some help from tactics) more easily. As an example, if <code>X Y : C</code>, and <code>f g : X \\hom Y</code>, there’s no reason why <code>construct_diagram [f,g]</code> couldn’t return a <code>\\Sigma (J : Type) [category J], J \\func C</code>, automatically deciding the index category J should be the walking parallel pair.</p>",
        "id": 136120823,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539964883
    },
    {
        "content": "<p>If this becomes easy enough, it becomes plausible to start defining “special” limits in terms of general ones. But without a huge improvement in this direction, it’s way too painful to expect a user to talk about equalizers as (defeq) special cases of limits. Just see the hoops I had to jump through to prove that having limits implies having equalizers...</p>",
        "id": 136120919,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539964967
    },
    {
        "content": "<p>Also, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I’m not sure if you saw it already, but there’s a second pull request (from the <code>limits-constructions</code> branch) that constructs products and equalizers from limits, etc.</p>",
        "id": 136121056,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539965122
    },
    {
        "content": "<p>I haven't yet looked in detail.</p>",
        "id": 136121069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539965154
    },
    {
        "content": "<p>I really hope that I will be able to write down a definition of <code>sieve</code> without <code>@</code>s. I must say that my experience with your library has been very positive. Writing things down is really pain-free and automation takes care of a lot of troubles.<br>\nDo you have a general guideline for when to add an auto_param in a definition?</p>",
        "id": 136121484,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539965527
    },
    {
        "content": "<p>Couldn't we have a function <code>construct_equalizer_diagram {a b} (f g : a \\hom b) : walking_fork \\func C</code>, and then define <code>equalizer f g := limit (construct_equalizer_diagram f g)</code>?</p>",
        "id": 136122297,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539966350
    },
    {
        "content": "<p>I like this idea. <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , did you try something like this before you settled on the current approach? Do you see problems with it?</p>",
        "id": 136126239,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539969871
    },
    {
        "content": "<blockquote>\n<p>But without a huge improvement in this direction, it’s way too painful to expect a user to talk about equalizers as (defeq) special cases of limits. Just see the hoops I had to jump through to prove that having limits implies having equalizers...</p>\n</blockquote>\n<p>I agree that it is more work starting from scratch to set up the basic definitions of things like equalizers as special cases of limits, but now that <em>you</em> have already jumped through those particular hoops, why would a user also need to?</p>",
        "id": 136126789,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539970539
    },
    {
        "content": "<p>I guess the problem with <code>equalizer f g := limit (construct_equalizer_diagram f g)</code> is that then the user of equalizers has to know the names of the objects and morphisms in the <code>walking_fork</code>. (Separately, I think <code>walking_fork</code> is the wrong name here; the \"handle\" of the fork is missing at this point.)</p>",
        "id": 136127042,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539970842
    },
    {
        "content": "<p>Maybe this is a small cost.</p>",
        "id": 136127048,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539970848
    },
    {
        "content": "<p>What should the objects and morphisms be?</p>",
        "id": 136127083,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539970908
    },
    {
        "content": "<p>I guess I'm really not seeing where there would be a simplification of the code, however.</p>",
        "id": 136127202,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971007
    },
    {
        "content": "<p>The simplification would come later, right? For example you have a massive file about deriving products and equalizers from limits. That would simplify.</p>",
        "id": 136127279,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971056
    },
    {
        "content": "<p>And functors preserving limits and such.</p>",
        "id": 136127290,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971066
    },
    {
        "content": "<p>Still for any theorem about limits, you need to restate a special version of it for equalizers/products/etc. None of these things require humans to write the proofs at this point.</p>",
        "id": 136127302,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971083
    },
    {
        "content": "<p>Sorry, maybe I'm dense, but what exactly do you mean?</p>",
        "id": 136127348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971153
    },
    {
        "content": "<p>Okay, I agree the files that construct equalizers, products, etc from limits would essentially disappear.</p>",
        "id": 136127349,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971155
    },
    {
        "content": "<p>Let's think about the construction <br>\n<code>def pi.post (f : β → C) (G : C ⥤ D) : G (limits.pi f) ⟶ (limits.pi (G.obj ∘ f)) := ...</code></p>",
        "id": 136127444,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971215
    },
    {
        "content": "<p><code>pi</code> = product of an arbitrary family?</p>",
        "id": 136127488,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539971265
    },
    {
        "content": "<p>if <code>limits.pi f</code> is defined as <code>limit (functor.of_function f)</code></p>",
        "id": 136127490,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971271
    },
    {
        "content": "<p>Yes.</p>",
        "id": 136127493,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971276
    },
    {
        "content": "<p>hmm... okay, maybe you guys are right here. :-)</p>",
        "id": 136127589,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971359
    },
    {
        "content": "<p>Wouldn't you just prove this by <code>limit.post</code>...?</p>",
        "id": 136127591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971363
    },
    {
        "content": "<p>Oohh, I really don't know. You guys have written orders of magnitude more code then I have. I'm just a user...</p>",
        "id": 136127656,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971406
    },
    {
        "content": "<p>So... for now I agree that this is worth exploring.</p>",
        "id": 136127698,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971445
    },
    {
        "content": "<p>However, I'm hoping to pause for a while on Lean, in not too long, as I have a lot of maths I want to work on.</p>",
        "id": 136127744,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971494
    },
    {
        "content": "<p>So I'm not sure what to do with this PR in the meantime.</p>",
        "id": 136127754,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971507
    },
    {
        "content": "<p>Options:</p>",
        "id": 136127755,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971509
    },
    {
        "content": "<p>1. leave it open for others to modify</p>",
        "id": 136127764,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971517
    },
    {
        "content": "<p>2. close it for now</p>",
        "id": 136127801,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971523
    },
    {
        "content": "<p>I'm not sure exactly where that \"...\" was going, but another example to keep in mind is \"if D is a complete category then a cone in D^J is a limit cone iff each the value at each j in J is a limit cone\"</p>",
        "id": 136127811,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539971528
    },
    {
        "content": "<p>3. strip it down to just limits, not the special cases, and leave those for later</p>",
        "id": 136127820,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971545
    },
    {
        "content": "<p>I have been meaning to suggest that 3 is a good idea anyways</p>",
        "id": 136127834,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539971561
    },
    {
        "content": "<p>Because the PR involves a lot of relatively untested design, and I think it's worth it to go and try to prove loads of things about general limits to \"kick the tires\" and make sure we settle on a design that we want</p>",
        "id": 136127923,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539971662
    },
    {
        "content": "<p>Okay. I will strip it down. Maybe someone else can explore if the special cases defined as suggested above are usable.</p>",
        "id": 136127930,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539971667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> How hard would it be to test that on your homotopy lib?</p>",
        "id": 136128038,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971762
    },
    {
        "content": "<p>Or should we try this on a fork of Scott's lib?</p>",
        "id": 136128100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539971825
    },
    {
        "content": "<p>Probably not that easy since I have some setup of my own to prove a bunch of lemmas about pushouts. Though maybe I could sorry all those proofs and just see how usable it is in the actual homotopy theory part.</p>",
        "id": 136129012,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539972570
    },
    {
        "content": "<p>Yeah, I meant that you just create a branch, and maybe break a couple files, but test this idea on the other files.</p>",
        "id": 136129599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539973136
    },
    {
        "content": "<p>I'm not suggesting you uproot your <code>master</code> branch (-;</p>",
        "id": 136129608,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1539973148
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, do you have  ideas about how to define all the \"walking\" categories for limits of special shapes?</p>",
        "id": 136142166,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539986774
    },
    {
        "content": "<p>I have reduced my PR to just the plain limits.</p>",
        "id": 136142173,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539986784
    },
    {
        "content": "<p>Just as we have finite sets, why not have a collection of finite categories of the usual special shapes?</p>",
        "id": 136146298,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1539993567
    },
    {
        "content": "<p>Yes. The point is just to decide the names of the objects and morphisms, because these names will then be fixed forever, and part of the API.</p>",
        "id": 136146369,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993690
    },
    {
        "content": "<blockquote>\n<p>Wouldn't you just prove this by <code>limit.post</code>...?</p>\n</blockquote>\n<p>I've just been trying this, and quickly discovered the reason: <code>limit.post</code> assumes that you're in a complete category. However <code>pi.post</code> only assumes you have all products. Therefore you can't call <code>limit.post</code> from <code>pi.post</code>, and we're stuck proving it again.</p>",
        "id": 136146418,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993770
    },
    {
        "content": "<p>Maybe this is a sign that <code>pi.post</code> is not what we want to provide people anyway.</p>",
        "id": 136146426,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993804
    },
    {
        "content": "<p>Except ... that it is...</p>",
        "id": 136146470,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993844
    },
    {
        "content": "<p>Maybe I will finish off \"porting\" products to the new setup, and then you guys can have a look to see what can be reduced.</p>",
        "id": 136146475,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993882
    },
    {
        "content": "<p>I'll do products because there no walking categories are required, we just use <code>functor.of_function</code>.</p>",
        "id": 136146479,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539993901
    },
    {
        "content": "<p>We probably need things like <code>[has_limits_of_shape J]</code> for other purposes anyways</p>",
        "id": 136146551,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994076
    },
    {
        "content": "<p>e.g. <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">κ</span></span></span></span>-accessible categories have all <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>κ</mi></mrow><annotation encoding=\"application/x-tex\">\\kappa</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">κ</span></span></span></span>-filtered colimits</p>",
        "id": 136146593,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994096
    },
    {
        "content": "<p>(\"We\" = \"I\", perhaps)</p>",
        "id": 136146599,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994112
    },
    {
        "content": "<p>Similarly we want to talk about functors which preserve finite products or whatever</p>",
        "id": 136146608,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994149
    },
    {
        "content": "<p>or filtered colimits, etc. This seems to me like more evidence that we need to be able to represent special shapes of (co)limits as special cases of general (co)limits so that we can flexibly mix all these notions, though certainly I have not yet tried to construct a specific design for any of this</p>",
        "id": 136146677,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994277
    },
    {
        "content": "<p>Could we try something like... <code>has_limits_of {A : Type} (Q : A \\to \\Sigma (J : Type), J \\func C)</code></p>",
        "id": 136146882,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994705
    },
    {
        "content": "<p><code>has_limits</code> itself could be defined as <code>has_limits_of id</code></p>",
        "id": 136146949,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994814
    },
    {
        "content": "<p><code>has_products</code> could be defined as <code>has_limits_of A Q</code> with <code>A = \\Sigma (b : Type), b \\to C</code>, and <code>Q = \\lambda p, p.1, functor.of_function p.2</code>.</p>",
        "id": 136146965,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994874
    },
    {
        "content": "<p>That's super general but I think even that level of generality could be useful in specific circumstances.</p>",
        "id": 136146967,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994909
    },
    {
        "content": "<p>Maybe there's no need to specify the allowed functors?</p>",
        "id": 136147009,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994927
    },
    {
        "content": "<p>Just the allowed diagrams?</p>",
        "id": 136147015,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994940
    },
    {
        "content": "<p>For example cofibration categories or Waldhausen categories have an axiom which says that you can form a pushout if one of the legs is a cofibration (one of the bits of structure)</p>",
        "id": 136147016,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994940
    },
    {
        "content": "<p>I see.</p>",
        "id": 136147021,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539994956
    },
    {
        "content": "<p>I just hand-crafted this axiom in my project: <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.1/src/homotopy_theory/formal/cofibrations/precofibration_category.lean#L41</a></p>",
        "id": 136147033,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539994993
    },
    {
        "content": "<p>So I know this example off-hand because I already implemented it in Lean. I think this is a pretty rare scenario, but if doesn't make things too much more complicated...? Certainly the common case would be A = (J \\func C), or Sigma of that over all J of some form (e.g., J filtered)</p>",
        "id": 136147080,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539995070
    },
    {
        "content": "<p>i.e., stick <code>has_limits_of_shape J</code> as a specialization of <code>has_limits_of</code> and a generalization of <code>has_products</code></p>",
        "id": 136147151,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539995253
    },
    {
        "content": "<p>well, maybe even one more step: <code>has_limits_of</code>, allowing you to specify arbitrary diagrams and arbitrary functors out of those, then <code>has_limits_of_shapes</code> allowing you to specify a class of diagrams, but all functors out of them, then <code>has_limits_of_shape</code> for a single diagram, and then <code>has_binary_products</code> would be a specialisation of that.</p>",
        "id": 136147519,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539995910
    },
    {
        "content": "<p>in any case, I'll give this a go, I guess.</p>",
        "id": 136147522,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1539995917
    },
    {
        "content": "<p>Sounds great!</p>",
        "id": 136147525,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539995932
    },
    {
        "content": "<p>I should really finish up that Grand Plan for formalizing model categories that I started writing a while ago...</p>",
        "id": 136147610,
        "sender_full_name": "Reid Barton",
        "timestamp": 1539996090
    },
    {
        "content": "<p>While we are at it: Do people have strong opinions on whether the homs of a category live in <code>Type v</code> or <code>Sort v</code>? I think if we start doing all sorts of diagrams over preorders (or using preorders as categories in other places) it might help in manipulating the homs if they are just in <code>Prop</code> instead of the whole <code>ulift plift</code> dance.<br>\n<span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Let me stress that I really love what you've done so far <span class=\"emoji emoji-1f64f\" title=\"thank you\">:thank_you:</span>. The only reason that I have these questions is because your code is so good <span class=\"emoji emoji-1f44d\" title=\"thumbs up\">:thumbs_up:</span>  that I can't resist using it <span class=\"emoji emoji-1f61c\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 136153288,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540008107
    },
    {
        "content": "<p>I've tried this before, but it's not possible to use <code>Sort v</code>. Unfortunately at the moment I can't remember why... From memory if you just start at the top and switch it over you run into difficulties quite quickly, if you want to try it yourself. :-)</p>",
        "id": 136155058,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540012075
    },
    {
        "content": "<blockquote>\n<p>For example cofibration categories or Waldhausen categories have an axiom which says that you can form a pushout if one of the legs is a cofibration (one of the bits of structure)</p>\n</blockquote>\n<p>Dually, there are many cases where one has a class of morphisms of which pullbacks along arbitrary maps exist (eg submersions, in smooth manifolds)</p>",
        "id": 136157606,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1540017671
    },
    {
        "content": "<p>Right. At some point we want to formalise this list: <a href=\"https://stacks.math.columbia.edu/tag/02WE\" target=\"_blank\" title=\"https://stacks.math.columbia.edu/tag/02WE\">https://stacks.math.columbia.edu/tag/02WE</a></p>",
        "id": 136158656,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540020027
    },
    {
        "content": "<p>Well, <code>span</code> and <code>cospan</code> are obvious choices, as is <code>parallel_pair</code>. Then also for each finite set one should have the corresponding discrete category, so as to form products/coproduct. The empty category should be there too, to get terminal/initial objects.</p>",
        "id": 136159177,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1540021281
    },
    {
        "content": "<p>No, I want to know what the _objects_ and _morphisms_ inside, for example <code>parallel_pair</code> should be called.</p>",
        "id": 136173465,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050166
    },
    {
        "content": "<p>Should the objects be <code>source</code> and <code>target</code>, and the morphisms <code>left</code> and <code>right</code>?</p>",
        "id": 136173471,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050189
    },
    {
        "content": "<p>Yeah that's a tough one. <code>top_arrow</code>?</p>",
        "id": 136173472,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050194
    },
    {
        "content": "<p>Or should <code>parallel_pair := bool</code>??</p>",
        "id": 136173473,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050198
    },
    {
        "content": "<p>I like 0 and 1 for the objects</p>",
        "id": 136173480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050218
    },
    {
        "content": "<p>As in <code>def parallel_pair := fin 2</code>?</p>",
        "id": 136173484,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050238
    },
    {
        "content": "<p>Or</p>\n<div class=\"codehilite\"><pre><span></span>inductive parallel_pair | _0 | _1\n</pre></div>\n\n\n<p>??</p>",
        "id": 136173531,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050260
    },
    {
        "content": "<p>probably not literally</p>",
        "id": 136173532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050260
    },
    {
        "content": "<p>like the second</p>",
        "id": 136173535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050271
    },
    {
        "content": "<p>I just mean as names</p>",
        "id": 136173541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050296
    },
    {
        "content": "<p>okay, that's what I've done previously. Is there something better that <code>_0</code> and <code>_1</code> for the names?</p>",
        "id": 136173543,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050300
    },
    {
        "content": "<p><code>0</code> and <code>1</code> are achievable</p>",
        "id": 136173551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050310
    },
    {
        "content": "<p>Oh, how?</p>",
        "id": 136173555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050317
    },
    {
        "content": "<p>add an instance</p>",
        "id": 136173557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050324
    },
    {
        "content": "<p><code>has_zero</code> <code>has_one</code></p>",
        "id": 136173560,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050330
    },
    {
        "content": "<p>ah, I see.</p>",
        "id": 136173613,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050373
    },
    {
        "content": "<p>Isn't it just more confusing to have an inductive type with terms <code>_0</code>, <code>_1</code>, but then give them second names via instances?</p>",
        "id": 136173617,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050406
    },
    {
        "content": "<p>Probably</p>",
        "id": 136173619,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050417
    },
    {
        "content": "<p>I would call them <code>zero</code> and <code>one</code></p>",
        "id": 136173627,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050434
    },
    {
        "content": "<p>and then use <code>0</code> and <code>1</code> as notation</p>",
        "id": 136173635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050443
    },
    {
        "content": "<p>we do that for <code>nat</code>, it's not that confusing</p>",
        "id": 136173640,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050453
    },
    {
        "content": "<p>okay... And using <code>0</code> and <code>1</code> as notation via <code>has_zero</code> and <code>has_one</code> will work in pattern matching, etc, just like for nat.</p>",
        "id": 136173643,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050465
    },
    {
        "content": "<p>Sounds reasonable.</p>",
        "id": 136173644,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050469
    },
    {
        "content": "<p>On to the morphisms, then. :-)</p>",
        "id": 136173648,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050475
    },
    {
        "content": "<p>yeah...</p>",
        "id": 136173667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050483
    },
    {
        "content": "<p>And the names of objects in pullbacks and pushouts...</p>",
        "id": 136173692,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050494
    },
    {
        "content": "<p>no bright ideas there. <code>left</code> and <code>right</code> seem reasonable?</p>",
        "id": 136173694,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050500
    },
    {
        "content": "<p>Except that there's no sense in which the two are actually different...</p>",
        "id": 136173706,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050552
    },
    {
        "content": "<p>surely they're <code>top</code> and <code>bottom</code>?</p>",
        "id": 136173721,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050588
    },
    {
        "content": "<p>I don't think <code>left</code> and <code>right</code> imply any other difference</p>",
        "id": 136173723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050595
    },
    {
        "content": "<p>Which way do you draw your equalizers??</p>",
        "id": 136173724,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050596
    },
    {
        "content": "<p>Yeah, there's that too. <code>top</code> and <code>bottom</code> are probably better.</p>",
        "id": 136173768,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050616
    },
    {
        "content": "<p>(but maybe <code>top</code> and <code>bottom</code> have too many other connotations, with ordering?)</p>",
        "id": 136173769,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050623
    },
    {
        "content": "<p>I know, it's bugging me that the walking pair is always drawn with the arrows above each other</p>",
        "id": 136173772,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050633
    },
    {
        "content": "<p>oh -- and if <code>walking_pair</code> is the diagram for an equalizer, what is the diagram for a binary product?</p>",
        "id": 136173788,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050669
    },
    {
        "content": "<p>but I think that the analogy to posets is important, that's why 0 and 1 are useful</p>",
        "id": 136173789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050672
    },
    {
        "content": "<p>I was going to bring up binary things next.</p>",
        "id": 136173790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050678
    },
    {
        "content": "<p>which one is that?</p>",
        "id": 136173796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050706
    },
    {
        "content": "<p>A &gt; B &lt; C?</p>",
        "id": 136173799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050711
    },
    {
        "content": "<p>binary product is just the diagram with two objects, no arrows at all</p>",
        "id": 136173844,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050732
    },
    {
        "content": "<p>left and right, definitely</p>",
        "id": 136173849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050751
    },
    {
        "content": "<p>In my homotopy theory library I used the convention of naming things like the inclusions of a coproduct with <code>\\_0</code> and <code>\\_1</code>, and eventually I got annoyed that I hadn't chosen <code>\\_1</code> and <code>\\_2</code>, but it would be a lot of things to change.</p>",
        "id": 136173851,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050751
    },
    {
        "content": "<p>... I'd been tempted to call that the <code>walking_pair</code>, and the diagram for an equalizer the <code>walking_parallel_pair</code>, but that is contrary to usual usage, I think.</p>",
        "id": 136173852,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050761
    },
    {
        "content": "<p>I assume you're going to define it as <code>discrete</code> of some type?</p>",
        "id": 136173861,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050786
    },
    {
        "content": "<p>The reason is that <code>\\_1</code> and <code>\\_2</code> aligns better with Lean's builtin <code>p.1</code> and <code>p.2</code></p>",
        "id": 136173870,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050813
    },
    {
        "content": "<p>Okay, yeah, I guess that is best, so it's defeq a special case of arbitrarily indexed products.</p>",
        "id": 136173877,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050831
    },
    {
        "content": "<p>Yes, and it should also just be less work overall</p>",
        "id": 136173922,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050883
    },
    {
        "content": "<p>So is the indexing category for <code>binary_product</code> <code>discrete (fin 2)</code>, <code>discrete bool</code> or <code>discrete side</code>, where <code>side</code> is an inductive type with terms <code>left</code> and <code>right</code>?</p>",
        "id": 136173923,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050883
    },
    {
        "content": "<p>I maybe prefer the last?</p>",
        "id": 136173927,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050896
    },
    {
        "content": "<p>I think I do too</p>",
        "id": 136173931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050903
    },
    {
        "content": "<p>or something with terms <code>fst</code> and <code>snd</code>?</p>",
        "id": 136173937,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050918
    },
    {
        "content": "<p>That fits better with the naming of projection maps in Lean itself.</p>",
        "id": 136173942,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050932
    },
    {
        "content": "<p>the problem with that is they aren't maps</p>",
        "id": 136173947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050939
    },
    {
        "content": "<p>I would get the two confused</p>",
        "id": 136173992,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540050966
    },
    {
        "content": "<p>yes, but we'll be able to write things like <code>c.\\pi fst</code> for the first projection</p>",
        "id": 136173994,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540050974
    },
    {
        "content": "<p><code>left</code> and <code>right</code> are nice for <code>inl</code> and <code>inr</code> though</p>",
        "id": 136174001,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540050984
    },
    {
        "content": "<p>is it the same category being reused?</p>",
        "id": 136174009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051008
    },
    {
        "content": "<p>I don't see why not.</p>",
        "id": 136174021,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051042
    },
    {
        "content": "<p>ok, then I agree with Reid</p>",
        "id": 136174023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051060
    },
    {
        "content": "<p>Probably it should be... so that we can relate coproducts in C to products in C^op eventually</p>",
        "id": 136174025,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051063
    },
    {
        "content": "<p>although I guess technically one is the op of the other</p>",
        "id": 136174029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051078
    },
    {
        "content": "<p>Yes, technically it should be the op</p>",
        "id": 136174069,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051086
    },
    {
        "content": "<p>Great, I will use <code>side</code> with <code>left</code> and <code>right</code>.</p>",
        "id": 136174072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051103
    },
    {
        "content": "<p>but we're already writing the category as <code>discrete T</code> where <code>T</code> is the type of its objects</p>",
        "id": 136174074,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051110
    },
    {
        "content": "<p>Finally, pullbacks and pushouts</p>",
        "id": 136174075,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051112
    },
    {
        "content": "<p>Can we steal the same names?</p>",
        "id": 136174087,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051150
    },
    {
        "content": "<p>it would be nice here if everything is consistent...</p>",
        "id": 136174088,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051151
    },
    {
        "content": "<p><code>middle</code>??</p>",
        "id": 136174092,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051176
    },
    {
        "content": "<p>Is anyone going to actually see these names?</p>",
        "id": 136174095,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051194
    },
    {
        "content": "<p><code>left - inl &gt; 1 &lt; inr - right</code></p>",
        "id": 136174152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051216
    },
    {
        "content": "<p><code>left &lt; fst - 0 - snd &gt; right</code></p>",
        "id": 136174158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051234
    },
    {
        "content": "<p>okay, sounds good to me</p>",
        "id": 136174262,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051367
    },
    {
        "content": "<p>except...</p>",
        "id": 136174278,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051390
    },
    {
        "content": "<p>I guess those names are technically accurate in some sense, though I find them really confusing</p>",
        "id": 136174281,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051393
    },
    {
        "content": "<p>like, you have <code>fst</code> and <code>snd</code> involved in the diagram for pushouts and vice versa</p>",
        "id": 136174289,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051408
    },
    {
        "content": "<p>remember the morphisms there are terms of one-element types</p>",
        "id": 136174292,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051412
    },
    {
        "content": "<p>maybe we should just make all those morphisms types <code>punit</code>.</p>",
        "id": 136174303,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051432
    },
    {
        "content": "<p>and not have names at all</p>",
        "id": 136174308,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051440
    },
    {
        "content": "<p>we just have to name the objects here, so we'd have <code>inductive walking_pullback | left | right | one</code></p>",
        "id": 136174365,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051494
    },
    {
        "content": "<p>I don't think so... the type is a inductive family with two elements</p>",
        "id": 136174368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051496
    },
    {
        "content": "<p>As they say, no names is good names</p>",
        "id": 136174370,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051498
    },
    {
        "content": "<p>why? we need to have a type of morphisms from <code>left</code> to <code>one</code>, and it contains only <code>inl</code>.</p>",
        "id": 136174396,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051529
    },
    {
        "content": "<p>etc</p>",
        "id": 136174400,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051535
    },
    {
        "content": "<p>It depends on whether you want to define <code>hom</code> as a single inductive family, or a type defined by case analysis</p>",
        "id": 136174403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051538
    },
    {
        "content": "<p>I think types by case analysis is a bad idea</p>",
        "id": 136174418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051555
    },
    {
        "content": "<p>remember <code>hom : obj -&gt; obj -&gt; Type</code></p>",
        "id": 136174462,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051587
    },
    {
        "content": "<p>I agree it probably makes the finite amount of work it takes to set up these categories and describe functors from them larger</p>",
        "id": 136174474,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051614
    },
    {
        "content": "<p>maybe I'm confused here</p>",
        "id": 136174475,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051617
    },
    {
        "content": "<p>I don't know if it has any longer term consequences though</p>",
        "id": 136174478,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051623
    },
    {
        "content": "<p><code>inductive hom | inl : hom left 1 | inr : hom right 1</code></p>",
        "id": 136174484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051642
    },
    {
        "content": "<p>I see</p>",
        "id": 136174486,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051651
    },
    {
        "content": "<p>okay, that does sound good</p>",
        "id": 136174487,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051668
    },
    {
        "content": "<p>but makes it harder to name things. :-)</p>",
        "id": 136174489,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051675
    },
    {
        "content": "<p>what about identities though? I think the truly correct way to do this is to go through the free graph construction</p>",
        "id": 136174527,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051685
    },
    {
        "content": "<p>Er, free category on a graph construction</p>",
        "id": 136174531,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051692
    },
    {
        "content": "<p>I was just about to say the same</p>",
        "id": 136174533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051696
    },
    {
        "content": "<p>this is a graph, not a cat</p>",
        "id": 136174534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051711
    },
    {
        "content": "<p>which I do have written down somewhere</p>",
        "id": 136174536,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051720
    },
    {
        "content": "<p>yes... I have this as well. It is extraordinarily painful to use, and this is why I hadn't previously pursued this approach.</p>",
        "id": 136174539,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051742
    },
    {
        "content": "<p>but I'm still not sure whether it makes any difference once we're done defining all these little categories</p>",
        "id": 136174542,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051745
    },
    {
        "content": "<p>really? I wouldn't have expected that</p>",
        "id": 136174547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540051767
    },
    {
        "content": "<p>but Reid, isn't your point that \"all these little categories\" is not a fixed set?</p>",
        "id": 136174549,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051773
    },
    {
        "content": "<p>Specifically, it should be easy enough to change our mind about the definitions of these categories later, right?<br>\nAs long as we have a usable interface for building functors out of them</p>",
        "id": 136174552,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051789
    },
    {
        "content": "<p>for example: there is some category called <code>parallel_pair</code>, and to define a functor <code>parallel_pair \\func C</code> I have to give you two objects (a b : C) and two maps (f g : a \\hom b)</p>",
        "id": 136174619,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051861
    },
    {
        "content": "<p>yes</p>",
        "id": 136174627,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051868
    },
    {
        "content": "<p>my preference would be on the first cut to define the slightly larger  indexed inductive types for morphisms that include identity morphisms.</p>",
        "id": 136174633,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051902
    },
    {
        "content": "<p>and then... there is some extensionality rule or something... and then it doesn't matter what goes inside. Right?<br>\nAnd nobody really needs to care about the choices of names, since I just renamed everything <code>a b f g</code> anyways</p>",
        "id": 136174634,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051904
    },
    {
        "content": "<p>and only later to pursue defining these as path categories on graphs (because I don't know how to do this well)</p>",
        "id": 136174676,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051929
    },
    {
        "content": "<p>As long as we can maintain this interface, it shouldn't matter whether we use the free category on a graph, or define hom as an indexed inductive type, or define hom by case analysis</p>",
        "id": 136174678,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051967
    },
    {
        "content": "<p>or define the category as a poset if it happens to be one</p>",
        "id": 136174683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540051985
    },
    {
        "content": "<p>I can't see to find my previous attempt to construct equalizers, based on a free category, out of limits, which was so unpleasant...</p>",
        "id": 136174688,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540052014
    },
    {
        "content": "<p>I admit I never actually used my free category construction to do anything. I was going to use it to prove that Cat has coequalizers... but I didn't.</p>",
        "id": 136174736,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052062
    },
    {
        "content": "<p>Oh hey, are graphs an example of <code>has_hom</code>?</p>",
        "id": 136174758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052126
    },
    {
        "content": "<p>That depends on what <code>has_hom</code> means exactly--this example was in the back of my mind when commenting on that aspect of Simon's PR</p>",
        "id": 136174780,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052157
    },
    {
        "content": "<p>assuming categories extend it, it must mean the notation, with hom and objects</p>",
        "id": 136174823,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052205
    },
    {
        "content": "<p>I think Scott convinced me at one point that it was better to not build <code>category</code> on top of <code>graph</code>, but I don't remember why exactly... maybe if we rename <code>graph</code> to <code>has_hom</code> it is more palatable, haha</p>",
        "id": 136174824,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052208
    },
    {
        "content": "<p>I kind of want to reserve the name <code>graph</code> for <em>small</em> <code>has_hom</code>s</p>",
        "id": 136174883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052310
    },
    {
        "content": "<p>Mario I'm glad you agree--there's this discussion about what to rename <code>has_hom</code> to in Simon's PR, which is really \"the data of a category without the laws\"</p>",
        "id": 136174893,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052352
    },
    {
        "content": "<p>That would just be specializing the universe parameters of <code>has_hom</code> to be equal right?</p>",
        "id": 136174900,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052379
    },
    {
        "content": "<p>I think so? I'm not sure that's small enough. Maybe it doesn't make sense</p>",
        "id": 136174949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052454
    },
    {
        "content": "<p>I want <code>graph A : Type u</code> when <code>A : Type u</code></p>",
        "id": 136174956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052486
    },
    {
        "content": "<p>but there's no way I'm going to get that</p>",
        "id": 136174960,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052501
    },
    {
        "content": "<p>A graph is a set of vertices, together with a set of edges from a to b for each a and b</p>",
        "id": 136174961,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052504
    },
    {
        "content": "<p>Well, if graph isn't allowed to have multiple edges...</p>",
        "id": 136174964,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052511
    },
    {
        "content": "<p>yeah, simple graphs solve the problem</p>",
        "id": 136175003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1540052525
    },
    {
        "content": "<p>I guess actual graph theorists would call this a multigraph</p>",
        "id": 136175008,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052527
    },
    {
        "content": "<p>Anyways <code>graph</code>s would also be examples of <code>has_hom</code> in any case</p>",
        "id": 136175074,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052656
    },
    {
        "content": "<p>Anyways anyways, my overall claim is that these names don't really matter either, because people should only be using the interface like <code>parallel_pair_functor f g</code>.</p>",
        "id": 136175113,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540052759
    },
    {
        "content": "<p>Maybe that means the things to do is to pick the variable names which appear in the interface (like <code>f</code> and <code>g</code>?) and then choose the names of generating morphisms based on them in some systematic way (like <code>F</code> and <code>G</code>?)</p>",
        "id": 136175312,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540053059
    },
    {
        "content": "<p>or whatever naming convention seems least likely to collide with other relevant things, maybe <code>F</code> is a bad name</p>",
        "id": 136175325,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540053108
    },
    {
        "content": "<blockquote>\n<p>The reason is that <code>\\_1</code> and <code>\\_2</code> aligns better with Lean's builtin <code>p.1</code> and <code>p.2</code></p>\n</blockquote>\n<p>I was surprised once when I realised that the builtin notation was not <code>p.0</code> and <code>p.1</code> but presumably could have been, given that Lean was written by CS people.</p>",
        "id": 136178333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1540057906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I experimented with a new design for \"special\" shape limits. Now they are all defined as special cases of limits. If you want to have a quick look, see <a href=\"https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits\">https://github.com/leanprover-community/mathlib/tree/limits-others-new/category_theory/limits</a>.</p>",
        "id": 136199413,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540098171
    },
    {
        "content": "<p>I think it looks reasonable. I would like to try proving some things about limits in functor categories, and make sure they immediately imply the corresponding results about pullbacks/products/etc.</p>",
        "id": 136199421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540098216
    },
    {
        "content": "<p>I'm going to make other fundamental changes, I think.</p>",
        "id": 136302717,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540250039
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 136302755,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540250044
    },
    {
        "content": "<p>I'm going to change <code>cone F</code> at least so that it is an object, bundled with a natural transformation from the constant functor (with value that object) to <code>F</code>. I may go all the way and just define <code>cone F</code> as a special case of a comma category. That had, long ago, been my initial version of limits, but I was having too much trouble with it. Having learnt a few things, I think it's viable again, so will try again. :-)</p>",
        "id": 136302808,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540250135
    },
    {
        "content": "<p>I wanted exactly this description in order to prove that right adjoints preserve limits</p>",
        "id": 136303069,
        "sender_full_name": "Reid Barton",
        "timestamp": 1540250393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Cool! That sounds like a good generalisation.<br>\nConcretely, you had a definition of sheaves, and I have almost generalised it to arbitrary sites. The real test case is probably going to be sheafification, and more generally pushforward and pullbacks of sheaves (and the fact that those are adjoint).</p>",
        "id": 136319006,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540276944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> How general are you planning to set up comma categories? Only slices over an object, or the general thing where you start with two functors?</p>",
        "id": 136324809,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1540285029
    }
]
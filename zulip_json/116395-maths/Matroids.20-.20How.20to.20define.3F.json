[
    {
        "content": "<p>I'm interested in formalizing the combinatorial theory of matroids. After working on this / learning Lean for the last week or so, I am running into some basic issues with definitions that I don't know the solution to. This (somewhat long) post is an appeal for help. I will try to give the minimum amount of information to indicate what my problems are. </p>\n<p>There are many equivalent definitions of a matroid, but the one I am interested in is the following: a matroid is a pair (E,r), where E is a finite 'ground' set, and r is a function assigning a nonegative integer 'rank' to each subset X of E, so that three axioms are satisfied: </p>\n<p>R1 :  ∀ X ⊆ E, r(X) ≤ |X| <br>\nR2 :  ∀ X ⊆ Y ⊆ E,  r(X) ≤ r (Y) <br>\nR3 :  ∀ X ⊆ Y ⊆ E,  r (X ∪ Y) + r (X ∩ Y)  ≤ r(X) + r(Y) .</p>\n<p>The exact nature of the second and third axioms is not particularly important. It is somewhat important that cardinality appears in the first one though; this is one of the many reasons that matroids need to be finite, which is seemingly the source of a few of the problem I'm encountering.</p>\n<p>To give an idea of the kind of statements about matroids I would like to prove, I ask that you bear with me while I give three other definitions and one lemma statement. </p>\n<p>Given a set A ⊆ E, one can 'remove' A from M in two different ways to obtain matroids with ground set E \\ A.  the 'deletion' M \\ A is just the matroid obtained from M by restricting the rank function to the domain E \\ A. The 'contraction' M/A is the matroid on ground set E \\ A with rank function r' defined by r'(X) = r(X ∪ A) - r(A). The deletion is trivially a matroid, and it is an easy exercise to show that the contraction is a matroid. Finally, the 'dual' of a matroid M = (E,r) is the matroid M* = (E,r') with rank function defined by r'(X) = |X| - r(E) + r(E \\ X). It is also easy to show that M* is a matroid, and to prove the following: </p>\n<p><strong>Lemma</strong>: For all A ⊆ E we have (M / A)* = M* \\ D. </p>\n<p>That is, contraction and deletion are dual operations. These statements all seem simple enough, but I can't find a satisfactory way to set them up and prove them in lean.  </p>\n<p>A couple of years ago, Bryan Chen formalized a number of results about matroids in lean: see <a href=\"https://github.com/bryangingechen/lean-matroids\">https://github.com/bryangingechen/lean-matroids</a> . He started from a different, equivalent definition of matroids that does not involve a function, but encoded the above definition towards the end of his file, defining a matroid structure (paraphrased) as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">matroid</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"bp\">ℕ</span> <span class=\"o\">)</span>\n\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"n\">hX</span> <span class=\"bp\">≤</span> <span class=\"n\">card</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hXY</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hXY</span> <span class=\"n\">hY</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span> <span class=\"n\">hY</span><span class=\"o\">)</span>\n\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hX</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"err\">⊆</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">union_subset</span> <span class=\"n\">hX</span> <span class=\"n\">hY</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">inter_subset</span> <span class=\"n\">hX</span> <span class=\"n\">hY</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"n\">hX</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span> <span class=\"n\">hY</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This definition works. One can go ahead and define deletion, contraction and duality, and prove all of the claims I made above without too much trouble. However, the proofs are long, and the main reason is the requirement that every evaluation of the rank function at a set X, or invocation of the axioms, must be accompanied by a proof that X ⊆ E. This requires a massive amount of bookkeeping. A typical proof will contain many rank evaluations on different sets (defined by intersections, unions, differences, etc) often on multiple different matroids with interrelated ground sets. The fact that all rank evaluations are well-defined is invariably obvious, but keeping track of all the relevant proofs gets very unwieldy. I have persisted with this for 500+ lines, formalizing a modest chunk of the basic theory, and it is painful. Bryan has told me he had a similar experience.</p>\n<p>The solution to this seems to be to use types. Bryan also started to do this in the 'fintype2' branch of his git, but didn't get as far as the rank axioms. The idea is presumably to use the ground set E as a fintype, and think of the rank function as mapping finset E to ℕ. Here is an attempt. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">card</span> <span class=\"n\">X</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">:</span> <span class=\"n\">finset</span>  <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">fintype</span>\n\n<span class=\"n\">def</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"o\">(</span> <span class=\"err\">???</span> <span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>As you can see, I don't see how to proceed from here, even with the most basic definitions. I am hoping there is a sensible way to fill in the ??? and the sorrys so that <code>submatroid</code> captures the restriction of r to the subset F, together with the proofs that the three axioms are satisfied. Given that these proofs are all mathematically trivial, I would ideally like a solution that reflects this, and doesn't heavily use coercions or the like. </p>\n<p>However, even if this is possible, I'm a little put off; here there seems to be an artificial distiction made between the 'ground set' E, which is encoded as a fintype, and its subset F, which is encoded a a set. Ideally, I would like to treat E as a set like any other inside proofs, and likewise to not have to pay due to the artificial distiction between a set F as being both the 'universe' of a submatroid and simply a subset of E. Too much of this will certainly cause problems in proofs later on that involve things like infinite classes of matroids on overlapping ground sets with many different rank functions. </p>\n<p>I don't know if I'm asking too much, but what I am doing does seem mathematically natural enough that an elegant solution should be possible in lean. This seems like it should be analogous to issues arising in areas like algebra and topology, but from what I can tell, the finiteness causes new issues. One approach I considered with a friend is to use <code> set E</code> rather than <code>finset E</code> which made some things a little smoother but caused decidability problems with cardinalities. </p>\n<p>If you're still reading, thank you for getting this far! Please let me know any thoughts you may have.</p>",
        "id": 207558287,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597948699
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> Did some stuff with matroids, I think</p>",
        "id": 207558367,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597948746
    },
    {
        "content": "<p>Yes, I have discussed this with him and linked his contribution in my post.</p>",
        "id": 207558449,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597948791
    },
    {
        "content": "<p>This is a tricky problem indeed. The issue is that the coercion from finset to type is not very smooth (one has to write <code>(\\u s : set E)</code> to coerce <code>s</code> to a <code>set E</code> and then Lean can automatically coerce this to a type).</p>",
        "id": 207558719,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597948937
    },
    {
        "content": "<p>The discussions about <code>fincard</code> would seem to be relevant here. I certainly agree that the partial function <code>(r (X : finset α) (hX : X ⊆ E) : ℕ)</code> is a bad idea - in fact I'm probably one of the voices behind Brian's decision to do the 'fintype2' version. But I think it would be smoother to use <code>set E</code> instead of <code>finset E</code> in the revised definition, as in <code>(r : set E → ℕ)</code>. The main issue with doing this to begin with is that <code>card X</code> won't typecheck, but <code>fincard</code> solves that, since it has the type <code>fincard : Sort* → ℕ</code> it is very easy to use on basically anything.</p>",
        "id": 207559421,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597949290
    },
    {
        "content": "<p>I'm referring to <a href=\"#narrow/stream/113488-general/topic/finiteness\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/finiteness</a></p>",
        "id": 207559568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597949366
    },
    {
        "content": "<p>﻿﻿(In case it's of interest, <a href=\"#narrow/stream/113489-new-members/topic/finset.20of.20subtype.20from.20filter/near/134577961\">here's a thread</a> where I discuss some issues with defining matroid restriction on my fintype branch.)</p>",
        "id": 207559569,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597949366
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"err\">$</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R1</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">card_image_le</span><span class=\"o\">,</span>\n  <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R2</span> <span class=\"err\">$</span> <span class=\"n\">image_subset_image</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">image_inter</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R3</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 207559798,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597949484
    },
    {
        "content": "<p>how is this?</p>",
        "id": 207559802,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597949489
    },
    {
        "content": "<p>for some weird reason I can't make the argument of R1 implicit</p>",
        "id": 207559833,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597949507
    },
    {
        "content": "<p>or else <code>le_trans M.R1 card_image_le</code> fails</p>",
        "id": 207559845,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597949514
    },
    {
        "content": "<p>There is a <code>fincard</code> branch but no PR yet btw</p>",
        "id": 207559854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597949518
    },
    {
        "content": "<p>implicit arguments don't work on structure fields for reasons I haven't bothered to investigate. This is one of the reasons that we often restate axioms after the structure</p>",
        "id": 207560528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597949839
    },
    {
        "content": "<p>it's generally better to just use <code>(R1 : ∀ X : finset E, r X ≤ X.card)</code> in the fields because it's less confusing</p>",
        "id": 207560641,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597949887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> btw, if you don't plan on having more than one matroids on any type, it might be better to make it a <code>class</code> instead of a <code>structure</code></p>",
        "id": 207560897,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597950027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/116395-maths/topic/Matroids.20-.20How.20to.20define.3F/near/207560897\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"329425\">Peter Nelson</span> btw, if you don't plan on having more than one matroids on any type, it might be better to make it a <code>class</code> instead of a <code>structure</code></p>\n</blockquote>\n<p>I do need to have multiple matroids on the same type - the dual matroid (discussed near the top) is one reason why.</p>",
        "id": 207561052,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597950116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110064\">Kenny Lau</span> <a href=\"#narrow/stream/116395-maths/topic/Matroids.20-.20How.20to.20define.3F/near/207559798\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"err\">$</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R1</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">card_image_le</span><span class=\"o\">,</span>\n  <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R2</span> <span class=\"err\">$</span> <span class=\"n\">image_subset_image</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">image_inter</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R3</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n</blockquote>\n<p>I have a naive question that is more about the coding than the math - how is <code>matroid F</code> valid code, where the definition of matroid itself has no arguments, and how do the subsequent lambdas infer that s refers to a subset of F?</p>",
        "id": 207561840,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597950497
    },
    {
        "content": "<p>The argument <code>E</code> is a variable on the line above, so it is equivalent to <code>structure matroid (E : Type*) :=</code></p>",
        "id": 207561973,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1597950594
    },
    {
        "content": "<p>So lean will try and turn <code>F</code> into a <code>Type</code>, this will be the corresponding <code>subtype</code> to the <code>set E</code>.</p>",
        "id": 207562131,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1597950675
    },
    {
        "content": "<p>If you open it in vscode there will probably be some coercion up arrow before <code>F</code>.</p>",
        "id": 207562165,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1597950702
    },
    {
        "content": "<p>I also find it interesting in kenny's code that the matroid is not finite but all the operations still make sense</p>",
        "id": 207562815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951025
    },
    {
        "content": "<p>Yes, one can do some things with infinite matroids - however, they break down under duality, at least when defined in terms of the rank function, since the dual rank function includes a cardinality term.</p>",
        "id": 207563042,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597951141
    },
    {
        "content": "<p>I don't know the theory you are talking about, so I don't know what duality should mean here, but it sounds like maybe the fintype assumption should be introduced some time after the definition</p>",
        "id": 207563138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951199
    },
    {
        "content": "<p>it's generally good practice to introduce assumptions when they become necessary to state and prove things, and not before</p>",
        "id": 207563301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951276
    },
    {
        "content": "<p>I would prefer if the finiteness were baked in - the reason is that if you just define an infinite matroid as an infinite set satisfying the rank axioms, you don't have the full generality of infinite matroids, which really should allow sets of infinite rank as well. The right way to talk about infinite matroids is with a completely different definition.</p>",
        "id": 207563451,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597951354
    },
    {
        "content": "<p>I realize this is the mathematically natural thing to do, but it has no formalization advantage</p>",
        "id": 207563518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951402
    },
    {
        "content": "<p>I see, that makes sense.</p>",
        "id": 207563545,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597951416
    },
    {
        "content": "<p>It's like saying \"I know y=f(x) is a function of x only, but let's define a new function F(x,a)=f(x) which ignores a\". This is all over mathlib. For example the real square root function doesn't ask that the input is nonnegative. The assumptions which makes things sane are in the theorems not the definitions.</p>",
        "id": 207563713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597951497
    },
    {
        "content": "<p>with f(x) you know, syntactically, that it doesn't depend on a. With f(x,a) you have a theorem to prove, and apply in lots of places, and this is just added headache</p>",
        "id": 207563853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951567
    },
    {
        "content": "<p>This is all quite a paradigm shift in my head. I'm having a blast doing this stuff, though!</p>",
        "id": 207564001,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597951665
    },
    {
        "content": "<p>I guess the easiest example is how division is defined for every element in a field -- with <code>a / 0 = 0</code> for all <code>a</code></p>",
        "id": 207564141,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597951725
    },
    {
        "content": "<p>the thing that surprised me about kenny's definition is that it's actually not total nonsense for infinite types. My fincard suggestion would have been nonsense for infinite types because <code>fincard X = 0</code> when <code>X</code> is infinite</p>",
        "id": 207564347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951816
    },
    {
        "content": "<p>it's maybe not the ideal infinite matroid type but it's still relatively well defined, which means that a lot of theorems will nevertheless apply in the infinite case</p>",
        "id": 207564439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597951877
    },
    {
        "content": "<p>One thing I didn't realize when I was formalizing the rank in my repo was how important it was to choose good definitions for formalization. </p>\n<p>Oxley defines the rank of a matroid (defined via the independent set axioms) as the cardinality of a basis and then defines the rank of a subset of the ground set as the rank of the submatroid created by restricting to that subset. I probably would've gotten less stuck if I had put off defining restriction and submatroids and instead simply defined the rank of a subset to be the cardinality of the maximal independent set contained in that subset. (Of course, restriction and submatroids are important concepts in their own right, but it's not clear that they're absolutely essential to the notion of rank.)</p>\n<p>In math, switching between these two is somehow completely transparent, but when formalizing, making sure that the extra layers of definitions are easy to work with and have a nice \"API\" can be very difficult (particularly for newcomers like me!)</p>",
        "id": 207565784,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597952603
    },
    {
        "content": "<p>Yes - different matroid people have their own favourite axiom sets, but I (humbly) think that the rank function is the most powerful for formalization because it can reduce case analysis to a simple verification of linear inequalities</p>",
        "id": 207566006,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597952754
    },
    {
        "content": "<p>Matroids/submatroids seem to have the same issue that graphs/subgraphs have, what I was calling the \"synecdoche problem\" in a topic on #general.</p>\n<p>A matroid has two things that can vary, the <code>E</code> type and the rank function.  You don't want to define a class on <code>E</code> because the rank function can vary, so a matroid is best as a structure.  However, you want a submatroid to be a matroid, too, and it would be nice to have a type <code>submatroid M</code> of submatroids for <code>M</code> a matroid (probably where all the matroid deletions live).</p>\n<p>You might take a look at the <a href=\"https://github.com/leanprover-community/mathlib/blob/simple_graphs2/src/combinatorics/simple_graph.lean\"><code>mathlib:simple_graphs2</code></a> branch, where I'm experimenting with a solution to this problem for simple graphs.  I think the technique works really well so far, with the only cost being that to introduce an abstract simple graph you need three things rather than two:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">simple_graph</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 207566018,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597952761
    },
    {
        "content": "<p>Graphs and matroids are very similar, so I suspect a good solution to either will be good for the other.</p>",
        "id": 207566097,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597952796
    },
    {
        "content": "<p>Yes, I agree</p>",
        "id": 207566112,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597952806
    },
    {
        "content": "<p>(<a href=\"#narrow/stream/113488-general/topic/Substructures.20for.20structures.20without.20synecdoche\">Here's the thread on synecdoche</a>).</p>",
        "id": 207566136,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597952822
    },
    {
        "content": "<p>I posted about some of the design on <a class=\"stream\" data-stream-id=\"252551\" href=\"/#narrow/stream/252551-graph-theory\">#graph theory</a> (a private stream anyone can be added to).  I'll repost it here:</p>\n<p>The definition in the <code>simple_graphs2</code> branch sort of came out of the following design process.  Let's say you started with this definition of a simple graph:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>and then you define spanning subgraphs on a given graph (i.e., subgraphs with all the vertices) by something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">spanning_subgraph</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">prop</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">),</span> <span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span> <span class=\"bp\">→</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>One basic definition for simple graphs is the set of neighboring vertices:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">adj</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>However, if you have a <code>spanning_subgraph G</code>, you cannot use <code>neighbor_set</code> directly -- you would need some coercion.  Let's define an interface for this.  While you could try using <code>has_coe</code>, there is a typeclass inference problem: <code>has_coe a b</code> is a function of both <code>a</code> and <code>b</code>, so you would need to specify type hints to get it to coerce correctly (plus, we won't gain any benefits from Lean's automatic coercion features).  This is not so bad for spanning subgraphs, but it is not so good for subgraphs since the vertex type needs to be referred to as the vertex subset coerced to a type.  To make it so <code>b</code> is a function of <code>a</code>, we can define our own coercion class:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_simple_graph</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>Then, for example,</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">spanning_subgraph</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">to_simple_graph</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">G&#39;</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">adj</span><span class=\"o\">,</span>\n    <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n    <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">loopless</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">G&#39;</span><span class=\"bp\">.</span><span class=\"n\">prop</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>However, we cannot yet do <code>neighbor_set G' v</code> for <code>G' : spanning_subgraph G</code>, since it is not literally a graph.  Let's define some accessor functions to get some <code>simple_graph</code> fields for coerceable terms and use them to define the <code>neighbor_set</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_coe_to_simple_graph</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">has_coe_to_simple_graph</span><span class=\"bp\">.</span><span class=\"n\">V</span> <span class=\"n\">G</span>\n<span class=\"n\">def</span> <span class=\"n\">adj</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">has_coe_to_simple_graph</span><span class=\"bp\">.</span><span class=\"n\">to_simple_graph</span> <span class=\"n\">G</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">adj</span>\n\n<span class=\"n\">def</span> <span class=\"n\">neighbor_set</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>While <code>spanning_subgraph G</code> is not a <code>simple_graph</code> <em>per se</em>, you can interact with it as if it were one.</p>\n<p>This might be an OK interface as it is, but there is a simplification to this.  If we were to take the fields of <code>simple_graph</code> and put them into <code>has_coe_to_simple_graph</code>, then we would have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_coe_to_simple_graph</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"n\">G</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">symmetric</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">irreflexive</span> <span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"n\">G</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>This is the class <code>simple_graphs</code> that I had mentioned last week!  A weird thing about it, though, is how every field is a function.  What if we lifted the <code>G</code> argument out?  Let's also rename this class <code>simple_graph</code>.  We would obtain</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">simple_graph</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">adj</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">loopless</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">adj</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This is the definition in the <code>simple_graphs2</code> branch.  It is the result of  flattening the coercion class and the definition of the structure.  This lets us not have to redefine all the fields using accessor functions that depend on a coercion class: the members of this class <em>are</em> the accessor functions.  </p>\n<p>In the <code>has_coe_to_simple_graph</code> approach, note that to make things generic with respect to all things that are graph-like, lemmas and definitions would have to be in terms of the accessor functions anyway, so you would never refer to fields of <code>simple_graph</code>.  Thus, you lose nothing by folding it all in and defining this <code>simple_graph</code> class.</p>\n<p>One caveat is that to define a simple graph from a particular relation, you need a \"tautological\" instance:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">simple_graph_on</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"n\">V</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"n\">symmetric</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">irrefl</span> <span class=\"o\">:</span> <span class=\"n\">irreflexive</span> <span class=\"n\">rel</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">simple_graph_on</span><span class=\"bp\">.</span><span class=\"n\">simple_graph</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph_on</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">simple_graph</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">V</span> <span class=\"o\">:=</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">adj</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"o\">,</span>\n  <span class=\"n\">symm</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span>\n  <span class=\"n\">loopless</span> <span class=\"o\">:=</span> <span class=\"n\">G</span><span class=\"bp\">.</span><span class=\"n\">irrefl</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Another caveat is that different graphs have vertex types that are referred to differently, even if the vertex types are definitionally equal.  For graphs on the same vertex type, you would probably want to use the type <code>simple_graph_on V</code>.  One could define a bounded lattice instance for this.</p>",
        "id": 207566407,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597952977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span>  - does your graph code handle contracting edges? That is a classic example where the wrong definitions can cause trouble</p>",
        "id": 207566434,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597952997
    },
    {
        "content": "<p>I haven't gotten to that part exactly, though there is some hastily written <code>sorry</code>'d code.  I hestitate because I'm only used to edge contraction for multigraphs, which haven't been implemented yet.</p>",
        "id": 207566578,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597953063
    },
    {
        "content": "<p>Quick question - how do I go from a type E to the associated set?</p>",
        "id": 207567606,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597953584
    },
    {
        "content": "<p>Are you looking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.univ\">docs#set.univ</a> ?</p>",
        "id": 207567767,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1597953652
    },
    {
        "content": "<p>There's also <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.univ\">docs#finset.univ</a> to get a finset from a fintype.</p>",
        "id": 207568242,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1597953884
    },
    {
        "content": "<p>That's what I thought, but in <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> 's code, I am trying to define contraction (some matroid on ground set E \\ C) and I am getting a problem. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"err\">$</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">coe</span><span class=\"o\">,</span>\n  <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R1</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">card_image_le</span><span class=\"o\">,</span>\n  <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R2</span> <span class=\"err\">$</span> <span class=\"n\">image_subset_image</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">image_inter</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">R3</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>Now I want to add the line </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">contraction</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroid</span> <span class=\"o\">(</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"err\">\\</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">...</span> <span class=\"n\">foo</span> <span class=\"bp\">...</span><span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>But the argument of the second <code>matroid</code> gives a type mismatch error. I can't see why I can't get away with the above where the F works fine in Kenny's code.</p>",
        "id": 207570525,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1597955284
    },
    {
        "content": "<p><code>set.univ</code> does not have explicit arguments (I think the error message tells you this)</p>",
        "id": 207570641,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597955358
    },
    {
        "content": "<p>also we prefer <code>C\\^c</code> for complement of <code>C</code></p>",
        "id": 207570658,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1597955365
    },
    {
        "content": "<p>Here's a variation in the design space.  You have a <code>matroid_on</code> structure for matroids on a specific <code>E</code> type, and then you have a <code>matroids</code> class that gives terms of a type the structure of a matroid -- it could also be called the unwieldy <code>has_coe_to_matroid</code>.  Then you define accessor functions that, for <code>{α : Type v} [matroids α]</code>, give you the fields of the term's matroid structure.  Then you prove statements about matroids <code>M : α</code>.</p>\n<p>I gave an implementation of submatroids and a partial implementation of contracted matroids following this pattern.  (There are many missing simp lemmas that make this more useable.)  Having a separate type for matroid contractions of a given matroid might seem odd, but maybe it's useful to formalize that contracted matroids are in correspondence to submatroids of the dual (I don't actually know matroid theory -- fill in the correct statement if there is one <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finset</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid_on</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">R3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">matroids</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">to_matroid</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">matroid_on</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">matroid_on</span><span class=\"bp\">.</span><span class=\"n\">matroids</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroids</span> <span class=\"o\">(</span><span class=\"n\">matroid_on</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n  <span class=\"n\">to_matroid</span> <span class=\"o\">:=</span> <span class=\"n\">id</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">matroid</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">matroids</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"c1\">-- Accessor functions for terms that have a matroid representation</span>\n<span class=\"n\">def</span> <span class=\"n\">E</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">matroids</span><span class=\"bp\">.</span><span class=\"n\">E</span> <span class=\"n\">M</span>\n<span class=\"n\">def</span> <span class=\"n\">r</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">matroids</span><span class=\"bp\">.</span><span class=\"n\">to_matroid</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">r</span> <span class=\"n\">X</span>\n<span class=\"n\">def</span> <span class=\"n\">R1</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">matroids</span><span class=\"bp\">.</span><span class=\"n\">to_matroid</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R1</span> <span class=\"n\">X</span>\n<span class=\"n\">def</span> <span class=\"n\">R2</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⊆</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">matroids</span><span class=\"bp\">.</span><span class=\"n\">to_matroid</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R2</span> <span class=\"n\">h</span>\n<span class=\"n\">def</span> <span class=\"n\">R3</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∪</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">∩</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span> <span class=\"n\">X</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">matroids</span><span class=\"bp\">.</span><span class=\"n\">to_matroid</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">R3</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">delete</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">submatroid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">submatroid</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">F</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">submatroid</span><span class=\"bp\">.</span><span class=\"n\">matroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroids</span> <span class=\"o\">(</span><span class=\"n\">submatroid</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span> <span class=\"n\">M&#39;</span><span class=\"bp\">.</span><span class=\"n\">F</span><span class=\"o\">,</span>\n  <span class=\"n\">to_matroid</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">),</span>\n    <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"o\">(</span><span class=\"n\">R1</span> <span class=\"n\">M</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">card_image_le</span><span class=\"o\">,</span>\n    <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">R2</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">image_subset_image</span> <span class=\"n\">hs</span><span class=\"o\">),</span>\n    <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s₁</span> <span class=\"n\">s₂</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">image_union</span><span class=\"o\">,</span> <span class=\"n\">image_inter</span><span class=\"o\">],</span> <span class=\"n\">apply</span> <span class=\"n\">R3</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">matroid_contraction</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">contract</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">matroid_contraction</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">matroid_contraction</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">C</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">matroid_contraction</span><span class=\"bp\">.</span><span class=\"n\">matroid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">matroids</span> <span class=\"o\">(</span><span class=\"n\">matroid_contraction</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">E</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span> <span class=\"err\">↥</span><span class=\"o\">((</span><span class=\"err\">↑</span><span class=\"n\">M&#39;</span><span class=\"bp\">.</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">))</span><span class=\"err\">ᶜ</span><span class=\"o\">),</span>\n  <span class=\"n\">to_matroid</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"err\">∪</span> <span class=\"n\">M&#39;</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"n\">M&#39;</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"o\">,</span>\n    <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n      <span class=\"n\">convert_to</span> <span class=\"bp\">_</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">,</span> <span class=\"n\">symmetry</span><span class=\"o\">,</span>\n      <span class=\"n\">apply</span> <span class=\"n\">card_image_of_injective</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val_injective</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">disjoint</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">image</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"n\">M&#39;</span><span class=\"bp\">.</span><span class=\"n\">C</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">h₃</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">exfalso</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h₁</span> <span class=\"n\">h₃</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span><span class=\"o\">,</span>\n    <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n    <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">matroid</span>\n</code></pre></div>",
        "id": 207577923,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597959756
    },
    {
        "content": "<p>For those who are somewhat familiar with the definition of simple graphs in <code>mathlib:simple_graphs2</code>, I'd appreciate any thoughts you might have in comparing these two patterns.  They feel pretty much the same to use, but with the above you speak of an arbitrary matroid using</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">matroids</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but with the <code>mathlib:simple_graphs2</code> approach, you'd speak of an arbitrary matroid using</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">matroid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>The first approach opens you up to the possibility of extending the <code>matroids</code> typeclass to add additional constraints to either the matroids, or even doing wild stuff like putting a topology on <code>α</code> and saying how the matroid structures are continuously defined (as a made-up example).</p>",
        "id": 207578460,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597960182
    },
    {
        "content": "<p>And, by the way, if Lean had a way to let you prove things about <code>matroid_on</code> and have them automatically apply to anything with the <code>matroids</code> coercion typeclass, then there would be different design considerations here.</p>",
        "id": 207578653,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1597960333
    },
    {
        "content": "<p>I really like this, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> - it feels very natural to be able to extract either the ground set E or the rank function r from a given matroid M, and to have the ground set implemented as a finset rather than a type. (I think) because I am new to the syntax of lean, I don't understand the reason for having a separate  structure just for contractions. Will it be possible when using this code to consider a matroid and to not care that it happened to arise from a contraction?</p>",
        "id": 207626907,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1598012085
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"329425\">@Peter Nelson</span> I'm not sure what you are referring to exactly when you say \"it feels very natural [...] to have the ground set implemented as a finset rather than a type,\" since the implementation above is using a type for <code>E M</code>, so maybe you're speaking from your other experiences.</p>\n<p>For the type of contractions, I imagined you might have the following sort of statement (if it's true! I'm just guessing):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">dual</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">matroid_on</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">univ</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∉</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">-</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">)),</span>\n  <span class=\"n\">R1</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">R2</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">R3</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">dual_equiv</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">M</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">matroid_contraction</span> <span class=\"n\">M</span> <span class=\"err\">≃</span> <span class=\"n\">submatroid</span> <span class=\"o\">(</span><span class=\"n\">dual</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>Even if there's no such statement, it is potentially useful having a <code>matroid_contraction</code> structure to organize proofs and definitions specifically about contractions, and it saves you from having to write <code>↥((↑C : set (E M))ᶜ)</code> in lemma statements.  You'll have to experiment and see, though.</p>\n<blockquote>\n<p>Will it be possible when using this code to consider a matroid and to not care that it happened to arise from a contraction</p>\n</blockquote>\n<p>Yes, the way the pattern works is that \"consider a matroid\" is written <code>{α : Type v} [matroids α] (M : α)</code>.  This lets you not care about the way in which a matroid was constructed.  In a proof you can write <code>let M' := contract M C</code> and even though <code>M' : matroid_contraction M</code>, you can interact with <code>M'</code> as a matroid because it implements the <code>matroids</code> typeclass.</p>",
        "id": 207662798,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598031920
    },
    {
        "content": "<blockquote>\n<p>This lets you not care about the way in which a matroid was constructed.</p>\n</blockquote>\n<p>Well, you still have to care that the matroid was constructed via the rank axioms as opposed to e.g. the independent set axioms.</p>",
        "id": 207667776,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1598034521
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> . All I meant with E is that your axioms allow me to easily access a finset that is the ground set, rather than calling it a fintype. If I weren't about to go away on holiday, I would be refactoring my code like mad with your implementation. </p>\n<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> , my plan is to have the rank function as the base definition, and then prove the equivalences to the other definitions as theorems, and use defs to allow construction from circuits, indep, etc . I am not a fan of having competing types.</p>",
        "id": 207672323,
        "sender_full_name": "Peter Nelson",
        "timestamp": 1598036939
    },
    {
        "content": "<p>Yes, in hindsight I think that's probably a better way to organize things.</p>",
        "id": 207701660,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1598060919
    },
    {
        "content": "<p>I guess with this <code>matroids</code> class, you can give the other definitions as structures (maybe make them <code>protected</code> so someone would have to go out of their way to use them), give them <code>matroids</code> instances, define maps from the base definition to these alternative definitions, then prove each map and the <code>to_matroid</code> function together form a matroid isomorphism.  Lastly, you use these to pull the alternative axioms back to the base type.  (I might call this design \"star-shaped\".)  This gives precision to the statements that these other definitions are indeed equivalent.</p>\n<p>Since they all would implement the <code>matroids</code> class, you could actually use the structures as the way you construct matroids using the other definitions, since they would be automatically related to the base definition.  A <code>def</code> to do this would be superfluous at this point.</p>",
        "id": 207703761,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1598064330
    }
]
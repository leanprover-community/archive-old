[
    {
        "content": "<p>I need practical advice. As part of his work on group cohomology, <span class=\"user-mention\" data-user-id=\"243895\">@Shenyang Wu</span>  has three complexes of groups and a short exact sequence between those complexes, and he needs the standard result that we have an induced long exact sequence of cohomology. He is going to end up writing code which looks like the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">has_le</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">add_subgroup</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"c1\">-- actual def suppressed</span>\n\n<span class=\"n\">def</span> <span class=\"n\">monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">ker</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- actual def suppressed</span>\n\n<span class=\"n\">def</span> <span class=\"n\">subquotient</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- subgroup Y/X</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">subquotient</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span> <span class=\"n\">set</span> <span class=\"n\">monoid_hom</span>\n\n<span class=\"kn\">variables</span>\n  <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">dA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">dB</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">dC</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">B</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">dA</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">dB</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">B</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">C</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">dB</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">dC</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">exact1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">exact2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">exact3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">surjective</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"c1\">--include exact1 exact2 etc etc</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">add_comm_group</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">H</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">n</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">dA</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">A</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">subquotient</span> <span class=\"o\">(</span><span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">dA</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">dA</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">LES1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"n\">dA</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">H</span> <span class=\"n\">dB</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">LES2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"n\">dB</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">H</span> <span class=\"n\">dC</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">LES3</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"n\">dC</span> <span class=\"n\">n</span> <span class=\"bp\">→+</span> <span class=\"n\">H</span> <span class=\"n\">dA</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">exact1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">LES1</span> <span class=\"n\">dA</span> <span class=\"n\">dB</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">LES2</span> <span class=\"n\">dB</span> <span class=\"n\">dC</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">exact2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">LES2</span> <span class=\"n\">dB</span> <span class=\"n\">dC</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">LES3</span> <span class=\"n\">dA</span> <span class=\"n\">dC</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">exact3</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">LES3</span> <span class=\"n\">dA</span> <span class=\"n\">dC</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">LES1</span> <span class=\"n\">dA</span> <span class=\"n\">dB</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>Indeed, once the sorries are gone, he's basically finished his project.</p>\n<p>Now it would be nice to have such a result in mathlib but I am beginning now to think that this is the time to start using category theory. Would I be right in thinking that mathlib would not be particularly interested in a formalisation of the result as it stands above? </p>\n<p>I guess the correct generality for this result is to use <code>succ_str</code>instead of nat (any type with a successor function) and to formalise everything in the context of...what? Do we have abelian categories in mathlib? Is it even worth doing this in <code>Ab</code> or is even this unwise? People will want it for R-mod soon enough.</p>",
        "id": 190593168,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584185484
    },
    {
        "content": "<p>I'm afraid I can't give advice... I can only say that I ran into some DTT annoyances when I tried to build complexes and exact sequences in <code>Ab</code>.</p>",
        "id": 190593485,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584185986
    },
    {
        "content": "<p>But did you notice that I only ever added 1? My impression is that the DTT annoyances show up when <code>a + b</code> isn't defeq to <code>b + a</code>. For the result above I only need <code>succ n</code> so I am cautiously optimistic. Can you remember any more details about your problems? <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> suggested I use <code>succ_str</code> when we were talking about this in Bonn (because actually I want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mord\">1</span></span></span></span>-cocycles to be 0 so I can say things about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup></mrow><annotation encoding=\"application/x-tex\">H^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span>) but my memory with the dga exercise was that we wanted much more than what I need above.</p>",
        "id": 190594181,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187074
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/CDGAs/near/167848869\" title=\"#narrow/stream/116395-maths/topic/CDGAs/near/167848869\">link to CDGA conversation</a></p>",
        "id": 190594369,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187221
    },
    {
        "content": "<p>I think the problem there was the multiplication map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>×</mo><msub><mi>A</mi><mi>j</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mi>j</mi></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_i\\times A_j\\to A_{i+j}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 190594378,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187259
    },
    {
        "content": "<p>Regarding abelian categories: As far as I know, we are waiting for <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>'s work on enriched categories until work on abelian categories in mathlib can start. I have defined abelian categories over at <a href=\"https://github.com/TwoFX/lean-homological-algebra\" target=\"_blank\" title=\"https://github.com/TwoFX/lean-homological-algebra\">https://github.com/TwoFX/lean-homological-algebra</a> as part of my (ongoing) BSc project with <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> and have proved some results about them, but it is currently completely unpolished.</p>",
        "id": 190594404,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584187298
    },
    {
        "content": "<p>I know what an abelian category is but I do not know what an enriched category is. Why can't we just define abelian categories as some typeclass on categories? Oh -- enriched means that the hom sets have extra structure like an ab group?</p>",
        "id": 190594582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187473
    },
    {
        "content": "<p>oh wooah, thanks for that link, you have done a ton of stuff.</p>",
        "id": 190594613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187542
    },
    {
        "content": "<p>Oh I see, so this is a genuine hold-up? Are you saying that we don't have the definition of an additive category in mathlib? This sort of project would be perfect for finding out what kind of an API is needed for such definitions. Are you going to do the long exact sequence result I mention above? After I talked to Sebastian I talked to <span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> for a while about how to do this sort of thing in Lean -- he did a bunch of homological algebra in Lean 2 for his thesis.</p>",
        "id": 190594764,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594613\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594613\">said</a>:</p>\n<blockquote>\n<p>oh wooah, thanks for that link, you have done a ton of stuff.</p>\n</blockquote>\n<p>Like I said, it really needs a ton of cleanup (which I am going to do in the coming days). The goal is to develop a tactic that can prove diagram lemmas like the five lemma or the snake lemma in abelian categories by chasing pseudoelements.</p>",
        "id": 190594769,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584187775
    },
    {
        "content": "<p>That sounds really ambitious!</p>",
        "id": 190594809,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584187801
    },
    {
        "content": "<p>That would be wonderful!</p>",
        "id": 190594881,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584187842
    },
    {
        "content": "<p>The current prototype of the tactic already works on modules. The following code successfully proves the four lemma:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">four</span> <span class=\"o\">(</span><span class=\"n\">hα</span> <span class=\"o\">:</span> <span class=\"n\">range</span> <span class=\"n\">α</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hβ</span> <span class=\"o\">:</span> <span class=\"n\">ker</span> <span class=\"n\">β</span> <span class=\"bp\">=</span> <span class=\"err\">⊥</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hδ</span> <span class=\"o\">:</span> <span class=\"n\">ker</span> <span class=\"n\">δ</span> <span class=\"bp\">=</span> <span class=\"err\">⊥</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ker</span> <span class=\"n\">γ</span> <span class=\"bp\">=</span> <span class=\"err\">⊥</span> <span class=\"o\">:=</span>\n<span class=\"n\">ker_eq_bot&#39;</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">c</span> <span class=\"n\">hc</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">chase</span> <span class=\"n\">c</span> <span class=\"o\">[</span><span class=\"n\">hc</span><span class=\"o\">]</span> <span class=\"kn\">using</span> <span class=\"o\">[</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">f&#39;</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"k\">with</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span> <span class=\"n\">a&#39;</span> <span class=\"n\">a</span> <span class=\"n\">only</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</pre></div>",
        "id": 190594898,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584187878
    },
    {
        "content": "<p>(After many lines of declaring variables)</p>",
        "id": 190594904,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584187902
    },
    {
        "content": "<p>But the killer test would be to try bring it down from the <code>category_theory</code> folder to some concrete stuff (for instance group cohomology or singular cohomology).</p>",
        "id": 190594907,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584187909
    },
    {
        "content": "<p>The example you pasted above seems to be already concrete. Is it linked in any way with the abstract non-sense?</p>",
        "id": 190594961,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584187966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594961\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594961\">said</a>:</p>\n<blockquote>\n<p>The example you pasted above seems to be already concrete. Is it linked in any way with the abstract non-sense?</p>\n</blockquote>\n<p>Not yet. This is the prototype of the diagram chasing strategy that only works for modules. I am going to port it to abelian categories in the next few days. I do have a (manual) proof of the four lemma in abelian categories (see <code>abfour.lean</code>) and I do have a (very very very messy) proof that the the category <code>Module R</code> is abelian (see the bottom of <code>modules.lean</code>).</p>",
        "id": 190595032,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584188082
    },
    {
        "content": "<p>what does the <code>chase</code> tactic do exactly?</p>",
        "id": 190595318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584188492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594764\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190594764\">said</a>:</p>\n<blockquote>\n<p>Oh I see, so this is a genuine hold-up? Are you saying that we don't have the definition of an additive category in mathlib? This sort of project would be perfect for finding out what kind of an API is needed for such definitions. Are you going to do the long exact sequence result I mention above?</p>\n</blockquote>\n<p>That is right, there are no additive categories in mathlib, but <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is working on enriched categories which have additive categories as a special case (I think): see the <code>enriched</code> branch. My project will not contain any cohomology (it's only about defining abelian categories and (automatically) chasing pseudoelements).</p>",
        "id": 190595337,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584188518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595318\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595318\">said</a>:</p>\n<blockquote>\n<p>what does the <code>chase</code> tactic do exactly?</p>\n</blockquote>\n<p>It chases an element along a given list of morphisms by appropriately using surjectivity and exactness assumptions. When it needs to find a preimage of some element <code>b</code> under a map <code>f</code> and it finds some assumption of the form <code>range f = ker g</code>, it will try to prove <code>g b = 0</code> automatically. It does this by generating a ton of hypothesis about all elements it comes across and doing a depth-first search over those hypotheses while taking injective maps into account. It is very specific to diagram lemmas like the five lemma and not smart at all, but tries to exploit the fact that in the proofs of these lemmas, \"there is really only one thing to do at every point\" (at least that is what mathematicians claim).</p>",
        "id": 190595717,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584189016
    },
    {
        "content": "<p>The first thing I did when I started using Lean was prove the 5 lemma. I think it was an excellent exercise for beginners (-;</p>",
        "id": 190595792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584189168
    },
    {
        "content": "<p>isn't there a small finite number of diagram lemmas though?</p>",
        "id": 190595798,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584189195
    },
    {
        "content": "<p>seems like it would be easier to just prove them all</p>",
        "id": 190595803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584189216
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595803\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190595803\">said</a>:</p>\n<blockquote>\n<p>seems like it would be easier to just prove them all</p>\n</blockquote>\n<p>Probably. I'm not saying that this is how diagram lemmas should be proven once they appear in mathlib. I just thought it would be fun to write a tactic.</p>",
        "id": 190595949,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584189366
    },
    {
        "content": "<p>I will be curious to see what the pseudoelement version of this tactic looks like</p>",
        "id": 190595966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584189453
    },
    {
        "content": "<p>As long as the proof for modules doesn't need subtraction, it won't look much different, except that instead of <code>ker_eq_bot</code> it will use <code>mono_iff_injective_on_pseudoelements</code> etc. (This is why pseudoelements are so useful). When there is subtraction involved, things get a little tricky (but the module prototype doesn't do subtraction either). Pseudoelements don't form an abelian group, but there's a construction that is like subtracting pseudoelements in some ways. I am currently not sure whether this is strong enough to prove the epi version of the four lemma in abelian categories. The usual way to prove the epi version is \"by duality, the epi version follows from the mono version\", but as far as I can tell, arguing using duality isn't really supported in the Lean category theory library at the moment.</p>",
        "id": 190596211,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584189905
    },
    {
        "content": "<p>It's <code>to_additive</code> all over again, but this time with the added complication that arrow composition gets reversed</p>",
        "id": 190597308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584192209
    },
    {
        "content": "<p>What's the problem with applying the category theorem to <code>opposite A</code> and then rewriting everything away?</p>",
        "id": 190597362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584192314
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190597362\" title=\"#narrow/stream/116395-maths/topic/long.20exact.20sequence.20of.20cohomology/near/190597362\">said</a>:</p>\n<blockquote>\n<p>What's the problem with applying the category theorem to <code>opposite A</code> and then rewriting everything away?</p>\n</blockquote>\n<p>I tried this, but I only got as far as showing that <code>opposite A</code> is a preadditive category if <code>A</code> is until I came to the conclusion that this is impratical. The proof was on the order of 70 lines.</p>",
        "id": 190597481,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1584192525
    },
    {
        "content": "<p>That we don't have all those rewrite lemmas at the moment</p>",
        "id": 190597482,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584192528
    },
    {
        "content": "<p>If so that's a pretty significant hole in the category theory library. I definitely expect there to be a theorem that a mono in <code>opposite A</code> is an epi in <code>A</code>, a product in <code>opposite A</code> is a coproduct in <code>A</code>, and so on. Not having that is like not having the theorem <code>-(a + b) = -a + -b</code></p>",
        "id": 190597946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584193406
    },
    {
        "content": "<p>Yes, there is a gaping hole regarding duality. :-(</p>",
        "id": 190602522,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584201631
    },
    {
        "content": "<p>The hole might be larger than what is there</p>",
        "id": 190603868,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584203965
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> this <code>enriched</code> branch is getting pretty big and clearly a bunch of it works but there are also some <code>sorry</code>s. Can I help? Is there any way part of it can be PR'ed, to get the ball rolling? I would like abelian categories for several distinct reasons.</p>",
        "id": 190606476,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584208132
    },
    {
        "content": "<p>A lot of it is irrelevant: it was me trying to be fancy and do categories enriched in something general, rather than the useful situation of categories enriched in a concrete category.</p>",
        "id": 190606495,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208179
    },
    {
        "content": "<p>Let me slice it up asap.</p>",
        "id": 190606497,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208186
    },
    {
        "content": "<p>I would really like to have the fact that the forgetful functor from (Module R) to AddCommGroup is lax monoidal. This is only just now possible to do, and is meant to happen in <code>src/category_theory/enriched/examples.lean</code>.</p>",
        "id": 190606568,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208278
    },
    {
        "content": "<p>If you wanted to have a look, the sorries in that file are the next thing to work on, in order to be able to test my enriched categories design.</p>",
        "id": 190606578,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208307
    },
    {
        "content": "<p>\"Enriched\" means what? The hom sets are objects of some other category? And then some compatibility with compostion?</p>",
        "id": 190606627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584208345
    },
    {
        "content": "<p>Oh I guess I can just read the code and see what it means :-)</p>",
        "id": 190606629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584208357
    },
    {
        "content": "<p>I had masses of plans for the easter break and they have all fallen through! I need things to do :-)</p>",
        "id": 190606641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584208389
    },
    {
        "content": "<p>Yes, that's exactly what enriched means.</p>",
        "id": 190606798,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208650
    },
    {
        "content": "<p>(Enriched potentially means that you don't have have hom _sets_, just an object in some other category whose objects doesn't necessarily have underlying sets. That's _not_ what we're going to do today, and I just deleted all the work on that from <code>enriched</code>, and moved it to a separate branch <code>enriched_abstract</code>.)</p>",
        "id": 190606858,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208720
    },
    {
        "content": "<p>The key example to think about is of course being enriched in <code>Ab</code>.</p>",
        "id": 190606874,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208739
    },
    {
        "content": "<p>The first key definition is a <code>concrete_monoidal_category</code>, which is a monoidal category, which is concrete (i.e. has a faithful functor to <code>Type</code>), and the forgetful functor is _lax_ monoidal.</p>",
        "id": 190606960,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208856
    },
    {
        "content": "<p>Lax monoidal means you don't have to take tensor products to tensor products, but you do have to have a map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊗</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(X) \\otimes F(Y) \\to F (X \\otimes Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 190606976,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208904
    },
    {
        "content": "<p>Let's check what that is for <code>Ab</code>: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(X)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span></span></span></span> is just the underlying type, and the \"laxerator\" is just the map building a pure tensor: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>↦</mo><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">(x,y) \\mapsto x \\otimes y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>.</p>",
        "id": 190607035,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584208963
    },
    {
        "content": "<p>Next we're going to define what it means for a category to be \"enriched over V\", where <code>V</code> is one of these <code>concrete_monoidal_category</code>s.</p>",
        "id": 190607047,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209004
    },
    {
        "content": "<p>So we have:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">v</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">[</span><span class=\"err\">𝒱</span> <span class=\"o\">:</span> <span class=\"n\">concrete_monoidal_category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒱</span> <span class=\"err\">𝒞</span>\n\n<span class=\"n\">class</span> <span class=\"n\">enriched_over</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">e_hom</span>   <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"kn\">notation</span> <span class=\"n\">X</span> <span class=\"bp\">`</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"n\">Y</span><span class=\"o\">:</span><span class=\"mi\">10</span> <span class=\"o\">:=</span> <span class=\"n\">e_hom</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">e_id</span>    <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span><span class=\"bp\">_</span> <span class=\"n\">V</span> <span class=\"err\">⟶</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">X</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"kn\">notation</span> <span class=\"bp\">`</span> <span class=\"mi\">𝟙</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">e_id</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">e_comp</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"err\">⊗</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"err\">⟶</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Z</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">e_hom_forget</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"err\">≃</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">e_id_forget</span>  <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">e_hom_forget</span> <span class=\"n\">X</span> <span class=\"n\">X</span> <span class=\"o\">(</span><span class=\"n\">as_term</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">e_comp_forget</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">forget</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"err\">⟶</span><span class=\"o\">[</span><span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"n\">Z</span><span class=\"o\">)),</span>\n  <span class=\"n\">e_hom_forget</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span> <span class=\"err\">≫</span> <span class=\"n\">e_hom_forget</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">e_hom_forget</span> <span class=\"n\">X</span> <span class=\"n\">Z</span> <span class=\"o\">((</span><span class=\"n\">forget</span> <span class=\"n\">V</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">e_comp</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">forget</span><span class=\"bp\">.</span><span class=\"n\">μ</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 190607062,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209024
    },
    {
        "content": "<p>This says...</p>",
        "id": 190607068,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209032
    },
    {
        "content": "<p><code>e_hom</code> gives us an object in <code>V</code> for each pair of objects in <code>C</code>, and we introduce notation <code>X ⟶[V] Y</code> for this.</p>",
        "id": 190607111,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209060
    },
    {
        "content": "<p>(that is, <code>X ⟶ Y</code> will continue to mean the plain type of morphisms, while <code>X ⟶[V] Y</code> will be the bundled abelian group, or whatever)</p>",
        "id": 190607122,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209092
    },
    {
        "content": "<p>I'm staring at the definition of monoidal category right now and realising how subtle it all is. I don't know this stuff.</p>",
        "id": 190607148,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209139
    },
    {
        "content": "<p>Then we need enriched identities and enriched composition, which will be morphisms in <code>V</code>.</p>",
        "id": 190607150,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209140
    },
    {
        "content": "<p>The enriched identity is just a <code>V</code>-morphism <code>𝟙_ V ⟶ (X ⟶[V] X)</code>. We could probably simplify this even further if we restricted to the case where the forgetful functor from <code>V</code> to <code>Type</code> is assumed to be representable --- as it is for <code>Ab</code>, of course.</p>",
        "id": 190607217,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209220
    },
    {
        "content": "<p>The enriched composition is a <code>V</code>-morphism <code>(X ⟶[V] Y) ⊗ (Y ⟶[V] Z) ⟶ (X ⟶[V] Z)</code>, i.e., in the <code>Ab</code> case, a bilinear map.</p>",
        "id": 190607228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209248
    },
    {
        "content": "<p>Then we need an identification before the type underlying <code>X ⟶[V] Y</code> and <code>X ⟶ Y</code> itself. I wish there was a way to insist these were definitionally equal, but I think there just isn't, so we need to keep track of this iso.</p>",
        "id": 190607278,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209310
    },
    {
        "content": "<p>I'm still stuck at lax monoidal. If I have a faithful functor to <code>Type</code> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>⊗</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">X\\otimes Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> doesn't make sense.</p>",
        "id": 190607285,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209339
    },
    {
        "content": "<p>After that we need the identities saying that the enriched identity and enriched composition descend to the original one at the type level.</p>",
        "id": 190607292,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209356
    },
    {
        "content": "<p>Depends on what <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span> means</p>",
        "id": 190607293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584209358
    },
    {
        "content": "<p>Yes --- in <code>Type</code> the monoidal structure is just going to be cartesian product.</p>",
        "id": 190607297,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209376
    },
    {
        "content": "<p>So lax monoidal just says we have a sensible function from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>Y</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊗</mo><mi>Y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(X) \\times F(Y) \\to F(X \\otimes Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>, which is the \"construct a pure tensor\" function.</p>",
        "id": 190607354,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209432
    },
    {
        "content": "<p>Got it.</p>",
        "id": 190607370,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209466
    },
    {
        "content": "<p>The axioms for \"lax monoidal\" are just saying that this is appropriately associative when we do threefold products, and natural in X and Y.</p>",
        "id": 190607372,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209476
    },
    {
        "content": "<p>I was just imagining you were going to be putting a typeclass structure on hom sets e.g. <code>[add_comm_group (X \\h Y)]</code></p>",
        "id": 190607440,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209632
    },
    {
        "content": "<p>Well, the problem is that we need to know that composition is a morphism in the appropriate category.</p>",
        "id": 190607494,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209706
    },
    {
        "content": "<p>This is a really complex set-up!</p>",
        "id": 190607495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209711
    },
    {
        "content": "<p>It may well be possible to do simpler things in special cases. :-) But I'm not keen to do this once for <code>add_comm_group</code>, and then again for <code>module R</code>, and then ...</p>",
        "id": 190607544,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209769
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 190607547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209784
    },
    {
        "content": "<p>We'll certainly provide that instance, when <code>V</code> is a bundled category.</p>",
        "id": 190607550,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209803
    },
    {
        "content": "<p>So you really will be able to write <code>f + g</code>.</p>",
        "id": 190607552,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209811
    },
    {
        "content": "<p>Is it common for a category to be \"enriched over itself\"?</p>",
        "id": 190607555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209814
    },
    {
        "content": "<p>Yes.</p>",
        "id": 190607557,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209820
    },
    {
        "content": "<p>And another route is to only do this.</p>",
        "id": 190607560,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209830
    },
    {
        "content": "<p>e.g. if R is a commutative ring I think this is how it works. But if R is a non-commutative ring then it's enriched in/over/by/with Ab</p>",
        "id": 190607563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209849
    },
    {
        "content": "<p>I don't know the right preposition :-)</p>",
        "id": 190607566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209859
    },
    {
        "content": "<p>I think \"over\" is the usual one here.</p>",
        "id": 190607610,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209887
    },
    {
        "content": "<p>and if C is a complex of R-modules with R commutative then C is probably enriched over R-mod</p>",
        "id": 190607611,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209890
    },
    {
        "content": "<p>so there seems to be no real benefit in self-enrichment</p>",
        "id": 190607616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209913
    },
    {
        "content": "<p>Well, there is even the Hom-complex, right?</p>",
        "id": 190607618,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584209920
    },
    {
        "content": "<p>aka internal hom</p>",
        "id": 190607619,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584209928
    },
    {
        "content": "<p>i.e. you can set it up but then you'd immediately want other stuff anyway</p>",
        "id": 190607620,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584209929
    },
    {
        "content": "<p>\"Categories enriched over themselves\" go by names like \"closed categories\", \"closed monoidal categories\", etc.</p>",
        "id": 190607623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209936
    },
    {
        "content": "<p>Yes, chain complexes also have internal hom, but you don't always want to think about that.</p>",
        "id": 190607633,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584209955
    },
    {
        "content": "<p>But you also don't always want to <em>not</em> think about it (-;</p>",
        "id": 190607636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584209978
    },
    {
        "content": "<p>I am thinking about Ext and Tor (for rings), it would be good to have these, but having spent some time thinking about this recently (and bearing in mind comments Chris always makes to me at Xena about doing things in the correct generality the first time around) I think that probably the thing to aim for is abelian categories.</p>",
        "id": 190607678,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584210005
    },
    {
        "content": "<p>Yes, we'll have to have two versions of chain complexes, one enriched over itself, and one enriched over something smaller.</p>",
        "id": 190607680,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210011
    },
    {
        "content": "<p>Yes...</p>",
        "id": 190607682,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210021
    },
    {
        "content": "<p>I think defining biproducts is a good easy step on the way to abelian categories.</p>",
        "id": 190607685,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210035
    },
    {
        "content": "<p>We're getting pretty close otherwise.</p>",
        "id": 190607686,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210047
    },
    {
        "content": "<p>I guess the dream situation would be that you write Ext and Tor once, and then magically they become abelian groups if R is a non-comm ring, and R-modules if it's commutative.</p>",
        "id": 190607691,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584210059
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 190607696,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210069
    },
    {
        "content": "<p>and even in number theory where almost everything is commutative, you still want group cohomology, and one way of doing this is ext and tor for the non-commutative group ring.</p>",
        "id": 190607706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584210112
    },
    {
        "content": "<p>Defining \"normal monomorphisms\" and \"normal epimorphisms\" needs to be done as well.</p>",
        "id": 190607776,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1584210231
    },
    {
        "content": "<p>What even are those</p>",
        "id": 190608120,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584210795
    },
    {
        "content": "<p>the kernel of an epimorphism is a normal monomorphism? ;-)</p>",
        "id": 190608125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584210830
    },
    {
        "content": "<p>OK, I guess in most cases (like in an abelian category) it is the same as regular monomorphism.</p>",
        "id": 190608260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584211043
    },
    {
        "content": "<p>Oh I was just guessing!</p>",
        "id": 190609429,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584213049
    },
    {
        "content": "<p>You were close enough</p>",
        "id": 190609442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584213099
    },
    {
        "content": "<p>Actually, it's the kernel of anything</p>",
        "id": 190609444,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584213112
    }
]
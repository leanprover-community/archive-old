[
    {
        "content": "<p>hey all, this is not lean related, so i thought the maths channel would be appropriate:<br>\ni'm implementing type theory (inspired by <a href=\"http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/\">http://math.andrej.com/2012/11/08/how-to-implement-dependent-type-theory-i/</a>).<br>\ni had a little problem when determining the type of a (dependent) pair term. the code was (roughly):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">Pair</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">terms</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">terms</span><span class=\"p\">.</span><span class=\"n\">as_ref</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\">     </span><span class=\"n\">ta</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">infer_term</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">tb</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">infer_term</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">shift</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">tb</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// delta, cut_off</span>\n<span class=\"w\">        </span><span class=\"n\">Sigma</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">((</span><span class=\"n\">ta</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tb</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>basically: infer the types of the sub-terms and construct a sigma type by shifting the second type (to account for the scope introduced by a sigma type).<br>\nthe problem was: obviously, the sigma type could never refer to its fst value. i'm using syntactic equality of reduced terms as definitional equality. to check types i use definitional equality (and u1 &lt;= u2 for sorts).<br>\nso if the type of snd depends on the value passed into fst, that information gets lost.<br>\ni have solved the problem by substituting the value <code>a</code> (shifted by one) in <code>tb</code> (after shifting) with <code>Var(0)</code>.<br>\nand now for why i'm posting this:<br>\ni'm not too comfortable with the solution.<br>\nfirst of all, sub-tree matching is pretty expensive, compared to the other operations in the type checker.<br>\nsecondly, i have not seen this \"trick\" anywhere else. the links to the code in the article are dead, but this seems to be the code from around that time: <a href=\"https://github.com/Andromedans/andromeda/blob/d7ec08f94331e1254dc4430607e7ea95b16a7f6f/typing.ml\">https://github.com/Andromedans/andromeda/blob/d7ec08f94331e1254dc4430607e7ea95b16a7f6f/typing.ml</a> they also shift the type of snd, but there is no substitution.<br>\nthe typing rule in mltt80 is: <code>(a: A) (b: B(a)) |- (a, b): (\\Sigma x: A)B(x)</code>. i interpret the presence of <code>x</code> as the same kind of information loss that i've experienced before my change.<br>\nin conclusion: my \"trick\" seems fishy to me. maybe someone knows how this problem (determining the (dependent) type of a pair) is usually handled in type checking kernels.</p>\n<p>edit: here is an example that failed to type check (due to mismatched de bruijn indices in the type of the pair (a, b) - argument to g at the end - specifically, b's type was referring to the parameter <code>a</code>, not the first value of the pair -- this is the lean equivalent)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">T</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span><span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)),</span> <span class=\"n\">f</span> <span class=\"n\">x.1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">:</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">g</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 271756151,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644773088
    },
    {
        "content": "<p>I'm sure someone else can give you a better survey of general solutions, but Lean uses locally nameless, which I think would solve this by replacing occurrences of <code>a</code> in <code>b</code> with <code>Local(ta, unique)</code> instead of <code>Var(0)</code>, and then the result would be <code>Sigma (x : ta), tb.abstract(locals)</code>.</p>",
        "id": 271760119,
        "sender_full_name": "Chris B",
        "timestamp": 1644779041
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"228466\">@Chris B</span> ! So this does appear to be a \"real\" problem that needs to be addressed in a type checker. I was mostly worried that I did something wrong, elsewhere in my code (which could of course still be the case :P).<br>\nFor now, I'm fine with my tree substitution thing. But if anyone else has something interesting about this topic, I'd of course still be interested!</p>",
        "id": 271760507,
        "sender_full_name": "Leonard Wiechmann",
        "timestamp": 1644779584
    }
]
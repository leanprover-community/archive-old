[
    {
        "content": "<p>The local Langlands conjectures for GL_n state the existence of a canonical bijection between some set and some other set of the same cardinality. The word \"canonical\" here was initially defined to mean \"we would like the bijection to have the following ten properties, and possibly some other properties too if we think of any that look useful and which we didn't mention yet\". It is now a theorem that there is exactly one bijection with these ten properties, so we're all good.</p>\n<p>I am interested in whether it is possible to turn the bijection into a computer program. Let me be more precise. I am kind of suspecting that it is not possible to do this, because I am kind of suspecting that it not even possible to define the two sides. But my understanding of this stuff is still hazy.</p>\n<p>One side involves continuous group homomorphisms from the group <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">a</mi><mi mathvariant=\"normal\">l</mi></mrow><mo>(</mo><msub><mover accent=\"true\"><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow></mrow><mo stretchy=\"true\">‾</mo></mover><mi>p</mi></msub><mi mathvariant=\"normal\">/</mi><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{Gal}(\\overline{\\mathbb{Q}}_p/\\mathbb{Q}_p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.241368em;vertical-align:-0.35247799999999996em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">a</span><span class=\"mord mathrm\">l</span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16667em;\"></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.08502200000000004em;\"><span style=\"top:-2.4836300000000002em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.35247799999999996em;\"></span></span></span></span></span><span class=\"mord mathrm\">/</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, a Galois group invoving the algebraic closure of the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">p</span></span></span></span>-adic numbers. The other side involves actions of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mrow><mi mathvariant=\"normal\">G</mi><mi mathvariant=\"normal\">L</mi></mrow><mi>n</mi></msub><mo>(</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathrm{GL}_n(\\mathbb{Q}_p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">G</span><span class=\"mord mathrm\">L</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> on infinite-dimensional complex vector spaces. Is this already enough to conclude that this is impossible constructively?</p>",
        "id": 168306931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560775800
    },
    {
        "content": "<p>I think the proof of the existence of algebraic closure invokes Zorn's lemma somewhere doesn't it? Or is there a constructive variant?</p>",
        "id": 168313073,
        "sender_full_name": "Koundinya Vajjha",
        "timestamp": 1560780373
    },
    {
        "content": "<p>Algebraic closure of a general field requires Zorn. Algebraic closure of the complex numbers does not!</p>",
        "id": 168313151,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560780434
    },
    {
        "content": "<p>There's a constructive variant for some fields. I guess Q and finite fields would be possible</p>",
        "id": 168313184,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560780456
    },
    {
        "content": "<p>Right. But what about Q_p?</p>",
        "id": 168313193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560780463
    },
    {
        "content": "<p>I would say almost certainly, because virtually everything is computable if you define it as a quotient by some horribly undecidable relation.</p>",
        "id": 168313375,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560780591
    },
    {
        "content": "<p>Is the question whether it's computable in the sense that addition on reals as quotient of cauchy sequences is computable, or whether it's computable in a practical sense?</p>",
        "id": 168313529,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560780699
    },
    {
        "content": "<p>The question is whether I can write a program which computes this canonical bijection in theory. I felt like the easiest way of answering it would be to convince myself that one can't even compute the two sets in theory.</p>",
        "id": 168321468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560786088
    },
    {
        "content": "<p>You can definitely compute actions of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mtext>GL</mtext><mi>n</mi></msub><mo>(</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{GL}_n(\\mathbb{Q}_p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord text\"><span class=\"mord mathrm\">GL</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> in theory. I think <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}_p}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.174998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span> is computable as well, you can algebraically close first and then complete right?</p>",
        "id": 168323787,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560787730
    },
    {
        "content": "<p>The <code>\\overline</code> doesn't work</p>",
        "id": 168323962,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560787824
    },
    {
        "content": "<p>Let's assume <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.05556em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.16667em;\"></span></span></span></span></span></span></span> is computable. We now want to complete with respect to a norm. But I don't know how to get that norm computably.</p>",
        "id": 168323963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560787823
    },
    {
        "content": "<p>The padic norm is computable right?</p>",
        "id": 168324018,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560787863
    },
    {
        "content": "<p>The problem is that there are many ways to extend the p-adic norm on the rationals to a norm on its algebraic closure.</p>",
        "id": 168324023,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560787868
    },
    {
        "content": "<p>Doesn't matter if the norm is computable, since you only need it to define a relation, which are always computable in Lean.</p>",
        "id": 168324059,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560787921
    },
    {
        "content": "<p>For example, in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[i]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\">i</span><span class=\"mclose\">]</span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>+</mo><mi>i</mi><mo>)</mo><mo>(</mo><mn>2</mn><mo>−</mo><mi>i</mi><mo>)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">(2+i)(2-i)=5</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">5</span></span></span></span> and the factors are coprime. So to extend the 5-adic norm to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span> you need to decide which one will have valuation 1 and which one valuation 0.</p>",
        "id": 168324108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560787930
    },
    {
        "content": "<p>And then you need to make infinitely many other such decisions in a compatible manner.</p>",
        "id": 168324126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560787945
    },
    {
        "content": "<p>In ideal-theoretic terms, 5 is no longer prime in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[i]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\">i</span><span class=\"mclose\">]</span></span></span></span>, it factors into two prime ideals <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>+</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(2+i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(2-i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span>, and more generally for number field you're going to have to factor the ideal <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(5)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">5</span><span class=\"mclose\">)</span></span></span></span> and then choose one of the factors, in a compatible way across all number fields.</p>",
        "id": 168324270,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788050
    },
    {
        "content": "<p>There are uncountably many ways of extending the 5-adic norm on the rationals to a norm on the algebraic closure of the rationals.</p>",
        "id": 168324322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788082
    },
    {
        "content": "<p>Choosing an arbitrary relation is fine according to Lean</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">,</span>\n  <span class=\"n\">equivalence</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"n\">b</span> <span class=\"n\">d</span><span class=\"o\">,</span>\n  <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">d</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"bp\">=</span><span class=\"o\">),</span> <span class=\"bp\">⟨</span><span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"bp\">*⟩</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">X_setoid</span> <span class=\"o\">:</span> <span class=\"n\">setoid</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">r</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">def</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">quotient</span> <span class=\"bp\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">r</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">--computable</span>\n<span class=\"n\">def</span> <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on₂</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"err\">⟦</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"err\">⟧</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"n\">hab</span> <span class=\"n\">hcd</span><span class=\"o\">,</span>\n    <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound</span> <span class=\"err\">$</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some_spec</span> <span class=\"n\">r</span><span class=\"bp\">._</span><span class=\"n\">proof_1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hab</span> <span class=\"n\">hcd</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 168324890,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788482
    },
    {
        "content": "<blockquote>\n<p>You can definitely compute actions of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mtext>GL</mtext><mi>n</mi></msub><mo>(</mo><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\text{GL}_n(\\mathbb{Q}_p)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.036108em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord text\"><span class=\"mord mathrm\">GL</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> in theory. I think <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}_p}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.174998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span> is computable as well, you can algebraically close first and then complete right?</p>\n</blockquote>\n<p>Nope, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}_p}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.174998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span> is not complete.</p>",
        "id": 168324926,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560788522
    },
    {
        "content": "<p>If we completed Q-bar then we could define Q_p-bar as the stuff in the completion which was algebraic over Q_p.</p>",
        "id": 168324986,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788554
    },
    {
        "content": "<p>But I'm not convinced we can complete Q-bar yet. However Chris' add post is a bit discomboulating.</p>",
        "id": 168325000,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788575
    },
    {
        "content": "<p>I'm completely confused. Why aren't the reals computable in Lean...</p>",
        "id": 168325293,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560788811
    },
    {
        "content": "<p>They are.</p>",
        "id": 168325301,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788820
    },
    {
        "content": "<p>But <code>inv</code> isn't</p>",
        "id": 168325317,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788830
    },
    {
        "content": "<p>Aha.</p>",
        "id": 168325329,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560788837
    },
    {
        "content": "<p>I thought that anything uncountable was uncomputable almost by definition.</p>",
        "id": 168325332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788839
    },
    {
        "content": "<p>What about <code>nat -&gt; nat</code>?</p>",
        "id": 168325345,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788853
    },
    {
        "content": "<p>What does it mean for the reals to be computable?</p>",
        "id": 168325347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788856
    },
    {
        "content": "<p>I guess it means <code>+</code>, <code>*</code> and <code>-</code> are computable.</p>",
        "id": 168325377,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788876
    },
    {
        "content": "<p>I think anything uncountable has non decidable equality.</p>",
        "id": 168325471,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560788924
    },
    {
        "content": "<p>I know what it means for a function nat -&gt; nat to be computable. For more general domains I am a bit confused.</p>",
        "id": 168325513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560788956
    },
    {
        "content": "<blockquote>\n<p>What does it mean for the reals to be computable?</p>\n</blockquote>\n<p>a type is always comuptable.</p>",
        "id": 168325532,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1560788976
    },
    {
        "content": "<blockquote>\n<p>I think anything uncountable has non decidable equality.</p>\n</blockquote>\n<p>Ok, and I guess this means that for uncountable fields <code>inv</code> will be noncomputable.</p>",
        "id": 168325605,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560789003
    },
    {
        "content": "<p>I'm quite sure that <code>inv</code> is used somewhere in Langlands (-;</p>",
        "id": 168325651,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560789036
    },
    {
        "content": "<p>No, because as Kenny showed you can make more or less any field computable, by defining it as some quotient of field expressions.</p>",
        "id": 168325691,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560789075
    },
    {
        "content": "<p>Types: That is true in the sense that you don't have to put <code>noncomputable</code> in front of it in Lean. But I think I established in the computability thread that there are proofs which are noncomputable in the sense that you can't write a program, but Lean would let you mark them as computable because Lean doesn't generate bytecode for theorems becuase of impredicabilitvity or whatever it's called.</p>",
        "id": 168325694,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560789079
    },
    {
        "content": "<p>I think if you want that sort of computability, you have to never use any of the 3 axioms. And avoiding <code>quot.sound</code> might be hard.</p>",
        "id": 168326346,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560789585
    },
    {
        "content": "<p>ooh I'd not thought of it like that.</p>",
        "id": 168326838,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560789976
    },
    {
        "content": "<p>Without the quotient axiom one can still build quotients, but the universal property isn't computable because you have to choose an element in an equivalence class. The axiom doesn't magically make things computable.</p>",
        "id": 168326890,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560790044
    },
    {
        "content": "<p>I'm not sure what definition of computable is being used here but whatever real numbers as Cauchy sequences are, they are definitely not thought of as computable in general. Of course in certain cases you can compute with real numbers, and do useful things with them (Brouwer / Bishop) style.</p>",
        "id": 168330323,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560792837
    },
    {
        "content": "<p>here's a recent paper (2019!) about computable analysis</p>",
        "id": 168330594,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560793030
    },
    {
        "content": "<p><a href=\"https://hal.inria.fr/hal-02088293/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-02088293/document\">https://hal.inria.fr/hal-02088293/document</a></p>",
        "id": 168330601,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1560793032
    },
    {
        "content": "<p>The definition used is \"Lean does not demand that I mark the definition <code>noncomputable</code>\"</p>",
        "id": 168331244,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560793505
    },
    {
        "content": "<p>This MSE question of mine might be helpful for defining <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}_p}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.174998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span>: <a href=\"https://math.stackexchange.com/questions/1032885/proving-existence-of-overline-bbb-q-p-without-ac\" target=\"_blank\" title=\"https://math.stackexchange.com/questions/1032885/proving-existence-of-overline-bbb-q-p-without-ac\">Proving existence of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><msub><mi mathvariant=\"double-struck\">Q</mi><mi>p</mi></msub></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{\\mathbb{Q}_p}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8888900000000001em;\"></span><span class=\"strut bottom\" style=\"height:1.174998em;vertical-align:-0.286108em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8888900000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span><span style=\"top:-3.80889em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"></span></span></span></span></span></span></span>\nwithout AC</a></p>",
        "id": 168343553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560802408
    },
    {
        "content": "<blockquote>\n<p>Consider the subset relation on finite extensions of Qp. This is a directed set, because we can take the union of two finite extensions to get another finite extension.</p>\n</blockquote>\n<p>I don't follow this part. What is a finite extension of Q_p? It doesn't seem like even a set to me, let alone a directed set. If it's a set of isomorphism classes, then one can't take the union of two finite extensions (by which I assume you mean the field generated by the union) because this is not an isomorphism-invariant thing. For example, within the complexes, the field generated by Q(a) and Q(b) if a^3=b^3=2 depends on whether a and b are equal cube roots of 2 or unequal ones.</p>",
        "id": 168349744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560807352
    },
    {
        "content": "<p>Subsets of <code>nat \\times polynomial Q_p</code> with random field structures such that Q_p embeds into them with order by subset such that inclusion is a field hom.</p>",
        "id": 168350252,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560807814
    },
    {
        "content": "<p>Is the algebraic closure just the direct limit of that?</p>",
        "id": 168350452,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560807984
    },
    {
        "content": "<p>We can't then take the (field generated by the) union of two random extensions, at least not without further work.</p>\n<p>I am concerned that we need some form of countable choice to make this work.</p>",
        "id": 168350457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560807989
    },
    {
        "content": "<p>I don't see how we have finite joins yet.</p>",
        "id": 168350468,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560808005
    },
    {
        "content": "<p>Oh yes. This is why we need Zorn.</p>",
        "id": 168350563,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1560808085
    },
    {
        "content": "<p>I should warn you that my knowledge of algebraic number theory was extremely sketchy when I wrote that Q</p>",
        "id": 168351593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560808989
    },
    {
        "content": "<p>it is still pretty sketchy</p>",
        "id": 168351598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560808999
    },
    {
        "content": "<p>rereading it, I had the same question about unions of field extensions</p>",
        "id": 168351611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809015
    },
    {
        "content": "<p>Maybe Milne has something to say about it?</p>",
        "id": 168351624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809037
    },
    {
        "content": "<p>I think it is true that finite field extensions are a directed set though, because that claim doesn't imply uniqueness of the join</p>",
        "id": 168351705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809081
    },
    {
        "content": "<p>there may be multiple ways to make the field extensions compatible, but there should be at least one way</p>",
        "id": 168351731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809114
    },
    {
        "content": "<p>I don't understand, with Chris's description of the order, how two different copies of Q(sqrt 2) could have any join</p>",
        "id": 168351759,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560809157
    },
    {
        "content": "<p>or any joint upper bound</p>",
        "id": 168351799,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560809163
    },
    {
        "content": "<p>two copies of Q(sqrt 2) have join Q(sqrt 2)</p>",
        "id": 168351818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809183
    },
    {
        "content": "<p>i.e. there is a field that embeds both</p>",
        "id": 168351834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809209
    },
    {
        "content": "<p>But they are different subsets of the fixed universe and the ordering was supposedly containment</p>",
        "id": 168351839,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560809224
    },
    {
        "content": "<p>like, literal set inclusion that's a field homomorphism</p>",
        "id": 168351848,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560809236
    },
    {
        "content": "<p>I don't think there is a fixed universe here</p>",
        "id": 168351853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809242
    },
    {
        "content": "<p>I was going with</p>\n<blockquote>\n<p>Subsets of <code>nat \\times polynomial Q_p</code> with random field structures such that Q_p embeds into them with order by subset such that inclusion is a field hom.</p>\n</blockquote>",
        "id": 168351866,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560809262
    },
    {
        "content": "<p>maybe you have to allow taking quotients of the subsets?</p>",
        "id": 168351995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809377
    },
    {
        "content": "<p>I don't think \"order by subset\" works very well when the field structures are random</p>",
        "id": 168352108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809465
    },
    {
        "content": "<p>You can make chains pretty well, but you don't get a directed set</p>",
        "id": 168352147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809511
    },
    {
        "content": "<p>I think one might need countable choice to pull this off.</p>",
        "id": 168352313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560809653
    },
    {
        "content": "<p>I did actually work this out in metamath, but only as far as the definitions so I'm not totally sure it all works</p>",
        "id": 168352314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809655
    },
    {
        "content": "<p><a href=\"http://us2.metamath.org/mpeuni/mmtheorems269.html#ccp\" target=\"_blank\" title=\"http://us2.metamath.org/mpeuni/mmtheorems269.html#ccp\">http://us2.metamath.org/mpeuni/mmtheorems269.html#ccp</a></p>",
        "id": 168352315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809655
    },
    {
        "content": "<p>The actual construction is very straightforward - it's just the splitting field of an increasing sequence of finite sets that covers <code>polynomial ZZ</code></p>",
        "id": 168352607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560809927
    },
    {
        "content": "<p>The general problem is as follows. If L and M are random finite field extensions of K, then LM is not a thing. If we regard L and M as subsets of K-bar then LM is definitely a thing, but if L and M are just random things defined up to isomorphism, then different embeddings of L and M into K-bar might give rise to completely different LM's, fields that don't even have the same degree over K for example. An analogous problem is that the \"intersection\" of L and M is not a well-defined thing until you embed into K-bar, but if L and M are not normal extensions then there will be more than one image in K-bar so the intersection might change.</p>",
        "id": 168352614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560809934
    },
    {
        "content": "<blockquote>\n<p>For example, in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[i]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mopen\">[</span><span class=\"mord mathit\">i</span><span class=\"mclose\">]</span></span></span></span> we have <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>+</mo><mi>i</mi><mo>)</mo><mo>(</mo><mn>2</mn><mo>−</mo><mi>i</mi><mo>)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">(2+i)(2-i)=5</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">+</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">2</span><span class=\"mbin\">−</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">5</span></span></span></span> and the factors are coprime. So to extend the 5-adic norm to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><mo>(</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(i)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">i</span><span class=\"mclose\">)</span></span></span></span> you need to decide which one will have valuation 1 and which one valuation 0.</p>\n</blockquote>\n<p>Do the two choices of valuation give isomorphic valued fields? Does one get a diagram of all possible choices of valued field extensions?</p>",
        "id": 168352638,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560809956
    },
    {
        "content": "<blockquote>\n<p>The actual construction is very straightforward - it's just the splitting field of an increasing sequence of finite sets that covers <code>polynomial ZZ</code></p>\n</blockquote>\n<p>Splitting fields are defined up to isomorphism but not unique isomorphism, so if you have an abstract splitting field of f then you have to make a choice when you're embedding it into an abstract splitting field of fg. I'm not ruling out the possibility that ther's some way of making all these choices consistently somehow though in the specific case of the p-adics.</p>",
        "id": 168352746,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810022
    },
    {
        "content": "<p>my splitting field construction is 100% constructive</p>",
        "id": 168352762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810040
    },
    {
        "content": "<p>it requires a total order on the base set to make random choices</p>",
        "id": 168352777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810061
    },
    {
        "content": "<p>it's defined just above at that link</p>",
        "id": 168352803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810103
    },
    {
        "content": "<blockquote>\n<p>Do the two choices of valuation give isomorphic valued fields? Does one get a diagram of all possible choices of valued field extensions?</p>\n</blockquote>\n<p>Yes, complex conjugation gives an isomorphism in this case. For a non-Galois extension though the valuations might not be isomorphic, e.g. 5 can factor as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi><msup><mi>Q</mi><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">PQ^2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord mathit\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span></span></span></span> for two different primes <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\">Q</span></span></span></span> and then the two valuations will definitely be different (they will have different \"ramification degree\"). For a finite extension of Q there's just a finite set of extensions of the p-adic valuation. For a finite Galois extension they're all Galois conjugate (this is not immediately obvious but it's true), i.e. you can move from any one to another one by applying an automorphism of the field. In the limit there are uncountably many and I don't know what a diagram is, but they might well be acted on transitively by the absolute galois group of the rationals.</p>",
        "id": 168352900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810210
    },
    {
        "content": "<p>I don't think you can define any total order on Q_p though. Maybe it depends on exactly what you need out of the total order</p>",
        "id": 168352904,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560810215
    },
    {
        "content": "<p>You don't, and I did</p>",
        "id": 168352908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810225
    },
    {
        "content": "<p>it's just the real order on the cantor set</p>",
        "id": 168352956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810247
    },
    {
        "content": "<p>how is it decidable?</p>",
        "id": 168352969,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560810263
    },
    {
        "content": "<p>because ZFC</p>",
        "id": 168352985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810270
    },
    {
        "content": "<p>I don't know whether that matters in this context though</p>",
        "id": 168352998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810287
    },
    {
        "content": "<p>Oh I thought we were trying to be totally constructive</p>",
        "id": 168353004,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560810293
    },
    {
        "content": "<p>What link are we supposed to be looking at? Mario is your argument still that Q_p-bar can be made constructively (whatever that means when we're talking about uncountable objects)</p>",
        "id": 168353020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810306
    },
    {
        "content": "<p>5 years ago I was just trying to do the construction in ZF</p>",
        "id": 168353025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810309
    },
    {
        "content": "<p>The metamath link contains a list of definitions with comments on every line</p>",
        "id": 168353062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810353
    },
    {
        "content": "<p>So we're allowed AC? I am still so confused about what constructive means.</p>",
        "id": 168353065,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810356
    },
    {
        "content": "<p>The link I followed just gave me a definition of Q_p, not Q_p-bar. Maybe I missed something.</p>",
        "id": 168353114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810373
    },
    {
        "content": "<p>Oh, I did: the very bottom thing.</p>",
        "id": 168353135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810402
    },
    {
        "content": "<p>df-qp is Q_p, df-qpa is Q_p-bar</p>",
        "id": 168353148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810410
    },
    {
        "content": "<p>I'm assuming constructive means \"with no axioms\"</p>",
        "id": 168353159,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560810422
    },
    {
        "content": "<p>ZF is not quite the same thing as lean-constructive, but they are surprisingly similar in the broad strokes</p>",
        "id": 168353167,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810436
    },
    {
        "content": "<blockquote>\n<p>Define the completion of the 𝑝-adic rationals.</p>\n</blockquote>\n<p>This is \"completion\" in what sense??</p>",
        "id": 168353176,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810445
    },
    {
        "content": "<p>df-qpa is algebraic completion, df-cp is metric completion</p>",
        "id": 168353202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810472
    },
    {
        "content": "<p>Whatever are the \"p-adic rationals\"? Are they the rationals with the p-adic metric, or the p-adic numbers?</p>",
        "id": 168353205,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810477
    },
    {
        "content": "<p>padic numbers</p>",
        "id": 168353251,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810486
    },
    {
        "content": "<p>By \"algebraic completion\" do you mean what mathematicians call \"algebraic closure\"?</p>",
        "id": 168353252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810492
    },
    {
        "content": "<p>I believe so</p>",
        "id": 168353261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810501
    },
    {
        "content": "<p>OK got it.</p>",
        "id": 168353263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560810506
    },
    {
        "content": "<p>Oh, yes, I forgot the analogy with covering spaces, whereby one might not have a 'good enough' action by deck transformations (analogous to non-Galois field extns). So maybe I mean this: consider the algebraic closure not as a single field, but as an 'Ind-valued field' (or similar), whereby one has all the valued finite extensions and all the ways they map to each other. Maybe a stupid and known-to-fail idea, but my category theorist's nose leads me that way.</p>",
        "id": 168353432,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560810672
    },
    {
        "content": "<p>what does Ind-valued mean?</p>",
        "id": 168353459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810710
    },
    {
        "content": "<p>To clarify on constructivism in metamath: We have LEM from the very beginning - it's built on classical logic. But AC is an axiom, and metamath tracks axioms, so we try to minimize its use when possible. It's not intuitionistic mathematics, it's just ZF</p>",
        "id": 168353683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810894
    },
    {
        "content": "<p>There is a separate database devoted to developing intuitionistic mathematics, but I don't think it's likely to discover anything that hasn't already been done in Coq and Agda and the other constructive proof assistants</p>",
        "id": 168353781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560810976
    },
    {
        "content": "<p>When you want to avoid AC, you start worrying about whether certain sets are \"definable\", not merely proven to exist</p>",
        "id": 168353956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560811130
    },
    {
        "content": "<p>and this takes the place of constructive definition in lean</p>",
        "id": 168353973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560811141
    },
    {
        "content": "<p>For example, from the well ordering theorem there is a well order of the real numbers, but there is (provably in the metatheory) no definable well order of the reals</p>",
        "id": 168354070,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560811204
    },
    {
        "content": "<p>Ind-(valued field), not (Ind-valued) field.</p>",
        "id": 168354202,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560811329
    },
    {
        "content": "<p>what is Ind- then?</p>",
        "id": 168354223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560811355
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/ind-object\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/ind-object\">https://ncatlab.org/nlab/show/ind-object</a></p>",
        "id": 168354504,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560811616
    },
    {
        "content": "<p>You can take the class of all finite extensions of Q equipped with a valuation extending the p-adic valuation. But in general you can have more than one morphism between two objects.</p>",
        "id": 168376976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560843842
    },
    {
        "content": "<p>Sure, but you can have more than one embedding of a finite extension of Q (sans valuation) into larger extensions of Q (ditto). Somehow it all works out. I'm surely missing details, and not using the right words... Instead of Qbar one could work with the Ind-field that is all the finite extensions of Q, maybe?? Awful, since we know we can construct Qbar, but on the geometric side people think about pro-étale covers...</p>",
        "id": 168377426,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560844320
    },
    {
        "content": "<p>I don't understand how to take the limit without using choice. Say I have two directions to go at each stage. How can I find a way to the end without choice?</p>",
        "id": 168377493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560844376
    },
    {
        "content": "<p>I think if you work with an Ind-field you don't actually take the limit.</p>",
        "id": 168377516,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560844408
    },
    {
        "content": "<p>So you don't actually build <code>Qp-bar</code></p>",
        "id": 168377523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560844419
    },
    {
        "content": "<p>Just some substitute that is hopefully good enough in practice.</p>",
        "id": 168377531,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560844433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> Correct me if I'm wrong <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 168377589,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560844464
    },
    {
        "content": "<p>You still have to prove that a colimit sequence exists</p>",
        "id": 168377607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560844487
    },
    {
        "content": "<p>or directed set</p>",
        "id": 168377612,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560844494
    },
    {
        "content": "<p>and in this case the actual taking of the colimit isn't a problem, because the necessary colimits exist in whatever category this is</p>",
        "id": 168377649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560844541
    },
    {
        "content": "<p>I'm not sure this is turning into a program</p>",
        "id": 168377830,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560844691
    },
    {
        "content": "<p>Taking some big colimit in the category of rings, and then getting a field out of it by choosing a random maximal ideal (to quotient out by) is where choice strikes if you do it this way</p>",
        "id": 168377868,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560844733
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> correct. _Don't_ take the colimit. Work with the Ind-field, much as one would work with eg the pro-group of automorphisms.</p>",
        "id": 168378148,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560844937
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130272\">@David Michael Roberts</span> But I guess that for some applications you will need to know that the colimit exists, right?</p>",
        "id": 168378188,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560845003
    },
    {
        "content": "<blockquote>\n<p>and in this case the actual taking of the colimit isn't a problem, because the necessary colimits exist in whatever category this is</p>\n</blockquote>\n<p>The existence is a proof, hence irrelevant. But taking the colimit requires choices. I still don't see how to do that \"canonically\".</p>",
        "id": 168378278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560845066
    },
    {
        "content": "<p>If you can make it the colimit of a sequence, then you can pick an order</p>",
        "id": 168378350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845106
    },
    {
        "content": "<p>hence the suggestion to use an increasing sequence of finite sets</p>",
        "id": 168378381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845123
    },
    {
        "content": "<p>where the order is based on an arbitrary total order on Qp</p>",
        "id": 168378409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845147
    },
    {
        "content": "<p>In practice, one might only work in some collection of intermediate extension (cf the Stacks project proving that one only ever needs small categories of schemes, given some initial schemes of interest). One would need to prove the theory required to actually trace through ordinary results that use an actual construction-using-Choice, but people seem to be having fun with eg condensed objects these days, which is not too dissimilar.</p>",
        "id": 168378510,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560845221
    },
    {
        "content": "<p>I think it is pretty likely that Cp is an avoidable convenience, but then again so are most infinite sets. That doesn't mean I want to do formalization that way</p>",
        "id": 168378626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845327
    },
    {
        "content": "<p>To actually answer Kevin's question, the better place to investigate is how people actually do computations on Cp</p>",
        "id": 168378665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845368
    },
    {
        "content": "<p>like something you could put in a CAS</p>",
        "id": 168378676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845387
    },
    {
        "content": "<blockquote>\n<p>hence the suggestion to use an increasing sequence of finite sets</p>\n</blockquote>\n<p>What I don't understand with the \"increasing sequence of finite sets and order based on arbitrary total order\" approch is that even if you stick to splitting fields, you will still have to choose a map from each splitting field to the next one up.</p>",
        "id": 168378757,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845419
    },
    {
        "content": "<p>Yes, surely people don't work with actual elements of some enormous topological ring.</p>",
        "id": 168378764,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560845433
    },
    {
        "content": "<blockquote>\n<p>like something you could put in a CAS</p>\n</blockquote>\n<p>People don't do computations with C_p, nobody really understands it. People prove theorems about it.</p>",
        "id": 168378769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845444
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> don't choose :-) use them all.</p>",
        "id": 168378776,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560845452
    },
    {
        "content": "<p>Given two finite extensions, does there exist a common finite extension embedding both?</p>",
        "id": 168378799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845486
    },
    {
        "content": "<blockquote>\n<p>People don't do computations with C_p, nobody really understands it. People prove theorems about it.</p>\n</blockquote>\n<p>I think that's pretty clear evidence that Cp is not meant to be computable</p>",
        "id": 168378818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845514
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> don't choose :-) use them all.</p>\n</blockquote>\n<p>Right.</p>\n<blockquote>\n<p>Yes, surely people don't work with actual elements of some enormous topological ring.</p>\n</blockquote>\n<p>Right. </p>\n<p>So the question is: although people don't actually ever talk about elements or whatever, the Langlands philosophy (in this case just class field theory) says \"here are two sets, there is a bijection between them. Yes, the elements of one of the sets can be described as \"group homomorphisms\", even though nobody has ever seen an element of one of the groups in question -- but this doesn't matter\". My question is whether this bijection can ever be a computer program.</p>",
        "id": 168378909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845585
    },
    {
        "content": "<p>For the bijection itself to be a computer program, you need computable representations of both sides and a program that transforms one representation to the other. But it's also possible that one is a concrete computable type and the other is some noncomputable mess, and the bijection is saying that the noncomputable mess has a \"nice\" representation</p>",
        "id": 168379014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845700
    },
    {
        "content": "<blockquote>\n<p>Given two finite extensions, does there exist a common finite extension embedding both?</p>\n</blockquote>\n<p>In some sense there is more than one. Given the two finite extensions, you can tensor product them together, and this gives you a <em>ring</em> not a field. The ring has finitely many maximal ideals; you can just choose one, and quotient out by it, and there is a common finite extension extending both.</p>",
        "id": 168379016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845701
    },
    {
        "content": "<p>Is it possible to enumerate the maximal ideals?</p>",
        "id": 168379036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845729
    },
    {
        "content": "<p>In general, I doubt it. In the case of the p-adic numbers -- maybe.</p>",
        "id": 168379051,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845753
    },
    {
        "content": "<p>Assume everything is countable and labeled</p>",
        "id": 168379101,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845771
    },
    {
        "content": "<p>I just don't know. I've not really thought about this kind of question before.</p>",
        "id": 168379120,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845795
    },
    {
        "content": "<p>I've never had to avoid AC throughout my entire adult life.</p>",
        "id": 168379124,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845804
    },
    {
        "content": "<p>why do you think there are finitely many maximal ideals?</p>",
        "id": 168379126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560845808
    },
    {
        "content": "<p>If our base field is K, of characteristic 0, and L and M are finite extensions of K, then L tensor M is a finite direct sum of finite extensions of K.</p>",
        "id": 168379165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845846
    },
    {
        "content": "<p>This follows from some sort of chinese remainder argument. We can write M=K[X]/f(X) with f irreducible, and then L tensor M is just L[X]/f(X) where now f might not be irreducible any more, but it only has finitely many factors.</p>",
        "id": 168379241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845895
    },
    {
        "content": "<p>We have to choose a factor. Of course we also have to choose f.</p>",
        "id": 168379254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560845908
    },
    {
        "content": "<p>I forget how irreducibility / factor finding algorithm works, but assuming you can calculate that for integer polynomials, I think that does the job</p>",
        "id": 168379469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560846095
    },
    {
        "content": "<p>Is class field theory a program in the sense that you mean? It certainly involves uncountable sets, and arbitrary p-adic numbers, including non-computable ones. On the other hand, doesn't the inductive structure of the local langlands correspondance imply that it should be computable \"modulo class field theory\" (more precisely, modulo the local langlands correspondence for characters of Levi subgroups)? Do I remember correctly that the number of supercuspidal representations of fixed central character and conductor are finite? </p>\n<p>Also, the computability aspects of a group and of its isomorphism classes of representations (of some type) can be very different. For instance, the unitary group U(n) is uncomputable in some sense, since the real numbers are, but its finite-dimensional continuous representations are described by highest weight theory and are computable.</p>",
        "id": 168380301,
        "sender_full_name": "Simon Pepin Lehalleur",
        "timestamp": 1560846936
    },
    {
        "content": "<p>I'm trying to work this out Simon. It's a weird question (in the sense that I've never cared about it before and none of my friends care about this question either). I think that I still don't really understand the question yet. I seem to have several competing definitions of computability in my head.</p>",
        "id": 168380389,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560847029
    },
    {
        "content": "<p>The only reason I'm asking at all is that I wrote this blog post saying that proofs were not programs and then a bunch of constructivists on Twitter told me that I wasn't trying hard enough.</p>",
        "id": 168380410,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560847065
    },
    {
        "content": "<blockquote>\n<p>a bunch of constructivists on Twitter told me that I wasn't trying hard enough.</p>\n</blockquote>\n<p>They are probably right, but don't take it personally. Prior to Bishop's book on constructive analysis (which is a gem), people thought constructivist ideas were too weak to do any analysis, and were fixated on things like 'all functions are continuous'. Turns out there's no real issue, the trick is arriving at classically equivalent definitions that have constructive content.</p>",
        "id": 168381151,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560847821
    },
    {
        "content": "<blockquote>\n<p>Is class field theory a program in the sense that you mean? It certainly involves uncountable sets, and arbitrary p-adic numbers, including non-computable ones. On the other hand, doesn't the inductive structure of the local langlands correspondance imply that it should be computable \"modulo class field theory\" </p>\n</blockquote>\n<p>Colin McLarty gave a talk at the Association for Symbolic Logic meeting last year titled \"Class field theory in exponential function arithmetic (EFA)\", and EFA is an incredibly weak system.</p>",
        "id": 168560140,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1560994995
    }
]
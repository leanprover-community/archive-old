[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and I have been discussing the sheaf of meromorphic functions.</p>\n<p>Here is an initial definition of the sheaf of rings of fractions.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.filtered_colimits</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing.limits</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.sites.sheaf</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.sites.sheafification</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.sheaves.sheaf_condition.sites</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.localization</span>\n<span class=\"c1\">--import category_theory.filtered</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">Sheaf</span> <span class=\"o\">(</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">is_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"bp\">≤</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V</span><span class=\"o\">)),</span> <span class=\"n\">P.val.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">regular_element</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">submonoid</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">s</span> <span class=\"o\">},</span>\n  <span class=\"n\">one_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">hf</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_mem'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">mul_assoc</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">specialize</span> <span class=\"n\">hs</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">ht</span> <span class=\"n\">V</span> <span class=\"n\">h</span> <span class=\"n\">_</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">map_is_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">≤</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">f</span> <span class=\"bp\">→</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">hf</span> <span class=\"n\">W</span> <span class=\"n\">h</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">comp_apply</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">P.val.map_comp</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">op_comp</span><span class=\"o\">],</span>\n  <span class=\"n\">intros</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">comap_regular_element</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">U</span> <span class=\"bp\">⟶</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">U.unop</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">V.unop</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_monoid_hom</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">V.unop</span> <span class=\"bp\">≤</span> <span class=\"n\">U.unop</span> <span class=\"o\">:=</span> <span class=\"n\">le_of_hom</span> <span class=\"n\">h.unop</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">is_regular_element</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">map_is_regular_element</span> <span class=\"n\">P</span> <span class=\"n\">this</span> <span class=\"n\">f</span> <span class=\"n\">hf</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">hom_of_le</span> <span class=\"n\">this</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">change</span> <span class=\"n\">h.unop.op</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">congr'</span> <span class=\"mi\">1</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">total_fraction_presheaf</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">CommRing</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">CommRing.of</span> <span class=\"bp\">$</span> <span class=\"n\">localization</span> <span class=\"o\">(</span><span class=\"n\">regular_element</span> <span class=\"n\">P</span> <span class=\"n\">U.unop</span><span class=\"o\">),</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comap_regular_element</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">change</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U.unop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">algebra</span> <span class=\"o\">(</span><span class=\"n\">P.val.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">V.unop</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">localization</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">ring_hom.id</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">P.val.map</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">P.val.map</span> <span class=\"n\">f</span><span class=\"o\">))</span> <span class=\"n\">_</span> <span class=\"bp\">=</span>\n      <span class=\"o\">(</span><span class=\"n\">is_localization.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_localization.map_comp_map</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span> <span class=\"bp\">.</span>\n\n<span class=\"c1\">-- Why is this needed???</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">is_filtered</span> <span class=\"o\">((</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cover</span> <span class=\"n\">U</span><span class=\"o\">)</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">total_fraction_sheaf</span> <span class=\"o\">:</span> <span class=\"n\">Sheaf</span> <span class=\"o\">(</span><span class=\"n\">opens.grothendieck_topology</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">CommRing</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">presheaf_to_Sheaf</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">total_fraction_presheaf</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Now if `P` is the sheaf of holomorphic functions, then `total_fraction_sheaf P` should be</span>\n<span class=\"c1\">-- the sheaf of meromorphic functions.</span>\n</code></pre></div>\n</div></div>\n<p>As you can see, there are some pain points in this code, around the following points:</p>\n<ol>\n<li>I used Grothendieck topologies, because as far as I know we cannot easily sheafify presheaves of commutative rings using sheaves from the <code>topology</code> part of mathlib.</li>\n<li>Mapping localizations is more difficult than it should be... I could add some algebra instances, sure, but it's still a bit annoying.</li>\n<li>There are some annoying points coming up due to <code>op</code>, but I don't see any way to avoid them.</li>\n<li>Why do I need to manually add the <code>is_filtered</code> instance toward the bottom?</li>\n</ol>",
        "id": 267316997,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641677412
    },
    {
        "content": "<p>It would be better to develop a general construction of localization of sheaves of commutative rings by a sub(pre)sheaf of monoids. If someone wants to try to even write down the type of such a construction, that would be great!</p>",
        "id": 267317269,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641677813
    },
    {
        "content": "<p>A probably not that related question: what is a better way to talk about a \"sub(pre)sheaf of monoids\"?<br>\nAn mono into the image of the <code>F : Sheaf X CommRing</code> under some forgetful functor <code>Sheaf X CommRing ⥤  Sheaf X Monoid</code>?<br>\nI was thinking about this just this afternoon (though I was thinking about ideal sheaves) and I have yet obtained a satisfactory solution.</p>",
        "id": 267317737,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641678538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> that question is definitely related! Note that to localize a ring, one must use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid\">docs#submonoid</a> at some point</p>",
        "id": 267317820,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678666
    },
    {
        "content": "<p>(at least in the way localization is currently done)</p>",
        "id": 267317826,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678682
    },
    {
        "content": "<p>If you have a morphism of sheaves of monoids, you can localize at the images, I guess... But I don't know how workable that would be in practice</p>",
        "id": 267317886,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641678738
    },
    {
        "content": "<p>I thought so too. Since most of the substuff library talks about the bundled substuff, we would need to juggle with images all the time if we go for this approach.</p>",
        "id": 267317912,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641678792
    },
    {
        "content": "<p>For sheaves of ideals, you can model them as kernels of morphisms of sheaves of rings, for example.</p>",
        "id": 267318580,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641679556
    },
    {
        "content": "<p>You'll have a bad notion of equality that way</p>",
        "id": 267319362,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641680491
    },
    {
        "content": "<p>equality is evil anyway</p>",
        "id": 267319370,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641680509
    },
    {
        "content": "<p>Perhaps not for sheaves of ideals</p>",
        "id": 267319419,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1641680535
    },
    {
        "content": "<p>ok, fair point..</p>",
        "id": 267319425,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641680546
    },
    {
        "content": "<p>Is there no way to use <code>non_zero_divisors</code> here?</p>",
        "id": 267323550,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641685946
    },
    {
        "content": "<p>For example, if I am reading the definition, correctly, you're working on <code>{ obj := λ U, CommRing.of $ fraction_ring (P.val.obj U), ...}</code>? There are some API missing for your <code>2.</code> point. Just to familiarize myself with this part of the library, is there a reason to not use <code>CommRing.of_hom _</code> for your <code>hom := </code> construction?</p>",
        "id": 267324150,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641686825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> take a look at the definition on the nlab, <br>\n<a href=\"http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/sheaf+of+meromorphic+functions\">http://nlab-pages.s3.us-east-2.amazonaws.com/nlab/show/sheaf+of+meromorphic+functions</a></p>\n<p>and also (in the algebraic context) the top of page 141 of Hartshorne.</p>",
        "id": 267324896,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688060
    },
    {
        "content": "<p>I don't think using <code>non_zero_divisors</code> works in this level of generality.</p>",
        "id": 267324938,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688086
    },
    {
        "content": "<p>As for <code>CommRing.of_hom</code>, it's not really needed here, as morphisms in the category <code>CommRing</code> are defeq to ring homs.</p>",
        "id": 267324945,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688132
    },
    {
        "content": "<p>Oh wait, I see what you mean... maybe it does work to resolve 2, let me check.</p>",
        "id": 267324962,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688184
    },
    {
        "content": "<p>No, unfortunately the same annoyances show up with <code>CommRing.of_hom</code> as well... lean is not able to deduce the algebra and <code>is_localization</code> instances for some reason.</p>",
        "id": 267325052,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641688304
    },
    {
        "content": "<p>Yeah it didn't help when I tried</p>",
        "id": 267325053,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1641688316
    },
    {
        "content": "<p>A section of a sheaf of rings is regular if all its restrictions are <code>non_zero_divisors</code>. This is strictly stronger than just being a <code>non_zero_divisor</code> in <code>P(U)</code>, so <code>fraction_ring (P U)</code> already inverts too many things</p>",
        "id": 267342689,
        "sender_full_name": "David Wärn",
        "timestamp": 1641714685
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267316997\">said</a>:</p>\n<blockquote>\n<p>As you can see, there are some pain points in this code, around the following points:</p>\n<ol>\n<li>I used Grothendieck topologies, because as far as I know we cannot easily sheafify presheaves of commutative rings using sheaves from the <code>topology</code> part of mathlib.</li>\n</ol>\n</blockquote>\n<p>I didn't realise we had both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf\">docs#category_theory.Sheaf</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.sheaf\">docs#Top.sheaf</a>.  Is it planned for the former to subsume the latter at some point?</p>",
        "id": 267493874,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641845826
    },
    {
        "content": "<p>Ping <span class=\"user-mention\" data-user-id=\"384542\">@Justus Springer</span> <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span></p>",
        "id": 267495605,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641846750
    },
    {
        "content": "<p>Quoting Justus from his PR linking the two notions:</p>\n<blockquote>\n<p>@jcommelin I did briefly think about this and I'm not sure. It's a design decision I don't feel comfortable making at the moment. Removing the sheaf-on-space definition by making it a special case of the more general one certainly feels like the right thing to do. But on the other hand, I consider sheaves on spaces a pretty important special case and some users (e.g. me three weeks ago) may not want to think about sites and just do sheaves on spaces. So there probably should be a lot of API specialising every applicable concept around sheaves to the case of spaces anyway. So maybe it wouldn't even make that much of a difference in size. But conceptually, it would probably be the right thing do to in the long run.</p>\n<p>Note that some things can already be deduplicated using the equivalence of categories: Right now there are two proofs that composing a sheaf with an isomorphism-reflecting limit-preserving functor again yields a sheaf. They work in slightly different settings, but you could definitely make one a special case of the other by going around the equivalence of categories. I might try to do that soon.</p>\n</blockquote>",
        "id": 267495878,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641846907
    },
    {
        "content": "<p>Also -- how do I make a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf\">docs#category_theory.Sheaf</a>?  I think it's nearly possible to make the structure sheaf of a complex manifold as a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.sheaf\">docs#Top.sheaf</a> -- <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.local_predicate\">docs#Top.local_predicate</a> does this, the only problem is that it makes a sheaf of types rather than a sheaf of rings.</p>",
        "id": 267496002,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641846963
    },
    {
        "content": "<p>We have the equivalence between the two notions as an equivalence of categories.</p>",
        "id": 267496112,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847027
    },
    {
        "content": "<p>I see.  Would some sheaf person be up for modifying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Top.local_predicate\">docs#Top.local_predicate</a> to make sheaves of rings?</p>",
        "id": 267496167,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847059
    },
    {
        "content": "<p>The type vs. commring is an issue.</p>",
        "id": 267496172,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847061
    },
    {
        "content": "<p>We could refactor <code>local_predicate</code> to take in a sufficiently nice concrete category instead of <code>Type*</code>.</p>",
        "id": 267496486,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847216
    },
    {
        "content": "<p>Or we could build up enough of the API so that using <code>Sheaf (opens.grothendieck_topology X) A</code> isn't so scary.</p>",
        "id": 267496647,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> what do you think?</p>",
        "id": 267496702,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847327
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267496112\">said</a>:</p>\n<blockquote>\n<p>We have the equivalence between the two notions as an equivalence of categories.</p>\n</blockquote>\n<p>If I understand correctly, an equivalence of categories wouldn't give a bijection of the objects, let alone a bijection respecting definitional equality ... so this sounds like it would get awkward.</p>",
        "id": 267496770,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847378
    },
    {
        "content": "<p>I think the functors for this equivalence are defeq to the identity on the level of presheaves, but I'm not 100% sure (I think Justus is the person who built that equivalence?)</p>",
        "id": 267496860,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1641847430
    },
    {
        "content": "<p>Oh, that's nice then!</p>",
        "id": 267496946,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847455
    },
    {
        "content": "<p>For a presheaf <code>Cᵒᵖ ⥤ D</code>, we know that it is a sheaf on the space iff it is a sheaf wrt the grothendieck topology, and the two categories are defined as merely a subtype of the category of presheaves, so it should not be a pain to move from one to another.</p>",
        "id": 267497190,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267496486\">said</a>:</p>\n<blockquote>\n<p>We could refactor <code>local_predicate</code> to take in a sufficiently nice concrete category instead of <code>Type*</code>.</p>\n</blockquote>\n<p>This sounds great ...</p>",
        "id": 267497557,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641847799
    },
    {
        "content": "<p>I'm not sure how one would generalize <code>local_predicate</code> to concrete categories.<br>\nWe would need to know that the set of the functions satisfying P locally is an object in the category, and the condition would vary for different categories?</p>",
        "id": 267497677,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847844
    },
    {
        "content": "<p>Note that we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.presheaf.is_sheaf_iff_is_sheaf_forget\">docs#category_theory.presheaf.is_sheaf_iff_is_sheaf_forget</a>, so we should still be able to use the local predicate stuff for good enough concrete categories.</p>",
        "id": 267497888,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641847945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267497677\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how one would generalize <code>local_predicate</code> to concrete categories.<br>\nWe would need to know that the set of the functions satisfying P locally is an object in the category, and the condition would vary for different categories?</p>\n</blockquote>\n<p>Could you do it for categories which have been constructed using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled\">docs#category_theory.bundled</a> or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.bundled_hom.category\">docs#category_theory.bundled_hom.category</a> ?</p>",
        "id": 267500137,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641848970
    },
    {
        "content": "<p>We would still need to prove things like <a href=\"https://github.com/leanprover-community/mathlib/blob/dc3cbb7d7d31191be71a6a52015e03a7578ff961/src/algebraic_geometry/structure_sheaf.lean#L147-L210\">https://github.com/leanprover-community/mathlib/blob/dc3cbb7d7d31191be71a6a52015e03a7578ff961/src/algebraic_geometry/structure_sheaf.lean#L147-L210</a><br>\nfor each local predicates we want to use, and the condition crucially depends on the P used.</p>",
        "id": 267500693,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1641849188
    },
    {
        "content": "<p>Even if there's no way to abstract it to sheaves of \"certain kinds of categories\", it might be nice to provide a local-predicate construction for sheaves of rings, since that one's used a lot.</p>",
        "id": 267509111,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1641852886
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"130377\">David Wärn</span> <a href=\"#narrow/stream/116395-maths/topic/Meromorphic.20functions/near/267342689\">said</a>:</p>\n<blockquote>\n<p>A section of a sheaf of rings is regular if all its restrictions are <code>non_zero_divisors</code>. This is strictly stronger than just being a <code>non_zero_divisor</code> in <code>P(U)</code>, so <code>fraction_ring (P U)</code> already inverts too many things</p>\n</blockquote>\n<p>For those of you who want to look at old stuff, this problem is the source of a mistake in Grothendieck's EGA (it is written that the obvious presheaf is a sheaf, but it's not a presheaf!). It has been adressed in a nice paper of Steven Kleiman, <em>Some misconceptions about K_X</em>, L'enseignement mathématique, DOI:10.5169/seals-50379</p>",
        "id": 267787286,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1642022135
    },
    {
        "content": "<p>Antoine, I added a refence to your blog post about this, by Kevin's pointer to it! <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/field_theory/ratfunc.lean#L58\">https://github.com/leanprover-community/mathlib/blob/master/src/field_theory/ratfunc.lean#L58</a></p>",
        "id": 267787410,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642022200
    },
    {
        "content": "<p>It was my motivation to generalize <code>ratfunc.lift_on</code> to arbitary <code>[comm_ring K}</code> without requiring <code>[is_domain K]</code></p>",
        "id": 267787496,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1642022260
    },
    {
        "content": "<p>I think there is still a lot of stuff in the sheaf theory library that should be generalised from sheaves of types to sheaves valued in more general \"nice enough\" category. In fact, working with sheaves in lean made me realise what exactly \"nice enough\" means in this context: It needs to be a concrete category whose forgetful functor reflects isomorphisms and preserves limits and filtered colimits. The first two properties ensures that a presheaf is a sheaf if and only if the underlying presheaf of types is a sheaf, while preserving colimits ensures that taking stalks commutes with the forgetful functor. All the typical \"algebraic\" categories, like <code>Group</code> or <code>CommRing</code> satisfy this property (and this is already in mathlib). The stacks project calls these categories \"types of algebraic structures\" in <a href=\"https://stacks.math.columbia.edu/tag/007L\">stacks#007L</a>. So I believe if sheafification and the stuff about local prediactes should be generalised, it is this class of categories one should look at, not only <code>CommRing</code>.</p>",
        "id": 267917793,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642101858
    },
    {
        "content": "<p>Those are exactly the conditions I had set up for sheafification over a general site.</p>",
        "id": 267918273,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102101
    },
    {
        "content": "<p>E.g. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.grothendieck_topology.sheafify_is_sheaf\">docs#category_theory.grothendieck_topology.sheafify_is_sheaf</a></p>",
        "id": 267918371,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102151
    },
    {
        "content": "<p>Oh wow, I didn't know this already exists in mathlib for sites.</p>",
        "id": 267918883,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642102378
    },
    {
        "content": "<p>Actually since we have the adjunction <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.sheafification_adjunction\">docs#category_theory.sheafification_adjunction</a> and the equivalence between the site-theoretic definition of sheaves and the topological one, as an equivalence of categories, it would be easy to obtain the sheafification adjunction for topological spaces as well by composing... that's some sort of sheafification in general for topological spaces, although if you need more control over the stalks that would require additional work.</p>",
        "id": 267919098,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642102491
    },
    {
        "content": "<p>Yeah,  it seems it's about time that sheaves on sites and sheaves on spaces are unified. Maybe I should have tried to do that when I built the equivalence. The longer the theories move independently the harder it will be to clean it up and unify them. In a sense it doesn't matter that much because we'll still want all the API for the special case of sheaves on spaces, but it's the right thing to do conceptually.</p>",
        "id": 267920136,
        "sender_full_name": "Justus Springer",
        "timestamp": 1642103012
    },
    {
        "content": "<p>I also think that we should make the sites one the official definition (while keeping all the other sheaves on topology stuff). I would suppose that the transition won't be that painful, since we are just replacing a Prop valued thing into another that we know is equivalent.<br>\nThis gives us sheaves in categories without products (which I do not know how useful it is), but more importantly this makes it easier to access the sites stuff (sheafification, pullback-pushforward, abelian-ness, etc).</p>",
        "id": 267920548,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1642103206
    },
    {
        "content": "<p>(Thanks for the reminder that I should eventually mathlibify the fact that abelian sheaves are an abelian category ;))<br>\n<code>mathlibify</code> is the left adjoint to the forgetful functor from mathlib to lte, of course.</p>",
        "id": 267920733,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642103294
    },
    {
        "content": "<p>If we just want the sheaf for schemes and not general ringed spaces, then according to the misconceptions paper, we can define sections of the presheaf using the \"wrong\" definition on open affines, then sheafify and extend to all opens, using Andrew's work at <a href=\"https://leanprover-community.github.io/mathlib_docs/category_theory/sites/dense_subsite.html\">https://leanprover-community.github.io/mathlib_docs/category_theory/sites/dense_subsite.html</a>.</p>",
        "id": 268241634,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1642409056
    },
    {
        "content": "<p>Sure, but we should have a construction that will also let us construct meromorphic functions in the holomorphic setting (and other settings as well), not just in the algebraic context.</p>",
        "id": 268275865,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1642428958
    }
]
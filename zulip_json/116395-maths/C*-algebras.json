[
    {
        "content": "<p>I'm trying to define C*-algebras on mathlib, but I'm running into problems with the old/new structure command.</p>\n<p>I have a definition like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- A normed *-ring, the part of the structure of a normed involutive algebra that does</span>\n<span class=\"cm\">  not mention the ring over which it lies. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">normed_star_ring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"o\">(</span><span class=\"n\">norm_star</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"err\">‚àó</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>This class requires <code>set_option old_structure_cmd true</code> because <code>star_ring</code> and <code>normed_ring</code> share many fields. However, <code>normed_ring</code> is not defined with the old structure command. <br>\nAccording to <span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> this is not supported: <a href=\"#narrow/stream/113488-general/topic/not.20a.20structure/near/199043298\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/not.20a.20structure/near/199043298</a></p>\n<p>What is the way around this? Should I make a PR turning <code>normed_ring</code> (and <em>all</em> other structures in the algebraic hierarchy) into something that uses <code>old_structure_cmd</code>? Or should I, as a workaround, just add the fields of <code>star_ring</code> and then manually give the instance to <code>star_ring</code>? Or is there another workaround?</p>",
        "id": 200144521,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1591644375
    },
    {
        "content": "<p>The <code>old_structure_cmd</code> got its name for a reason. And I think that reason had to do with the fact that it was a bad idea to build the entire algebraic hierarchy using <code>old_structure_cmd</code>.<br>\nBut I'm not an expert.</p>",
        "id": 200144806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591644537
    },
    {
        "content": "<p>Maybe it's time for <code>set_option newer_structure_cmd true</code> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 200144987,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1591644634
    },
    {
        "content": "<p>As mentioned elsewhere <code>old_structure_cmd</code> is a bad name <a href=\"#narrow/stream/113488-general/topic/linter.20doc_blame.20with.20old_structure_cmd/near/193763895\">and should be renamed</a>. It has features that the \"new\" structure command doesn't have. I believe the new structure command is more efficient, but I don't think that is an efficiency bottleneck we are running up against (it doesn't help anything with type-class inference performance, which I think is mathlib's main bottleneck)</p>",
        "id": 200145483,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1591644925
    },
    {
        "content": "<p>I was looking around for the definition of C*-algebras, and saw in <code>analysis/normed_space/star.lean</code> the following:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- To get a C‚ãÜ-algebra `E` over field `ùïú`, use</span>\n<span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_ring</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_ring</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cstar_ring</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n <span class=\"o\">[</span><span class=\"n\">normed_algebra</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_module</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span><span class=\"bp\">.</span>\n</code></pre></div>\n<p>However, it seems that this is only going to give us <em>unital</em> C*-algebras. </p>\n<p>Of course, in the theory of C*-algebras, non-unital algebras play a prominent and crucial role, so we would need to handle these as well. When I went looking for the analogous typeclasses to define those, all I could find was <code>[non_unital_semiring R]</code>, but not even <code>[non_unital_ring R]</code> or <code>[non_unital_algebra ùïú R]</code>. Is it really the case that we don't yet have definitions and basic theorems for these typeclasses, or am I missing them, or is there some other way to do it?</p>",
        "id": 261970884,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637260900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I believe this is correct.  Note that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/cstar_ring\">docs#cstar_ring</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/non_unital_semiring\">docs#non_unital_semiring</a> are quite new (last few months), so the people who introduced them may not yet have developed all the theory for them which they envision.</p>",
        "id": 261976233,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637263125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> introduced C^*-algebras one week ago! <a href=\"https://github.com/leanprover-community/mathlib/issues/10145\">#10145</a></p>",
        "id": 261976479,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637263222
    },
    {
        "content": "<p>Yes this is all very new. I don't know much about non-unital C*-algebras, but given how this part of the library is constructed, I don't think it will be a big problem: almost every property involved comes from a different typeclass, so it's probably just a matter of figuring out the right list of typeclasses to include.</p>",
        "id": 261977343,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637263566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span>, do you have any plans to develop non-unital rings, algebras, normed algebras, etc?</p>",
        "id": 261977362,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637263571
    },
    {
        "content": "<p>Thanks for the confirmation. Yes, I did notice they were new. <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span>, I would be interested in helping you out with the development of C*-algebra theory. I guess there is a lot do. Do you already have a road map in mind (at least for the beginning), or is that something we need to develop? From my perspective, it seems like the background to handle the non-unital algebras is the most important, but then we need to work on fundamental results in Banach algebras.</p>",
        "id": 261977414,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637263595
    },
    {
        "content": "<p>One smallish, beginner-level task which occurs to me is proving that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function\">docs#bounded_continuous_function</a> is a C*-algebra.</p>",
        "id": 261977750,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637263728
    },
    {
        "content": "<p>The fact that it's a normed algebra is already there:<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.normed_algebra\">docs#bounded_continuous_function.normed_algebra</a></p>",
        "id": 261977930,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637263799
    },
    {
        "content": "<p>Sure, getting all the instances mentioned at the top would be relatively easy. Completeness would be a bit tricky, unless we already know that uniform limits of continuous functions are continuous, in which case it wouldn't be too hard.</p>",
        "id": 261978670,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637264056
    },
    {
        "content": "<p>Yep, it's there already.  <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_continuous_function.complete_space\">docs#bounded_continuous_function.complete_space</a></p>",
        "id": 261978789,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637264102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Excellent! There is indeed a lot to do (i.e. almost everything!), and it would be good to have someone who actually knows C*-algebras well to help out, as I'm hardly an expert -- in \"real life\" I only deal with finite-dimensional Euclidean spaces. The main thing I want to do is to get the functional calculus working: given a function <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span> on the spectrum of an operator <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 261978848,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637264132
    },
    {
        "content": "<p>Yes, of course, that is the most desirable initial goal.</p>",
        "id": 261978970,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637264177
    },
    {
        "content": "<p>I think the obvious next step right now is to define the spectrum.</p>",
        "id": 261979148,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637264272
    },
    {
        "content": "<p>It seems that inevitably when you create a typeclass with more than one field like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_monoid\">docs#star_monoid</a>, someone will eventually come along and say \"but I only want one of those fields!\". Supporting non-unital star algebras will amount to creating a <code>star_semigroup</code> below <code>star_monoid</code> and <code>star_non_unital_ring</code> below <code>star_ring</code></p>",
        "id": 261979150,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637264273
    },
    {
        "content": "<p>I'd love to see the Gelfand-Naimark theorem.  <span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kyt√∂l√§</span> has an open PR for the Banach-Alaoglu theorem, so maybe we have most of the prerequisites.</p>",
        "id": 261979399,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637264377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span>, we don't have a definition of spectrum yet, do we? I wonder about which functional calculus we should try to do first. In Banach algebras, we have a holomorphic functional calculus, but developing this will require lots of background about contour integrals with values in banach spaces. The continuous functional calculus will require the Gelfand transform.</p>",
        "id": 261979617,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637264470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  it is likely the case that Gelfand-Naimark is an easier first step than a functional calculus.</p>",
        "id": 261980012,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637264631
    },
    {
        "content": "<p>That's right, we don't have the spectrum yet. It was on my to-do list, but you're more than welcome to go for it!</p>",
        "id": 261980973,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637265020
    },
    {
        "content": "<p>I think you're right about Gelfand-Naimark, it'll be a lot easier to formalize than the holomorphic functional calculus.</p>",
        "id": 261981326,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637265212
    },
    {
        "content": "<p>My understanding is that once we get Gelfand-Naimark, we get functional calculus essentially for free.</p>",
        "id": 261981552,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637265307
    },
    {
        "content": "<p>Hmmm, that's not the way I'm used to doing it. What is the main idea of that argument? How does GNS give you a functional calculus?</p>",
        "id": 261981789,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637265421
    },
    {
        "content": "<p>A definition of spectrum I think should be relatively easy. How's this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">definition</span> <span class=\"n\">spectrum</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set</span> <span class=\"bp\">ùïú</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">|</span> <span class=\"bp\">¬¨</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">‚Ä¢</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>But I don't know where to put it. Would it belong in <code>algebra/algebra/basic</code>?</p>",
        "id": 261982513,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637265721
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/C*-algebras/near/261981789\">said</a>:</p>\n<blockquote>\n<p>Hmmm, that's not the way I'm used to doing it. What is the main idea of that argument? How does GNS give you a functional calculus?</p>\n</blockquote>\n<p>Maybe you don't actually need GNS; basically the argument is that given an element <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> your algebra, you can define an isomorphism between continuous functions on the spectrum of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> and the algebra. Then, you define <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(A)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> as the isomorphism applied to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span>. The reference I'm using is Kadison and Ringrose, \"Fundamentals of the Theory of Operator Algebras\", this stuff is at the beginning of the chapter on C*-algebras and doesn't seem too hard to formalize (at least a lot easier than the holomorphic calculus).</p>",
        "id": 261983312,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637266082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/C*-algebras/near/261982513\">said</a>:</p>\n<blockquote>\n<p>A definition of spectrum I think should be relatively easy. How's this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">definition</span> <span class=\"n\">spectrum</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">set</span> <span class=\"bp\">ùïú</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ùïú</span> <span class=\"bp\">|</span> <span class=\"bp\">¬¨</span> <span class=\"n\">is_unit</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">‚Ä¢</span><span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>But I don't know where to put it. Would it belong in <code>algebra/algebra/basic</code>?</p>\n</blockquote>\n<p>This looks like a good opportunity to try out  that script someone posted a few days ago to figure out where to put a lemma!</p>",
        "id": 261983509,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637266191
    },
    {
        "content": "<p>That looks to me like it's probably worthy of its own file, along with hopefully a handful of trivial statements about it</p>",
        "id": 261983835,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637266342
    },
    {
        "content": "<p>Perhaps <code>algebra/algebra/spectrum</code>?</p>",
        "id": 261983908,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637266391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span>, yes I'm quite familiar with Kadison and Ringrose. What you just described is the Gelfand transform. Basically, there is a homomorphism from any <em>commutative</em> (unital) Banach algebra into the (necessarily bounded) continuous functions on the compact Hausdorff space (the spectrum of the algebra, equivalently the space of characters, equivalently the maximal ideal space) equipped with the weak* topology. When the algebra is a commutative unital C*-algebra, one can show that this homomorphism is actually a * isomorphism.</p>\n<p>From this one can recover the continuous functional calculus for <em>normal</em> elements of a C*-algebra (normal because one needs that the algebra generated by this element is commutative).</p>",
        "id": 261984131,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637266512
    },
    {
        "content": "<p>Hi all! I would also be really happy to see <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mo>‚àó</mo></msup></mrow><annotation encoding=\"application/x-tex\">C^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span></span></span></span> algebras in mathlib.</p>\n<p>It is well outside my own expertise, but <em>if</em> someone knowledgeable (e.g. among the participants in this discussion) is willing to coordinate the development of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mo>‚àó</mo></msup></mrow><annotation encoding=\"application/x-tex\">C^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6887em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6887em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span></span></span></span> algebras in mathlib in a way that leaves room for minor and sporadic contributions, I would be very happy to try to participate a little. (I'll at least try to clean up the Banach-Alaoglu PR...)</p>",
        "id": 261984310,
        "sender_full_name": "Kalle Kyt√∂l√§",
        "timestamp": 1637266613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>, I'll get started on that.</p>",
        "id": 261984365,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637266639
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"373986\">@Kalle Kyt√∂l√§</span>, getting Banach-Alaoglu would be a massive help.</p>",
        "id": 261984690,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637266771
    },
    {
        "content": "<p>Here is Kalle's Banach-Alaoglu PR, by the way: <a href=\"https://github.com/leanprover-community/mathlib/issues/9862\">#9862</a></p>",
        "id": 261984971,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637266892
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> for context, the reason non-unital algebras play such an important role in C^*-algebras and a relatively less important role in other kinds of algebras is due to <em>spectral permanence</em>: given a non-unital C^*-algebra <code>A</code> and a * embedding of <code>A</code> into some <em>unital</em> C^*-algebra <code>B</code>, then for any <code>x : A</code>,  the spectrum of <code>‚Üëx : B</code> is independent of <code>B</code>.  This allows you to define the spectrum of <code>x : A</code> meaningfully (by defining it as the spectrum in the unitization of A). Spectral permanence does not hold in Banach algebras (even in Banach * algebras).</p>",
        "id": 261986274,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637267419
    },
    {
        "content": "<p>(btw I'm trying to review <a href=\"https://github.com/leanprover-community/mathlib/issues/9836\">#9836</a> but I'm new to all of this)</p>",
        "id": 261988013,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1637268292
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/C*-algebras/near/261977362\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span>, do you have any plans to develop non-unital rings, algebras, normed algebras, etc?</p>\n</blockquote>\n<p>I realise the thread has moved on but since I was directly asked I feel duty bound to reply: I do not currently have such plans but we always knew it was inevitable that we would need such definitions. Eric's work defining <code>non_unital_semiring</code> etc. shows that this can be done, is very valuable and just requires persistence.</p>",
        "id": 262043674,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637313628
    },
    {
        "content": "<p>I do wonder about the future of <code>comm_ring</code> though because we will also want to talk about commutative versions of all of all of these. Maybe <code>[comm_ring R]</code> should become <code>[ring R] [is_commutative R]</code></p>",
        "id": 262043962,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637313828
    },
    {
        "content": "<p>I have always thought it odd that we have ring and comm_ring and integral_domain all as top-level data-carrying types</p>",
        "id": 262047225,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637316092
    },
    {
        "content": "<p>On the other hand I'm slightly scared about <code>module</code> turning into <code>left_module</code> in the commutative case</p>",
        "id": 262047387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637316185
    },
    {
        "content": "<p><code>integral_domain</code> is now <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_domain\">docs#is_domain</a> and doesn't carry data</p>",
        "id": 262047505,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637316263
    },
    {
        "content": "<p>I can't help feeling that if we add <code>is_commutative R</code> we should be adding <code>is_associative R</code> too</p>",
        "id": 262047541,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637316288
    },
    {
        "content": "<p>And then of course we end up with <code>is_add_commutative R</code> too...</p>",
        "id": 262047612,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637316332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> I now have a file with some basic results about the spectrum of an element <code>a : A</code> where <code>A</code> is an <code>R</code>-algebra. The main results say that addition of elements of <code>R</code> commutes with spectrum, and does multiplication by units of <code>R</code>. Finally, the units of <code>R</code> in the spectrum of <code>a*b</code> coincide with those in the spectrum of <code>b*a</code>. The next main item in this agenda would be to prove the spectral mapping theorem for polynomials (here I think we will need to assume the scalars are an algebraically closed field, at least for one of the directions).</p>",
        "id": 262131975,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637357035
    },
    {
        "content": "<p>This is my first contribution, and so it is likely a bit too messy for mathlib as is (e.g., at the very least, it could probably use some golfing, attribute tagging, but likely much more). Should I create a PR anyway and just modify it? I don't want to waste reviewers time if possible.</p>",
        "id": 262132193,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637357155
    },
    {
        "content": "<p>Definitely make a PR. We‚Äôll be delighted to review it. We all learned by submitting PRs.</p>",
        "id": 262136060,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637359247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> Nice! I definitely think you should PR this. Have you looked at this page? <a href=\"https://leanprover-community.github.io/contribute/index.html\">https://leanprover-community.github.io/contribute/index.html</a></p>",
        "id": 262136141,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637359282
    },
    {
        "content": "<p>If it‚Äôs hundreds of lines, you might be asked to split it up but just creating the PR is a good first step.</p>",
        "id": 262136158,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637359293
    },
    {
        "content": "<p>There are instructions on how to make a first PR and a style guide -- just try to make your code fit the official style as best as you can, and then go ahead and open the PR!</p>",
        "id": 262136326,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1637359366
    },
    {
        "content": "<p>Yes, I have looked at the contribution guidelines, naming conventions, etc. I'll submit the PR shortly. It's about 200 lines.</p>",
        "id": 262136402,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637359420
    },
    {
        "content": "<p>Can someone give me write access to the non-master branches, or should I fork and PR? My github user name is: j-loreaux</p>",
        "id": 262141131,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637361838
    },
    {
        "content": "<p>Done, check <a href=\"https://github.com/leanprover-community/mathlib/invitations\">https://github.com/leanprover-community/mathlib/invitations</a></p>",
        "id": 262141499,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637362034
    },
    {
        "content": "<p>PR for spectrum: <a href=\"https://github.com/leanprover-community/mathlib/issues/10390\">#10390</a></p>",
        "id": 262153159,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1637371211
    },
    {
        "content": "<p>My specialisation is JB<code>*</code>-triples, so I know a certain amount about C<code>*</code>-algebras. (C<code>*</code>-algebras are special types of JB<code>*</code>-algebra, which are a type of JB<code>*</code>-triple). I'm interested in developing the theory of JB<code>*</code>-triples in Lean.</p>\n<p>On the subject of units, I've always defined a (non-associative) \"algebra\" to be a bilinear map on a vector space <code>A</code> (or more generally a module). When <code>A</code> is unital, it's easy to relate this to the definition of \"algebra\" in lean (where it's a ring homomorphism into the centre of <code>A</code>). If I was going to define \"algebra\" as a ring homomorphism then I would define it as a homomorphism into the centroid of the ring <code>A</code>. This gets over the problem of <code>A</code> not having a unit.</p>\n<p>Similarly, I define a triple as a trilinear map on a vector space/R-module <code>A</code>. If R is a <code>*</code>-module, then I define a <code>*</code>-triple as a map A¬≥ ‚Üí A which is linear and symmetric in the first and third variable and conjugate linear in the second. Triples also have a centroid. I've been pondering today if one could start with a concept of a \"triple ring\" <code>A</code> and then define a triple as a ring homomorphism into the centroid. It's not clear to me that this can be extended to <code>*</code>-triples though, as there isn't actually an involution defined on <code>A</code>.</p>\n<p>(Then there are even more general structures such as Jordan pairs and partial *-triples to consider.)</p>\n<p>Restricting attention back to the algebra case, of course it's possible to attach a unit to an algebra, but I seem to recall that extending the norm to the unitisation of a C<code>*</code>-algebra so that the unitisation is also a C<code>*</code>-algebra is more involved (Murphy, Theorem 2.1.6).</p>\n<p>I guess this is a verbose way of asking why mathlib uses the ring homomorphism definition of algebra rather than the bilinear map version? Possibly the homomorphism definition has advantages from a pure algebra point of view which I'm unaware of?</p>",
        "id": 264633578,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639329894
    },
    {
        "content": "<p>On attaching a unit: getting the C^* Norm comes essentially from considering the left regular representation of the algebra on itself. I don't consider this terribly onerous. </p>\n<p>The rest I'll have to think/read about.</p>",
        "id": 264633871,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1639330293
    },
    {
        "content": "<p>Why mathlib uses the ring hom definition? Because this part of the library was originally formalised with the motivation being schemes, so we followed a commutative algebra textbook and here the definitions are equivalent (and the ring hom definition is easy to work with)</p>",
        "id": 264634831,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639331549
    },
    {
        "content": "<p>It has been noted several times that if one is not doing commutative algebra then it's awkward sometimes in Lean and various proposals have been made to change the definitions. However it's also the case that because we got very advanced in commutative algebra very quickly we could make perfectoid spaces and ultimately works like this have brought new users into the community and have contributed to its growth in recent years, so it's not all bad.</p>",
        "id": 264634938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1639331686
    },
    {
        "content": "<p>I should return to <a href=\"https://github.com/leanprover-community/mathlib/pull/10221\">#10221</a>, which adds an explanation of why algebra is the way it is</p>",
        "id": 264637454,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639334721
    },
    {
        "content": "<p>So, as things currently stand in Mathlib, one could construct a non-associative, non-unital complex *-algebra like this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">star_mul_zero_class</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_zero_class</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">star</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">star_non_unital_non_assoc_semiring</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">star_mul_zero_class</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_add</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">star</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>(Except I also want an additive inverse - I guess that can be inferred from <code>[module ‚ÑÇ A]</code>)</p>",
        "id": 264640433,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639338753
    },
    {
        "content": "<p>Yes, at a glance that looks reasonable</p>",
        "id": 264642101,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639341027
    },
    {
        "content": "<p>I think the <code>star</code> classes you mention there are missing because no one needed them yet. I can't comment on whether they're things that are likely to be needed</p>",
        "id": 264642123,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639341111
    },
    {
        "content": "<p>Why force <code>mul_zero_class</code> into <code>star_mul_zero_class</code> and <code>non_unital_non_assoc_semiring</code> into <code>star_non_unital_non_assoc_semiring</code>, though?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">star_mul_class</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">star</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">star_add_class</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_add</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">star</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_mul_class</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_add_class</span> <span class=\"n\">A</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>",
        "id": 264642425,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1639341518
    },
    {
        "content": "<p>I was adapting the existing definitions of <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/star/basic.lean#L202\">star_ring</a> and <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/star/basic.lean#L71\">star_monoid</a> to the <code>non_unital_non_assoc_semiring</code> case. That may not be the best way to do it though?</p>",
        "id": 264642824,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639342156
    },
    {
        "content": "<p>Oh yeah actually the definitions I just gave should probably replace <code>star_ring</code> and <code>star_monoid</code>. Then you don't need any new definition for your stuff so far.</p>",
        "id": 264642922,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1639342296
    },
    {
        "content": "<p>Doesn't that put two different star structures on <code>A</code>?</p>",
        "id": 264644671,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639344696
    },
    {
        "content": "<p>Oh true. I guess you want the intersection as well or make them mixins. But <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_ring\">docs#star_ring</a> is definitely asking for too much, right?</p>",
        "id": 264645228,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1639345558
    },
    {
        "content": "<p>We could just relax the typeclass on the existing definition</p>",
        "id": 264645638,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639346149
    },
    {
        "content": "<p>Yeah that's exactly what I meant.</p>",
        "id": 264645689,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1639346200
    },
    {
        "content": "<p>So, this will establish that</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span>  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">‚ÑÇ</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>has an additive inverse:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span>  <span class=\"n\">ring_module_has_add_group</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">add_group</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">),</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span><span class=\"o\">),</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">‚Ä¢</span><span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">add_left_neg</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">nth_rewrite</span> <span class=\"mi\">1</span>  <span class=\"bp\">‚Üê</span> <span class=\"o\">(</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">has_neg.neg</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">‚Üê</span> <span class=\"n\">add_smul</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"mi\">1</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">add_left_neg</span><span class=\"o\">,</span> <span class=\"n\">zero_smul</span><span class=\"o\">]</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>In fact this works more generally for <code>R</code> a ring. It feels a bit odd to be doing it this way around (i.e. <code>R</code> a ring, <code>A</code> a semiring rather than <code>R</code> a semiring and <code>A</code> a (non-unital, non-associative) ring. I guess the alternative would be to introduce another set of classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A not-necessarily-unital, not-necessarily-associative semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor add_comm_group distrib mul_zero_class]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">add_comm_group</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">distrib</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_class</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- An associative but not-necessarily unital semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring semigroup_with_zero]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">semigroup_with_zero</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- A unital but not-necessarily-associative semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring mul_zero_one_class]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_one_class</span> <span class=\"n\">Œ±</span>\n</code></pre></div>\n<p>?</p>",
        "id": 264762495,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639426022
    },
    {
        "content": "<p>Are you asking for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.add_comm_monoid_to_add_comm_group\">docs#module.add_comm_monoid_to_add_comm_group</a>?</p>",
        "id": 264788920,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639440169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks. So, trying to put this all together, one might have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span>  <span class=\"n\">ring_module_has_add_comm_group</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">A</span> <span class=\"o\">:=</span> <span class=\"n\">module.add_comm_monoid_to_add_comm_group</span> <span class=\"n\">R</span>\n\n<span class=\"c1\">-- Replaces algebra.star star_monoid</span>\n<span class=\"kd\">class</span> <span class=\"n\">star_mul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">star</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Replaces algebra.star star_ring</span>\n<span class=\"kd\">class</span> <span class=\"n\">star_add</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_add</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">star</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n\n<span class=\"c1\">-- Let R br a *-ring and let A be a non-unital, non-associative R*-module</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">star_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_add</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_mul</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">star_add</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- c.f. analysis.normed-spaces normed_ring</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_non_unital_non_assoc_semiring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_sub</span> <span class=\"n\">Œ±</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">has_norm</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">metric_space</span> <span class=\"n\">Œ±</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dist_eq</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">norm_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">‚â§</span> <span class=\"n\">norm</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">norm</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_non_unital_non_assoc_semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- c.f. normed_algebra</span>\n<span class=\"kd\">class</span> <span class=\"n\">normed_module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_norm</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_norm</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_scalar_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">norm</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">‚Ä¢</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">norm</span> <span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">norm</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">normed_module</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Replaces analysis.normed-spaces.star cstar_ring</span>\n<span class=\"kd\">class</span> <span class=\"n\">cstar_condition</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_star</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_norm</span> <span class=\"n\">E</span><span class=\"o\">]:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_star_mul_self</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">},</span> <span class=\"bp\">‚à•</span><span class=\"n\">star</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">=</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span> <span class=\"bp\">*</span> <span class=\"bp\">‚à•</span><span class=\"n\">x</span><span class=\"bp\">‚à•</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">cstar_condition</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">cstar_condition</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Check that we haven't accidentally given A a unit</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>(Except that for a C*-algebra, the multiplication would be associative, and the norm complete.)</p>",
        "id": 264824021,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639469874
    },
    {
        "content": "<p>That doesn't work, because <code>[star_add A] [star_mul A]</code> means \"let A have two different star operators, one additive and one multiplicative\"</p>",
        "id": 264824324,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639470080
    },
    {
        "content": "<p>And you also do not want your <code>ring_module_...</code> instance, it's dangerous and creates diamonds</p>",
        "id": 264824434,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639470159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span>  thanks, so instead I would need to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- Replaces algebra.star star_monoid</span>\n<span class=\"kd\">class</span> <span class=\"n\">star_mul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_mul</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">*</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">star</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Replaces algebra.star star_ring</span>\n<span class=\"kd\">class</span> <span class=\"n\">star_add</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_involutive_star</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">star_add</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">star</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">star</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">star</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">has_involutive_star</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n</code></pre></div>\n<p>How did you intend me to use <code>module.add_comm_monoid_to_add_comm_group</code>?</p>",
        "id": 264825697,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639471038
    },
    {
        "content": "<p>I only wanted to point out that it already exists. But even though it exists, I highly doubt you want to use it here.</p>",
        "id": 264825829,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471123
    },
    {
        "content": "<p>That approach indeed solves the doubled star operator, but is annoying to work with</p>",
        "id": 264825928,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471194
    },
    {
        "content": "<p>Have a look at how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_ring/src\">src#star_ring</a> avoids the problem in a different way (via <code>star_ring.to_star_add_monoid</code> immediately below)</p>",
        "id": 264826018,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471231
    },
    {
        "content": "<p>Would it be better to use the alternative approach I mentioned earlier?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A not-necessarily-unital, not-necessarily-associative semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor add_comm_group distrib mul_zero_class]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">add_comm_group</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">distrib</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_class</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- An associative but not-necessarily unital semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring semigroup_with_zero]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">semigroup_with_zero</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- A unital but not-necessarily-associative semiring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring mul_zero_one_class]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">mul_zero_one_class</span> <span class=\"n\">Œ±</span>\n</code></pre></div>",
        "id": 264826064,
        "sender_full_name": "Christopher Hoskin",
        "timestamp": 1639471269
    },
    {
        "content": "<p>Those typeclasses look reasonable to me, I think they're not there because no one needed them.</p>",
        "id": 264826111,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471311
    },
    {
        "content": "<p>Although the extends clauses are wrong</p>",
        "id": 264826239,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471373
    },
    {
        "content": "<p>They should extend the semiring versions</p>",
        "id": 264826268,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471395
    },
    {
        "content": "<p>And the last one should extend the other two</p>",
        "id": 264826303,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639471431
    },
    {
        "content": "<p>That is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A not-necessarily-unital, not-necessarily-associative ring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor add_comm_group non_unital_non_assoc_semiring ]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">add_comm_group</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">non_unital_non_assoc_semiring</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- An associative but not-necessarily unital ring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring non_unital_semiring ]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_unital_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">non_unital_semiring</span> <span class=\"n\">Œ±</span>\n\n<span class=\"sd\">/-- A unital but not-necessarily-associative ring. -/</span>\n<span class=\"kd\">@[protect_proj, ancestor non_unital_non_assoc_ring non_assoc_semiring ]</span>\n<span class=\"kd\">class</span> <span class=\"n\">non_assoc_ring</span> <span class=\"o\">(</span><span class=\"n\">Œ±</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span>\n  <span class=\"n\">non_unital_non_assoc_ring</span> <span class=\"n\">Œ±</span><span class=\"o\">,</span> <span class=\"n\">non_assoc_semiring</span> <span class=\"n\">Œ±</span>\n</code></pre></div>",
        "id": 264842650,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639480980
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/C*-algebras/near/264637454\">said</a>:</p>\n<blockquote>\n<p>I should return to <a href=\"https://github.com/leanprover-community/mathlib/pull/10221\">#10221</a>, which adds an explanation of why algebra is the way it is</p>\n</blockquote>\n<p>This docstring is now live at <a href=\"https://leanprover-community.github.io/mathlib_docs/algebra/algebra/basic.html#implementation-notes\">https://leanprover-community.github.io/mathlib_docs/algebra/algebra/basic.html#implementation-notes</a></p>",
        "id": 265082394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1639605797
    },
    {
        "content": "<p>Just noting for anyone else passing the same way: Eric's suggestion for <code>non_unital_non_assoc_ring</code> above was implemented by Christopher in <a href=\"https://github.com/leanprover-community/mathlib/pull/11124\">#11124</a>, but without including also the development of <code>non_unital_ring</code> (and the less interesting <code>non_assoc_ring</code>).</p>",
        "id": 273308518,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645839954
    },
    {
        "content": "<p>These are now in <a href=\"https://github.com/leanprover-community/mathlib/pull/12300\">#12300</a>.</p>",
        "id": 273308932,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645840483
    },
    {
        "content": "<p>How would everyone feel about having <code>cstar_ring</code> extend <code>star_ring</code> rather than be an additional mixin? I haven't actually tried it, but it seems it should work.</p>",
        "id": 273376207,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645928253
    },
    {
        "content": "<p>I don't have a strong opinion either way, if it works as an extension of <code>star_ring</code> I'm happy with that.</p>",
        "id": 273376391,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1645928563
    },
    {
        "content": "<p>I'll investigate.</p>",
        "id": 273386094,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645943084
    },
    {
        "content": "<p>I've just made a first attempt at defining von Neumann algebras. <a href=\"https://github.com/leanprover-community/mathlib/pull/12329\">#12329</a></p>\n<p>I've given both abstract definition (C^* algebra with a Banach predual) and the concrete definition (parameterised by a Hilbert space H, a star subalgebra of B(H) which is equal to its double commutant).</p>\n<p>Knowing me there is something horribly wrong with one or both of the definitions --- there's no theorems about either yet!</p>\n<p>However both definitions were pleasantly easy to make: thanks everyone for all the work on mathlib.</p>",
        "id": 273386158,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645943231
    },
    {
        "content": "<p>I'll have a look soon! I'm excited.</p>",
        "id": 273386700,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645944120
    },
    {
        "content": "<p>(I probably should have proved even the most basic theorems before posting this. It's an RFC, not a PR. :-)</p>",
        "id": 273386744,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1645944159
    }
]
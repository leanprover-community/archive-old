[
    {
        "content": "<p>What is the proper definition of \"cyclic permutation\" if working over an infinite type? The current definition in mathlib is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- A permutation is a cycle when any two nonfixed points of the permutation are related by repeated</span>\n<span class=\"sd\">  application of the permutation. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">is_cycle</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">^</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span>\n</code></pre></div>\n<p>However, that indicates that <code>(+ 1)</code> is a cyclic permutation:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.perm.cycles</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">equiv</span> <span class=\"n\">equiv.perm</span>\n\n<span class=\"kd\">@[simps apply symm_apply]</span>\n<span class=\"kd\">def</span> <span class=\"n\">succ_equiv</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">succ_equiv_inv_apply</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">succ_equiv</span><span class=\"bp\">⁻¹</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">inv_def</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">succ_equiv_pow_apply</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">succ_equiv</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">hk</span> <span class=\"n\">generalizing</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">pow_succ'</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">succ_equiv_gpow_apply</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">succ_equiv</span> <span class=\"bp\">^</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">k</span> <span class=\"n\">using</span> <span class=\"n\">int.induction_on</span> <span class=\"k\">with</span> <span class=\"n\">k</span> <span class=\"n\">IH</span> <span class=\"n\">k</span> <span class=\"n\">IH</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">gpow_add</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">gpow_sub</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">inv_def</span><span class=\"o\">,</span> <span class=\"n\">symm_apply_eq</span><span class=\"o\">,</span>\n        <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span> <span class=\"n\">add_left_comm</span><span class=\"o\">,</span> <span class=\"n\">add_sub</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">infinite_cycle</span> <span class=\"o\">:</span> <span class=\"n\">is_cycle</span> <span class=\"n\">succ_equiv</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">is_cycle</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Would it make sense to redefine <code>is_cycle p</code> to somehow encode that <code>∃ (k : ℕ) (hk : 1 &lt; k), p ^ k = 1</code>?</p>",
        "id": 238784374,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621006074
    },
    {
        "content": "<p>Yes, (+ 1) is cyclic</p>",
        "id": 238784542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621006136
    },
    {
        "content": "<p><code>int</code> is also a cyclic group</p>",
        "id": 238784637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621006188
    },
    {
        "content": "<p>OK, and does factoring a permutation into its disjoint cycles only make sense in finite contexts?</p>",
        "id": 238784884,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621006288
    },
    {
        "content": "<p>It should always make sense with this definition</p>",
        "id": 238785048,
        "sender_full_name": "David Wärn",
        "timestamp": 1621006371
    },
    {
        "content": "<p>well you have to do something special since there could be an ininite number of pairwise disjoint cycles but yes it works</p>",
        "id": 238785072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621006380
    },
    {
        "content": "<p>It's the classification of group actions by Z. Generally if you have G acting on X, then X can be partitioned into orbits, such that each orbit looks like the action of G on G / H for some H</p>",
        "id": 238785642,
        "sender_full_name": "David Wärn",
        "timestamp": 1621006602
    },
    {
        "content": "<p>Even computably, it works?</p>",
        "id": 238785700,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621006627
    },
    {
        "content": "<p><code>cycle_factors</code> as it is currently in mathlib assumes <code>fintype</code>. Does one rely on some sort of <code>attach</code> magic to make it work over infinite types?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simps apply]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">attach</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">perm</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">perm.subtype_perm</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 238785909,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1621006719
    },
    {
        "content": "<blockquote>\n<p>Even computably, it works?</p>\n</blockquote>\n<p>No, the \"in the same cycle\" relation is not decidable</p>",
        "id": 238790216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621008564
    },
    {
        "content": "<p>Why do we require <code>f x ≠ x</code>? Aren't one-cycles cycles?</p>",
        "id": 238809821,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1621016942
    },
    {
        "content": "<p>I think this is something like \"1 is not a prime\"</p>",
        "id": 238810043,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621017038
    },
    {
        "content": "<p>if you include 1 cycles then you can't say that a cycle is a cycle since there are all those 1 cycles on all the other points</p>",
        "id": 238810093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621017067
    },
    {
        "content": "<p>I think you would need another representation of \"cycle\" that picks out the subset that is the cycle to be able to talk about 1-cycles properly</p>",
        "id": 238810256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621017136
    },
    {
        "content": "<p>By \"an element is a product of disjoint cycles\" I've always implicitly assumed that the 1-cycles are there but not mentioned, but now I see there's another approach. It's a bit different to \"1 is not prime\" but it's very similar. Is a cycle in a symmetric group a pair (g,S) where S is a subset of the set plus a proof that the cycle acts transitively on the set and fixes everything else? If so then the identity is a cycle in more than one way in general. If the cycle is determined by g only then the identity will have to be the empty product of cycles (which is fine, but I had never thought of it like that, in contrast to 1 definitely being the empty product of primes)</p>",
        "id": 238810822,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621017386
    },
    {
        "content": "<p>Yes, this is a bit different to 1 not being prime. If you think about the partition of [n] into orbits, then a 1-cycle is just an orbit with one element (where the action of Z looks like the action on Z/1Z), and there's nothing special about this. But if you think of a cycle as a permutation, and the cycle decomposition as a product, then one-cycles look special, unless you remember their \"support\". Sometimes it's very important to remember one-cycles: for example if you have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi><mo>∈</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sigma \\in A_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, then it's a fact that the conjugacy classes of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">A_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> agree precisely unless the cycle type of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span> consists of distinct odd numbers (in which case the conjugacy class in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>S</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">S_n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> splits in two), and this only works if you count one-cycles (two one-cycles means no splitting). Similarly the formula for the number of permutations with a given cycle type looks more natural with one-cycles. In mathlib, the cycle type <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.cycle_type\">docs#equiv.perm.cycle_type</a> doesn't count one-cycles, although <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.perm.partition\">docs#equiv.perm.partition</a> does. I expect each definition works better in different circumstances.</p>",
        "id": 238814398,
        "sender_full_name": "David Wärn",
        "timestamp": 1621019098
    }
]
[
    {
        "content": "<p>Where should <a href=\"https://en.wikipedia.org/wiki/Bornological_space\">bornology</a> live? Is it topology, (functional) analysis?</p>",
        "id": 271907172,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644883195
    },
    {
        "content": "<p>IMHO topology</p>",
        "id": 271908128,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644883686
    },
    {
        "content": "<p>Are you happy with <code>topology.bornology.basic</code> + <code>topology.bornology.hom</code> + <code>topology.category.Born</code>?</p>",
        "id": 271908241,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644883776
    },
    {
        "content": "<p><code>bornology.hom</code> should be called <code>bounded</code> resp. <code>bounded_map</code> to mimic <code>continuous</code> resp. <code>continuous_map</code></p>",
        "id": 271910127,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885092
    },
    {
        "content": "<p>The file or the object? because I'm calling the object <code>bounded_map</code>.</p>",
        "id": 271910211,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885148
    },
    {
        "content": "<p>Also, we can't call the predicate <code>bounded</code> for obvious reasons.</p>",
        "id": 271910245,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885178
    },
    {
        "content": "<p>Why not?</p>",
        "id": 271910253,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885187
    },
    {
        "content": "<p>Because it already refers to the sets.</p>",
        "id": 271910263,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885198
    },
    {
        "content": "<p>A set can't be continuous, but it definitely can be bounded.</p>",
        "id": 271910277,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885212
    },
    {
        "content": "<p>Just as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_open_map\">docs#is_open_map</a> is not called <code>is_open</code>.</p>",
        "id": 271910291,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885228
    },
    {
        "content": "<p>Ok, so <code>is_bounded_map</code> and <code>bounded_map</code></p>",
        "id": 271910349,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885253
    },
    {
        "content": "<p>Do we need unbundled version?</p>",
        "id": 271910384,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644885286
    },
    {
        "content": "<p>Maybe? I don't know. I just did the bundled version because I know for sure it will be useful.</p>",
        "id": 271910411,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885310
    },
    {
        "content": "<p>Jireh had done an unbundled version earlier.</p>",
        "id": 271910430,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885324
    },
    {
        "content": "<p>I think the unbundled version would be useful to have, e.g. for bounded linear maps</p>",
        "id": 271910448,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885340
    },
    {
        "content": "<p>What do you have in mind? Do you want to show <code>is_bounded_map f</code> for all bounded linear maps <code>f</code>? because that's not how it works since the hom refactor.</p>",
        "id": 271910533,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885392
    },
    {
        "content": "<p>Why isn't the predicate on sets called <code>is_bounded</code> btw to be consistent with <code>is_open</code>?</p>",
        "id": 271910534,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885393
    },
    {
        "content": "<p>Well, actually, it is called like that.</p>",
        "id": 271910581,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885432
    },
    {
        "content": "<p>BTW we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded\">docs#bounded</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metroc.bounded\">docs#metroc.bounded</a></p>",
        "id": 271910585,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644885433
    },
    {
        "content": "<p>No, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.bounded\">docs#set.bounded</a> since <span class=\"user-mention\" data-user-id=\"459227\">@Violeta Hernández</span> came along.</p>",
        "id": 271910616,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885461
    },
    {
        "content": "<p>Ah, the former is now called <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.bounded\">docs#set.bounded</a></p>",
        "id": 271910632,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644885473
    },
    {
        "content": "<p>Oh I thought you were complaining at my suggestion for the name  <code>bounded</code> for the predicate on maps because it conflicts with the name for sets.</p>",
        "id": 271910709,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885513
    },
    {
        "content": "<p>I honestly don't really care about names. But I do think we should try to be consistent.</p>",
        "id": 271910757,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885551
    },
    {
        "content": "<p>Ah no, I complained because it was not obviously about functions and could easily be confused with several predicates about sets.</p>",
        "id": 271910767,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885558
    },
    {
        "content": "<p>Now what's the issue with bounded linear maps? I haven't been following the morphism refactor.</p>",
        "id": 271910898,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885659
    },
    {
        "content": "<p>I'm asking you what you expect from the unbundled predicate. If there is some type such that all its terms are (mathematically, not in Lean) <code>bounded_map</code>s, then this type will get a <code>bounded_map_class</code> instance rather than a lemma saying all its terms respect <code>is_bounded_map</code>.</p>",
        "id": 271910987,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885750
    },
    {
        "content": "<p>How would you define a bounded linear map?</p>",
        "id": 271911164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644885894
    },
    {
        "content": "<p>What do you mean? <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_bounded_linear_map\">docs#is_bounded_linear_map</a> is already a thing, but I don't know if that's what you're referring to. You're the one who brought them up.</p>",
        "id": 271911229,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644885962
    },
    {
        "content": "<p>Yury asked whether we should have an unbundled version. What I was suggesting is that it would be worthwhile to have because we have definitions, like bounded linear maps, which impose boundedness as a predicate in addition to some other property, like linearity. Similarly to how continuity can be dropped in to define continuous multiplication, etc. If we only had a bundled version, defining such things would get annoying.</p>",
        "id": 271911528,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644886182
    },
    {
        "content": "<p>Sorry, my brain is bundled. I cannot comprehend such thoughts <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 271911639,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644886260
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12046\">#12046</a> for <code>bounded_map</code><br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/12045\">#12045</a> for <code>Born</code></p>",
        "id": 271911708,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644886318
    },
    {
        "content": "<p>Honestly, I'm not qualified to know whether we need the unbundled predicate. My job is the bundled type. Feel free to add the unbundled version if you feel like it's needed. Just be aware of what the bundled type can do.</p>",
        "id": 271911875,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644886441
    },
    {
        "content": "<p>Sorry if my question was written in a way that suggested negative answer. I just thought that this is a question that should be asked. If the unbundled version is useful, then we should have it.</p>",
        "id": 271914285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644888223
    },
    {
        "content": "<p>If you want the unbundled version I wrote, it's sitting in a commit on the branch for <a href=\"https://github.com/leanprover-community/mathlib/pull/12036\">#12036</a>, but it should be moved and renamed according to the above.</p>",
        "id": 271916391,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644890090
    },
    {
        "content": "<p>Could you also add a class <code>bounded_space</code> that says <code>bounded univ</code>?</p>",
        "id": 271953100,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644920565
    },
    {
        "content": "<p>It seems there are two (incompatible?) ways to get a bornology from a metric space. One is to declare bounded all sets which are contained in some ball, the other is to get the topology induced by the metric and declare bounded the sets whose closure is compact.</p>",
        "id": 271953672,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644920885
    },
    {
        "content": "<p>This also suggests <code>topological_space</code> should extend <code>bornological_space</code>. Do not do this in <a href=\"https://github.com/leanprover-community/mathlib/pull/12036\">#12036</a> though.</p>",
        "id": 271953724,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644920916
    },
    {
        "content": "<p>Can you also a reducible non-instance <code>bornological_space.cofinite</code> (not sure about the name) where <code>cobounded := cofinite</code>?</p>",
        "id": 271953792,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644920968
    },
    {
        "content": "<p>Then we'll get the nice instance <code>compact_space -&gt; bounded_space</code>.</p>",
        "id": 271953906,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644921026
    },
    {
        "content": "<p>Once we have <code>bornological_space</code> in, I'll define <code>bornological_module</code> and <code>convex_bornological_module</code>.</p>",
        "id": 271954148,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644921165
    },
    {
        "content": "<p>Oh actually I think we have a naming problem. On <a href=\"https://en.wikipedia.org/wiki/Bornological_space\">Wikipedia</a>, a bornological space is not a space with a bornology, but rather a space where we can recover the topology from the bornology.</p>",
        "id": 271954651,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644921431
    },
    {
        "content": "<p>Right, the metric and topological versions are incompatible in general because any metric space is homeomorphic to the same space with a bounded metric.</p>",
        "id": 271975631,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644932985
    },
    {
        "content": "<p>So for metric spaces the bornology should be the metric (co)bounded sets, not the ones from the topology.</p>",
        "id": 271976280,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933288
    },
    {
        "content": "<p>That means you can't consider topological spaces as bornological spaces however.</p>",
        "id": 271976360,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644933329
    },
    {
        "content": "<p>Oh sorry, we do have a naming problem. I didn't catch that distinction on my read through. I guess we just use <code>bornology</code>?</p>",
        "id": 271976478,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933378
    },
    {
        "content": "<p>I'm happy with <code>bornology_space</code>, if that makes for a more coherent naming scheme.</p>",
        "id": 271976531,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644933414
    },
    {
        "content": "<p>Then we would end up having both <code>bornology_space</code> and <code>bornological_space</code>, which I think could get confusing.</p>",
        "id": 271976763,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933515
    },
    {
        "content": "<p>Eh, not our fault. You got confused too <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 271976844,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644933552
    },
    {
        "content": "<p>Right, topological spaces shouldn't get a bornology instance automatically.</p>",
        "id": 271976924,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933589
    },
    {
        "content": "<p>But I don't think we should contribute to the confusion. My preference I think it's for <code>bornology</code>.</p>",
        "id": 271977099,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933636
    },
    {
        "content": "<p>Do you know anything about bornology or are you just reading the Wikipedia like I am? Would be nice if someone had working experience with them to guide us.</p>",
        "id": 271977105,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644933638
    },
    {
        "content": "<p>No, I don't have experience.</p>",
        "id": 271977158,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644933664
    },
    {
        "content": "<p>I'm sure Patrick would suggest to follow Bourbaki in this case...</p>",
        "id": 271977222,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644933692
    },
    {
        "content": "<p>So, Bourbaki distinguishes a bornology from a <em>covering bornology</em>, where the latter includes the condition that the union of the bounded sets is the entire space, but it seems that this has since just been included in the definition. Moreover, notice there are two wikipediea pages <a href=\"https://en.wikipedia.org/wiki/Bornology\">bornology</a> and <a href=\"https://en.wikipedia.org/wiki/Bornological_space\">bornological space</a>. In the former, it looks like they call the cobounded sets the <em>filter at infinity</em> (although I personally prefer cobounded, especially because of the comap definition of bounded maps). A quick text search of Bourbaki seems to suggest they don't refer to this filter at all, but it's possible I missed it.</p>",
        "id": 271996536,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644941402
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465995\">@Daniel Roca González</span> would probably be interested in this, since he's working on coarse structures (which seems to be a bit of a stronger concept).</p>",
        "id": 272002299,
        "sender_full_name": "Rémi Bottinelli",
        "timestamp": 1644943760
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Yaël Dillies</span> I have pushed the changes suggested above and used the <code>bornology</code> terminology to be consistent with Bourbaki and Wikipedia.</p>",
        "id": 272003032,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644944039
    },
    {
        "content": "<p>We can have a type synonym for the \"closure is compact\" bornology</p>",
        "id": 272016743,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1644949464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"197836\">Jireh Loreaux</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/271996536\">said</a>:</p>\n<blockquote>\n<p>In the former, it looks like they call the cobounded sets the <em>filter at infinity</em> (although I personally prefer cobounded, especially because of the comap definition of bounded maps). </p>\n</blockquote>\n<p>That was why I'd named it <code>infty</code> earlier, but <code>cobounded</code> makes more sense to me.  Wikipedia cites <a href=\"https://www.worldcat.org/title/topological-vector-spaces/oclc/144216834\">https://www.worldcat.org/title/topological-vector-spaces/oclc/144216834</a> which seems like it would be good to take a look at.</p>",
        "id": 272016747,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644949467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461830\">Rémi Bottinelli</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/272002299\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465995\">Daniel Roca González</span> would probably be interested in this, since he's working on coarse structures (which seems to be a bit of a stronger concept).</p>\n</blockquote>\n<p>I haven't had time to work on it for some weeks, but yes it's definitely related.</p>",
        "id": 272017013,
        "sender_full_name": "Daniel Roca González",
        "timestamp": 1644949572
    },
    {
        "content": "<p>Terminology from Chapter 6 of Narici and Beckenstein, \"Topological Vector Spaces\":</p>\n<ul>\n<li>a <em>bornology</em> or <em>boundedness</em> for the structure. Elements of the set of subsets are <em>bounded sets</em>. The definition consists of the covering condition and closure under subsets and finite unions.</li>\n<li><code>T</code> along with <code>bornology T</code> is a <em>bounded structure</em></li>\n<li>the bornology of bounded sets of a topological vector space is <em>usual bornology</em> or <em>natural boundedness</em></li>\n<li>the bornology of relatively compact sets of a topological space is the <em>compact bornology</em></li>\n<li>the cobounded sets according to a bornology form the <em>filter at infinity</em></li>\n<li>mentions definitions for the <em>base</em> and <em>subbase</em> of a bornology, generating bornologies, weaker/stronger bornologies, etc.</li>\n<li>if <code>f : A -&gt; B</code> is a function and <code>(A, S)</code> and <code>(B, T)</code> are bounded structures, and if <code>f</code> carries bounded sets to bounded sets, then <code>f</code> is <em>locally bounded</em>. If <code>f</code> is invertible and both <code>f</code> and the inverse of <code>f</code> are locally bounded, then <code>f</code> is a <em>bornomorphism</em></li>\n<li>a bornology on a vector space is a <em>vector bornology</em> if scalar multiplication and addition are locally  bounded (using the natural bornologies on product spaces)</li>\n<li>exercise 6.111 defines <em>bornivorous</em> subsets of a topological vector space (synonym: the set is a <em>bornivore</em>)</li>\n<li>exercise 6.203 describes two constructions to create new bornologies from a bornology on a topological space: taking closures and taking interiors of the bounded sets.</li>\n</ul>",
        "id": 272019206,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644950529
    },
    {
        "content": "<p>It seems to me that <code>[bornology T]</code> and <code>locally_bounded f</code> could be the names, with <code>locally_bounded_map</code> for the homs.</p>",
        "id": 272020585,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644951165
    },
    {
        "content": "<p>I don't quite understand the \"local\" part of the names. Is there another notion of bounded map?</p>",
        "id": 272020667,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644951214
    },
    {
        "content": "<p>Aaah, maps with a uniform bound?</p>",
        "id": 272020697,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644951230
    },
    {
        "content": "<p>Yeah</p>",
        "id": 272020764,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644951245
    },
    {
        "content": "<p>The identity map <code>reals -&gt; reals</code> with the usual bornology on <code>reals</code> is locally bounded (and a bornomorphism).</p>",
        "id": 272020813,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644951275
    },
    {
        "content": "<p>I will change the name in <a href=\"https://github.com/leanprover-community/mathlib/pull/12046\">#12046</a> then.</p>",
        "id": 272020913,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644951340
    },
    {
        "content": "<p>I'm not defining bornomorphisms yet because I'm waiting for <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s equiv refactor (or is it usable already?)</p>",
        "id": 272021019,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644951380
    },
    {
        "content": "<p>We don't have a definition for maps with a uniform bound do we? Isn't is just <code>bounded (range f)</code></p>",
        "id": 272029188,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644954924
    },
    {
        "content": "<p>Yes to both.</p>",
        "id": 272029310,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644954976
    },
    {
        "content": "<p>Personally, I would prefer to see just <code>bounded_map</code> as opposed to <code>locally_bounded_map</code>, but I understand if the majority is not with me on this. In many cases where bornology is useful (functional analysis) the maps are just called bounded anyway.</p>",
        "id": 272029656,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644955140
    },
    {
        "content": "<p>What about <code>borned_map</code>? This is apparently nonstandard, but follows quite the \"born...\" terminology.</p>",
        "id": 272029954,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644955242
    },
    {
        "content": "<p>Another terminology note that I forgot to mention: a reason I proposed <code>bornology</code> a few messages back versus <code>bornological_space</code> is that a bornological space is a locally convex vector space <code>X</code> such that every locally bounded linear map <code>X -&gt; Y</code> with <code>Y</code> a locally convex vector space is continuous. (Section 13.2 of the book.)</p>",
        "id": 272030500,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644955459
    },
    {
        "content": "<p>Yes, thanks Kyle, we realized that just a bit earlier in the thread. I didn't read carefully enough the first time.</p>",
        "id": 272030568,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644955498
    },
    {
        "content": "<p>I mean, if we go with the french, then why not <code>bornee_map</code>? I like it.</p>",
        "id": 272030768,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644955588
    },
    {
        "content": "<p>Half correct French is a bit painful for me to read.</p>",
        "id": 272030854,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644955638
    },
    {
        "content": "<p>Or is it just <code>borne</code>? I don't know the gender of \"map\" in french.</p>",
        "id": 272030858,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644955640
    },
    {
        "content": "<p><code>«map_bornée»</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 272030905,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644955673
    },
    {
        "content": "<p>I originally suggested it with the accent before I realized it wasn't an allowable character in declarations and had to be quoted.</p>",
        "id": 272031147,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644955798
    },
    {
        "content": "<p>Yeah...</p>",
        "id": 272031477,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644955951
    },
    {
        "content": "<p>And that's why we don't have the étale topology in mathlib</p>",
        "id": 272031521,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644955983
    },
    {
        "content": "<p>I don't really have a hat in the ring here, but <code>locally_bounded</code> seems to be the most self-explanatory name (<code>bounded</code> feels like \"uniformly bounded,\" and, apologies to the francophones, all the words associated to bornology seem more like made-up words to me than usual...)</p>",
        "id": 272031936,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644956203
    },
    {
        "content": "<p>Ignoring bornologies, I think the usual notion of \"locally bounded\" is that each point in the domain has a neighborhood whose image is bounded. This seems to carry over to maps between topological vector spaces with their usual bornologies.</p>",
        "id": 272031945,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644956207
    },
    {
        "content": "<p>I think all those words were invented by Bourbaki at the same time they invented the <a href=\"https://en.wikipedia.org/wiki/Barrelled_space\">espaces tonnelés</a>. They clearly liked this kind of jokes</p>",
        "id": 272032426,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1644956464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/272021019\">said</a>:</p>\n<blockquote>\n<p>I'm not defining bornomorphisms yet because I'm waiting for <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span>'s equiv refactor (or is it usable already?)</p>\n</blockquote>\n<p>Equiv classes up to <code>mul_equiv</code>/<code>add_equiv</code> are already in, <code>ring_equiv</code> was straightforward (up to some <code>simp</code>/coercion details). So I'd say you can go ahead and use <code>equiv_like</code>.</p>",
        "id": 272032439,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1644956469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"306601\">@Kyle Miller</span> you convinced me, <code>locally_bounded_map</code> is preferable to <code>bounded_map</code>.</p>",
        "id": 272033662,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644957076
    },
    {
        "content": "<p>Can someone explain to me the plan for making a bornology from a metric space? If I understand correctly, we don't want to make it an instance because of non-defeq diamonds and so we want to implement it in the metric space structure itself (as with uniform spaces), right? But then don't we run into a bootstrapping problem, that is, we will have to define the <code>cobounded</code> filter on the metric space before we define bounded sets in a metric space? I would like to give this  a shot, but I'm not sure how to proceed.</p>",
        "id": 272035351,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644957971
    },
    {
        "content": "<p>There's no bootstrapping problem if you define <code>cobounded</code> before <code>metric_space</code>.</p>",
        "id": 272035611,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644958116
    },
    {
        "content": "<p>Could someone explain what the diamond problem here is?</p>",
        "id": 272035914,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644958258
    },
    {
        "content": "<p>Oh, is one that if a <code>metric_space</code> gives a <code>bornology</code>, then since product spaces have bornology and metric space instances, then they might defeq disagree on the <code>bornology</code> instance?</p>",
        "id": 272036165,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644958383
    },
    {
        "content": "<p>Yes, that's the point.</p>",
        "id": 272036232,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644958429
    },
    {
        "content": "<p>Yeah, exactly the same story as with the product topology.</p>",
        "id": 272036253,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644958441
    },
    {
        "content": "<p>Good thing is: same problem, same solution.</p>",
        "id": 272036315,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644958455
    },
    {
        "content": "<p>Okay, I guess I understand what to do. I'm going to give it a try.</p>",
        "id": 272036522,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644958557
    },
    {
        "content": "<p>How does this look?</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>bornology from a pseudo metric</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.real.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.bornology.basic</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> bornology from a pseudo metric -/</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">bounded_iff_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dist_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dist_triangle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"bp\">;</span> <span class=\"n\">rintro</span> <span class=\"o\">⟨</span><span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">hC</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">cases</span> <span class=\"n\">s.eq_empty_or_nonempty</span> <span class=\"k\">with</span> <span class=\"n\">h</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">subst</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">hx</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"k\">calc</span>\n        <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">dist_triangle</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n        <span class=\"bp\">...</span>      <span class=\"bp\">≤</span> <span class=\"n\">_</span>                   <span class=\"o\">:</span> <span class=\"n\">add_le_add_right</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">y</span> <span class=\"n\">hy</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">C</span> <span class=\"bp\">+</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"k\">calc</span>\n      <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">dist_comm</span> <span class=\"n\">a</span> <span class=\"n\">y</span> <span class=\"bp\">▸</span> <span class=\"n\">dist_triangle</span> <span class=\"n\">x</span> <span class=\"n\">a</span> <span class=\"n\">y</span>\n      <span class=\"bp\">...</span>      <span class=\"bp\">≤</span> <span class=\"n\">_</span>                   <span class=\"o\">:</span> <span class=\"n\">add_le_add</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hC</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">)⟩,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bornology.of_dist</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dist_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">dist_triangle</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">≤</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">dist</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">bornology</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">cobounded</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">sets</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span> <span class=\"o\">},</span>\n    <span class=\"n\">univ_sets</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">false.elim</span> <span class=\"o\">(</span><span class=\"n\">compl_univ.subst</span> <span class=\"n\">hx</span><span class=\"o\">)⟩,</span>\n    <span class=\"n\">sets_of_superset</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span>\n    <span class=\"o\">{</span> <span class=\"n\">rintros</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">hc</span><span class=\"o\">⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">hc</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">compl_subset_compl.mpr</span> <span class=\"n\">h</span> <span class=\"n\">hx</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"o\">(</span><span class=\"n\">compl_subset_compl.mpr</span> <span class=\"n\">h</span> <span class=\"n\">hy</span><span class=\"o\">))⟩</span> <span class=\"o\">},</span>\n    <span class=\"n\">inter_sets</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span><span class=\"o\">,</span>\n    <span class=\"kd\">begin</span>\n      <span class=\"n\">by_cases</span> <span class=\"n\">hs'</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"n\">univ</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">hs'</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">ht</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">hz</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ne_univ_iff_exists_not_mem</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">hs'</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">bounded_iff_aux</span> <span class=\"n\">dist</span> <span class=\"n\">dist_comm</span> <span class=\"n\">dist_triangle</span> <span class=\"n\">u</span> <span class=\"n\">z</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">hs</span> <span class=\"n\">ht</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n        <span class=\"n\">rcases</span> <span class=\"o\">⟨</span><span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">ht</span><span class=\"o\">⟩</span> <span class=\"k\">with</span> <span class=\"o\">⟨⟨</span><span class=\"n\">r₁</span><span class=\"o\">,</span> <span class=\"n\">hr₁</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">r₂</span><span class=\"o\">,</span> <span class=\"n\">hr₂</span><span class=\"o\">⟩⟩,</span>\n        <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">max</span> <span class=\"n\">r₁</span> <span class=\"n\">r₂</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">or.elim</span> <span class=\"o\">((</span><span class=\"n\">compl_inter</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subst</span> <span class=\"n\">hx</span><span class=\"o\">)</span>\n          <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hx'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hr₁</span> <span class=\"n\">x</span> <span class=\"n\">hx'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span>\n          <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hx'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hr₂</span> <span class=\"n\">x</span> <span class=\"n\">hx'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">le_max_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))⟩,</span> <span class=\"o\">}</span>\n    <span class=\"kd\">end</span> <span class=\"o\">},</span>\n  <span class=\"n\">le_cofinite</span> <span class=\"o\">:=</span>\n  <span class=\"kd\">begin</span>\n    <span class=\"n\">refine</span> <span class=\"n\">le_def.mpr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">filter.mem_mk</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_cofinite</span> <span class=\"n\">at</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">revert</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">generalize</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"bp\">ᶜ</span> <span class=\"bp\">=</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">h.dinduction_on</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">s</span> <span class=\"n\">hx</span> <span class=\"n\">hs</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">false.elim</span> <span class=\"n\">hx</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">λ</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">bounded_iff_aux</span> <span class=\"n\">dist</span> <span class=\"n\">dist_comm</span> <span class=\"n\">dist_triangle</span> <span class=\"n\">u</span> <span class=\"n\">x</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h</span> <span class=\"bp\">⊢</span><span class=\"o\">,</span>\n      <span class=\"n\">rcases</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">hr</span><span class=\"o\">⟩,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">insert_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">max</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"n\">or.elim</span> <span class=\"n\">hy</span>\n        <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"n\">mem_singleton_iff.mp</span> <span class=\"n\">hy'</span> <span class=\"bp\">▸</span> <span class=\"n\">le_max_right</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span>\n        <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">hy'</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">hr</span> <span class=\"n\">y</span> <span class=\"n\">hy'</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">le_max_left</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))⟩</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Add this to the structure of a pseudo metric :</span>\n\n<span class=\"cm\">`(to_bornology : bornology α := bornology.of_dist dist dist_comm dist_triangle)`</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>\n</div></div>",
        "id": 272064345,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1644976299
    },
    {
        "content": "<p>Looks good!</p>",
        "id": 272064590,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644976531
    },
    {
        "content": "<p>(except that I know feel a <span aria-label=\"golf\" class=\"emoji emoji-1f3cc\" role=\"img\" title=\"golf\">:golf:</span> urge)</p>",
        "id": 272064607,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644976552
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/12078\">#12078</a>: bornology for pseudo metric structure</p>",
        "id": 272159663,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1645036907
    },
    {
        "content": "<p>I'm late to the party, but it's really nice to see that you are taking care of that, it'll be useful for my work on distributions !</p>",
        "id": 272284697,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1645115324
    },
    {
        "content": "<p>I've been working with bornologies recently, mostly proving that the topology of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">S</span></span></span></span>-convergence (see <a href=\"https://github.com/leanprover-community/mathlib/pull/13073\">#13073</a>) is the same as the topology of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"fraktur\">S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>-convergence, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"fraktur\">S</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">S</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> is the bornology generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">S</span></span></span></span> (which is actually not true, see below), and I have a few questions about the intended way of using this definition and its API in mathlib :</p>\n<ul>\n<li>Are there any good reasons to make it a <code>class</code> ? I may be biased because I've been working quite low level in the API, especially in <a href=\"https://github.com/leanprover-community/mathlib/pull/12964\">#12964</a>, but I'm starting to think it would just be easier to make bornologies explicit everywhere, because I can't think of any <code>bornology</code> we could declare as an instance that would not conflict (at least definitionally) with the metric one in at least one case. Like, we can't make the Von Neumann bornology an instance because we can have TVSs with a metric structure, we can't make the compact bornology an instance because it would conflict in a case of a metric space, ...</li>\n<li>Would it be easier to remove the covering condition from the definition and just have it as a separate def/typeclass, mimicking how we chose to separate <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.ne_bot\">docs#filter.ne_bot</a> from the definition of filters ? I'm asking this because it turns out the result I was trying to prove is false with this definition of bornology. Of course that's not a good reason for changing the definition, but I think what <em>is</em> a good reason is that I can't find an easy way to express it without having a notion of \"noncovering bornology\", whereas adding some covering assumption when needed. So, yes, it would go against the current usage in the litterature, but it would definitely make formalization easier imo</li>\n</ul>",
        "id": 277637053,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1648997043
    },
    {
        "content": "<p>The idea at some point was to make <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.is_bounded\">docs#bornology.is_bounded</a> subsume <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a>, in which case having it a class makes sense.</p>",
        "id": 277642036,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1648999711
    },
    {
        "content": "<p>Is the theorem true if you assume a covering condition on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">S</span></span></span></span>? Isn't it enough for your purposes?</p>",
        "id": 277648819,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1649004232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"268315\">Anatole Dedecker</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/277637053\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Would it be easier to remove the covering condition from the definition and just have it as a separate def/typeclass, mimicking how we chose to separate <a href=\"https://leanprover-community.github.io/mathlib_docs/find/filter.ne_bot\">docs#filter.ne_bot</a> from the definition of filters ? I'm asking this because it turns out the result I was trying to prove is false with this definition of bornology.</li>\n</ul>\n</blockquote>\n<p>Once you remove the covering condition, you're left with just a filter -- maybe you can prove what you need about filters then wrap it up in bornologies in the cases where the bornology theorem is true? (Not sure if this is actually a good idea, but it might be one way to go about implementing Patrick's suggestion.)</p>",
        "id": 277650075,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1649005703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306601\">Kyle Miller</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/277650075\">said</a>:</p>\n<blockquote>\n<p>maybe you can prove what you need about filters then wrap it up in bornologies in the cases where the bornology theorem is true? (Not sure if this is actually a good idea, but it might be one way to go about implementing Patrick's suggestion.)</p>\n</blockquote>\n<p>Indeed that's what I ended up doing, but it's a bit more painful because there are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/compl\">docs#compl</a> popping everywhere</p>",
        "id": 277652960,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1649009387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110031\">Patrick Massot</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/277648819\">said</a>:</p>\n<blockquote>\n<p>Is the theorem true if you assume a covering condition on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">S</mi></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{S}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6914em;\"></span><span class=\"mord mathfrak\">S</span></span></span></span>?</p>\n</blockquote>\n<p>Indeed, I proved it too. </p>\n<blockquote>\n<p>Isn't it enough for your purposes?</p>\n</blockquote>\n<p>Ahem, I <em>may</em> have been a bit distracted from distributions indeed <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> More seriously, this was mostly a way to test the uniform convergence API, so indeed I don't <em>need</em> it, but I thought it was a shame not to have the general theorem.</p>",
        "id": 277653258,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1649009736
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> So, I will provide my input on your original two points, but perhaps I will just show my own ignorance (likely the latter). </p>\n<ul>\n<li>It seems to me that the situation is very much like the situation with topologies. Most of the time, you have one you want to work with, but every so often you need others. When this happens it is kind of a pain unless you have a few common topologies that repeatedly show up, in which case you create type synonyms. As for the conflicting instances problem, isn't this just a matter of baking the bornology into the definitions themselves? For example, now a TVS would get the von Neumann bornology in the definition, and then so would normed vector spaces? Perhaps I'm missing something here.</li>\n<li>I really don't think we should exclude the cofinite/covering condition, because then it's just a filter.</li>\n</ul>",
        "id": 277906331,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649176211
    },
    {
        "content": "<p>Sorry, I realized I may not have been entirely clear. The point would be that a <code>normed_space</code> would come with a defined bornology. Then in the derived instances <code>metric_space</code>and <code>topological_vector_space</code> (I just noticed the latter doesn't exist, what do we do here, just <code>[module 𝕜 E]</code> <code>[has_continuous_add E]</code> <code>[has_continuous_smul 𝕜 E]</code>? If so, we might need to actually make a TVS class for my suggestion to work) you would replace the default generated bornology with the one coming from the normed space and then prove that it has the specified form. I think this would avoid the defeq problem.</p>",
        "id": 277930715,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649186266
    },
    {
        "content": "<p>I have the bad feeling that this is more difficult to do. For something like Fréchet space you have that 'metrically bounded = bounded' (Fréchet implies that the space is metrizable), but it is not true for all topologically vector spaces. I guess that we will need a class of metrizable tvs for which 'metrically bounded = bounded' and normed spaces just extend that. Unfortunately, we cannot do everything on the level of groups, since the von Neumann bornology needs <code>has_continuous_smul</code>.</p>",
        "id": 277937084,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649189486
    },
    {
        "content": "<p>Isn't a bornological space exactly an LCS where the von Neumann bounded sets are metrically bounded, or did I internalize that definition incorrectly? If that's correct, then maybe we want this type class, and it's exactly the one that generalizes TVS with a bornology and metric space with a bornology in the defeq way. Then normed spaces and Frechet spaces would be instances of this. Then a TVS which is metrizable and has a bornology which doesn't coincide would rightly be considered an outlier. Does all this make sense?</p>",
        "id": 277942008,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649192153
    },
    {
        "content": "<p>(sorry, my characterization of bornological spaces applies when the space is metrizable, otherwise the condition involves a neighborhood of zero)</p>",
        "id": 277942289,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649192290
    },
    {
        "content": "<p>Hi, what's the status here? I want to add lemmas like <code>antilipschitz_with.tendsto_cobounded</code> and corollaries for left/right scalar multiplication. Which filter should I use for <code>cobounded</code>?</p>",
        "id": 278597642,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649701897
    },
    {
        "content": "<p>I mean <code>cobounded</code> instance that comes from <code>pseudo_metric_space</code>.</p>",
        "id": 278597787,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649701949
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.cobounded\">docs#bornology.cobounded</a> I believe</p>",
        "id": 278597801,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649701956
    },
    {
        "content": "<p>BTW, what are your plans about diamonds? E.g., <code>cobounded</code> coming from metric space structure and the one coming from a TVS structure are not defeq.</p>",
        "id": 278597992,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649702044
    },
    {
        "content": "<p>I'm sorry for asking questions that probably were answered before. I haven't read backlog for a while.</p>",
        "id": 278598107,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649702093
    },
    {
        "content": "<p>BTW, why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_space\">docs#bounded_space</a> extends <code>bornology</code>? How do I say \"consider a bounded metric space\"?</p>",
        "id": 278598185,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649702125
    },
    {
        "content": "<p>We plan on incorporating <code>bornology</code> into <code>metric_space</code> in the same as <code>uniform_space</code> has been done before. Does that fix your diamond?</p>",
        "id": 278598201,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649702131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/278598185\">said</a>:</p>\n<blockquote>\n<p>BTW, why <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bounded_space\">docs#bounded_space</a> extends <code>bornology</code>? How do I say \"consider a bounded metric space\"?</p>\n</blockquote>\n<p>I believe this is a mistake, given the mixin approach of the topology library.</p>",
        "id": 278598538,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649702257
    },
    {
        "content": "<p>It looks like there is no instance <code>metric_space.to_bornology</code> yet (at least, not in the list of instances <a href=\"https://leanprover-community.github.io/mathlib_docs/topology/bornology/basic.html#bornology\">here</a>), so I can't use it for <code>antilipschitz_with.tendsto_cobounded</code>.</p>",
        "id": 278598993,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649702439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> already has all the code for it. It just needs a PR I believe.</p>",
        "id": 278599095,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649702484
    },
    {
        "content": "<p>It has been PR-ed</p>",
        "id": 278599269,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1649702553
    },
    {
        "content": "<p>It’s in the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_metric_space\">docs#pseudo_metric_space</a>, but maybe it is not registered as an instance</p>",
        "id": 278599329,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1649702584
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/278597992\">said</a>:</p>\n<blockquote>\n<p>BTW, what are your plans about diamonds? E.g., <code>cobounded</code> coming from metric space structure and the one coming from a TVS structure are not defeq.</p>\n</blockquote>\n<p>There are cases where they are not equal at all. This has caused me a bit of headache and I haven't had a good idea what to do about it.</p>",
        "id": 278599891,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649702861
    },
    {
        "content": "<p>What are these cases? A completely different approach is to use bornology as a bundled structure, not a class.</p>",
        "id": 278604752,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649705363
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz Doll</span> at the risk of beating a dead horse, can't this be addressed with a <code>bornological_space</code> class for TVS? Do you really have a lot of cases where the TVS bornology and the metric bornology aren't propositionally equal?</p>",
        "id": 278606554,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649706248
    },
    {
        "content": "<p>I know only one example and it is somewhat artificial: you take the seminorms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><msub><mi>a</mi><mi>n</mi></msub><mo>−</mo><msub><mi>b</mi><mi>n</mi></msub><mi mathvariant=\"normal\">∣</mi></mrow><annotation encoding=\"application/x-tex\">|a_n - b_n|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\">∣</span></span></span></span> on the space of all sequences and then take the usual metric generated by those seminorms. Every sequence is metrically bounded by 1, but not von Neumann bounded (it is in Narici-Beckenstein).</p>",
        "id": 278611757,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649708705
    },
    {
        "content": "<p>Yes, for bornological spaces we should be fine, but not having typeclasses for general topological vector spaces feels wrong.</p>",
        "id": 278612822,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649709210
    },
    {
        "content": "<p>isn't the way the bornology is defined for metric spaces essentially a bundled approach?</p>",
        "id": 278613083,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649709339
    },
    {
        "content": "<p>Right, I think we might want a generic TVS type class also. My thought is that the <code>bornological_space</code> type class would fix defeq issues, and that places where they aren't propositionally equal are sufficiently rare to not be a huge problem.</p>",
        "id": 278613215,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649709406
    },
    {
        "content": "<p>Do you mean an actual bornological space by <code>bornological_space</code> or did terminology lead you astray again?</p>",
        "id": 278613283,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1649709454
    },
    {
        "content": "<p>I mean actual bornological spaces. These are the ones for which the metric bornology and the von Neumann bornology coincide (at least, I think).</p>",
        "id": 278613420,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649709509
    },
    {
        "content": "<p>What is the definition of the bornology for a TVS? Does it work for any (normed) base field or only for reals? In the former case, you can't have an instance <code>[add_comm_group] [module k V] [has_continuous_smul k V] : bornology V</code> because it leads to an instance search <code>has_continuous_smul ?_m V</code>. In any case, you can't resolve defeq for normed spaces because a general normed space works with any underlying <code>metric_space</code> structure, hence with any underlying bornology.</p>",
        "id": 278616486,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649711023
    },
    {
        "content": "<p>So, I guess that the way to go with the bornology for a TVS is to have a mixin typeclass that says \"bornology on <code>V</code> agrees with the TVS structure\".</p>",
        "id": 278616702,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649711126
    },
    {
        "content": "<p>Is there a branch that replaces <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.is_bounded\">docs#bornology.is_bounded</a>?</p>",
        "id": 278617859,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649711753
    },
    {
        "content": "<p>Not that I've created. Been busy with other things</p>",
        "id": 278617930,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649711773
    },
    {
        "content": "<p>see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.vonN_bornology\">docs#bornology.vonN_bornology</a> for the bornology arising naturally from a TVS.</p>",
        "id": 278618287,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649711959
    },
    {
        "content": "<p>Are there any (not yet formalized) theorems that link this bornology to the one arising from metric space structure?</p>",
        "id": 278618714,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649712086
    },
    {
        "content": "<p>I'm no longer convinced that my previous claim about bornological spaces holds. This is because such spaces have a <em>topology</em> which agrees with the one induced by the bornology, but that doesn't have anything to do with the <em>metric</em> structure. So, consider ℝ with the usual metric and then the metric bounded sets are exactly the von Neumann bounded sets (considering ℝ as a TVS). However, we may replace the metric with a bounded metric without changing the topology. Then every set is metric bounded, but since the topology didn't change the von Neumann bounded sets are the usual bounded sets. Now the two bornologies don't agree, but nevertheless ℝ is still a bornological space.</p>",
        "id": 278628614,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649718342
    },
    {
        "content": "<p>Point being, I think Moritz is right, the metric bornology and the von Neumann bornology can easily fail to be propositionally equal, even if the TVS is bornological. Perhaps letting metric spaces have a bornology instance is not the right way to go, even if we keep the metric bornology structure.</p>",
        "id": 278628907,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1649718576
    },
    {
        "content": "<p>What do we need to assume to say that the bornology is the same as the one from the <code>metric_space</code> structure?</p>",
        "id": 278645276,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649735601
    },
    {
        "content": "<p>E.g., is it true for a normed space? Or only for a finite dimensional normed space?</p>",
        "id": 278645285,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649735626
    },
    {
        "content": "<p>I'm going to add a <code>complete_lattice</code> structure on <code>bornology α</code>. Which order should I choose: <code>t ≤ t'</code> if <code>@is_bounded α t s → @is_bounded α t' s</code> or if <code>@is_bounded α t' s → @is_bounded α t s</code>?</p>",
        "id": 278646793,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649737277
    },
    {
        "content": "<p>One makes <code>is_bounded</code> monotone, another makes <code>cobounded</code> monotone.</p>",
        "id": 278646812,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649737308
    },
    {
        "content": "<p>Started review of bornology API in <a href=\"https://github.com/leanprover-community/mathlib/pull/13374\">#13374</a></p>",
        "id": 278648297,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1649739271
    },
    {
        "content": "<p>For normed spaces is it correct since a set is von Neumann bounded iff all seminorms are bounded.</p>",
        "id": 278649495,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649740894
    },
    {
        "content": "<p>But if you are only normable, then I think (haven't checked the details) you could replace the metric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant=\"normal\">∥</mi></mrow><annotation encoding=\"application/x-tex\">d(x,y) = \\|x - y\\|</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">∥</span></span></span></span> by the metric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant=\"normal\">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant=\"normal\">∥</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi mathvariant=\"normal\">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant=\"normal\">∥</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">d(x,y) = \\frac{\\|x - y\\|}{1 + \\|x - y\\|}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.53em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.01em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">∥</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mtight\">∥</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">∥</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mbin mtight\">−</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mtight\">∥</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> and then every set is metrically bounded, but not von Neumann bounded (this is the normed version of the example I mentioned above, which isn't so artificial after all and the same thing Jireh was saying).</p>",
        "id": 278649722,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649741229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/278646793\">said</a>:</p>\n<blockquote>\n<p>I'm going to add a <code>complete_lattice</code> structure on <code>bornology α</code>. Which order should I choose: <code>t ≤ t'</code> if <code>@is_bounded α t s → @is_bounded α t' s</code> or if <code>@is_bounded α t' s → @is_bounded α t s</code>?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"268315\">@Anatole Dedecker</span> has a PR for that already: <a href=\"https://github.com/leanprover-community/mathlib/pull/12964\">#12964</a></p>",
        "id": 278650847,
        "sender_full_name": "Moritz Doll",
        "timestamp": 1649742713
    },
    {
        "content": "<p>I'm going to merge <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.is_bounded\">docs#bornology.is_bounded</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a>. The next PR in line is <a href=\"https://github.com/leanprover-community/mathlib/pull/13927\">#13927</a>. It would be nice if someone who uses bornology outside of <code>mathlib</code> will review it.</p>",
        "id": 282428134,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652647527
    },
    {
        "content": "<p>My main goal is to be able to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.cobounded\">docs#bornology.cobounded</a> on metric spaces (and reformulate various lemmas in terms of this filter).</p>",
        "id": 282428184,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652647588
    },
    {
        "content": "<p>Will you need the complete lattice structure on bornologies ? I didn't really get back to it because I didn't need it immediately (and also because, in the case I had in mind, I really wanted the generated \"noncovering bornology\", not the generated bornology), but I can revivre <a href=\"https://github.com/leanprover-community/mathlib/pull/12964\">#12964</a> if you need it.</p>",
        "id": 282429792,
        "sender_full_name": "Anatole Dedecker",
        "timestamp": 1652650039
    },
    {
        "content": "<p>I won't need it.</p>",
        "id": 282432181,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652653577
    },
    {
        "content": "<p>I just want to have <code>cobounded : filter complex</code></p>",
        "id": 282432188,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652653608
    },
    {
        "content": "<p>And restate lemmas that use <code>comap norm at_top</code> in terms of <code>cobounded</code>.</p>",
        "id": 282432201,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652653632
    },
    {
        "content": "<p>BTW, I see that we have some non-instance bornologies. What's the plan: restate lemmas about <code>is_bounded</code> etc so that they take <code>{_ : bornology α}</code> instead of <code>[bornology α]</code>, introduce type tags, or something else?</p>",
        "id": 282432271,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1652653734
    },
    {
        "content": "<p>Let me ping here again about <a href=\"https://github.com/leanprover-community/mathlib/pull/13927\">#13927</a>. I have a few other changes that depend on it.</p>",
        "id": 283248855,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1653249515
    },
    {
        "content": "<p>E.g., I want to</p>\n<ul>\n<li>start using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bornology.is_bounded\">docs#bornology.is_bounded</a> instead of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric.bounded\">docs#metric.bounded</a></li>\n<li>move definitions of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_emetric_space\">docs#pseudo_emetric_space</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_metric_space\">docs#pseudo_metric_space</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/emetric_space\">docs#emetric_space</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metric_space\">docs#metric_space</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_metrizable_space\">docs#pseudo_metrizable_space</a>, and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/metrizable_space\">docs#metrizable_space</a> to a new file; then we can use <code>[metrizable_space X]</code> instead of <code>[metric_space X]</code> much earlier.</li>\n</ul>",
        "id": 283249208,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1653249979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/Bornology/near/283248855\">said</a>:</p>\n<blockquote>\n<p>Let me ping here again about <a href=\"https://github.com/leanprover-community/mathlib/pull/13927\">#13927</a>. I have a few other changes that depend on it.</p>\n</blockquote>\n<p>How reasonable would it be to change <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_emetric_space.to_pseudo_metric_space_of_dist\">docs#pseudo_emetric_space.to_pseudo_metric_space_of_dist</a> to require the bornology to already exist? In that PR, you change two uses of it to subsequently replace the bornology; are there any other uses of it?</p>",
        "id": 283255266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653258509
    },
    {
        "content": "<p>It is used 5 times in <code>mathlib</code>. I'll check all of them tonight.</p>",
        "id": 283256416,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1653260170
    },
    {
        "content": "<p>See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pseudo_emetric_space.to_pseudo_metric_space\">docs#pseudo_emetric_space.to_pseudo_metric_space</a></p>",
        "id": 283256869,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1653260765
    },
    {
        "content": "<p>We have no bornology in this case.</p>",
        "id": 283256895,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1653260848
    },
    {
        "content": "<p>RIght, I guess what I was suggesting is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">pseudo_emetric_space.to_pseudo_metric_space_of_dist</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">bornology</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">pseudo_emetric_space</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">dist</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">edist_ne_top</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">edist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≠</span> <span class=\"bp\">⊤</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">ennreal.to_real</span> <span class=\"o\">(</span><span class=\"n\">edist</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">h'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n    <span class=\"n\">is_bounded</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀ᶠ</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"k\">in</span> <span class=\"n\">at_top</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">⦄,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">⦄,</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">dist</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n</code></pre></div>\n<p>I have no idea if that's actually helpful</p>",
        "id": 283257244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653261316
    }
]
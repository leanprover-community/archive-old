[
    {
        "content": "<p>Hi,<br>\nI've been working on proving the following lemma since last week:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I proved another helper lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex'</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I would now like to use the helper lemma <code>linear_isometry_complex'</code> in my proof of  <code>linear_isometry_complex</code> and am uncertain how to go at this.<br>\nSince <code>linear_isometry_complex</code> has a <code>∃ a : ℂ, |a| = 1</code>, I wanted to use:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">use</span> <span class=\"n\">exp</span> <span class=\"bp\">^</span> <span class=\"n\">I</span> <span class=\"bp\">*</span> <span class=\"n\">θ</span>\n</code></pre></div>\n<p>and I need to define a function, say <code>h</code> that will fit the hypotheses of <code>linear_isometry_complex'</code>:<br>\n<code>h 0 = 0</code> and <code>h 1 = 1</code><br>\nfor <code>h 0 = 0</code>I can use <code>linear_isometry.map_zero</code>, but I get stuck with the definition of <code>h</code> because I would need to take in <code>θ</code> as an argument.<br>\nI'm wondering if I'm going in a good direction here or if there is a way to define this <code>h</code> function without using <code>exp ^ I * θ</code>.</p>",
        "id": 230265008,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615752769
    },
    {
        "content": "<p>How about defining <code>a := f 1</code> and then letting <code>h</code> be <code>a⁻¹ • f</code>, (i.e., <code>λ z, a⁻¹ * f z</code>, but the first definition will make it automatically a linear map)?</p>",
        "id": 230265372,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615753248
    },
    {
        "content": "<p>ok nice thanks, then there is no need to define a <code>θ</code>. I'll try it out!</p>",
        "id": 230265827,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615753824
    },
    {
        "content": "<p>By the way, <code>conj a</code> might work more nicely than <code>a⁻¹</code>, I'm not sure, you could try it both ways!</p>",
        "id": 230266595,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615754561
    },
    {
        "content": "<p>The advantage of <code>conj a</code> is that you don't need to get division involved, which is in general a good idea (you can use <code>ring</code> to do your algebra, for example, if division is not involved).</p>",
        "id": 230266974,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615754988
    },
    {
        "content": "<p>thanks for the tips :)</p>",
        "id": 230267259,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615755293
    },
    {
        "content": "<p>btw for the definition of <code>h</code> I'm guessing I need to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n     <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">z</span>\n     <span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n     <span class=\"o\">,</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n     <span class=\"o\">},</span>\n</code></pre></div>\n<p>otherwise I'll just get a <code>h</code> with type <code>ℂ → ℂ</code></p>",
        "id": 230267282,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615755319
    },
    {
        "content": "<p>If your f is already linear then just <code>bub</code> it with <code>conj a</code> like Heather said and hopefully you won't need to fill in those sorries</p>",
        "id": 230267519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615755575
    },
    {
        "content": "<p>Bubbing should send a linear map to a linear map</p>",
        "id": 230267634,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615755645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I guess François is saying that he can't do this because <code>f</code> lives in <code>ℂ →ₗᵢ[ℝ] ℂ</code> which is only a real vector space, not complex?  My bad.</p>",
        "id": 230267674,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615755687
    },
    {
        "content": "<p>Sorry if I'm not understanding completely.. I'm still new to Lean. <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  What does bubbing mean (does it mean that Lean will just understand the type of <code>h</code> from using <code>conj</code>)? and I'm still unsure about the meaning of the  notation <code>ℂ →ₗᵢ[ℝ] ℂ</code>.. I know it is some sort of linear map but not sure what the <code>ᵢ</code> stands for, nor the <code>[ℝ]</code>.</p>",
        "id": 230268280,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615756209
    },
    {
        "content": "<p>Indeed, one limitation of Lean's tools is that it can be hard to discover where a notation is defined.  <code>ℂ →ₗᵢ[ℝ] ℂ</code> is notation for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_isometry\">docs#linear_isometry</a>, here an <code>ℝ</code>-linear map from <code>ℂ</code> to <code>ℂ</code> which also preserves lengths.</p>",
        "id": 230268648,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615756564
    },
    {
        "content": "<p>So, in your constructor, you'll have </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 230268714,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615756659
    },
    {
        "content": "<p>ok right, that's what I observed (Lean was asking me to provide something for <code>norm_map'</code> as well and I imagine this case isn't one where bubbing will work? (since for me just setting <code>h := λ z, a⁻¹ * f z</code> directly gives <code>ℂ → ℂ</code> instead of <code>ℂ →ₗᵢ[ℝ] ℂ</code>)</p>",
        "id": 230269040,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615756971
    },
    {
        "content": "<p>Right ... the property <code>norm_map'</code> is not preserved under scalar multiplication/<code>\\bub</code>/<code>•</code> !</p>",
        "id": 230269155,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1615757123
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"375581\">@François Sunatori</span> sorry to mislead you! Bub is <code>\\bub</code>, the dot. But as you have pointed out you might not be able to use it (I was reading on my phone and couldn't even see the little l and i because of a font issue). Yes why not just make it a function, and then beef it up to a linear isometry manually, the way you originally said. By the way if you write <code>def foo  : ℂ →ₗᵢ[ℝ] ℂ := {! !}</code> and then click on the light bulb and then click on the bottom-but-one option (something about fields of a structure) then it will print out all the fields of the structure which you need to fill in.</p>",
        "id": 230276257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615761905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for the clarification about the bub (I was searching for that word in the codebase but didn't find anything related to what we were talking about haha, but I just tried typing <code>\\bub</code> now and indeed it gives the <code>•</code>)!  and also thanks for the trick involving <code>{! !}</code>. I didn't know I could do that.</p>",
        "id": 230284246,
        "sender_full_name": "François Sunatori",
        "timestamp": 1615771454
    },
    {
        "content": "<p>I've gotten further in the proof of <code>linear_isometry_complex</code> but not as quickly as I did  with <code>linear_isometry_complex'</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n      <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.map_add</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">mul_add</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.map_smul</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">algebra.mul_smul_comm</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">complex.abs_inv</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">complex.abs_mul</span><span class=\"o\">,</span>\n        <span class=\"gr\">sorry</span>\n      <span class=\"o\">},</span>\n    <span class=\"o\">},</span>\n  <span class=\"n\">use</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"k\">have</span> <span class=\"n\">H0</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">linear_isometry.map_zero</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"c1\">-- TODO from use to_fun definition: λ z, (f 1)⁻¹ * f z?</span>\n        <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n      <span class=\"c1\">-- TODO from use to_fun definition: λ z, (f 1)⁻¹ * f z?</span>\n      <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">linear_isometry_complex'</span> <span class=\"n\">z</span> <span class=\"n\">h</span> <span class=\"n\">H0</span> <span class=\"n\">H1</span><span class=\"o\">),</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I'm left with 3 <code>sorry</code>s. I'm trying to tackle the proof of <code>have H1 : h 1 = 1</code>.<br>\nI'm not sure how to apply <code>λ z, (f 1)⁻¹ * f z</code> that I defined in <code>h.to_fun</code>.<br>\nOnce I write a proof for a field in an instance of a Lean <code>record</code>, can I invoke <code>h.to_fun</code> and use it with <code>exact</code> or <code>rw</code> for example?</p>\n<p>Thanks :)</p>",
        "id": 231243886,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616363958
    },
    {
        "content": "<p>You're proving the wrong thing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">use</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>This says \"there exists a complex number a such that if |a|=1 then something is true\" so you can prove it by supplying any complex number whose norm isn't 1.</p>",
        "id": 231245828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616366119
    },
    {
        "content": "<p>Oh ok... so in that case it needs to be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>?<br>\n(replace the → with ∧)</p>",
        "id": 231245974,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616366325
    },
    {
        "content": "<p>but I would still like an answer to the following question:</p>\n<blockquote>\n<p>I'm not sure how to apply λ z, (f 1)⁻¹ * f z that I defined in h.to_fun.<br>\nOnce I write a proof for a field in an instance of a Lean record, can I invoke h.to_fun and use it with exact or rw for example?</p>\n</blockquote>",
        "id": 231246339,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616366798
    },
    {
        "content": "<p>Instead of <code>have</code>, use <code>let</code>; <code>have</code> forgets the definition, <code>let</code> remembers it.</p>",
        "id": 231246442,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616366885
    },
    {
        "content": "<p>Thus,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 231246445,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616366894
    },
    {
        "content": "<p>Then, when the time comes to remember how <code>h</code> was defined, you can do something like <code>rw h</code> or <code>simp only [h]</code> or <code>unfold h</code>.</p>",
        "id": 231246466,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616366933
    },
    {
        "content": "<p>I think you're going the wrong way with the first <code>sorry</code>. You have to use that |f(x)|=|x|. How about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>      <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">intros</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n        <span class=\"n\">change</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"bp\">∥⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">,</span>\n        <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"o\">},</span>\n</code></pre></div>",
        "id": 231246640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616367170
    },
    {
        "content": "<p>For the others, I think Heather's advice on let v have should see you through.</p>\n<p>While I'm here I should point out that in early 2018 I was running around on the Lean chat going \"me and a bunch of undergraduates have defined schemes!\" and there were essentially no other number theorists or algebraic geometers here at the time, so the definition just sat there for a while with the computer scientists looking bemusedly at it, and then Johan Commelin showed up, took one look at the definition and said \"you know that -&gt;, don't you think it should be an \\and?\"</p>",
        "id": 231246735,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616367303
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> for the trick to change to <code>∥-∥</code>.. I actually wasn't too sure how far I would be able to get with route I had taken.  And thanks for the story ! I guess I'll remember to watch out for that one in the future!</p>",
        "id": 231246997,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616367620
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> <code>let</code> is exactly what I need! I guess I should have tried <code>let</code> in the first place.. I think I wrongly assumed that it was a synonym for <code>have</code> and maybe the parts of mathlib I was looking at weren't using <code>let</code> so much.</p>",
        "id": 231247069,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616367674
    },
    {
        "content": "<p><code>have</code> is for proofs, <code>let</code> is for data.</p>",
        "id": 231248033,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616368812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231246466\">said</a>:</p>\n<blockquote>\n<p>Then, when the time comes to remember how <code>h</code> was defined, you can do something like <code>rw h</code> or <code>simp only [h]</code> or <code>unfold h</code>.</p>\n</blockquote>\n<p>In the proof for </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>\n<p>When I try to use <code>rw h</code> or <code>unfold h</code>I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">rewrite</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"kd\">lemma</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">an</span> <span class=\"n\">equality</span> <span class=\"n\">nor</span> <span class=\"n\">a</span> <span class=\"n\">iff</span>\n</code></pre></div>\n<p>but using <code>simp only [h]</code><br>\ngives me<br>\n<strong>A</strong>: <code>⇑{to_linear_map := {to_fun := λ (z : ℂ), a⁻¹ * ⇑f z, map_add' := _, map_smul' := _}, norm_map' := _} 1 = 1</code><br>\nand I would like to apply <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> to <code>1</code><br>\nso I tried using <code>simp</code> (which simplified the expression and applied <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> when I used it <code>norm_map'</code>) but it gives me <code>simplify tactic failed to simplify</code>.<br>\nHow would I go at getting <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out of <strong>A</strong>?</p>",
        "id": 231251082,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616372754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"375581\">@François Sunatori</span>  Does it work to do <code>simp</code> rather than <code>simp only</code>?</p>",
        "id": 231253479,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616375940
    },
    {
        "content": "<p>no...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>gives</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">simplify</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">simplify</span>\n</code></pre></div>",
        "id": 231253558,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376039
    },
    {
        "content": "<p>Sorry, I should have been more precise.  I meant you to keep the <code>h</code> -- <code>simp [h]</code> rather than <code>simp only [h]</code>.</p>",
        "id": 231253602,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616376095
    },
    {
        "content": "<p>oh ok, yes it works but it gives me the same result as <code>simp only [h]</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⇑</span><span class=\"o\">{</span><span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n</code></pre></div>",
        "id": 231253676,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376197
    },
    {
        "content": "<p>I would still need some way to get <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out somehow... when I worked on the proof for <code>norm_map'</code> in the definition of <code>h</code>, I was able to use <code>simp</code> to get <code>λ (z : ℂ), a⁻¹ * ⇑f z</code> out and apply it to an argument, but not in this case...</p>",
        "id": 231253771,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376333
    },
    {
        "content": "<p>Ah, I see!  OK, here's a line that seems to do it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>Basically this is the <code>come_on_lean</code> tactic that people joke about ...</p>",
        "id": 231253906,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616376508
    },
    {
        "content": "<p>That is, we're instructing Lean to check that the following statement is definitionally equal to our goal.</p>",
        "id": 231253925,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616376553
    },
    {
        "content": "<p>oh lol I haven't heard about that one yet!</p>",
        "id": 231253926,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376566
    },
    {
        "content": "<p>could it be because in the case of <code>norm_map'</code> I was dealing with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⇑</span><span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>while this time I'm dealing with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⇑</span><span class=\"o\">{</span><span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>where <code>to_fun</code> is a level deeper?</p>",
        "id": 231253938,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376587
    },
    {
        "content": "<p>Seems plausible!</p>",
        "id": 231253986,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616376620
    },
    {
        "content": "<p>Thanks a lot! I really couldn't wrap my head around why it worked for <code>norm_map'</code> but not in this case (I still don't know why but at least I have a workaround now!)</p>",
        "id": 231254041,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376708
    },
    {
        "content": "<p>There are not many uses of <code>change</code> in mathlib, because usually each definition (in the library proper rather than a definition hidden inside a proof like yours is) is immediately followed by a lemma which unfolds that definition, whose proof is <code>rfl</code>.  Often this \"definition-unfolding\" lemma is even a simp-lemma.</p>",
        "id": 231254089,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616376755
    },
    {
        "content": "<p>Oh I see. Would it make sense to have that extra lemma or is it so specific that it doesn't really make sense to define it outside of this proof?</p>",
        "id": 231254251,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616376958
    },
    {
        "content": "<p>I'd say, not at this stage.  That sort of \"infrastructure\" can be figured out after everything else is working.</p>",
        "id": 231254379,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616377128
    },
    {
        "content": "<p>By the way, here's an example of the kind of thing I was describing:  see how the imaginary part function <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.im_clm\">docs#complex.im_clm</a>, as a continuous linear map, is immediately followed by a simp-lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.im_clm_apply\">docs#complex.im_clm_apply</a> explaining what it does as a function.</p>",
        "id": 231254492,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616377275
    },
    {
        "content": "<p>(I tend to write my <code>@[simp]</code> lemmas as soon as they're needed --- every time I try <code>simp</code> and it doesn't solve the goal, I stop to think if a lemma is missing. Life is so much easier once they're in place.)</p>",
        "id": 231254630,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616377498
    },
    {
        "content": "<p>Oh yes I remember seeing a few of those <code>rfl</code> lemmas often just after a definition.. Thanks, now I understand why they're there!</p>",
        "id": 231254750,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616377664
    },
    {
        "content": "<p>Interestingly when I try the next step to go from <code>(f 1)⁻¹ * f 1 = 1</code> to <code>1 = 1</code>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">let</span> <span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n        <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n        <span class=\"n\">rw</span> <span class=\"n\">mul_left_inv</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n        <span class=\"bp\">...</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span><span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">},</span>\n<span class=\"n\">H0</span> <span class=\"o\">:</span> <span class=\"bp\">⇑</span><span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">h.map_zero</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">group</span> <span class=\"n\">ℂ</span>\n</code></pre></div>\n<p>but when I look in <code>analysis.normed_space.linear_isometry</code> I see an <code>instance : group (E ≃ₗᵢ[R] E)</code> with <code>mul_left_inv</code> defined..<br>\nIs there something I'm missing to make Lean aware that <code>f</code> has access to <code>mul_left_inv</code>?</p>",
        "id": 231255926,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616378934
    },
    {
        "content": "<p>I also tried adding <code>import analysis.normed_space.linear_isometry</code> but it didn't change anything</p>",
        "id": 231255945,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616378982
    },
    {
        "content": "<p>Careful, <code>ℂ ≃ₗᵢ[ℝ] ℂ</code> is a group but <code>ℂ</code> itself is not a group!</p>",
        "id": 231256111,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616379194
    },
    {
        "content": "<p>Because 0 is not invertible.</p>",
        "id": 231256120,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616379211
    },
    {
        "content": "<p>oh right! oups</p>",
        "id": 231256174,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616379249
    },
    {
        "content": "<p>Instead of the lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_left_inv\">docs#mul_left_inv</a> (for groups only), you want to use the lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inv_mul_cancel\">docs#inv_mul_cancel</a>.</p>",
        "id": 231256396,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616379564
    },
    {
        "content": "<p>Ok nice and then I need to supply a proof that <code>a ≠ 0</code></p>",
        "id": 231256597,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616379764
    },
    {
        "content": "<p>I'm now running into an awkward situation..</p>\n<p>I have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">∨</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>and would like to get to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>When I use <code>rw ← mul_right_inj' H3</code> where (<code>H3 : a⁻¹ ≠ 0</code>), I'm able to get </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"bp\">∨</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>and then I try to use <code>rw ← mul_right_inj' H3 @(f z) @(a * conj z)</code> to act on the other equality<br>\nbut I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span>\n  <span class=\"n\">mul_right_inj'</span> <span class=\"n\">H3</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"bp\">↔</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">=</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span>\n</code></pre></div>",
        "id": 231403731,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616457969
    },
    {
        "content": "<p>I was trying to use the <code>@</code> to pass the parameters to implicit arguments <code>{b c}</code></p>",
        "id": 231403875,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616458093
    },
    {
        "content": "<p>The <code>@</code> has to go on the <code>mul_right_inj'</code></p>",
        "id": 231404382,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616458447
    },
    {
        "content": "<p>You can also use <code>conv</code> in this situation to \"zoom in\" on the subexpression you want to rewrite. The proof is sometimes easier to follow this way.</p>",
        "id": 231404439,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616458504
    },
    {
        "content": "<p>Thanks for the tips <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> , how would I use <code>conv</code>? Would I use it with <code>rw</code> or on its own?</p>",
        "id": 231404939,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616458866
    },
    {
        "content": "<p>Something like <code>conv at h { congr, skip, rw p }</code>.</p>",
        "id": 231404987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616458900
    },
    {
        "content": "<p>This says: \"look at h, split into subexpressions, skip over the first one, rewrite using <code>p</code> in the second one\".</p>",
        "id": 231405050,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616458925
    },
    {
        "content": "<p>nice, I just tried it.. yup it's much easier to follow like this! Thanks for the new tool!</p>",
        "id": 231405444,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616459198
    },
    {
        "content": "<p>I'm trying to use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">mul_left_cancel</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"n\">H_left</span>\n</code></pre></div>\n<p>and am getting the error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">pre</span><span class=\"bp\">-</span><span class=\"n\">numeral</span><span class=\"o\">,</span> <span class=\"kd\">universe</span> <span class=\"n\">level</span> <span class=\"n\">must</span> <span class=\"n\">be</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n</code></pre></div>\n<p>when I did my first pass on the proof, I wrote this lemma</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reals_mul_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and applied it like this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">mul_left_cancel</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"n\">H_left</span>\n</code></pre></div>\n<p>so that I could move on.<br>\nBut now I'm cleaning up the proof and would like to know what the error <code>invalid pre-numeral, universe level must be &gt; 0</code> means and how I can solve it.<br>\nThanks!</p>",
        "id": 231566294,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616546757
    },
    {
        "content": "<p>Can you share the full lemma statement and attempted proof?</p>",
        "id": 231568055,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616548198
    },
    {
        "content": "<p>it's for this lemma in particular (it's rather long and I'm working on making it shorter but here's the part I'm having an issue with):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex'</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n<span class=\"kd\">begin</span>\n  <span class=\"bp\">...</span>\n  <span class=\"k\">have</span> <span class=\"n\">Hre</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_re</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_im</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">conj_re</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">conj_im</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_neg_self</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_self_eq</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n    <span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">eq_comm</span> <span class=\"n\">at</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n    <span class=\"n\">ring</span> <span class=\"n\">at</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">reals_mul_left_cancel</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>   <span class=\"bp\">&lt;</span><span class=\"c1\">-------</span>\n  <span class=\"o\">},</span>\n  <span class=\"bp\">...</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231568291,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616548385
    },
    {
        "content": "<p>what's <code>H</code> here? just the statement</p>",
        "id": 231568849,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616548852
    },
    {
        "content": "<p>oh sorry, yes it's </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 231569127,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616549088
    },
    {
        "content": "<p>This works for me, so something is different than what you shared:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.buffer.parser.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">reals_mul_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">h</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">z.conj</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">conj</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_re</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_im</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">conj_re</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">conj_im</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">2</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">add_neg_self</span> <span class=\"n\">at</span> <span class=\"n\">H</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">two_mul</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">two_mul</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">eq_comm</span> <span class=\"n\">at</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n  <span class=\"n\">ring_nf</span> <span class=\"n\">at</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">reals_mul_left_cancel</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"n\">H_left</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 231569773,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1616549661
    },
    {
        "content": "<p>yes it works but I would like to get rid of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">reals_mul_left_cancel</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>and use </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">mul_left_cancel</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"n\">H_left</span>\n</code></pre></div>\n<p>instead</p>",
        "id": 231570478,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616550282
    },
    {
        "content": "<p>The reason you're getting the cryptic pre-numeral error is because <code>mul_left_cancel</code> has the arguments implicit so you're feeding it numbers when it expects something completely different; you'll see the same error if you change your lemma to use <code>{a b c : ℝ}</code>. You could just <code>linarith [H_left]</code> to get around it if you don't like using that lemma, or maybe people that know a lot more than me know how to give Lean more hints so that it would understand, say, <code>apply mul_left_cancel H_left</code>.</p>",
        "id": 231571729,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1616551432
    },
    {
        "content": "<p>Oh great,  thanks <span class=\"user-mention\" data-user-id=\"284160\">@Eric Rodriguez</span> ! I'll stick to <code>linarith [H_left]</code>. I haven't used much automation in my proofs yet. Does the <code>[H_left]</code>mean: try <code>linarith</code> lemmas with <code>H_left</code> as a parameter?</p>",
        "id": 231572206,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616551778
    },
    {
        "content": "<p>as far as I understand! I'm still learning so I'm sure the wiser ones will know far better :b</p>",
        "id": 231572266,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1616551813
    },
    {
        "content": "<p>I'm working on readying this lemma for a PR. I'm wondering:</p>\n<ul>\n<li>in which file it should be or should it be in its own file (e.g. <code>analysis/complex/isometry.lean</code>)?</li>\n<li>I have another lemma that I used in the proof of <code>linear_isometry_complex</code> for now it's called <code>linear_isometry_complex'</code>. How should I name it?</li>\n<li>I'll try to go through the documentation style (<a href=\"https://leanprover-community.github.io/contribute/doc.html\">https://leanprover-community.github.io/contribute/doc.html</a>) and rename some variables and if it will be in its own file I guess I'll need to add a file header.</li>\n<li>anything else I should know about the process?</li>\n</ul>\n<p>thanks!</p>",
        "id": 232105648,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616866753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"375581\">François Sunatori</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232105648\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I have another lemma that I used in the proof of <code>linear_isometry_complex</code> for now it's called <code>linear_isometry_complex'</code>. How should I name it?</li>\n</ul>\n</blockquote>\n<p>That depends a lot on the statement</p>",
        "id": 232105731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616866811
    },
    {
        "content": "<p>If it is reusable, it should be moved to the file where it belongs, and follow the naming convention</p>",
        "id": 232105753,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616866833
    },
    {
        "content": "<p>If it's really a one-off helper lemma, we typically append <code>_aux</code> or something like that.</p>",
        "id": 232105761,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616866850
    },
    {
        "content": "<p>I think it's more of a one-off helper lemma in this case so I'll add <code>_aux</code></p>",
        "id": 232105894,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616867003
    },
    {
        "content": "<p>How about the <code>linear_isometry_complex</code> lemma itself? in which file would it make most sense to add it?</p>",
        "id": 232106149,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616867250
    },
    {
        "content": "<p>your suggestion sounded good</p>",
        "id": 232106387,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616867485
    },
    {
        "content": "<p>ok, thanks :)</p>",
        "id": 232106508,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616867596
    },
    {
        "content": "<p>I think I would be ready to open a PR for this addition. This is a first for me and I look forward to getting some feedback. I would like to have write access for a non-master branch. My GitHub username is <code>frankymacster</code>. Thanks!</p>",
        "id": 232130509,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616893294
    },
    {
        "content": "<p>@maintainers</p>",
        "id": 232152343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616920487
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"375581\">@François Sunatori</span>, invitation sent! (Sorry, everyone must be enjoying their weekend, usually we're fast on these. :-)</p>",
        "id": 232154708,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616923448
    },
    {
        "content": "<p>Thanks! No worries, I expected that since I asked on a Saturday night ;)</p>",
        "id": 232169836,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616941205
    },
    {
        "content": "<p>Hi, I'm trying to use <code>conv</code> on the following expression</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>by doing:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>        <span class=\"n\">conv</span> <span class=\"o\">{</span>\n          <span class=\"n\">congr</span><span class=\"o\">,</span>\n          <span class=\"n\">intro</span> <span class=\"n\">z</span>    <span class=\"bp\">&lt;</span><span class=\"c1\">--------</span>\n        <span class=\"o\">},</span>\n</code></pre></div>\n<p>but <code>intro z</code> gives the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">unknown</span> <span class=\"n\">identifier</span> <span class=\"sc\">'z'</span>\n</code></pre></div>\n<p>How come I can't use <code>intro</code> in <code>conv</code>? Is there some other way to deal with a situation like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span><span class=\"bp\">⁻¹</span> <span class=\"bp\">*</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>to affect change to <code>a⁻¹ * ⇑f z = z</code> for example?<br>\nThanks!</p>",
        "id": 232214979,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616990012
    },
    {
        "content": "<p>Use <code>funext</code> to rewrite under binders in <code>conv</code>. See <a href=\"https://leanprover-community.github.io/extras/conv.html\">the docs</a>.</p>",
        "id": 232215051,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616990110
    },
    {
        "content": "<p>Thanks! I tried replacing <code>intro z</code> with <code>funext</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>       <span class=\"n\">conv</span> <span class=\"o\">{</span>\n          <span class=\"n\">congr</span><span class=\"o\">,</span>\n          <span class=\"n\">funext</span>\n        <span class=\"o\">},</span>\n</code></pre></div>\n<p>but the goal didn't change... the goal is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>before and after <code>funext</code></p>",
        "id": 232215496,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616990601
    },
    {
        "content": "<p>Ah, I guess <code>funext</code> only works on lambdas. Maybe you can try to get inside using <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#conv:%20find\"><code>find</code></a>?</p>",
        "id": 232215839,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616990958
    },
    {
        "content": "<p><code>conv in ..</code> should work?<br>\ne.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">conv</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n  <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>PS it'll be easier to help if you can make  a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> like I did here for people to try their suggestions</p>",
        "id": 232216033,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1616991167
    },
    {
        "content": "<p>great, both <code>find (f _ = _)</code> and  <code>conv in (_ = _)</code> worked! (I think I'll opt for <code>conv in (_ = _)</code> since it gave less lines). Thanks to you both :)</p>",
        "id": 232216255,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616991393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"127136\">Alex J. Best</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232216033\">said</a>:</p>\n<blockquote>\n<p>PS it'll be easier to help if you can make  a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> like I did here for people to try their suggestions</p>\n</blockquote>\n<p>One nice thing about a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> is that anyone can open it instantly in the web editor (using the tool in the top right corner of the code snippet) to play with it.</p>",
        "id": 232216293,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1616991479
    },
    {
        "content": "<p>Oh I didn't know that it opened the web editor! ok I'll try to do that next time, I guess it will make communicating things easier!</p>",
        "id": 232216503,
        "sender_full_name": "François Sunatori",
        "timestamp": 1616991664
    },
    {
        "content": "<p>I'm trying to generalize the expression <code>(f z).re = z.re</code> to <code>∀ (z : ℂ), (f z).re = z.re</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">add_self_eq</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">ring</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hf_re</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">h₃</span> <span class=\"o\">{</span>\n    <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_re</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">add_re</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_im</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">add_im</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_neg_self</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">add_neg_self</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">add_self_eq</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">add_self_eq</span><span class=\"o\">,</span>\n      <span class=\"n\">congr</span><span class=\"o\">,</span>\n      <span class=\"n\">skip</span><span class=\"o\">,</span>\n      <span class=\"c1\">-- refl,</span>\n      <span class=\"c1\">-- trivial,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>I tried to use <code>refl</code> and <code>trivial</code> inside <code>conv at h3</code> (and thought that it would work since I saw it used in <a href=\"https://leanprover-community.github.io/extras/conv.html\">https://leanprover-community.github.io/extras/conv.html</a>) but am getting this error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">conv.istep</span> <span class=\"mi\">19</span> <span class=\"mi\">6</span> <span class=\"mi\">19</span> <span class=\"mi\">6</span> <span class=\"n\">refl</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">refl</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span><span class=\"o\">),</span> <span class=\"bp\">?</span><span class=\"n\">m_2</span> <span class=\"n\">a</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">conv</span> <span class=\"bp\">?</span><span class=\"n\">m_1</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n</code></pre></div>\n<p>am I missing something here? or should I be trying a different tactic?<br>\nThanks!</p>",
        "id": 232524657,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617155805
    },
    {
        "content": "<p>One way to generalize it is just to say:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hf_re</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span> <span class=\"n\">add_re</span><span class=\"o\">,</span> <span class=\"n\">add_im</span><span class=\"o\">,</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">two_mul</span><span class=\"o\">,</span>\n         <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">two_ne_zero'</span><span class=\"o\">])]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 232526166,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617156986
    },
    {
        "content": "<p>oh nice, however an extra detail  is that <code>(∀ z : ℂ) : (f z).re = z.re</code> is a hypothesis in the lemma I'm working on. Will this work in that case?</p>",
        "id": 232526625,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617157403
    },
    {
        "content": "<p>I'm not sure what you mean. All I did was move the <code>∀ (z : ℂ)</code> to the left of the <code>colon</code> in <code> lemma name args *here* : statement := proof</code></p>",
        "id": 232526749,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617157505
    },
    {
        "content": "<p>And you'll be able to use it. Take a look:</p>",
        "id": 232526778,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617157530
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hf_re</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span> <span class=\"n\">add_re</span><span class=\"o\">,</span> <span class=\"n\">add_im</span><span class=\"o\">,</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">two_mul</span><span class=\"o\">,</span>\n         <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">two_ne_zero'</span><span class=\"o\">])]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">end</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">hf_re</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">hf_re :</span>\n<span class=\"cm\">  ∀ (f : ℂ →ₗᵢ[ℝ] ℂ),</span>\n<span class=\"cm\">    (∀ (z : ℂ), z + ⇑conj z = ⇑f z + ⇑conj (⇑f z)) → ∀ (z : ℂ), (⇑f z).re = z.re</span>\n<span class=\"cm\">-/</span>\n</code></pre></div>",
        "id": 232526802,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617157561
    },
    {
        "content": "<p>As you can see, I placed the <code>z</code> to the left of the colon, and the lemma, as Lean sees it, still has the universal quantifier.</p>",
        "id": 232526888,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617157598
    },
    {
        "content": "<p>ok thanks :) I'll see how I can use it in my lemma!</p>",
        "id": 232527122,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617157804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"375581\">François Sunatori</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232524657\">said</a>:</p>\n<blockquote>\n<p>I tried to use <code>refl</code> and <code>trivial</code> inside <code>conv at h3</code> (and thought that it would work since I saw it used in <a href=\"https://leanprover-community.github.io/extras/conv.html\">https://leanprover-community.github.io/extras/conv.html</a>) </p>\n</blockquote>\n<p>I think the docs may be unclear about this. That page says (modulo formatting):</p>\n<blockquote>\n<p>Once arrived at the relevant target, we can use rw as in normal mode. Note that Lean tries to solves the current goal if it became x = x (in the strict syntactical sense, definitional equality is not enough: one needs to conclude by refl or trivial in this case).</p>\n</blockquote>\n<p>It sounds like it's saying you can use <code>refl</code> or <code>trivial</code> inside the <code>conv</code> block, but I think what it actually means is just that in that case you need to say <code>refl</code> or <code>trivial</code> after the <code>conv</code> is over.</p>",
        "id": 232528845,
        "sender_full_name": "Greg Price",
        "timestamp": 1617159446
    },
    {
        "content": "<p>Putting the <code>z : ℂ</code> before the colon is a good way to write the proof, but perhaps it's informative to see another way you could more directly do what you were trying to do above:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hf_re</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₄</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">h₃</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">f : ℂ →ₗᵢ[ℝ] ℂ,</span>\n<span class=\"cm\">h₃ : ∀ (z : ℂ), z + ⇑conj z = ⇑f z + ⇑conj (⇑f z),</span>\n<span class=\"cm\">z : ℂ,</span>\n<span class=\"cm\">h₄ : z + ⇑conj z = ⇑f z + ⇑conj (⇑f z)</span>\n<span class=\"cm\">⊢ (⇑f z).re = z.re</span>\n<span class=\"cm\">-/</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 232529172,
        "sender_full_name": "Greg Price",
        "timestamp": 1617159742
    },
    {
        "content": "<p>oh right, I haven't thought of doing that! thanks for the trick :)</p>",
        "id": 232530354,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617160912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"397997\">Greg Price</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232529172\">said</a>:</p>\n<blockquote>\n<p>Putting the <code>z : ℂ</code> before the colon is a good way to write the proof</p>\n</blockquote>\n<p>Is there a preferred style for mathlib in terms of having</p>\n<ul>\n<li><code>z : ℂ</code> before the colon vs</li>\n<li><code>∀ (z : ℂ)</code> after the colon<br>\n?</li>\n</ul>",
        "id": 232530544,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617161080
    },
    {
        "content": "<p>Yes, the former!  It avoids one <code>intros</code> step.</p>",
        "id": 232530678,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617161187
    },
    {
        "content": "<p>And I might guess (not sure, though) that it's less sensitive to ordering of hypotheses in things like <code>library_search</code>.</p>",
        "id": 232530760,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617161267
    },
    {
        "content": "<p>thanks! I'll work on cleaning up my code to follow that more and maybe also split some parts out as smaller lemmas (I get the feeling my proofs were too long when I compare with other ones in mathlib)</p>",
        "id": 232531230,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617161695
    },
    {
        "content": "<p>Is there some rule of thumb or a style preference on when a code block should stay in a <code>have</code> inside a proof vs when it should be moved out?</p>",
        "id": 232531335,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617161778
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a>? What are the two options (it's OK to use <code>foo</code> instead of a real example)?</p>",
        "id": 232531383,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617161864
    },
    {
        "content": "<p>actually I was asking more as a general question if there's a general way or heuristic to determine when a proof should be split into smaller lemmas (for one I'm guessing if it can be reused elsewhere it's a good idea to move it out as its own lemma, but would there be other reasons?), but here's how I had it:<br>\nthe \"main\" lemma to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>an auxiliary lemma that I'm using in the proof of the one above</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span> <span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>but the proof I had for <code>linear_isometry_complex_aux</code> is almost 100 lines.. (maybe I didn't use the shortest path to get to it or I haven't used enough simplification tactics) but I'm asking because I'm guessing that at some point too many lines may not be preferable in the mathlib library.</p>",
        "id": 232532094,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617162545
    },
    {
        "content": "<p>In this case it looks like the <code>aux</code> lemma is an important particular case, and it can be used separately, so it should be a separate lemma.</p>",
        "id": 232532304,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617162743
    },
    {
        "content": "<p>\"To split or not to split\" is a matter of taste. I'm not sure what's more readable: a long proof with many named <code>have</code>s or a series of short lemmas.</p>",
        "id": 232532363,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617162807
    },
    {
        "content": "<p>Sure, if one of <code>have</code>s is a useful lemma, then it should be formulated separately. Otherwise it's OK to have long proofs.</p>",
        "id": 232532471,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1617162896
    },
    {
        "content": "<p>The proof for the aux lemma, in my mind, is something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">real</span> <span class=\"n\">parts</span> <span class=\"n\">must</span> <span class=\"k\">match</span> <span class=\"n\">up</span> <span class=\"o\">(</span><span class=\"n\">you've</span> <span class=\"n\">done</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"n\">lines</span><span class=\"o\">)</span>\n<span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">I</span> <span class=\"n\">maps</span> <span class=\"n\">to</span> <span class=\"n\">either</span> <span class=\"n\">I</span> <span class=\"n\">or</span> <span class=\"bp\">-</span><span class=\"n\">I</span>\n<span class=\"n\">every</span> <span class=\"n\">z</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">linear</span> <span class=\"n\">combination</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">so</span>  <span class=\"n\">the</span> <span class=\"n\">properties</span> <span class=\"n\">you've</span> <span class=\"n\">proved</span> <span class=\"n\">so</span> <span class=\"n\">far</span> <span class=\"n\">transfer</span>\n</code></pre></div>",
        "id": 232532479,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617162905
    },
    {
        "content": "<p>And the first two can be their own lemmas, I think (?)</p>",
        "id": 232532506,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617162928
    },
    {
        "content": "<p>ok yea I like that split. I'll try it that way</p>",
        "id": 232532587,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617162991
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span>  and <span class=\"user-mention\" data-user-id=\"308899\">@Yakov Pechersky</span> !</p>",
        "id": 232532606,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617163019
    },
    {
        "content": "<p>Haven't done complex analysis in a long time, so my assumptions about what's easy or what implies what might be wrong here.</p>",
        "id": 232532629,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617163044
    },
    {
        "content": "<p>so actually the way I had it for the <code>linear_isometry_complex_aux</code> (at a high level) was this way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_re</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_im</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"bp\">...</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>since the last 2 (<code>hf_re</code> and <code>hf_im</code>) are rather general I think I'll move them to their own lemmas and maybe the other cases would stay in the proof. I don't know how conventional it is to split a proof up this way in terms of the <code>have</code>s but it felt easier to follow for me when I did the original write up.</p>",
        "id": 232534109,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617164318
    },
    {
        "content": "<p>To tweak the statement a little further, how about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">linear_isometry.id</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">conj_li</span>\n</code></pre></div>\n<p>You don't need <code>h₀</code>, it's true automatically.</p>",
        "id": 232534305,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617164513
    },
    {
        "content": "<p>ok sure! it looks more concise!</p>",
        "id": 232534490,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617164691
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"308899\">Yakov Pechersky</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232532479\">said</a>:</p>\n<blockquote>\n<p>The proof for the aux lemma, in my mind, is something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">the</span> <span class=\"n\">real</span> <span class=\"n\">parts</span> <span class=\"n\">must</span> <span class=\"k\">match</span> <span class=\"n\">up</span> <span class=\"o\">(</span><span class=\"n\">you've</span> <span class=\"n\">done</span> <span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"mi\">2</span> <span class=\"n\">lines</span><span class=\"o\">)</span>\n<span class=\"k\">show</span> <span class=\"n\">that</span> <span class=\"n\">I</span> <span class=\"n\">maps</span> <span class=\"n\">to</span> <span class=\"n\">either</span> <span class=\"n\">I</span> <span class=\"n\">or</span> <span class=\"bp\">-</span><span class=\"n\">I</span>\n<span class=\"n\">every</span> <span class=\"n\">z</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"n\">linear</span> <span class=\"n\">combination</span> <span class=\"n\">of</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">so</span>  <span class=\"n\">the</span> <span class=\"n\">properties</span> <span class=\"n\">you've</span> <span class=\"n\">proved</span> <span class=\"n\">so</span> <span class=\"n\">far</span> <span class=\"n\">transfer</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I noticed a lemma that might help carrying out Yakov's idea: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext\">docs#is_basis.ext</a></p>",
        "id": 232534975,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617165054
    },
    {
        "content": "<p>applied to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complex.is_basis_one_I\">docs#complex.is_basis_one_I</a></p>",
        "id": 232535020,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617165101
    },
    {
        "content": "<p>With a <code>fin_cases</code> somewhere in there</p>",
        "id": 232535107,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1617165179
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232530760\">said</a>:</p>\n<blockquote>\n<p>And I might guess (not sure, though) that it's less sensitive to ordering of hypotheses in things like <code>library_search</code>.</p>\n</blockquote>\n<p>library_search (and indeed many tactics) can't tell the difference between arguments before vs after the colon.</p>",
        "id": 232541502,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1617171109
    },
    {
        "content": "<p>Hi, I'm continuing on the following lemma:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hf_im</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"n\">conv</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span> <span class=\"o\">{</span>\n    <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">complex.abs</span><span class=\"o\">],</span>\n      <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">real.sqrt_inj</span><span class=\"o\">,</span> <span class=\"n\">norm_sq_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">norm_sq_apply</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">,</span>\n        <span class=\"n\">mul_self_eq_mul_self_iff</span><span class=\"o\">],</span>\n      <span class=\"c1\">-- exact norm_sq_nonneg (f z),</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n<p>When I apply <code>rw real.sqrt_inj</code>, 2 more subgoals appear and I'm not sure within a <code>conv</code> how I can do a <code>swap</code>.<br>\nIs it doable? or do I need to go at this a different way?<br>\nThanks!<br>\n(I'm using <code>conv at h₁</code> because of the  <code> ∀ z</code>)</p>",
        "id": 233009630,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617459670
    },
    {
        "content": "<p>Maybe this is easier?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">hf_im</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h₁</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">complex.abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">real.sqrt_inj</span><span class=\"o\">,</span> <span class=\"n\">norm_sq_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">norm_sq_apply</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">,</span>\n        <span class=\"n\">mul_self_eq_mul_self_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 233011565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617461909
    },
    {
        "content": "<p>I hadn't used <code>specialize</code> yet. Thanks! it's much easier this way :)</p>",
        "id": 233012099,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617462475
    },
    {
        "content": "<p>Hi, I managed to write up the proofs for all the <code>have</code>s here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_re</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_im</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n <span class=\"o\">}</span>\n</code></pre></div>\n<p>what is left is the last <code>sorry</code>.</p>\n<p>I'm trying to get <code>(∀ z, f z = z) ∨ (∀ z, f z = conj z)</code> from <code>hf_re</code> and <code>hf_im</code>.</p>\n<p>After doing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf0'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf1'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₃'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf_re'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf_im'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">conv</span> <span class=\"o\">{</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">conv</span> <span class=\"o\">{</span>\n    <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"n\">skip</span><span class=\"o\">,</span>\n    <span class=\"n\">find</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ext_iff</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n</code></pre></div>\n<p>I end up with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span>\n</code></pre></div>\n<p>I tried a few things but wasn't able to get to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>the closest I got was </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">x.re</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">x.im</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">x.im</span>\n</code></pre></div>\n<p>but I still have a <code>∀ (x : ℂ)</code> too many (it's redundant but I don't know how to get rid of it).. Is there a way to simplify this expression to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>or am I taking a difficult path?<br>\nThanks!</p>",
        "id": 233050806,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617504879
    },
    {
        "content": "<p>It is worthwhile to try to carry through your own method, and probably someone will be able to help you with the details ... but I wanted to check that you also saw the advice from me and Yakov Pechersky above,<br>\n<a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534975\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/232534975</a><br>\nabout a different method using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext\">docs#is_basis.ext</a>.</p>",
        "id": 233057767,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617513932
    },
    {
        "content": "<p>I am on mobile, so I may be misunderstanding the issue, but you could try <code>and_distrib</code> (or something similar) to split/unsplit and-or statements.</p>",
        "id": 233058082,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617514375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  thanks, yes I had seen your and Yakov Pechersky's advice but I wasn't sure yet how to approach it that way so I wanted to try a first go at it with the tools that I already know and then on a second pass maybe try that advice. But maybe if it turns out that the path I'm taking is giving me too much trouble I might jump directly to trying <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext\">docs#is_basis.ext</a>.</p>",
        "id": 233058609,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617515056
    },
    {
        "content": "<p>Ok, this allows you to use some of your assumptions, but leaves still a tangled mess of foralls/ors!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">forall_and_distrib</span><span class=\"o\">,</span> <span class=\"n\">forall_and_distrib</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">and_or_distrib_left</span><span class=\"o\">,</span> <span class=\"bp\">←</span> <span class=\"n\">forall_or_distrib_left</span><span class=\"o\">],</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">hf_re'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n</code></pre></div>",
        "id": 233061165,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617518356
    },
    {
        "content": "<p>I am actually not even sure if what you want to prove is true...</p>",
        "id": 233061170,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1617518372
    },
    {
        "content": "<p>I think this might take you in a helpful direction:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf_im</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">hf_im</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hf_im</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- f: ℂ →ₗᵢ[ℝ] ℂ</span>\n    <span class=\"c1\">-- h: ⇑f 1 = 1</span>\n    <span class=\"c1\">-- hf_I : (⇑f I).im = I.im</span>\n    <span class=\"c1\">-- ⊢ ∀ (z : ℂ), ⇑f z = z</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">right</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- ...</span>\n    <span class=\"c1\">-- hf_I : (⇑f I).im = -I.im</span>\n    <span class=\"c1\">-- ⊢ ∀ (z : ℂ), ⇑f z = ⇑conj z</span>\n    <span class=\"gr\">sorry</span>\n  <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>",
        "id": 233066058,
        "sender_full_name": "Greg Price",
        "timestamp": 1617524700
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"397997\">@Greg Price</span>  the problem I get with using <code>specialize hf_im I</code> is that I still need to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑</span><span class=\"n\">conj</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>but now the hypothesis I would like to use (<code>∀ z, (f z).im = z.im ∨ (f z).im</code>) is specialized at <code>I</code>.</p>",
        "id": 233093958,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617551810
    },
    {
        "content": "<p>then you can do <code>have hf_im_I := hf_im I,</code> or just <code>cases hf_im I</code></p>",
        "id": 233094467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1617552249
    },
    {
        "content": "<p>My proof was getting more and more complicated to follow, so I'm starting to look into the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_basis.ext\">docs#is_basis.ext</a> direction.<br>\nI'm not sure how to start though... </p>\n<p>I'm guessing that</p>\n<ul>\n<li>I'll want to use <code>is_basis.ext</code> with <code>is_basis_one_I</code> as one of its arguments.</li>\n<li>I need to supply 2 linear maps in order to show  with <code>is_basis.ext</code> that they correspond everywhere, so I would use <code>f</code> as one of the linear maps and the other would be the identity map in once case and the conj map in the other?</li>\n</ul>\n<p>or will I be using one of these as the last argument to <code>is_basis.ext</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hf_re'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">have</span> <span class=\"n\">hf_im'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>?</p>\n<p>Also I'm unsure how I'll be using <code>fin_cases</code>.. maybe the path will be clearer to me once I know how to call <code>is_basis.ext</code>..</p>\n<p>Thanks again for all the help!</p>",
        "id": 233591848,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617848099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"375581\">François Sunatori</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233591848\">said</a>:</p>\n<blockquote>\n<p>I'm guessing that</p>\n<ul>\n<li>I'll want to use <code>is_basis.ext</code> with <code>is_basis_one_I</code> as one of its arguments.</li>\n<li>I need to supply 2 linear maps in order to show  with <code>is_basis.ext</code> that they correspond everywhere, so I would use <code>f</code> as one of the linear maps and the other would be the identity map in once case and the conj map in the other?</li>\n</ul>\n</blockquote>\n<p>This sounds good!</p>",
        "id": 233594476,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617850582
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"375581\">François Sunatori</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/233591848\">said</a>:</p>\n<blockquote>\n<p>or will I be using one of these as the last argument to <code>is_basis.ext</code></p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">have</span> <span class=\"n\">hf_re'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n<span class=\"k\">have</span> <span class=\"n\">hf_im'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I don't think you should have to consider real and imaginary parts separately.  But feel free to show us the setup if this seems to be forced on you.</p>",
        "id": 233594509,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1617850629
    },
    {
        "content": "<p>ok thanks for helping point the way..<br>\nso I'll try using <code>is_basis.ext is_basis_one_I &lt;a proposition involving f and id&gt;</code></p>\n<p><code>&lt;a proposition involving f and id&gt;</code> needs to be of type <code>(h : ∀i, f (v i) = g (v i))</code> where <code>i : ι</code> and <code>ι : Type*</code><br>\nis the <code>i</code> used to parametrize the dimension of the vector space having <code>v</code> as an element?</p>",
        "id": 233595334,
        "sender_full_name": "François Sunatori",
        "timestamp": 1617851434
    },
    {
        "content": "<p>I'm still unsure how to move forward at this point... </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₀</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf0</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_re</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hf_im</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span>\n <span class=\"o\">}</span>\n</code></pre></div>\n<p>(all but the last <code>sorry</code> have been proven)</p>\n<p>I haven't found how to apply <code>is_basis.ext</code> and <code>is_basis_one_I</code> here.<br>\nit looks like Lean expects the next argument to be of type <code>∀ (i : fin 1.succ), ⇑?m_4 (![1, I] i) = ⇑?m_5 (![1, I] i)</code></p>\n<p>I have a few questions here:</p>\n<ul>\n<li>what does <code>!</code> mean?</li>\n<li>what is the <code>i</code> of type <code>fin 1.succ</code>?<ul>\n<li><code>def fin (n : ℕ) := {i : ℕ // i &lt; n}</code> so it's a natural number that is smaller than <code>1.succ</code>?<br>\n    Where can I get this number from my current setup?</li>\n</ul>\n</li>\n</ul>\n<p>Thanks</p>",
        "id": 234953558,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618627930
    },
    {
        "content": "<p>Ok actually for <code>!</code><br>\nI found \"The notation <code>![a, b, ...]</code> expands to <code>vec_cons a (vec_cons b ...)</code>\"<br>\nso I'm guessing <code>![1, I]</code> is just the way that Lean represents vectors.</p>",
        "id": 234953930,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618628415
    },
    {
        "content": "<p>ok so my understanding is that <code>i</code> is the index of the length of the vector <code>![1, I]</code> which in this case is <code>1.succ</code></p>",
        "id": 234956882,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618631534
    },
    {
        "content": "<p>I tried as a test to add hypothesis <code>h4</code>  (that would have the expected type for the 2nd argument of <code>is_basis.ext</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf0'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"n\">hf0</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf1'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">|</span> <span class=\"o\">:=</span> <span class=\"n\">hf1</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h₃'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">h₃</span> <span class=\"n\">hf1'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf_re'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"n\">hf_re</span> <span class=\"n\">h₃'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hf_im'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span> <span class=\"n\">hf_im</span> <span class=\"n\">hf0</span> <span class=\"n\">hf_re'</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">is_basis.ext</span> <span class=\"n\">is_basis_one_I</span> <span class=\"n\">h4</span><span class=\"o\">,</span>\n</code></pre></div>\n<p>However I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">invalid</span> <span class=\"n\">field</span> <span class=\"kd\">notation</span><span class=\"o\">,</span> <span class=\"n\">type</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">form</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"n\">C</span> <span class=\"n\">is</span> <span class=\"n\">a</span> <span class=\"kd\">constant</span>\n  <span class=\"mi\">1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1</span>\n</code></pre></div>\n<p>when mousing over <code>1.succ</code>.<br>\nit seems to me that <code>fin n</code> is  a dependent type depending on a natural number.<br>\nwhen I change it to <code>2</code> I don't get the error anymore, but I now get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">is_basis_one_I.ext</span> <span class=\"n\">h4</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">h4</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">2</span><span class=\"o\">),</span> <span class=\"bp\">⇑</span><span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"n\">succ</span><span class=\"o\">),</span> <span class=\"bp\">⇑?</span><span class=\"n\">m_4</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">⇑?</span><span class=\"n\">m_5</span> <span class=\"o\">(</span><span class=\"bp\">!</span><span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>How can I get <code>∀ (i : fin 1.succ), ⇑f (![1, I] i) = id (![1, I] i)</code> to work here?</p>",
        "id": 234957903,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618632753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"375581\">@François Sunatori</span> Right <code>![a,b,c,x,y,z]</code> is just notation for the vector <code>(a,b,c,x,y,z)</code> in 6-dim space.<br>\nAnd <code>i : fin 1.succ</code> means some term of type <code>fin 1.succ</code> where <code>1.succ : nat</code> is just <code>2</code>. So <code>i = 0</code> or <code>i = 1</code>.<br>\nIn total <code>![1, I] i</code> means the <code>i</code>th component of the vector <code>(1,I)</code>. So this is <code>1</code> if <code>i = 0</code> and <code>I</code> if <code>i = 1</code>.</p>",
        "id": 234961612,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1618637209
    },
    {
        "content": "<p>Unpolished but sorry-free:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.real.sqrt</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry.id_apply</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">linear_isometry.id</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry.id_to_linear_map</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">linear_isometry.id.to_linear_map</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">linear_map.id</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hf_re</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span> <span class=\"n\">add_re</span><span class=\"o\">,</span> <span class=\"n\">add_im</span><span class=\"o\">,</span> <span class=\"n\">conj_re</span><span class=\"o\">,</span> <span class=\"n\">conj_im</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">two_mul</span><span class=\"o\">,</span>\n         <span class=\"o\">(</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">two_ne_zero'</span><span class=\"o\">])]</span> <span class=\"n\">using</span> <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">hf_im</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"bp\">|</span><span class=\"n\">z</span><span class=\"bp\">|</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"n\">z.im</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">im</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">z.im</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">specialize</span> <span class=\"n\">h₁</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">complex.abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"o\">[</span><span class=\"n\">real.sqrt_inj</span> <span class=\"o\">(</span><span class=\"n\">norm_sq_nonneg</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">norm_sq_nonneg</span> <span class=\"n\">_</span><span class=\"o\">),</span> <span class=\"n\">norm_sq_apply</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">),</span> <span class=\"n\">norm_sq_apply</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">add_left_cancel_iff</span><span class=\"o\">,</span> <span class=\"n\">mul_self_eq_mul_self_iff</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry.l0</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∥</span><span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"bp\">∥</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"bp\">∥</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">linear_isometry.norm_map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.map_sub</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry.l1</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">linear_isometry.l0</span> <span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">apply_fun</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">^</span> <span class=\"mi\">2</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">norm_sq_eq_abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">of_real_inj</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_conj</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">mul_conj</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">conj.map_sub</span><span class=\"o\">,</span> <span class=\"n\">conj.map_sub</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_sub</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_conj</span><span class=\"o\">,</span> <span class=\"n\">norm_sq_eq_abs</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_conj</span><span class=\"o\">,</span> <span class=\"n\">norm_sq_eq_abs</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">sub_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_right_inj</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"n\">of_real_pow</span><span class=\"o\">,</span> <span class=\"n\">ring_hom.map_one</span><span class=\"o\">,</span> <span class=\"n\">norm_eq_abs</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">add_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_left_inj</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry.re</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">re</span> <span class=\"bp\">=</span> <span class=\"n\">z.re</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">hf_re</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">linear_isometry.l1</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex_aux</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">have</span> <span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">I</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"n\">I</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">f</span> <span class=\"n\">I</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">,</span> <span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"n\">abs_I</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ext_iff</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">and_or_distrib_left</span><span class=\"o\">,</span> <span class=\"n\">neg_re</span><span class=\"o\">,</span> <span class=\"n\">I_re</span><span class=\"o\">,</span> <span class=\"n\">neg_im</span><span class=\"o\">,</span> <span class=\"n\">neg_zero</span><span class=\"o\">],</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">I_re</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.re</span> <span class=\"n\">h</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hf_im</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">norm_eq_abs</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.re</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">or.imp</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">h1</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">f.to_linear_map</span> <span class=\"bp\">=</span> <span class=\"n\">linear_isometry.id.to_linear_map</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">this</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">,</span> <span class=\"n\">linear_map.id_apply</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_basis.ext</span> <span class=\"n\">is_basis_one_I</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- I expected `simp [h1]` to work. Not sure why it didn't.</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">matrix.head_cons</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">,</span>\n        <span class=\"n\">linear_isometry.id_to_linear_map</span><span class=\"o\">,</span> <span class=\"n\">linear_map.id_coe</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">matrix.cons_val_one</span><span class=\"o\">],</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">f.to_linear_map</span> <span class=\"bp\">=</span> <span class=\"n\">conj_li.to_linear_map</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">,</span> <span class=\"n\">this</span><span class=\"o\">],</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">],</span>\n      <span class=\"c1\">-- should have a simp lemma that does this</span>\n      <span class=\"n\">refl</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">is_basis.ext</span> <span class=\"n\">is_basis_one_I</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">fin_cases</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">,</span> <span class=\"n\">matrix.cons_val_zero</span><span class=\"o\">],</span>\n      <span class=\"n\">change</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"c1\">-- simp lemma</span>\n      <span class=\"n\">ext</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"c1\">-- I expected `simp [h1]` to work. Not sure why it didn't.</span>\n      <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">matrix.head_cons</span><span class=\"o\">,</span> <span class=\"n\">linear_isometry.coe_to_linear_map</span><span class=\"o\">,</span>\n        <span class=\"n\">linear_isometry.id_to_linear_map</span><span class=\"o\">,</span> <span class=\"n\">linear_map.id_coe</span><span class=\"o\">,</span> <span class=\"n\">id.def</span><span class=\"o\">,</span> <span class=\"n\">matrix.cons_val_one</span><span class=\"o\">],</span>\n      <span class=\"n\">change</span> <span class=\"n\">f</span> <span class=\"n\">I</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"n\">I</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">conj_I</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h1</span><span class=\"o\">,</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n</div></div>",
        "id": 234974756,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1618651229
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307953\">@Ruben Van de Velde</span> oh that's quite a bit more than what I was asking for, but maybe I can go over it and try to learn from it and I may ask a few questions about some sections just so that I can learn and compare with what I had. Thanks</p>",
        "id": 234977861,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618654673
    },
    {
        "content": "<p>I'm now working on changing the initial statement to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">conj_li</span>\n</code></pre></div>\n<p>I defined <code>rotation</code> like so</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mul_assoc</span> <span class=\"bp\">↑</span><span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>but am getting the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">definition</span> <span class=\"bp\">'</span><span class=\"n\">rotation'</span> <span class=\"n\">is</span> <span class=\"kd\">noncomputable</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"bp\">'</span><span class=\"n\">complex.normed_field'</span>\n</code></pre></div>\n<p>I'm not sure what this error means.<br>\nI thought I was not exposing <code>normed_field</code> and tried using <code>open complex.normed_field</code> but that gives the error <code>invalid namespace name 'complex.normed_field'</code>.<br>\nAm I missing something here?</p>\n<p>Thanks :)</p>",
        "id": 235088114,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618767986
    },
    {
        "content": "<p>Add <code>noncomputable def ...</code> to the beginning</p>",
        "id": 235088329,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1618768244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span> thanks! <br>\nI just saw in <a href=\"https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html\">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html</a></p>\n<blockquote>\n<p>The standard library also defines a choice principle that is entirely antithetical to a computational interpretation, since it magically produces “data” from a proposition asserting its existence. Its use is essential to some classical constructions, and users can import it when needed. But expressions that use this construction to produce data do not have computational content, and in Lean we are required to mark such definitions as noncomputable to flag that fact.</p>\n</blockquote>",
        "id": 235088446,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618768385
    },
    {
        "content": "<p>If I understand well, I need to use <code>noncomputable def</code> when I use a record type to use it as data?</p>",
        "id": 235088540,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618768464
    },
    {
        "content": "<p>I'm not sure what you mean by record type, but my understanding is that <code>noncomputable</code> means Lean can't produce bytecode for the data your working with. So you can't do <code>#print ...</code>, but otherwise everything else works as normal</p>",
        "id": 235088699,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1618768641
    },
    {
        "content": "<p>It's only some types that are <code>noncomputable</code>, things like <code>complex</code> and <code>real</code> are some of them. If you just want to prove theorems the standard advice is to put the line <code>noncomputable theory</code> at the top of your file (below the imports), and lean will stop bothering you about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">definition</span> <span class=\"bp\">'</span><span class=\"n\">rotation'</span> <span class=\"n\">is</span> <span class=\"kd\">noncomputable</span><span class=\"o\">,</span> <span class=\"n\">it</span> <span class=\"n\">depends</span> <span class=\"n\">on</span> <span class=\"bp\">'</span><span class=\"n\">complex.normed_field'</span>\n</code></pre></div>\n<p>you don't really lose anything by doing this.</p>",
        "id": 235088821,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1618768764
    },
    {
        "content": "<p>I remember as a beginner being really concerned/confused about what the ramifications of all this noncomputable stuff was, as I was trying to formalise random undergraduate maths from my intro to proof course, and it turned out some was computable and some was not. The thing which took a while to dawn on me was this: if you make noncomputable stuff, then <code>#eval</code> and <code>#reduce</code> might not work -- but if you just want to prove theorems you never use these things anyway, you just use <code>theorem</code>. So <code>noncomputable</code> doesn't matter at all. The majority of the perfectoid space repo was noncomputable, for example.</p>",
        "id": 235091713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1618771585
    },
    {
        "content": "<p>I'm trying to get from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">conj_li</span>\n</code></pre></div>\n<p>to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>so that I can reuse the proof I have for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">,</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">∨</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">conj</span> <span class=\"n\">z</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>This is what I have:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">mul_add</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">intros</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mul_assoc</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span> <span class=\"n\">a</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">mul_assoc</span> <span class=\"bp\">↑</span><span class=\"n\">m</span> <span class=\"n\">a</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n      <span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n      <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">ha</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">conj_li</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">rw</span> <span class=\"n\">rotation</span><span class=\"o\">,</span>\n      <span class=\"n\">left</span><span class=\"o\">,</span>\n      <span class=\"n\">change</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n      <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"gr\">sorry</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n</code></pre></div>\n<p>Specifically for now, I'm trying to get from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>I tried to use the <code>come_on_lean</code> tactic (<code>to_fun := λ (z : ℂ), a * z</code> because I want to get <code>λ (z : ℂ), a * z</code> \"out\" of <code>rotation</code>) to go from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span>\n</code></pre></div>\n<p>to </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>but I get this error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℂ</span> <span class=\"bp\">→</span> <span class=\"n\">ℂ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span>\n</code></pre></div>\n<p>Is there a way for me to isolate the <code>to_fun</code> from the <code>rotation</code> linear isometry in this case?</p>\n<p>Thanks!</p>",
        "id": 235105073,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618783001
    },
    {
        "content": "<p>Is this true or am I missing something? <code>f</code> doesn't need to be a rotation, but you are asserting that it is?</p>",
        "id": 235105928,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1618783920
    },
    {
        "content": "<p>You want the proof that <code>coe_fn</code> is injective</p>",
        "id": 235106236,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618784215
    },
    {
        "content": "<p>Something like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.coe_injective\">docs#linear_map.coe_injective</a>, but for <code> →ₗᵢ[ℝ]</code>. Edit: ah, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_isometry.coe_fn_injective\">docs#linear_isometry.coe_fn_injective</a></p>",
        "id": 235106254,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618784247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"355764\">@Hanting Zhang</span>   sorry, here I'm assuming <code>|a| = 1</code> so it <code>a = e^iθ</code> and I'm not considering translations</p>",
        "id": 235106336,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618784335
    },
    {
        "content": "<p>Oh, actually just <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#ext\">tactic#ext</a> should do the trick</p>",
        "id": 235106426,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618784451
    },
    {
        "content": "<p>Oh nevermind, I missed the little <code>ₗᵢ</code> subscript, sorry!</p>",
        "id": 235106471,
        "sender_full_name": "Hanting Zhang",
        "timestamp": 1618784516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> Thanks! I'll look into <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_isometry.coe_fn_injective\">docs#linear_isometry.coe_fn_injective</a>. By the way, I've been seeing <code>coe</code> a lot and I think it has to do with <code>⇑</code> but I still don't really understand what it means... Could you enlighten me or point me to a doc about it? Thank you!</p>",
        "id": 235106474,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618784519
    },
    {
        "content": "<p>I don't know what <code>come_on_lean</code> refers to, but the trick is to add a helper lemma as soon as you've made the definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">],</span>\n  <span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"n\">algebra.lmul</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">rotation_apply</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 235106738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618784838
    },
    {
        "content": "<p><code>come_on_lean</code> refers to the comment <br>\n<a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253906\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/linear_isometry_complex/near/231253906</a></p>",
        "id": 235106827,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618784982
    },
    {
        "content": "<p>Then you can get back to doing maths rather than fighting lean with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">conj_li</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">left</span><span class=\"o\">,</span>\n    <span class=\"n\">ext1</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">rotation_apply</span><span class=\"o\">,</span>\n    <span class=\"gr\">sorry</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 235106833,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618784987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/linear_isometry_complex/near/235106738\">said</a>:</p>\n<blockquote>\n<p>I don't know what <code>come_on_lean</code> refers to, but the trick is to add a helper lemma as soon as you've made the definition:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">],</span>\n  <span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"n\">algebra.lmul</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">rotation_apply</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>wow that's much simpler than what I had written.. I hope I can write concisely like that at some point</p>",
        "id": 235106936,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618785081
    },
    {
        "content": "<p>The trick there was knowing that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.lmul\">docs#algebra.lmul</a> already existed</p>",
        "id": 235106990,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618785130
    },
    {
        "content": "<p>But all you actually needed to get out of your struggle is that <code>rotation_apply</code> lemma</p>",
        "id": 235107005,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618785161
    },
    {
        "content": "<p>When you define a bundled map <code>some_func</code>, you almost never want to <code>rw some_func</code>; you usually want to define an <code>_apply</code> lemma like I do there</p>",
        "id": 235107051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618785207
    },
    {
        "content": "<p>ok yes, I recall seeing some <code>_apply</code> lemmas where there was just a <code>rfl</code> as proof.<br>\nI'll keep in mind that I better add those when I have a <code>def</code> for a function inside a record</p>",
        "id": 235107140,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618785292
    },
    {
        "content": "<p>Sometimes its more useful to define <code>coe_some_func</code> instead of <code>some_func_apply</code>, especially if you didn't actually end up using a <code>λ</code> to define the function:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">⇑</span><span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">algebra.lmul</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>",
        "id": 235107184,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618785351
    },
    {
        "content": "<p>But that can often lead simp in a direction that's unhelpful</p>",
        "id": 235107252,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618785402
    },
    {
        "content": "<p>ok so, when I see <code>coe_</code> and <code>_apply</code> I can assume they are used for a similar purpose? The one of getting a \"field\" out of a record.</p>",
        "id": 235107673,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618785951
    },
    {
        "content": "<p>and is the <code>⇑</code> linked to <code>coe</code> (coercion)?</p>",
        "id": 235107739,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618786007
    },
    {
        "content": "<p>Strictly <code>⇑</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coe_fn\">docs#coe_fn</a></p>",
        "id": 235107745,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618786023
    },
    {
        "content": "<p><code>↑</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coe\">docs#coe</a>,  <code>↥</code> is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/coe_sort\">docs#coe_sort</a>. Lots of lemma names are pretty lax about the difference, especially since sometimes <code>↑</code> ends up meaning one of the other arrows</p>",
        "id": 235107852,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618786099
    },
    {
        "content": "<p>ah ok, great! thanks.. it's getting clearer to me :)</p>",
        "id": 235107892,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618786155
    },
    {
        "content": "<p>I managed to get a little further by adding <code>conj_li_apply</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.complex.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.complex.exponential</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.linear_isometry</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"kn\">local</span> <span class=\"kd\">notation</span> <span class=\"bp\">`|`</span> <span class=\"n\">x</span> <span class=\"bp\">`|`</span> <span class=\"o\">:=</span> <span class=\"n\">complex.abs</span> <span class=\"n\">x</span>\n\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">rotation</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">norm_map'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">ha</span><span class=\"o\">],</span>\n  <span class=\"n\">to_linear_map</span> <span class=\"o\">:=</span> <span class=\"n\">algebra.lmul</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">rotation_apply</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">z</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n\n<span class=\"kd\">lemma</span> <span class=\"n\">linear_isometry_complex</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span> <span class=\"bp\">→ₗᵢ</span><span class=\"o\">[</span><span class=\"n\">ℝ</span><span class=\"o\">]</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"bp\">|</span><span class=\"n\">a</span><span class=\"bp\">|</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">rotation</span> <span class=\"n\">ha</span> <span class=\"bp\">∨</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">rotation</span> <span class=\"n\">ha</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">conj_li</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∥</span><span class=\"n\">a</span><span class=\"bp\">∥</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">],</span>\n    <span class=\"n\">rw</span> <span class=\"n\">linear_isometry.norm_map</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">conv</span> <span class=\"o\">{</span>\n      <span class=\"n\">congr</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n\n    <span class=\"c1\">-- left,</span>\n    <span class=\"c1\">-- ext1 z,</span>\n    <span class=\"c1\">-- rw rotation_apply,</span>\n\n    <span class=\"c1\">-- right,</span>\n    <span class=\"c1\">-- ext1 z,</span>\n    <span class=\"c1\">-- norm_num,</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Now I need to use <code>conv</code> followed by <code>congr</code> to change the 2 sides of the <code>∨</code> in <code>f = rotation _ ∨ f = (rotation _).comp conj_li</code>.<br>\nI would like to apply the commented out sections to the 2 sides of the <code>∨</code>, but I don't know how to use <code>ext1</code> in conversion tactic mode. What should I be using once in <code>conv</code>?</p>\n<p>Thanks!</p>",
        "id": 235115376,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618794300
    },
    {
        "content": "<p>I looked for all instances of <code>conv</code> in mathlib but haven't seen an example of an <code>ext</code> being used in a <code>conv</code> block.. and I couldn't find something doing the equivalent of an <code>ext</code> either..<br>\nIs it possible that it can't be used in a <code>conv</code> block and that I should approach this from a different direction?</p>",
        "id": 235116821,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618796035
    },
    {
        "content": "<p>Does funext work in this context?</p>",
        "id": 235117647,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1618796992
    },
    {
        "content": "<p><code>ext</code> wouldn't work in <code>conv</code> i don't think, as presumably it'd have to write it as (<code>∀ z, &lt;stuff&gt; ∨ ∀ z, &lt;stuff&gt;</code> whilst <code>ext</code> immediately <code>intros</code>. not sure how feasible it is but maybe just do the work in some <code>have</code>s and then <code>rw</code></p>",
        "id": 235117696,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618797011
    },
    {
        "content": "<p>just tried it alex, it basically seems to be a noop</p>",
        "id": 235117728,
        "sender_full_name": "Eric Rodriguez",
        "timestamp": 1618797056
    },
    {
        "content": "<p>right, no <code>funext</code> didn't work.. I'll try with some <code>have</code>s then. Thanks!</p>",
        "id": 235118100,
        "sender_full_name": "François Sunatori",
        "timestamp": 1618797519
    },
    {
        "content": "<p>Ideally at this point you'd use the maths proof to decide whether the left or right of the or is true</p>",
        "id": 235139680,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1618817786
    }
]
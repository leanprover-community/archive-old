[
    {
        "content": "<p>So I've been thinking about how to state the following fundamental theorem: if we have a short exact sequence of complexes of objects in an abelian category (say), then we get an associated long exact sequence of cohomology groups. </p>\n<p>I spent a while yesterday playing with Johan's <code>differential_object I V</code> category. Here V is an abelian category (or in practice something a bit weaker) and I is an index set. The objects in this differential object category are just I-indexed families of elements of V (i.e. a function I -&gt; V) equipped with maps <code>d i j : V i -&gt; V j</code> for all <code>i</code> and <code>j</code>. I want to add the further axiom that d^2=0 whenever it makes sense. I am even tempted by the idea of having some abstract morphism type <code>M</code> like <code>I</code>, equipped with two maps <code>s : M -&gt; I</code> and <code>t : M -&gt; I</code>and then you get <code>d (s m) (t m) : V (s m) -&gt; V (t m)</code>. In the traditional example I = M = integers, and s(m)=m and t(m) is either m+1 or m-1 depending on whether you're doing homology or cohomology. But I want to keep the axiom \"d^2=0 whenever it makes sense\" (I don't want to use this model for double complexes, double complexes should have two d's I think).</p>\n<p>If subobjects in V form a complete lattice (eg Ab, R-mod...), then one can take the cohomology of one of these crazy complexes A to get an I-indexed family H: you look at all the maps with target A and take the join of their images; this is a subobject of the meet of all the kernels of maps out of I, so you can take the quotient. Note that this quotient object <code>H i</code> doesn't have a <code>d</code> any more, it's not an object of the category, it's just an I-indexed family of objects in V. So what can we do with it?</p>\n<p>A morphism A -&gt; B in this category is one which commutes with all the d's in M. This <code>H</code> construction is functorial with respect to these morphism in the sense that for all i we get an induced <code>H i A -&gt; H i B</code>.</p>\n<p>A short exact sequence  0 -&gt; A -&gt; B -&gt; C -&gt; 0  in the complex category is a collection of short exact sequences indexed by I and commuting with all the d's in M. You can think about it as a family of injections A i -&gt; B i and a family of surjections B i -&gt; C i and images equals kernels. I am guessing that the H-construction is \"exact in the middle\" (even in this generality, but I might be wrong). It is certainly true if the maps s and t are injective -- this is what the traditional proof boils down to : the join of the images is just one image and the meet of the kernels is just one kernel.</p>\n<p>Finally, it seems to me that if 0 -&gt; A -&gt; B -&gt; C -&gt; 0 is short exact in this complex category, then for any m : i -&gt; j you get a map from <code>Delta_m : H i C</code> to <code>H j A</code>. I didn't check this. Again if S and T are injective, <code>H i B -&gt; H i C -&gt; H j A -&gt; H j B</code> is exact, and I don't know if this is true in general.</p>\n<p>Thought of in this way, the long exact sequence is in some sense a red herring. It just becomes a combination of these two other theorems.</p>",
        "id": 230694304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1615989593
    },
    {
        "content": "<p>So one could argue that the long exact sequence of cohomology associated to a short exact sequence of complexes was really a construction and three theorems, and one does not have to even worry about how to talk about a long exact sequence of cohomology groups. I mean, when do we really use this long exact sequence? We just say things like \"oh and H^2(A)=0 by a theorem of Grothendieck so this map on H^1's is surjective\". It's not like we take the long exact sequence itself and then tensor it with something to make a complex and then do cohomology again. For example last week I thought \"I need the long exact sequence for Tor to prove this theorem about flatness\" but actually I just need some very specific assertion of the form \"Tor_1(B)-&gt;Tor_1(C)-&gt;Tor_0(A)-&gt;Tor_0(B) is exact\".</p>\n<p>So here's what things look like abstractly.  Say h,i,j are three indices in I and say h R i and i R j are true, so there are d maps A_h -&gt; A_i and A_i -&gt; A_j with d^2=0 if A is any complex. If we have a triple (h,i,j) like this, we can form H^i(A), meaning ker (A_i -&gt; A_j) / range (A_h -&gt; A_i). It depends on the triple.</p>\n<p>Definition 1) If A -&gt; B is a morphism of complexes, and (h,i,j) is a triple as above, then there's an associated morphism of cohomology groups H^i(A) -&gt; H^i(B).</p>\n<p>Theorem 2) If 0 -&gt; A -&gt; B -&gt; C is exact then H^i(A) -&gt; H^i(B) -&gt; H^i(C) is exact.</p>\n<p>Definition 3) If 0 -&gt; A -&gt; B -&gt; C -&gt; 0 is exact and we throw in another index k with j -&gt; k, so we now have two triples (h,i,j) and (i,j,k), then there's an associated map delta_{i,j} : H^i(C) -&gt; H^j(A).</p>\n<p>Theorem 4: with (h,i,j,k) as above, H^i(B)-&gt;H^i(C)--(delta)--&gt;H^j(A)-&gt;H^j(B) is exact.</p>\n<p>Those are the only theorems you ever need when you're actually using the long exact sequence in practice. Theorem 2 gives you what we call \"exactness at H^i(B)\" and theorem 4 gives you \"exactness at H^j(A) and H^i(C)\". You can now package this data up any way you like (e.g. fin 3 x Z or N or whatever) but these theorems are the interface that we want I think. </p>\n<p>There is a variant when you let e.g. h vary so you're considering lots of maps d : A_h -&gt; A_i, and it all works the same, you just replace all the A_h with their direct sum. Similarly letting j vary just replaces things with their direct product.</p>\n<p>An issue I can see looming: how are we actually going to define these cohomology groups in the lawless complex situation? It's all very well having d's everywhere, but are we really going to take the meet of the kernels and quotient out by the join of the images?</p>",
        "id": 230741956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005321
    },
    {
        "content": "<p>Wait, where do the meets of kernels and joins of images come into play?</p>",
        "id": 230742755,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005606
    },
    {
        "content": "<p>If you have a random complex with d's everywhere and you want to take its cohomology, you're forced to use all d's for images and kernels</p>",
        "id": 230742811,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005637
    },
    {
        "content": "<p>Unless you define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">H</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">j</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"n\">im</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"n\">i</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 230742881,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005676
    },
    {
        "content": "<p>If you just want an answer which depends only on <code>i</code>. In practice we only ever use the variant where the answer depends on <code>h, i, j</code> with h+1=i and i+1=j but I was thinking more generally.</p>",
        "id": 230742883,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005680
    },
    {
        "content": "<p>But I can see why you wouldn't want to do that</p>",
        "id": 230742925,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005684
    },
    {
        "content": "<p>Right</p>",
        "id": 230742935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005690
    },
    {
        "content": "<p>Having three indices feels like it's not going to scale. So maybe the meets-and-joins idea works.</p>",
        "id": 230743053,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005742
    },
    {
        "content": "<p>But just hard-coding <code>i -1</code> and <code>i + 1</code> will bring back all the DTT issues</p>",
        "id": 230743102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005764
    },
    {
        "content": "<p>If you define <code>H (i)</code> as meet of kernels over join of images then (in the succ-structure case) you will still be able to prove that for all h and j, there's a map from ker(d i j) to H i with kernel range(d h i)</p>",
        "id": 230743145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005786
    },
    {
        "content": "<p>Still, I keep having the feeling that we are battling against the system in a way that shouldn't be necessary.</p>",
        "id": 230743352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005857
    },
    {
        "content": "<p>This needs that arbitrary meets and joins of subobjects need to exist in your underlying abelian category too (is that one of the axioms? I never know what the axioms are)</p>",
        "id": 230743438,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005895
    },
    {
        "content": "<p>I know that arbitrary products of objects might not exist (e.g. finite abelian groups), but this is something different.</p>",
        "id": 230743533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616005932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230743438\">said</a>:</p>\n<blockquote>\n<p>This needs that arbitrary meets and joins of subobjects need to exist in your underlying abelian category too (is that one of the axioms? I never know what the axioms are)</p>\n</blockquote>\n<p>Well, the meets and joins aren't that arbitrary, so we can certainly prove that these specific ones exist.</p>",
        "id": 230743704,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1616005999
    },
    {
        "content": "<p>Have a look at <code>category_theory.subobject</code> to see what we have in mathlib already about the lattice structure on subobjects.</p>\n<p>In particular from the module-doc:</p>\n<blockquote>\n<p>We also provide the <code>semilattice_inf_top (subobject X)</code> instance when <code>[has_pullback C]</code>,<br>\nand the <code>semilattice_sup (subobject X)</code> instance when <code>[has_images C] [has_binary_coproducts C]</code>.</p>\n</blockquote>\n<p>makes no mention of arbitrary meets and joins so far :-)</p>",
        "id": 230778194,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616019494
    },
    {
        "content": "<p>But presumably it is not hard.</p>",
        "id": 230778291,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616019528
    },
    {
        "content": "<p>I think one blocker might be that we don't have typeclasses for <code>complete_semilattice_Inf</code> and <code>complete_semilattice_Sup</code>, we just have their combination.</p>",
        "id": 230778634,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616019635
    },
    {
        "content": "<p>I wonder if this is just a red herring. The way I see it there are explicit lemmas involving only finitely many abelian groups and some compatible collection of indices. The idea about taking sups and infs was a way to work around this index issue -- so one could talk about the cohomology in degree n without hard wiring the numbers n-1 and n+1 into the system. But I think another way is just to use pred_succ structures</p>",
        "id": 230824975,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616054392
    },
    {
        "content": "<p>Here is what I think is the main issue. I'm talking about stating and proving the assertion that in an arbitrary ab cat, or perhaps just R-modules, that a short exact sequence of complexes produces a long exact sequence of cohomology. I think the sup and inf stuff is just a red herring now. The cohomology of the complex <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_i\\to A_{i+1}\\to A_{i+2}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> is a kernel modulo an image, and as far as I can see this is not going to be equal to the cohomology of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>A</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">A_{(i+1)-1}\\to A_{i+1}\\to A_{i+2}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.03853em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.891661em;vertical-align:-0.208331em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> in the sense of Lean. If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i,j,k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> are consecutive indexes then it looks like one might have to carry around both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> when talking about <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>j</mi></msup></mrow><annotation encoding=\"application/x-tex\">H^j</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.824664em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span></span></span></span></span></span></span></span></span></span></span>. Example: a short exact sequence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>→</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo>→</mo><mi>C</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0\\to A\\to B\\to C\\to 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> gives <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^{i,j,k}(A)\\to H^{i,j,k}(B)\\to H^{i,j,k}(C)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span></span></span></span> and if you have another consecutive index l after that then you get maps <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^{i,j,k}(C)\\to H^{j,k,l}(A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span>.</p>",
        "id": 230952571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616109969
    },
    {
        "content": "<p>And the theorem is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mrow><mi>j</mi><mo separator=\"true\">,</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>l</mi></mrow></msup><mo stretchy=\"false\">(</mo><mi>B</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">H^{i,j,k}(B)\\to H^{i,j,k}(C)\\to H^{j,k,l}(A)\\to H^{j,k,l}(B).</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0991079999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8491079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct mtight\">,</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mclose\">)</span><span class=\"mord\">.</span></span></span></span> And my feeling is that these results are all you actually need. Note that in particular I am not convinced that we need to make the long exact sequence as a complex.</p>",
        "id": 230952785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616110113
    },
    {
        "content": "<p>I am however concerned that we will have more than one version of what a mathematician might call <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>i</mi></msup><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^i(A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0746639999999998em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">A</span><span class=\"mclose\">)</span></span></span></span> which will depend on the explicit choice of predecessor and successor of i, with different choices related by eq to homs</p>",
        "id": 230953747,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1616110814
    },
    {
        "content": "<p>Out of curiosity, what's a situation where you'll want a general indexing set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> and not just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>?</p>",
        "id": 230954131,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1616111130
    },
    {
        "content": "<p>Lots of times <code>nat</code> is the natural indexing set.</p>",
        "id": 230955733,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616112351
    },
    {
        "content": "<p>e.g. the <a href=\"https://ncatlab.org/nlab/show/Moore+complex\">Moore complex</a></p>",
        "id": 230955790,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616112372
    },
    {
        "content": "<p>or de Rham cohomology, or ...</p>",
        "id": 230955820,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616112396
    },
    {
        "content": "<p>unfortunately also it appears that sometimes <code>nat \\cup {-1}</code> is useful. :-)</p>",
        "id": 230955833,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616112421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> perhaps the solution is the same solution as we have for everything else: make a characteristic predicate saying \"this object is the i-th cohomology of this complex\". Just like there is no \"the localization\" there is no \"the i-th cohomology\"</p>",
        "id": 230961432,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1616116518
    },
    {
        "content": "<p>Maybe I am getting happier with this picture.</p>\n<p>The <code>differential_object</code> gadget with <code>d i j : X i \\hom X j</code>, satisfying no laws except <code>d i j \\gg d j k = 0</code>, is really talking about an object that the simultaneously graded, and has a differential satisfying d^2 = 0 on the the direct sum of all the graded pieces, but where the differential doesn't have to respect the grading.</p>",
        "id": 230970639,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124483
    },
    {
        "content": "<p>You can try to take the homology here, as <code>ker d / im d</code> (a subquotient of the direct sum), but there's no reason to think this will be a graded object.</p>",
        "id": 230970692,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124553
    },
    {
        "content": "<p>To get that you need to know that the image of d is the same thing as the direct sum of the intersections of the image of d with each graded piece.</p>",
        "id": 230970770,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124607
    },
    {
        "content": "<p>(The corresponding fact for the kernel is automatic.)</p>",
        "id": 230970781,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124617
    },
    {
        "content": "<p>And <code>d</code> respecting the grading in pretty much any way at all ensures that.</p>",
        "id": 230970810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124653
    },
    {
        "content": "<p>Now if you know that this condition is going to hold (but haven't yet got a concrete reason, like that <code>d i j = 0</code> unless <code>j = i + 1</code>), I think you're justified in defining <code>i</code>-th homology as the intersection of all the kernels <code>d i j</code> quotiented by the join of all the images <code>d k i</code>... Is that really right?</p>",
        "id": 230970915,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124789
    },
    {
        "content": "<p>The <code>subobject</code> API that Bhavik and I wrote recently is good for doing exactly this kind of thing,</p>",
        "id": 230970939,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124805
    },
    {
        "content": "<p>and I'm pretty sure that just from <code>d_comp_d</code> we can obtain the morphism from the join of the images to the meet of the kernels.</p>",
        "id": 230970954,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124841
    },
    {
        "content": "<p>using the <code>factor_thru</code> API provided in <code>category_theory.subobject</code>.</p>",
        "id": 230971004,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124857
    },
    {
        "content": "<p>I guess something we are missing, discussed a few days ago, is that <code>category_theory.subobject</code> only has binary meets and joins at the moment.</p>",
        "id": 230971041,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124882
    },
    {
        "content": "<p>So...</p>\n<ol>\n<li>let's write <code>complete_semilattice_Sup</code> and <code>complete_semilattice_Inf</code>, slotting them in the hierarchy</li>\n<li>add those instances to <code>subobject X</code> given suitable hypotheses on the category,</li>\n<li>see if we can define homology this way?</li>\n</ol>",
        "id": 230971148,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616124974
    },
    {
        "content": "<p>I haven't followed all the details of the thread, but isn't any <code>complete_semilattice_Sup</code> a <code>complete_lattice</code>: <a href=\"https://planetmath.org/CriteriaForAPosetToBeACompleteLattice\">https://planetmath.org/CriteriaForAPosetToBeACompleteLattice</a></p>",
        "id": 230982602,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1616136379
    },
    {
        "content": "<p>The hypotheses on the category should be wide pullbacks and coproducts+images for _Inf and _Sup respectively</p>",
        "id": 230983733,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616137624
    },
    {
        "content": "<p>But does Bryan's observation apply? If you have wide_pullbacks, you get all <code>Inf</code>s, and then for free you get all <code>Sup</code>s?</p>",
        "id": 230984155,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616138015
    },
    {
        "content": "<p>(or the other way, with coproducts and images)</p>",
        "id": 230984165,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616138034
    },
    {
        "content": "<p>(Hooray that wide pullbacks are already here; this isn't what they were originally intended for, right?)</p>",
        "id": 230984228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616138079
    },
    {
        "content": "<p>It's not what I explicitly intended them for, but the proof of the special adjoint functor theorem takes an Inf of subobjects, and I think I had that in mind when making wide pullbacks as well, it might even be in the module doc</p>",
        "id": 230984375,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616138240
    },
    {
        "content": "<p>I'm pretty sure Bryan's correct, though there might be some universe subtleties - having wide pullbacks or coproducts would mean type v indexed such, and if C isn't well powered (which I think isn't a notion we have) then Sub X might not be in Type v, so getting \"all Infs\" could be trickier than it seems</p>",
        "id": 230984577,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616138427
    },
    {
        "content": "<p>But, I think that doing this all with the assumption of well poweredness should be safe</p>",
        "id": 230984719,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616138523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123965\">Bryan Gin-ge Chen</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230982602\">said</a>:</p>\n<blockquote>\n<p>I haven't followed all the details of the thread, but isn't any <code>complete_semilattice_Sup</code> a <code>complete_lattice</code>: <a href=\"https://planetmath.org/CriteriaForAPosetToBeACompleteLattice\">https://planetmath.org/CriteriaForAPosetToBeACompleteLattice</a></p>\n</blockquote>\n<p>As it turned out this is in mathlib: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/complete_lattice_of_Inf/src\">src#complete_lattice_of_Inf</a>.</p>",
        "id": 231180555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616285369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"246273\">Bhavik Mehta</span> <a href=\"#narrow/stream/116395-maths/topic/long.20exact.20sequences/near/230983733\">said</a>:</p>\n<blockquote>\n<p>The hypotheses on the category should be wide pullbacks and coproducts+images for _Inf and _Sup respectively</p>\n</blockquote>\n<p>I tried doing this on <a href=\"https://github.com/leanprover-community/mathlib/tree/subobject_complete_lattice\">branch#subobject_complete_lattice</a>, but ran into universe issues immediately. I could do start setting things up for <code>[small_category C]</code>, but it's not going to work for <code>[large_category C]</code>. Could you take a look at some point?</p>",
        "id": 231199037,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616310773
    },
    {
        "content": "<p>I feel like we have to shove <code>mono_over A</code> down a universe level, but I don't know how to say this.</p>",
        "id": 231199098,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616310847
    },
    {
        "content": "<p>Oh... this is exactly being well powered.</p>",
        "id": 231199114,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616310878
    },
    {
        "content": "<p>Now the question is how do we set up well-powered categories... My first guess was to say that for every object X, there exists a small poset which is equivalent (as a poset) to the subobjects of X, but an alternative could be to say there's a small type and a surjection from mono_over such that iso subobjects go to the same place</p>",
        "id": 231215227,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616331833
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6801\">#6801</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/6802\">#6802</a></p>",
        "id": 231215278,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616331872
    },
    {
        "content": "<p>They are presumably totally wrong, because I have previously avoided thinking about what \"well-powered\" meant. :-)</p>",
        "id": 231215290,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616331909
    },
    {
        "content": "<p>I'll take a closer look in a moment but it looks very promising!</p>",
        "id": 231215909,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1616332675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span>, I've used <code>well_powered</code> from <a href=\"https://github.com/leanprover-community/mathlib/issues/6802\">#6802</a> to build the arbitrary <code>Inf</code> of subobjects (given wide pullbacks), and I think I've written down the correct construction for <code>Sup</code> (given images and coproducts), but I can't work out how to prove <code>Sup_le</code>.</p>",
        "id": 231251749,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616373650
    },
    {
        "content": "<p>Specifically, I don't even see the paper proof. Any hints?</p>",
        "id": 231251756,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616373666
    },
    {
        "content": "<p>This is all on <a href=\"https://github.com/leanprover-community/mathlib/tree/subobject_complete_lattice\">branch#subobject_complete_lattice</a>, in <code>src/category_theory/subobject/lattice.lean</code>. There's one sorry for the construction of the morphism, and one sorry to check a commutative diagram (presumably easy once I know the morphism).</p>",
        "id": 231251768,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616373713
    },
    {
        "content": "<p>Cancel that, now I get it. :-)</p>",
        "id": 231251943,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616373915
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6809\">#6809</a> now has a <code>complete_lattice</code> structure on <code>subobject X</code>, for any well powered category with coproducts, wide pullbacks, images, and a zero object.</p>",
        "id": 231253136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1616375505
    }
]
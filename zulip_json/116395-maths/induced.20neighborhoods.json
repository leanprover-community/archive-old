[
    {
        "content": "<p>What should we do with the duplication <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L557-L558</a> vs <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L862</a>?</p>",
        "id": 169041614,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561562940
    },
    {
        "content": "<p>And where is the corresponding lemma for the coinduced topology?</p>",
        "id": 169043080,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561563954
    },
    {
        "content": "<p>maybe it's wrong actually</p>",
        "id": 169043416,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561564182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>?</p>",
        "id": 169043423,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561564190
    },
    {
        "content": "<p>I guess just delete the second one and update its uses to use the first one</p>",
        "id": 169043776,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561564417
    },
    {
        "content": "<p>I don't think we need to preserve the name</p>",
        "id": 169043801,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561564432
    },
    {
        "content": "<p>What about the coinduced topology?</p>",
        "id": 169043961,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561564539
    },
    {
        "content": "<p>The function and the element are explicit in one, implicit in the other. Which is \"right\"?</p>",
        "id": 169046330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566069
    },
    {
        "content": "<p>explicit</p>",
        "id": 169046359,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566099
    },
    {
        "content": "<p>And what's the algorithm for working this out? Both f and a are determined by the type of the conclusion.</p>",
        "id": 169046435,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566143
    },
    {
        "content": "<p>you don't use the type of the conclusion in the accounting, just other hypotheses</p>",
        "id": 169046466,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566172
    },
    {
        "content": "<p>One way to put it: if you write <code>have := my_thm a b c h1 h2</code> with all explicit variables filled in, then there should be no metavariables remaining</p>",
        "id": 169046497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566221
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 169046550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566246
    },
    {
        "content": "<p>The rule for iff's is a bit different though; it is sufficient that <code>(my_iff a).1 h</code> and <code>(my_iff a).2 h'</code> have no metavariables</p>",
        "id": 169046595,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566288
    },
    {
        "content": "<blockquote>\n<p>What about the coinduced topology?</p>\n</blockquote>\n<p>Is the corresponding lemma still about comaps, or about maps? Or are they the same?</p>",
        "id": 169046826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566480
    },
    {
        "content": "<p>The tempting statement uses <code>map</code>, but it looks wrong</p>",
        "id": 169046896,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561566515
    },
    {
        "content": "<p>It may be missing because there isn't a nice statement</p>",
        "id": 169046970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566568
    },
    {
        "content": "<p>Can we guess statements and then somehow try them out on all topological spaces with at most three elements?</p>",
        "id": 169046998,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566588
    },
    {
        "content": "<p>I ran into that issue yesterday. It would be really cool to be able to formalise a guess and then just try it</p>",
        "id": 169047064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566615
    },
    {
        "content": "<p>Where is this nuchaku thing again?</p>",
        "id": 169047096,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561566641
    },
    {
        "content": "<p>In fact Lean should have an option where it occasionally tests your goal with random values for the variables and then prints a little message saying \"by the way your goal is false right now\" if it finds a counterexample</p>",
        "id": 169047118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561566659
    },
    {
        "content": "<p><a href=\"https://github.com/nunchaku-inria/nunchaku\" target=\"_blank\" title=\"https://github.com/nunchaku-inria/nunchaku\">https://github.com/nunchaku-inria/nunchaku</a></p>",
        "id": 169047307,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561566783
    },
    {
        "content": "<p>I don't know how far it is from being usable</p>",
        "id": 169047332,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561566800
    },
    {
        "content": "<p>or how far it is from lean</p>",
        "id": 169047430,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121058\">@Jasmin Blanchette</span> Help us! Where is leanchaku?</p>",
        "id": 169047563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561566939
    },
    {
        "content": "<p>Even something like this <a href=\"#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798\" title=\"#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/noob.20question%28s%29/near/168891798</a> would be cool.</p>",
        "id": 169047666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567013
    },
    {
        "content": "<p>That requires your goal be computable though</p>",
        "id": 169047721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567056
    },
    {
        "content": "<p>You just guess</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>randomly and fire a bunch of topological spaces at it and see.</p>",
        "id": 169047722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567056
    },
    {
        "content": "<p>most top space stuff isn't computable</p>",
        "id": 169047740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567068
    },
    {
        "content": "<p>Even if they only have 3 elements?</p>",
        "id": 169047755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567076
    },
    {
        "content": "<p>it's not a computable statement - it's not written in terms of computable functions</p>",
        "id": 169047817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567103
    },
    {
        "content": "<p>it's just some thing about sets</p>",
        "id": 169047830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567113
    },
    {
        "content": "<p>can we enumerate all subsets of a decidable finset?</p>",
        "id": 169047843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567132
    },
    {
        "content": "<p>Sure it's possible to algorithmically determine the answer on small finite sets but we would need a decision procedure</p>",
        "id": 169047851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567145
    },
    {
        "content": "<p>\"just check everything\"?</p>",
        "id": 169047874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567169
    },
    {
        "content": "<p>And many of the facts aren't even over computable types, e.g. you might have to check whether {1} = {2, 3} as elements of <code>set nat</code></p>",
        "id": 169047955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567212
    },
    {
        "content": "<p>I want to stick to finite decidable types.</p>",
        "id": 169047992,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567242
    },
    {
        "content": "<p>even then</p>",
        "id": 169048041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567278
    },
    {
        "content": "<p>even if it said <code>set (fin 4)</code> there it wouldn't work</p>",
        "id": 169048063,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567292
    },
    {
        "content": "<p>because you can't have a decidable_eq for set</p>",
        "id": 169048083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567311
    },
    {
        "content": "<p>I saw Kenny do this once. Someone said \"is it true that every commutative binary relation is associative\" and a couple of minutes later Kenny said \"no, here is a random two element set and a random commutative binary relation which is not associative\"</p>",
        "id": 169048087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567315
    },
    {
        "content": "<p>which he found by using a tool which searched for counterexamples</p>",
        "id": 169048155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567340
    },
    {
        "content": "<p>It's possible to make computable versions of all the functions in the statement, but I don't think you can get that to happen automatically by inferring a decidable instance</p>",
        "id": 169048196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567373
    },
    {
        "content": "<blockquote>\n<p>because you can't have a decidable_eq for set</p>\n</blockquote>\n<p>What if they're decidable sets or something? There must be a way around this.</p>",
        "id": 169048213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567387
    },
    {
        "content": "<p>I just want to let A and B be sets of size 3 and put a random topology on A and choose a random element and test the proposition.</p>",
        "id": 169048243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567422
    },
    {
        "content": "<p>I think you can prove <code>decidable (s = t)</code> if <code>decidable_pred s</code> and <code>decidable_pred t</code> and <code>s t : set A</code> where <code>fintype A</code></p>",
        "id": 169048299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567446
    },
    {
        "content": "<p>Is there <code>decidable_pred_set A</code>?</p>",
        "id": 169048313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567470
    },
    {
        "content": "<p>that's called <code>A -&gt; bool</code></p>",
        "id": 169048323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567485
    },
    {
        "content": "<p>Fair comment.</p>",
        "id": 169048346,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567505
    },
    {
        "content": "<p>If you encoded topologies as <code>(A -&gt; bool) -&gt; bool</code> you could get most things to compute</p>",
        "id": 169048380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567541
    },
    {
        "content": "<p>Patrick, do you fancy refactoring topology again?</p>",
        "id": 169048427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561567563
    },
    {
        "content": "<p>There is also <code>data.analysis.topology</code> which has \"computational realizers\" for topologies and filters</p>",
        "id": 169048511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567661
    },
    {
        "content": "<p>basically a computable top basis</p>",
        "id": 169048528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567680
    },
    {
        "content": "<p>which works even on \"real world\" topologies like the reals</p>",
        "id": 169048576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561567699
    },
    {
        "content": "<p>I've just come back to this. So I think</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>is false, because a subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> of <code>beta</code> is in the LHS iff <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span></span></span></span> is in the interior of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>, and is in the RHS iff <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span></span></span></span> is in the interior of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>. The first of these implies the second, but if I only know that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span></span></span></span> is in the interior of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span> I can't deduce that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span></span></span></span> is in the interior of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> (consider a closed embedding with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> equal to the image and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span></span></span></span> not in the interior of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> computed in <code>beta</code>).</p>",
        "id": 169079178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561582602
    },
    {
        "content": "<p>Oh darn it I can't just consider a closed embedding because f is not just continuous, I need to find an example where beta has the coinduced topology. So I still think it's false. Here are my thoughts. It's really annoying not being able to write beta in Zulip without copy-paste so I'm going to call it <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span>, and similarly <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> for <code>\\alpha</code>.</p>\n<p>So an arbitrary subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">Y\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is in the LHS if there's some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">V\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> open such that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>∈</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">f(a)\\in V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">V\\subseteq Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span>. The definition of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span></span></span></span> being open in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is simply that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi><mo>:</mo><mo>=</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">U := f^{-1}(V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">:</span><span class=\"mrel\">=</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span> is open in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>. </p>\n<p>So <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is in the LHS iff there exists some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">U\\subseteq A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\">A</span></span></span></span> open and a pre-image under <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, such that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a\\in U\\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>. And <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is in the RHS iff there exists some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">U\\subseteq A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\">A</span></span></span></span> open (but not necessarily a preimage under <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span>) such that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">a\\in U\\subseteq f^{-1}(Y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<p>So now this is all about whether subsets are pre-images or not, so we can throw away <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and just put an equivalence relation on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> (and let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> be the quotient and <code>f=mk</code>). And now the question is: come up with an example of a topological space <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> and a random equivalence relation on it which has nothing to do with the topology,  with the property that there's a union <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span> of equivalence classes <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>(</mo><mi>Y</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(f^{-1}(Y))</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.22222em;\">Y</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> and an element <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">a\\in A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">∈</span><span class=\"mord mathit\">A</span></span></span></span> and an open subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>∈</mo><mi>U</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">a\\in U\\subseteq X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span></span></span></span>, but where there is no <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>U</mi><mo mathvariant=\"normal\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">U'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.751892em;\"></span><span class=\"strut bottom\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathrm mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span> satisfying the same properties and also being a union of equivalence classes. </p>\n<p>The simplest way to do this would be to just have two equivalence classes, one of them being not open, and set-theoretically the disjoint union of an open set and a point, and the other one being the rest. </p>\n<p>So it seems to me that the simplest counterexample is this. Let <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>:</mo><mo>=</mo><mo>{</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>η</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">S:=\\{s,\\eta\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mrel\">:</span><span class=\"mrel\">=</span><span class=\"mopen\">{</span><span class=\"mord mathit\">s</span><span class=\"mpunct\">,</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">η</span><span class=\"mclose\">}</span></span></span></span> be the top space with two elements, a closed (non-open) point <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">s</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">s</span></span></span></span> and an open point <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>η</mi></mrow><annotation encoding=\"application/x-tex\">\\eta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">η</span></span></span></span> (is this called Sierpinski space or something?). Let <code>alpha</code> be the disjoint union of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and a discrete one point space <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{a\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathit\">a</span><span class=\"mclose\">}</span></span></span></span>, as a topological space. Let <code>beta</code> be <code>bool</code> and define a map <code>alpha -&gt; beta</code> by sending <code>s</code> and <code>a</code> to <code>tt</code> and <code>eta</code> to <code>ff</code>. </p>\n<p>If I've got this calculation right, and I may not have, then this should be a counterexample, with the subset <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mi>s</mi><mo separator=\"true\">,</mo><mi>a</mi><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{s,a\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord mathit\">s</span><span class=\"mpunct\">,</span><span class=\"mord mathit\">a</span><span class=\"mclose\">}</span></span></span></span> being in the right hand side but not the left hand side.</p>\n<p>How best to get Lean to check my working?</p>",
        "id": 169112503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561622808
    },
    {
        "content": "<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>",
        "id": 169112962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561623250
    },
    {
        "content": "<p>In writing down a proof I just had to write <code>existsi subset.trans _ hY</code> because <code>use (subset.trans _ hY)</code> gave me the cool error</p>\n<div class=\"codehilite\"><pre><span></span>failed to instantiate goal with subset.trans 6._.104 hY\n</pre></div>",
        "id": 169113935,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561624095
    },
    {
        "content": "<p>I have had issues with <code>use</code> in the past as well... it's not a total replacement of <code>existsi</code></p>",
        "id": 169113975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561624140
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>I think this theorem is also false, for exactly the same reasons. Are the theorems equivalent? Just shows how little I know about filters. I'm working through examples like this because I've realised that actually I have had very little experience working with filters and lattices in Lean; my abysmal efforts at 3am last Sat trying to make instances of lattice classes where I found that I didn't even know how to create the structures let alone use them, has somehow woken me up a bit.</p>",
        "id": 169115302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625437
    },
    {
        "content": "<blockquote>\n<p>I think that <code>alpha := option Prop</code> and <code>f := is_some</code> will work to get that</p>\n</blockquote>\n<p>I wanted <code>option Sierpinski_space</code>. This feels different. Is it? If Prop = bool then...I'm assuming the top on bool is the discrete top. Am I wrong?</p>",
        "id": 169115366,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625507
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[instance]\nprotected def bool.topological_space : topological_space bool :=\n⊤\n</pre></div>\n\n\n<p>You don't want \"truth to be an open condition, falsehood to be a closed one\" or something? Oh, is the point that the map Prop -&gt; bool is noncomputable and hence not continuous?</p>",
        "id": 169115585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625680
    },
    {
        "content": "<p>The topology on Prop is sierpinski, the topology on bool is discrete</p>",
        "id": 169115761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561625845
    },
    {
        "content": "<p>Those two theorems are not equivalent</p>",
        "id": 169115776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561625867
    },
    {
        "content": "<p>(well I guess they are equivalent if they are both false)</p>",
        "id": 169115784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561625881
    },
    {
        "content": "<p>And the map from bool to Prop is continuous, and the noncomputable map from Prop to bool is not.</p>",
        "id": 169115785,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625881
    },
    {
        "content": "<p>I'm not totally convinced that the sierpinski topology on Prop is the \"right\" one, but it is convenient in this case</p>",
        "id": 169115868,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561625936
    },
    {
        "content": "<blockquote>\n<p>Those two theorems are not equivalent</p>\n</blockquote>\n<p>Right. I asked because it seemed to me that at the end of the day they were both asking the same question, which surprised me a little.</p>",
        "id": 169115881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625949
    },
    {
        "content": "<p>Are either of map o comap or comap o map the identity?</p>",
        "id": 169115893,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561625974
    },
    {
        "content": "<p>aah</p>",
        "id": 169115951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626013
    },
    {
        "content": "<p>not in general, with these sort of galois connections things</p>",
        "id": 169115959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561626022
    },
    {
        "content": "<p>I can just look in the library for theorems whose names contain <code>map_comap</code> etc, and see examples of conditions which force it. So I can see that neither is true in general (as I suspected).</p>",
        "id": 169115976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626048
    },
    {
        "content": "<p>I think that for at least one of those theorems, it's true in general iff it's true for surjections, and perhaps for surjections you can do something.</p>",
        "id": 169116018,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626093
    },
    {
        "content": "<p>But this isn't my point. I just want to say to Lean \"hey Lean, just go through your database of small topological spaces and find counterexamples for me please\". The fact that there is a counterexample with alpha having three elements makes me think that this is possible. Your suggestion with <code>option Prop</code> is somehow not going in the way I want this to go.</p>",
        "id": 169116111,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626152
    },
    {
        "content": "<p>It also makes me have to learn what the topology on <code>option X</code> is</p>",
        "id": 169116163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626212
    },
    {
        "content": "<p>Turns out there isn't one yet</p>",
        "id": 169116246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561626278
    },
    {
        "content": "<p>I'm trying to prove this too; here's my prelude so far</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">order</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">filter</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">option</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">coinduced</span> <span class=\"n\">option</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">t</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sierp</span> <span class=\"o\">:=</span> <span class=\"n\">bool</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">sierp</span> <span class=\"o\">:=</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"o\">{{</span><span class=\"n\">tt</span><span class=\"o\">}}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">is_open_sierp</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">sierp</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ha</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tt</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">h_H</span> <span class=\"k\">with</span> <span class=\"n\">rfl</span><span class=\"bp\">|⟨⟨⟩⟩</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">trivial</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">h_ih_a</span> <span class=\"n\">ha</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">h_ih_a_1</span> <span class=\"n\">ha</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rcases</span> <span class=\"n\">ha</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h_ih</span> <span class=\"bp\">_</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169116275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561626307
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">option</span> <span class=\"n\">sierp</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">ff</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">le_of_eq</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">nhds_coinduced</span> <span class=\"n\">f</span> <span class=\"n\">none</span><span class=\"o\">),</span>\n  <span class=\"n\">replace</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">this</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">mem_map</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">,</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">h₃</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_open_coinduced</span><span class=\"o\">,</span> <span class=\"n\">is_open_coinduced</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h₂</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h₁</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">is_open_sierp</span> <span class=\"bp\">_</span> <span class=\"n\">h₂</span> <span class=\"n\">ff</span> <span class=\"n\">h₃</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">refine</span> <span class=\"n\">mem_nhds_sets_iff</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">⟨</span><span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">},</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">or</span><span class=\"bp\">.</span><span class=\"n\">inl</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">rfl</span><span class=\"bp\">|⟨⟨⟩⟩</span><span class=\"o\">),</span> <span class=\"n\">exact</span> <span class=\"n\">rfl</span> <span class=\"o\">},</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">is_open_coinduced</span><span class=\"o\">,</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">eq_empty_iff_forall_not_mem</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">some</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"o\">{</span><span class=\"n\">none</span><span class=\"o\">}))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">],</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"bp\">⟨⟨⟩⟩|⟨⟨⟩⟩</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169116672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561626630
    },
    {
        "content": "<p>I reduced the (false) theorem</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span>1 goal\nα β : Type,\nT : topological_space α,\nf : α → β,\na : α,\nX : set α,\nhX : X ∈ (nhds a).sets\n⊢ ∃ (t : set β) (H : t ∈ nhds (f a)), f ⁻¹&#39; t ⊆ X\n</pre></div>",
        "id": 169116970,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561626872
    },
    {
        "content": "<p>reduced in what direction?</p>",
        "id": 169117133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627001
    },
    {
        "content": "<p>Are you saying that goal implies the theorem or vice versa?</p>",
        "id": 169117143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627021
    },
    {
        "content": "<p>This seems to say that an arbitrary neighbourhood of a should be contained within a neighbourhood which is a preimage. Exactly the same false statement. In fact this should be perhaps thought of as the criterion under which one can deduce both of these theorems <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> ; it looks to me like it's equivalent. Does it have some more natural interpretation? I think the goal I just posted above, when considered as a hypothesis, is basically equivalent to both the theorems.</p>",
        "id": 169117155,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627031
    },
    {
        "content": "<p>I am saying that I started with the false theorem, tried to prove it, and that's where I'm stuck.</p>",
        "id": 169117161,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627050
    },
    {
        "content": "<p>However I am not sure I actually did anything non-reversible.</p>",
        "id": 169117177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627067
    },
    {
        "content": "<p>Here's a different question. What <em>is</em> an expression for <code>@nhds β (topological_space.coinduced f T) (f a)</code>?</p>",
        "id": 169117298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627166
    },
    {
        "content": "<p>I've been thinking about it as some sort of sub-filter of  <code>nhds a</code></p>",
        "id": 169117322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627200
    },
    {
        "content": "<p>So there is at least one inequality that can be proved then</p>",
        "id": 169117376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627221
    },
    {
        "content": "<p>It's not really a sub-filter, because it also contains a bunch of junk coming from points in beta which aren't in the image of f</p>",
        "id": 169117401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627256
    },
    {
        "content": "<p>I don't really know how to think about filters.</p>",
        "id": 169117414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627265
    },
    {
        "content": "<p>You will notice that in the proof of false above the first thing I do is use <code>le_of_eq</code> on the false theorem, so maybe the other inequality holds</p>",
        "id": 169117416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627269
    },
    {
        "content": "<p>Oh yeah, I proved inclusions for both false theorems</p>",
        "id": 169117426,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627285
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">hY</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">HVY</span><span class=\"o\">,</span> <span class=\"n\">HV</span><span class=\"o\">,</span> <span class=\"n\">HaV</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n    <span class=\"n\">existsi</span> <span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"bp\">_</span> <span class=\"n\">hY</span><span class=\"o\">),</span>\n      <span class=\"n\">split</span><span class=\"o\">,</span>\n        <span class=\"n\">exact</span> <span class=\"n\">HV</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">HaV</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">HVY</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- bad way</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hX</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_comap_sets</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span> <span class=\"c1\">--goal is false</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169117453,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627308
    },
    {
        "content": "<p>I didn't formalise the other proof but it's equally easy.</p>",
        "id": 169117563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627367
    },
    {
        "content": "<p>I have no feeling for what should go in the library (or whether something is already there).</p>",
        "id": 169117598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627404
    },
    {
        "content": "<p>usually it is <code>comap f L' &lt;= L</code> and <code>L' &lt;= map f L</code> that are the strong/ false properties; the other inequalities <code>L &lt;= comap f L'</code> and <code>map f L &lt;= L'</code> are equivalent to each other (they are the adjunction) and are equivalent to a tendsto</p>",
        "id": 169117616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627434
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced_comap</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">nhds</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"n\">tendsto_iff_comap</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">$</span>\n<span class=\"k\">by</span> <span class=\"n\">apply</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">continuous_coinduced_rng</span>\n</pre></div>",
        "id": 169118157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627869
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">HY</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span> <span class=\"n\">at</span> <span class=\"n\">HY</span><span class=\"o\">,</span>\n  <span class=\"n\">rcases</span> <span class=\"n\">HY</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"n\">HV</span><span class=\"o\">,</span> <span class=\"n\">HOV</span><span class=\"o\">,</span> <span class=\"n\">HaV</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_map</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">mem_nhds_sets_iff</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">f</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"n\">existsi</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">swap</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">HV</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">HOV</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">HaV</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 169118259,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627929
    },
    {
        "content": "<p>Aah but you can just do that one with the Galois connection thing I guess.</p>",
        "id": 169118267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627941
    },
    {
        "content": "<p>I'm assuming it works that way around :-)</p>",
        "id": 169118296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561627972
    },
    {
        "content": "<p>yes, it's even easier because this is the definition of tendsto:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nhds_coinduced_map</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">nhds</span> <span class=\"n\">β</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">coinduced</span> <span class=\"n\">f</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">apply</span> <span class=\"n\">continuous</span><span class=\"bp\">.</span><span class=\"n\">tendsto</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">continuous_coinduced_rng</span>\n</pre></div>",
        "id": 169118320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561627992
    },
    {
        "content": "<p>So now the only question left is whether that goal I posted above is a sufficiently interesting precondition to get the other inequalities. I'm having trouble visualising it in some conceptual way. Once one has visualised it in a conceptual way, it might simply turn into literally the statement of the inequality in the other direction.</p>",
        "id": 169118450,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561628104
    },
    {
        "content": "<p>I suspect this has something to do with being a quotient map</p>",
        "id": 169118465,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561628127
    },
    {
        "content": "<p>because <code>topological_space.coinduced</code> is basically the quotient topology</p>",
        "id": 169118484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1561628154
    },
    {
        "content": "<p>Thank you very much Kevin and Mario. I didn't think that question would trigger so many messages in my absence. I should have written more assertively I thought the obvious nice formula was wrong (even if I don't have a counter-example).</p>",
        "id": 169132521,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1561640751
    },
    {
        "content": "<p>What I found frustrating is that I still don't really understand why we can't just say \"test this on all surjections from topological spaces with at most three elements\". Is the fact that an open set is a map to Prop and not bool enough to actually stop this happening?</p>",
        "id": 169149573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561652301
    },
    {
        "content": "<p>It's enough to make it more difficult.</p>",
        "id": 169150094,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1561652676
    },
    {
        "content": "<p>If only we had some tactic that would transform maps to <code>Prop</code> into maps to the equivalent <code>bool</code>...</p>",
        "id": 169150284,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561652837
    },
    {
        "content": "<p>Should we define <code>toboological_space</code>? Define some <code>transfer</code> relations? Would it be easy to test Kevin's question on <code>toboological_space</code>s with at most 3 elements? Or would this still require a significant amount of work?</p>",
        "id": 169150418,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1561652940
    },
    {
        "content": "<p>I just like doing little exercises like this, I need to learn more about how to use filters and lattices and the like.</p>",
        "id": 169151278,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561653589
    },
    {
        "content": "<p>The fact that we have to deal with <code>set (set X)</code> and not just <code>set X</code> also makes it a bit more difficult</p>",
        "id": 169151483,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561653726
    },
    {
        "content": "<p>I couldn't get <code>f ⁻¹' ⁻¹'</code> to work :-)</p>",
        "id": 169151498,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561653759
    },
    {
        "content": "<p>That's the definition of filter.map</p>",
        "id": 169151548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561653818
    },
    {
        "content": "<p>maybe <code>((f ⁻¹') ⁻¹')</code>?</p>",
        "id": 169152366,
        "sender_full_name": "Reid Barton",
        "timestamp": 1561654465
    },
    {
        "content": "<p>I couldn't get that to work</p>",
        "id": 169173895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1561668452
    }
]
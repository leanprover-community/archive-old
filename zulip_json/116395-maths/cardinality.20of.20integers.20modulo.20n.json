[
    {
        "content": "<p>I am trying to prove the following result</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span> <span class=\"o\">{(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)})</span> <span class=\"err\">≃</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>This seems a simple result in math, but I am having a lot of trouble making a simple proof in lean. Anyone got any suggestions?</p>",
        "id": 155093729,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547481520
    },
    {
        "content": "<p>I don't think you want that <code>fintype</code> there.</p>",
        "id": 155093930,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547481721
    },
    {
        "content": "<p><code>fintype</code> means as much as \"Hey Lean, this type is finite\".</p>",
        "id": 155093986,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547481746
    },
    {
        "content": "<p>That is right, I first wanted to split proving finite and the exact cardinality separately, but realized I could combine the two</p>",
        "id": 155094056,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547481826
    },
    {
        "content": "<p>If you want to construct a map from <code>ideal.quotient ...</code> to the right, look for things called <code>lift</code> in the file of ideal quotients.</p>",
        "id": 155094142,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547481877
    },
    {
        "content": "<p>Maybe the easiest way would be to compute the kernel of the <code>cast : int → zmod n</code></p>",
        "id": 155094197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547481938
    },
    {
        "content": "<p>And then use the isomorphism theorem (that we probably don't have <span class=\"emoji emoji-1f923\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span>)</p>",
        "id": 155094207,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547481944
    },
    {
        "content": "<p>We don't have an isomorphism theorem. At least not for rings</p>",
        "id": 155094270,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547481971
    },
    {
        "content": "<p><code>zmod</code> may also be <code>fin</code> since I am not necessarily interested in the ring structure of it</p>",
        "id": 155094320,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482056
    },
    {
        "content": "<p>There is already a construction of <code>zmod n</code> in <code>data.zmod.basic</code></p>",
        "id": 155094395,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547482109
    },
    {
        "content": "<p>But there it is not constructed using the integers. The thing on the left naturally arises from a problem I have and I want to relate the two</p>",
        "id": 155094448,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482163
    },
    {
        "content": "<p>Or at least get the necessary result about cardinality of the quotient on the left</p>",
        "id": 155094468,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482184
    },
    {
        "content": "<p>I agree that the lemma you state should be proven at some point. So we might as well do it now.</p>",
        "id": 155094806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482460
    },
    {
        "content": "<p>This is what I have thus far:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">let</span> <span class=\"n\">nℤ</span> <span class=\"o\">:=</span> <span class=\"bp\">@</span><span class=\"n\">span</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">_</span> <span class=\"o\">{(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)}</span> <span class=\"k\">in</span>\n<span class=\"k\">let</span> <span class=\"bp\">ℤ</span><span class=\"n\">modnℤ</span> <span class=\"o\">:=</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"n\">nℤ</span> <span class=\"k\">in</span>\n<span class=\"k\">have</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"n\">modnℤ</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">nℤ</span> <span class=\"err\">$</span> <span class=\"n\">of_nat</span> <span class=\"err\">$</span> <span class=\"n\">m</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"err\">%</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n    <span class=\"n\">is_lt</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">},</span>\n<span class=\"k\">have</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"n\">modnℤ</span> <span class=\"bp\">→</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 155094821,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482477
    },
    {
        "content": "<p>I think it is better to prove the isomorphism theorem. Because you will need that time and again</p>",
        "id": 155094902,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  Do you have anything in that direction?</p>",
        "id": 155094956,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482577
    },
    {
        "content": "<p>I'm not sure on your application, but I think the best way to do quotient rings in Lean is to not prove things about the <code>quotient</code> construction, but prove lemmas about quotient rings for any quotient, even if it isn't constructed using the <code>quot</code> constant. For example, <code>ideal.lift</code>, should have been defined with a type like this.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">q</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hq</span> <span class=\"o\">:</span> <span class=\"n\">surjective</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">q</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">γ</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>Would refactoring the library like this help?</p>",
        "id": 155094967,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547482589
    },
    {
        "content": "<p>For the cardinality, all you need is the isomorphism theorem on groups, which is already there.</p>",
        "id": 155095011,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547482638
    },
    {
        "content": "<p>Aah, if we have it for groups, then proving it for rings shouldn't be too hard. But I agree that we don't need it for the cardinality result.</p>",
        "id": 155095086,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482688
    },
    {
        "content": "<p>So working with the predefined group structure on <code>zmod n</code> should do the trick</p>",
        "id": 155095132,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482748
    },
    {
        "content": "<p>I will try to make that work</p>",
        "id": 155095145,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547482769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Don't you need your <code>q</code> to be a ring hom as well?</p>",
        "id": 155095283,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482900
    },
    {
        "content": "<p>I mean, you can probably define this... But then you can't really prove things about it.</p>",
        "id": 155095362,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482956
    },
    {
        "content": "<p>... without extra assumptions</p>",
        "id": 155095375,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547482970
    },
    {
        "content": "<p>Yes, I missed that out.</p>",
        "id": 155095395,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547482988
    },
    {
        "content": "<blockquote>\n<p>Would refactoring the library like this help?</p>\n</blockquote>\n<p>I think the current version of lift is fine, as you most often want maps from a quotient</p>",
        "id": 155095676,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547483230
    },
    {
        "content": "<p>Why do you need to construct <code>ℤmodnℤ</code> using <code>quotient</code> instead of using <code>zmod n</code>?</p>",
        "id": 155095796,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547483326
    },
    {
        "content": "<p>For finite fields, to show that they are field extensions of some field with p elements, I make use of the natural map from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span> to the field which factors over a quotient of that form.</p>",
        "id": 155095933,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547483428
    },
    {
        "content": "<p>So if you had <code>lift</code> with the type I suggested, you could show the field homomorphism directly from <code>zmodp p hp</code> instead of mentioning <code>ideal.quotient</code> right?</p>",
        "id": 155096132,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547483611
    },
    {
        "content": "<p>I would need to prove that the map to <code>zmod p hp</code> is surjective, which is I think the difficult part of the proof I want</p>",
        "id": 155096375,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547483781
    },
    {
        "content": "<p>A priori you do not know that there is a map from <code>zmod p hp</code> to the field</p>",
        "id": 155096447,
        "sender_full_name": "Joey van Langen",
        "timestamp": 1547483857
    },
    {
        "content": "<p>There's a proof somewhere that <code>fin.val</code> is a one-sided inverse of <code>int.cast</code> or perhaps only <code>nat.cast</code></p>",
        "id": 155096521,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547483906
    },
    {
        "content": "<p>I vote in favour of <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> 's suggestion for refactoring.  I have thought about the technicalities of formalizing a number of arguments, both for arbitrary commutative rings and for rings arising in algebraic topology, and it is clear that the more flexible form of the lift construction will be much more convenient in many places.  The same applies for localisations: instead of a theorem about homomorphisms $A[S^{-1}]\\to B$ , there should be an <code>is_localization</code> predicate for maps $A\\to A'$ and a theorem about maps $A'\\to B$ when that predicate is satisfied.</p>",
        "id": 155097440,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547484622
    },
    {
        "content": "<p>I don't quite understand this yet, but I'd like to [NB <code>$$ A\\to A'$$</code>for maths mode on Zulip]. Currently given a commutative ring <code>A</code> and a submonoid <code>S</code> of <code>A</code> we have some localisation type <code>loc A S</code>plus a proof it's a ring, and the universal property theorems. </p>\n<p>This approach gave me trouble. I was a Lean amateur at the time. I wanted to prove things like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mo>]</mo><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>g</mi><mo>]</mo><mo>=</mo><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mi>g</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/f][1/g]=A[1/fg]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span><span class=\"mrel\">=</span><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span> (that's the mathematician's \"=\" there -- \"canonical isomorphism\" if you'd rather) from the universal property and if I remember correctly there was a lot of kerfuffle. See <a href=\"https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230\">https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L230</a> for example.  In fact <a href=\"https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288\" target=\"_blank\" title=\"https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288\">https://github.com/kbuzzard/lean-stacks-project/blob/ad816148cd9292f9205efd2674e180418d2680ec/src/localization_UMP.lean#L288</a> was even worse -- I briefly explain what I was trying to do in the comments above. I was hoping <span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernandez Mir</span> would refactor all this, this month.</p>\n<p>Is the idea instead that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mrel\">:</span><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">S\\subseteq A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\">A</span></span></span></span> then we have a predicate which mathematically means that the induced <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-algebra structure on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span>?</p>",
        "id": 155100374,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547486848
    },
    {
        "content": "<p>Compare with <a href=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382\">https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L379-L382</a> and how it appears in different statements, including <a href=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934\">https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/continuity.lean#L934</a>  but not only</p>",
        "id": 155110131,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547494645
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">ideals</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">quotient</span> <span class=\"o\">(</span><span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">span</span> <span class=\"o\">({</span><span class=\"n\">n</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"bp\">ℤ</span><span class=\"o\">))</span> <span class=\"err\">≃</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">lift_on&#39;</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">⟨</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"err\">%</span><span class=\"n\">n</span><span class=\"o\">),</span>\n      <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_lt</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">$</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod_nonneg</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_ne_zero</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">))]</span><span class=\"bp\">;</span> <span class=\"n\">exact</span>\n      <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod_lt_of_pos</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_pos</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"err\">$</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pos_of_ne_zero</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">⟩</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n    <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span> <span class=\"n\">j</span> <span class=\"n\">hij</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">hk</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">mem_span_singleton</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hij</span> <span class=\"k\">in</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">eq_of_veq</span> <span class=\"err\">$</span> <span class=\"k\">show</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n      <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">eq_add_of_sub_eq</span> <span class=\"n\">hk</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">add_mul_mod_self_left</span><span class=\"o\">]),</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">induction_on&#39;</span> <span class=\"n\">x</span> <span class=\"err\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">quotient</span><span class=\"bp\">.</span><span class=\"n\">sound&#39;</span> <span class=\"err\">$</span> <span class=\"n\">ideal</span><span class=\"bp\">.</span><span class=\"n\">mem_span_singleton&#39;</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"n\">i</span><span class=\"err\">%</span><span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">-</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs_of_nonneg</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod_nonneg</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_ne_zero</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">h</span><span class=\"o\">)),</span>\n      <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod_def</span><span class=\"o\">,</span> <span class=\"n\">sub_sub</span><span class=\"o\">,</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span> <span class=\"n\">sub_add_eq_sub_sub</span><span class=\"o\">,</span> <span class=\"n\">sub_self</span><span class=\"o\">,</span> <span class=\"n\">zero_sub</span><span class=\"o\">,</span> <span class=\"n\">neg_mul_eq_mul_neg</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span><span class=\"o\">]</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">fin</span><span class=\"bp\">.</span><span class=\"n\">eq_of_veq</span> <span class=\"err\">$</span> <span class=\"k\">show</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs</span> <span class=\"o\">(</span><span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"err\">%</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_mod</span><span class=\"o\">,</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">nat_abs_of_nat</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">mod_eq_of_lt</span> <span class=\"n\">k</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 155121156,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547501728
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, this is the idea. Something just like it came up during the mathlib maintenance discussion at lean together, where we had an equality theorem <code>quotient (separation_setoid A) = (\\bot : ideal A).quotient</code>, IIRC. If we could say that something is a quotient rather than having a quotient construction, then this typal equality could be avoided</p>",
        "id": 155132489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547511456
    },
    {
        "content": "<p>Topology already has the notion of a \"quotient map\" that is already performing this exact thing, we just need to extend it to quotient maps of rings, groups, etc, as well as localization maps and maps for other kinds of constructions</p>",
        "id": 155132583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547511531
    },
    {
        "content": "<p>Of course we still want the construction - it's no good having theorems about quotient maps if we can't prove they exist - but being able to quantify over things isomorphic to a particular construction is actually a really powerful way to avoid DTT hell</p>",
        "id": 155132712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547511607
    },
    {
        "content": "<p>I think we've also talked about having a <code>euclidean_space A</code> typeclass that basically means \"isomorphic to R^n\" which seems silly but is useful for exactly this kind of thing - you don't want to build in a dependence on the precise way a type is constructed</p>",
        "id": 155132787,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547511685
    },
    {
        "content": "<p>Yes, this is exactly why I posted the cryptic link in my previous message in this thread.</p>",
        "id": 155152420,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547539186
    },
    {
        "content": "<p>And I wanted to mention this <code>quotient (separation_setoid A) = (\\bot : ideal A).quotient</code> (which is <a href=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/quotient_topological_structures.lean#L189\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/19e7b1f574d813b9b305b41f8c0820c01bf99c84/analysis/topology/quotient_topological_structures.lean#L189\">here</a>) in my Amsterdam talk but I didn't have time. Note that I did find a workaround in the mean time, but we should still do something more systematic.</p>",
        "id": 155152528,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547539307
    },
    {
        "content": "<p>One big difference between localisations and Euclidean space is that if the <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-algebra <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> as an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-algebra then it's uniquely isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> as an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-algebra. However if a space is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi mathvariant=\"double-struck\">R</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span> as an <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">R</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span>-vector space, then there is in general more than one isomorphism, and you may or may not want to keep track of an isomorphism I guess, depending on what you're doing.</p>",
        "id": 155152826,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547539656
    },
    {
        "content": "<blockquote>\n<p>Is the idea instead that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mrel\">:</span><span class=\"mord mathit\">A</span><span class=\"mrel\">→</span><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">S\\subseteq A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mrel\">⊆</span><span class=\"mord mathit\">A</span></span></span></span> then we have a predicate which mathematically means that the induced <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span>-algebra structure on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span>?</p>\n</blockquote>\n<p>Aah! The penny has just dropped. Instead of the definition of the predicate being \"B is isomorphic to the A[1/S] we constructed\", it says \"B satisfies the universal property we want\". Is that the idea? We have predicates for universal properties?</p>",
        "id": 155155008,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547542830
    },
    {
        "content": "<p>Are all isomorphisms isomorphic?</p>",
        "id": 155155081,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547542933
    },
    {
        "content": "<p>but universal property is not a property... it is a function and has data right</p>",
        "id": 155155095,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547542972
    },
    {
        "content": "<p>Given f:A-&gt;B and S in A, the universal property just says that for all A -&gt; C sending S to units, there's a unique B -&gt; C making the diagram commute. Does this have data?</p>",
        "id": 155155118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547543030
    },
    {
        "content": "<p>Universal property is more than isomorphism, it's unique isomorphism.</p>",
        "id": 155155163,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547543050
    },
    {
        "content": "<p>of course this has data</p>",
        "id": 155155170,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547543068
    },
    {
        "content": "<p>?</p>",
        "id": 155155174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547543080
    },
    {
        "content": "<p>But modulo <code>choice</code> it doesn't</p>",
        "id": 155155178,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547543086
    },
    {
        "content": "<p>The data is the unique B -&gt; C that fits</p>",
        "id": 155155929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547544072
    },
    {
        "content": "<p>Right, it's constructively data but classically a property, because we also assert that it is unique</p>",
        "id": 155155952,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547544105
    },
    {
        "content": "<p>I think we really need a typeclass that is nonempty + subsingleton</p>",
        "id": 155155996,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547544124
    },
    {
        "content": "<p>and another that is inhabited+subsingleton</p>",
        "id": 155156002,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547544137
    },
    {
        "content": "<p>You can't make the map constructively unless you have an explicit inverse for your units. I am unclear about whether as a mathematician I should even care about this discussion. For sure I want something that works if I just know abstractly that something is a unit</p>",
        "id": 155156144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547544322
    },
    {
        "content": "<p>Generalising Kenny's argument one should have two definitions of unit as well -- existence of an inverse, and the inverse</p>",
        "id": 155156216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547544391
    },
    {
        "content": "<blockquote>\n<p>Generalising Kenny's argument one should have two definitions of unit as well -- existence of an inverse, and the inverse</p>\n</blockquote>\n<p>We do... there is <code>units</code> and <code>is_unit</code>, if I'm not mistaken.</p>",
        "id": 155156249,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1547544465
    },
    {
        "content": "<p>Good point about needing to have an actual inverse in order to construct the induced map constructively.<br>\nThe good news is that any constructively reasonable definition will also be at least usable classically, because you can always conjure up the witness you need using <code>choice</code>. The question is what is most convenient.</p>",
        "id": 155156625,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547544877
    },
    {
        "content": "<p><code>is_unit a</code> is defined as <code>∃u:units α, a = u</code>, the other version would be with a sigma instead of an exists</p>",
        "id": 155156657,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547544918
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>Is the idea instead that if $f:A\\to B$ and $S\\subseteq A$ then we have a predicate which mathematically means that the induced $A$-algebra structure on $B$ is isomorphic to $A[1/S]$?</p>\n</blockquote>\n<p>Aah! The penny has just dropped. Instead of the definition of the predicate being \"B is isomorphic to the A[1/S] we constructed\", it says \"B satisfies the universal property we want\". Is that the idea? We have predicates for universal properties?</p>\n</blockquote>\n<p>In general this is the idea but in some cases you can also give an equivalent but more hands-on description of the predicate, e.g., R -&gt; S being a quotient map of rings can be defined either in terms of a universal property or just as a surjective map.</p>",
        "id": 155156939,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547545252
    },
    {
        "content": "<p>Another way of looking at this is that a map being of the form R -&gt; R/I is something that is either true by definition or not, while a map being a quotient map is a theorem you can <em>prove</em> using any methods at your disposal.<br>\nThe tradeoff is that it's not quite as convenient to use the quotient map hypothesis because you need to pass it to the place it is used, while Lean \"just knows\" when a ring is defined as a quotient ring.</p>",
        "id": 155157804,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547546284
    },
    {
        "content": "<p>The analogue of <code>is_surjective</code> in the localisation situation is not something I think I can write down without simply saying something like \"image of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> lands in the units, and induced map from concrete localisation is a bijection\". Is such a predicate useful?</p>",
        "id": 155159954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547548686
    },
    {
        "content": "<p>You can't directly use the universal property as the definition, because of universe issues (it can't quantify over all universes), so you have to find an \"internal\" characterization roughly equivalent to the construction itself</p>",
        "id": 155162195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551640
    },
    {
        "content": "<p><em>boggle</em></p>",
        "id": 155162213,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551678
    },
    {
        "content": "<p>How about \"is isomorphic to Kenny's explicit construction\" then?</p>",
        "id": 155162265,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551699
    },
    {
        "content": "<p>The <code>is_quotient </code> class could include a truncated inverse to the quotient map.</p>",
        "id": 155162268,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547551714
    },
    {
        "content": "<p>I don't even want to use universes. How about I make everything in Type?</p>",
        "id": 155162293,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551773
    },
    {
        "content": "<p>I think for localization it is something like \"there is a surjective map from A x S and some additional about it\"</p>",
        "id": 155162297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551785
    },
    {
        "content": "<p>It's much worse than that</p>",
        "id": 155162301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551801
    },
    {
        "content": "<p>It's \"it's what Kenny wrote when he defined localisation\"</p>",
        "id": 155162351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551819
    },
    {
        "content": "<p>you don't need the proofs though</p>",
        "id": 155162361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551832
    },
    {
        "content": "<p>but you probably need to spell out the equivalence relation again</p>",
        "id": 155162376,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551860
    },
    {
        "content": "<p>you may need the equivalence relation</p>",
        "id": 155162385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551867
    },
    {
        "content": "<p>but there may also be a way to characterize it via ideals or something</p>",
        "id": 155162392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551887
    },
    {
        "content": "<p>Kenny's definition of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>S</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/S]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mclose\">]</span></span></span></span> is a quotient of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">A\\times S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mbin\">×</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> by an equivalence relation.</p>",
        "id": 155162393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551890
    },
    {
        "content": "<p>so that it looks more like a universal property</p>",
        "id": 155162394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551901
    },
    {
        "content": "<p>So the predicate we need is \"it satisfies the universal property that the quotient by an equivalence relation satisfies\"</p>",
        "id": 155162441,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551931
    },
    {
        "content": "<p>that is <code>is_quotient</code> the way we are going</p>",
        "id": 155162453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547551949
    },
    {
        "content": "<p>Here <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">A\\times S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mbin\">×</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is little more than a monoid</p>",
        "id": 155162454,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547551952
    },
    {
        "content": "<p>you might also be able to get away with just maps from A -&gt; loc and S -&gt; loc since it's a ring</p>",
        "id": 155162485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547552024
    },
    {
        "content": "<p>or just what you said - a ring hom A -&gt; loc and an assertion that the image of S are units</p>",
        "id": 155162542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547552076
    },
    {
        "content": "<p>oh but you still have to say surjective using a map from A x S</p>",
        "id": 155162773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547552395
    },
    {
        "content": "<p>If you have that situation, and <code>(s₁ * r₂ - s₂ * r₁) * t = 0</code> where <code>t \\in S</code>, then mapping across <code>f : A -&gt; loc</code>, you have <code>(f s₁ * f r₂ - f s₂ * f r₁) * f t = 0</code> and <code>f t</code> is invertible so <code>f s₁ * f r₂ = f s₂ * f r₁</code>, and <code>f s₁</code> and <code>f s₂</code> are invertible so <code>f r₁ / f s₁ = f r₂ / f s₂</code>. So this direction is already provable. The other direction can be asserted: if <code>f r₁ / f s₁ = f r₂ / f s₂</code> then there exists <code>t \\in S</code> such that <code>(s₁ * r₂ - s₂ * r₁) * t = 0</code></p>",
        "id": 155163051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547552745
    },
    {
        "content": "<p>I have put some stuff about localization at <br>\n<a href=\"https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean\" target=\"_blank\" title=\"https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean\">https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization.lean</a><br>\nIt is not finished, but I would be interested in comments on the general architecture.<br>\nThe idea is to set things up so that you can make computable maps out of a localisation <br>\nif you have enough data, and you can make non-computable maps if you only have<br>\nexistence statements, and as much stuff as possible is shared between the two cases.</p>",
        "id": 155179691,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547567352
    },
    {
        "content": "<p>So in your definition of <code>is_localization</code> you do <em>not</em> write \"it satisfies the universal property\", you instead write down some explicit ring-theoretic criterion following Mario's suggestion that such a criterion should exist.</p>",
        "id": 155182495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569198
    },
    {
        "content": "<p>Whilst I am no Lean expert, I am slightly worried about lines 102-120 because you are defining data in tactic mode, and I think that data constructed in this way usually turns out to be very unwieldy because tactic mode was not really designed for this. Possibly.</p>",
        "id": 155182632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569268
    },
    {
        "content": "<p>This is totally fake tactic mode, it could be rewritten as a term without any effort.</p>",
        "id": 155182775,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547569366
    },
    {
        "content": "<p>I think it also means that writing it as Neil did should be harmless</p>",
        "id": 155182791,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547569381
    },
    {
        "content": "<p>I totally agree that it's fake tactic mode. I was less sure than you about whether writing it as Neil did would be harmless.</p>",
        "id": 155182932,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569464
    },
    {
        "content": "<p>I checked the maths and it seems to me that this does indeed characterise rings isomorphic to the localisation.</p>",
        "id": 155182978,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569497
    },
    {
        "content": "<p>I am still a bit unclear as to why one can't just write \"it satisfies the universal property\", but I've seen this sort of thing be problematic before.</p>",
        "id": 155183026,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569534
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">submonoid_ann</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_submonoid</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">as</span> <span class=\"o\">:</span> <span class=\"n\">ann_aux</span> <span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">as</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">ann_aux</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">S</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">ea0</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">eb0</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">ann_aux</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"n\">S</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">ea0</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">eb0</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"bp\">_</span> <span class=\"bp\">⟨⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">eb0</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">ann_aux</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">S</span> <span class=\"n\">a</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">eb0</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"k\">begin</span> <span class=\"n\">rw</span> <span class=\"n\">ann_aux</span><span class=\"bp\">.</span><span class=\"n\">smul</span><span class=\"o\">,</span><span class=\"n\">refl</span><span class=\"o\">,</span><span class=\"kn\">end</span><span class=\"bp\">⟩</span>\n<span class=\"o\">}</span>\n</pre></div>",
        "id": 155183133,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569600
    },
    {
        "content": "<p>Oh, everything other than <code>carrier</code> is a prop anyway, so i'm really fussing about nothing.</p>",
        "id": 155183311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547569761
    },
    {
        "content": "<p>By the way, regarding getting this <code>is_localization</code> information around, it can easily be a typeclass (with a not so interesting search problem) and so get this data to where it needs to be</p>",
        "id": 155183871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547570180
    },
    {
        "content": "<p>Note that <code>has_denom_data</code> is a bit problematic because it is not a subsingleton</p>",
        "id": 155184036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547570313
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_localization_initial</span>\n <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_localization_data</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">inverts_data</span> <span class=\"n\">S</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">intro</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">e</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">gsi</span><span class=\"o\">,</span><span class=\"n\">e3</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">gsi</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Here's another place (the only other place?) where Neil uses tactics to define data.</p>",
        "id": 155184467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547570727
    },
    {
        "content": "<p>This is even more fake tactic</p>",
        "id": 155184701,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547570940
    },
    {
        "content": "<p>I hadn't heard this kind of deprecation of tactics-for-data before.  It seems to me to be a very natural translation of how I would write definitions in ordinary mathematics.  Is there something that I am missing?</p>",
        "id": 155184944,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547571132
    },
    {
        "content": "<p>tactics tend to produce ugly proof terms, which is fine for proofs (well not really, but that's another discussion) and causes problems for defs, because defs are later unfolded and their definitions matter</p>",
        "id": 155185025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547571224
    },
    {
        "content": "<p>Some tactics are fine and produce exactly what you expect, like <code>exact</code> and <code>intro</code>, while things like <code>rw</code> and <code>simp</code> are hell to work with</p>",
        "id": 155185094,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547571267
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_localization_initial&#39;</span>\n <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_localization_data</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">inverts_data</span> <span class=\"n\">S</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n</pre></div>\n\n\n<p>This is what I would have written. But I don't understand things well enough to know whether it makes a difference.</p>",
        "id": 155185103,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547571282
    },
    {
        "content": "<p>Because Neil only used <code>intro</code>, <code>rcases</code> and <code>exact</code> maybe it doesn't matter.</p>",
        "id": 155185125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547571317
    },
    {
        "content": "<p><code>rcases</code> and <code>cases</code> will use the corresponding <code>cases_on</code> recursor, which is sometimes what you want and sometimes not. We often prefer to use projections when applicable, as in Kevin's version</p>",
        "id": 155185196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547571367
    },
    {
        "content": "<p>Neil -- the bottom line is that the sorries you have at the end of the file -- if they are easier to fill in using my suggestion then this is why my suggestion is better, and if they aren't then I'm talking nonsense :-)</p>",
        "id": 155185251,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547571429
    },
    {
        "content": "<p>You could also use <code>let ⟨⟨s,a⟩,e⟩ := hf.has_denom b in ...</code> in place of the <code>rcases</code> application, which is more or less the same but produces an auxiliary definition that you can unfold on command. Sometimes this is good, sometimes not</p>",
        "id": 155185363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547571509
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_localization_initial</span>\n <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_localization_data</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">inverts_data</span> <span class=\"n\">S</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"k\">let</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">e</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n         <span class=\"bp\">⟨</span><span class=\"n\">gsi</span><span class=\"o\">,</span><span class=\"n\">e3</span><span class=\"bp\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hg</span> <span class=\"n\">s</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">gsi</span>\n</pre></div>",
        "id": 155185377,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547571528
    },
    {
        "content": "<p>Arg, Mario was faster</p>",
        "id": 155185387,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547571535
    },
    {
        "content": "<p><code>set_option eqn_compiler.zeta true</code></p>",
        "id": 155185412,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547571558
    },
    {
        "content": "<p>You can also put underscores instead of creating names you won't use</p>",
        "id": 155185527,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547571627
    },
    {
        "content": "<p>My definition unfolds to <code> g (((hf.has_denom b).val).snd) * (hg (((hf.has_denom b).val).fst)).val</code>, Neil's to</p>\n<div class=\"codehilite\"><pre><span></span>subtype.cases_on (hf.has_denom b)\n    (λ (val : ↥S × A) (e : f ↑(val.fst) * b = f (val.snd)),\n       prod.cases_on val\n         (λ (s : ↥S) (a : A) (e : f ↑((s, a).fst) * b = f ((s, a).snd)),\n            subtype.cases_on (hg s) (λ (gsi : C) (e3 : g ↑s * gsi = 1), g a * gsi))\n         e)\n</pre></div>",
        "id": 155185627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547571714
    },
    {
        "content": "<p>Patrick's becomes </p>\n<div class=\"codehilite\"><pre><span></span> <span class=\"n\">is_localization_initial</span><span class=\"bp\">._</span><span class=\"n\">match_2</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">hg</span> <span class=\"n\">b</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>and <code>is_localization_initial._match_2</code> becomes </p>\n<div class=\"codehilite\"><pre><span></span> subtype.cases_on _a\n    (λ (val : ↥S × A) (property : f ↑(val.fst) * b = f (val.snd)),\n       prod.cases_on val\n         (λ (val_fst : ↥S) (val_snd : A) (property : f ↑((val_fst, val_snd).fst) * b = f ((val_fst, val_snd).snd)),\n            id_rhs C (is_localization_initial&#39;&#39;._match_1 S g val_fst val_snd (hg val_fst)))\n         property)\n</pre></div>",
        "id": 155185828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547571869
    },
    {
        "content": "<p>What about the defeq equivalence classes?</p>",
        "id": 155186036,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547572049
    },
    {
        "content": "<p>Patrick's and Neil's definitions should be defeq, but Kevin's is different</p>",
        "id": 155186066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572074
    },
    {
        "content": "<p>So I have some visible instances of <code>cases_on</code> and you don't.  My guess is that the framework for structures effectively defines  <code>fst</code> and <code>snd</code> in terms of <code>cases_on</code>.  But perhaps that's wrong.  And even if it's right, perhaps it is somehow better to bury the call to <code>cases_on</code> deeper down.  I don't feel that I understand the issues very well here.</p>",
        "id": 155186115,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547572084
    },
    {
        "content": "<p>Me neither, that's why I brought it up here.</p>",
        "id": 155186134,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547572108
    },
    {
        "content": "<p>Technically the projections are defined in terms of cases_on, but they are buried really deep and lean has special support for them</p>",
        "id": 155186162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572143
    },
    {
        "content": "<p>The <code>rcases</code> tactic is getting from <code>&lt;b,c&gt;</code> to <code>b</code> and <code>c</code> using <code>cases_on</code>, whereas my direct approach is going from <code>a:=&lt;b,c&gt;</code> to <code>b</code> using <code>a.1</code>. But you're saying that <code>a.1</code> is defined using <code>cases_on</code> anyway?</p>",
        "id": 155186224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547572199
    },
    {
        "content": "<p>But it is useful to do the cases late rather than at the beginning because then you can prove things about the shape of the expression even when it's not a pair or whatever</p>",
        "id": 155186273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572203
    },
    {
        "content": "<p>To take a simpler example, we've discussed the difference between the definitions </p>\n<div class=\"codehilite\"><pre><span></span>prod.map (f : A -&gt; C) (g : B -&gt; D) : A x B -&gt; C x D | &lt;a, b&gt; := &lt;f a, g b&gt;\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span>prod.map (f : A -&gt; C) (g : B -&gt; D) : A x B -&gt; C x D := \\lam p : A x B, &lt;f p.1, g p.2&gt;\n</pre></div>",
        "id": 155186357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572286
    },
    {
        "content": "<p>The advantage of the second definition is that <code>prod.map f g p</code> already unfolds to a pair, while the first definition does not</p>",
        "id": 155186509,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572388
    },
    {
        "content": "<p>In both cases <code>prod.map f g &lt;a, b&gt; = &lt;f a, g b&gt;</code> is definitional</p>",
        "id": 155186541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572414
    },
    {
        "content": "<p>So as an application <code>(prod.map f g p).1 = f p.1</code> is definitional only with the second definition</p>",
        "id": 155186643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547572498
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">is_localization_data</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ring_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"o\">:</span> <span class=\"n\">inverts_data</span> <span class=\"n\">S</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"n\">is_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">is_localization_initial</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"n\">hf</span> <span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_one</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">is_localization_initial</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"o\">(</span><span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">has_denom</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">s</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">h</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">f</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_one</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">hg</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">s</span> <span class=\"err\">∈</span> <span class=\"n\">ker</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"k\">show</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_sub</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">sub_self</span><span class=\"o\">,</span>\n    <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">this</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:=</span> <span class=\"n\">hf</span><span class=\"bp\">.</span><span class=\"n\">ker_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h4</span> <span class=\"n\">at</span> <span class=\"n\">h3</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">h3</span> <span class=\"k\">with</span> <span class=\"n\">t</span> <span class=\"n\">Ht</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"bp\">⟨⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">t</span><span class=\"bp\">⟩</span><span class=\"o\">,</span><span class=\"n\">h5</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">-</span> <span class=\"n\">s</span> <span class=\"n\">at</span> <span class=\"n\">Ht</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"n\">at</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">Ht</span> <span class=\"n\">at</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sub_mul</span> <span class=\"n\">at</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sub_eq_zero</span> <span class=\"n\">at</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h6</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">t</span><span class=\"o\">),</span>\n      <span class=\"n\">rw</span> <span class=\"n\">h5</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"n\">g</span> <span class=\"n\">at</span> <span class=\"n\">h6</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">is_ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"n\">g</span> <span class=\"n\">at</span> <span class=\"n\">h6</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">hg</span> <span class=\"n\">t</span> <span class=\"k\">with</span> <span class=\"bp\">⟨</span><span class=\"n\">u</span><span class=\"o\">,</span><span class=\"n\">hu</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"k\">calc</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">mul_one</span>\n    <span class=\"bp\">...</span>      <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">hu</span>\n    <span class=\"bp\">...</span>      <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span>\n    <span class=\"bp\">...</span>      <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"n\">g</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">u</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">h6</span>\n    <span class=\"bp\">...</span>      <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">mul_assoc</span>\n    <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hu</span><span class=\"o\">,</span><span class=\"n\">mul_one</span><span class=\"o\">]</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n<span class=\"bp\">...</span>\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> can you do any better?</p>",
        "id": 155188586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547574206
    },
    {
        "content": "<p>My bet: yes.</p>",
        "id": 155188663,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547574250
    },
    {
        "content": "<p>I wondered whether he would just answer \"yes\" and leave it at that :-)</p>",
        "id": 155188685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547574267
    },
    {
        "content": "<blockquote>\n<p>Technically the projections are defined in terms of cases_on, but they are buried really deep and lean has special support for them</p>\n</blockquote>\n<p>Why doesn't this work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span> <span class=\"c1\">-- doesn&#39;t work</span>\n</pre></div>",
        "id": 155188753,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547574330
    },
    {
        "content": "<p>The question boils down to proving that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)=f(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">g(a)=g(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span>, which looks suspicious until you realise that we know something about the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, namely that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>s</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">t(a-s)=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">t</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mbin\">−</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">0</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>t</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">t\\in S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\">t</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>; the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">g(t)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">t</span><span class=\"mclose\">)</span></span></span></span> is also a unit is what gets us home.</p>",
        "id": 155188758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547574337
    },
    {
        "content": "<p>Actually I think Kenny would far rather refactor my proof than write his own.</p>",
        "id": 155188921,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547574462
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Lean has two type checkers: the kernel and the type context.  The kernel is the small low-level one, and the type context is the high-level one used for tactics, etc., which also supports unification, type class inference, etc.  The kernel only does the final check when you add a theorem to the environment.  Now, the kernel knows that prod.fst is defined in terms of rec, but the type context pretends projections are opaque definitions that only reduce when applied to the <code>mk</code> constructor.  With a bit of creativity (i.e., circumventing the type context), you can still prove your example using just rfl:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">run_cmd</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">add_decl</span> <span class=\"err\">$</span> <span class=\"n\">declaration</span><span class=\"bp\">.</span><span class=\"n\">thm</span> <span class=\"bp\">`</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst_def</span> <span class=\"o\">[]</span>\n    <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"bp\">=</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">rec</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n    <span class=\"o\">(</span><span class=\"n\">pure</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">))</span>\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">refl_lemma</span><span class=\"o\">]</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst_def</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst_def</span>\n</pre></div>",
        "id": 155190260,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1547575561
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> mwe?</p>",
        "id": 155190559,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547575809
    },
    {
        "content": "<p>Ramon and me just isolated a lemma, and we now know how to prove <code>is_ring_hom (is_localization_initial S f hf g hg)</code></p>",
        "id": 155190610,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547575865
    },
    {
        "content": "<p>The lemma is that if <code>is_localization_data S f</code> and <code>inverts_data S g</code> then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>b</mi><mo>)</mo><mspace width=\"0.277778em\"></mspace><mo>⟹</mo><mspace width=\"0.277778em\"></mspace><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">f(a)=f(b)\\implies g(a)=g(b)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathit\">b</span><span class=\"mclose\">)</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟹</span></span><span class=\"mord mathit\"><span class=\"mspace thickspace\"></span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span></span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">b</span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 155191027,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547576214
    },
    {
        "content": "<p>and the proof is that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a-b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mbin\">−</span><span class=\"mord mathit\">b</span></span></span></span> is in the kernel of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> so by <code>ker_eq</code> on <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.10764em;\">f</span></span></span></span> we know <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">s(a-b)=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">s</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mbin\">−</span><span class=\"mord mathit\">b</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">0</span></span></span></span> for some <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">s\\in S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"base\"><span class=\"mord mathit\">s</span><span class=\"mrel\">∈</span><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span></span></span></span>; hence <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>s</mi><mi>a</mi><mo>)</mo><mo>=</mo><mi>g</mi><mo>(</mo><mi>s</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">g(sa)=g(sb)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">a</span><span class=\"mclose\">)</span><span class=\"mrel\">=</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mord mathit\">b</span><span class=\"mclose\">)</span></span></span></span>, but we can cancel <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">g(s)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathit\">s</span><span class=\"mclose\">)</span></span></span></span> because of <code>inverts_data S</code></p>",
        "id": 155191153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547576297
    },
    {
        "content": "<p>Everything now follows after some algebra</p>",
        "id": 155191167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547576312
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> mwe?</p>\n</blockquote>\n<p><a href=\"https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c\">https://gist.github.com/kbuzzard/b40f8501b311ada3e42b1314f2c0426c</a></p>\n<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span>  -- what is going on here is that Neil has defined a predicate <code>is_localisation f S</code> where <code>f:A -&gt; B</code> and <code>S : set A</code>; the predicate is true iff B is isomorphic to A[1/S]. I just wanted to write the universal property (for all C, if I have h:A -&gt; C such that h(s) is invertible for all s then there's a unique B -&gt; C making the diagram commute) but Mario seems to think that there are universe issues with this approach. Neil has taken a completely different approach, noting that given f : A -&gt; B and the hypothesis that f(s) is a unit for all s in S implies that there's a map A x S - &gt;B sending (a,s) to f(a)/f(s). The claim is that B = A[1/S] in the maths sense iff this map A x S -&gt; B is surjective and the kernel of f : A -&gt; B is the a such that there's s with a*s=0. This is not proved in the file but looks OK to me -- the hypothesis gives a map A[1/S] -&gt; B, the surjectivity claim implies it's surjective, and the kernel claim implies that it's injective.</p>",
        "id": 155194135,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547578464
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernandez Mir</span> might fill in the proofs. I guess we also need that <code>A -&gt; loc A S</code> satisfies the predicate -- this might be something which would be easier for you to do.</p>",
        "id": 155194402,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547578669
    },
    {
        "content": "<p>The universal property is actually more like (forall u: universe, forall C : Type u, ...), but this predicate isn't definable in Lean, so you have to find an equivalent things that doesn't quantify over universes.</p>",
        "id": 155194489,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1547578719
    },
    {
        "content": "<p>Right -- so I just want to quantify over the universe that A and S are in.</p>",
        "id": 155194523,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547578746
    },
    {
        "content": "<p>Because that's what I do in real live maths in ZFC with no universes -- this \"stick to one universe\" approach doesn't usually cause me problems.</p>",
        "id": 155194567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547578799
    },
    {
        "content": "<p>Surely we can prove that the universal property for one universe (if chosen correctly) implies it for all universes, which is a statement we can write down because it only involves prefix quantification of universes, and we can apply it wherever needed when applying the universal property.<br>\n(The proof can be that we already constructed the localization within the original universe, so another candidate which has the universal property within that universe must be isomorphic to it, and we know the localization we constructed actually has the universal property for all universes.)</p>",
        "id": 155195578,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547579523
    },
    {
        "content": "<p>I just came here to say the same thing. What is wrong with this strategy? Somehow Neil's version seems cleaner though.</p>",
        "id": 155196737,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547580340
    },
    {
        "content": "<p>The test case would be to prove that a composition of <code>is_localization</code> maps is <code>is_localization</code></p>",
        "id": 155197181,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547580704
    },
    {
        "content": "<p>which should be easy with the universal property</p>",
        "id": 155197249,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547580752
    },
    {
        "content": "<p>Here are some basic test cases:<br>\n1. Can we identity <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><msup><mi>a</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo><mo>[</mo><msup><mi>b</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[a^{-1}][b^{-1}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mo>(</mo><mi>a</mi><mi>b</mi><msup><mo>)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[(ab)^{-1}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mopen\">(</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">b</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>?<br>\n2. If <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mi>e</mi><mn>2</mn></msup><mo>=</mo><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">e^2=e</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span></span></span></span></span><span class=\"mrel\">=</span><span class=\"mord mathit\">e</span></span></span></span>, can we identify <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[e^{-1}]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8141079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathit\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mathrm mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mi mathvariant=\"normal\">/</mi><mo>(</mo><mn>1</mn><mo>−</mo><mi>e</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">A/(1-e)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mord mathrm\">/</span><span class=\"mopen\">(</span><span class=\"mord mathrm\">1</span><span class=\"mbin\">−</span><span class=\"mord mathit\">e</span><span class=\"mclose\">)</span></span></span></span>?<br>\n3. If we define <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msub></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{(p)}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:1.04409em;vertical-align:-0.3551999999999999em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathit mtight\">p</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"></span></span></span></span></span></span></span></span> as a subring of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span>, can we produce the ring map <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi mathvariant=\"double-struck\">Z</mi><mrow><mo>(</mo><mi>p</mi><mo>)</mo></mrow></msub><mo>→</mo><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mi mathvariant=\"normal\">/</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}_{(p)}\\to\\mathbb{Z}/p</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mathit mtight\">p</span><span class=\"mclose mtight\">)</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"></span></span></span></span></span><span class=\"mrel\">→</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\">p</span></span></span></span>?<br>\nI think that all of the maps implicit in these examples should be computable under very mild assumptions.</p>",
        "id": 155197619,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547581103
    },
    {
        "content": "<p>there is nothing wrong with Reid's strategy, it's just less direct and possibly leads to worse defeqs</p>",
        "id": 155198610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547581906
    },
    {
        "content": "<p>Neil's test 1 came up a lot in the schemes repo.</p>\n<p>I guess the idea that everything should be proved constructively and then we just deduce the classical stuff from it.</p>",
        "id": 155198991,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582263
    },
    {
        "content": "<p>Yeah, if you want the constructive version then it's not as nice.</p>",
        "id": 155198995,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547582267
    },
    {
        "content": "<p>Do we care about being constructive here? At the very least I would want any constructive version to be a subsingleton like <code>fintype</code></p>",
        "id": 155199105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582339
    },
    {
        "content": "<p>also, why the sudden focus on localization? I think the quotient case is far more prevalent and pressing</p>",
        "id": 155199157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582386
    },
    {
        "content": "<p>I think the constructive version should use an indexed family rather than a set S</p>",
        "id": 155199480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582600
    },
    {
        "content": "<p>That is, <code>S</code> should be the image of a monoid hom rather than a submonoid</p>",
        "id": 155199591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582673
    },
    {
        "content": "<p>because we're refactoring the schemes repo and we had just been trying to make sense of the stuff I wrote about universal properties of localisation, that's why I jumped on this. I had arranged to meet Ramon at 4pm today and Neil's post arrived shortly beforehand so I thought it was a really good time to understand this alternative approach. I think it's beautiful!</p>",
        "id": 155199598,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582679
    },
    {
        "content": "<p>I think that S should be an arbitrary set, and we should localise at the monoid generated by S.</p>",
        "id": 155199631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582709
    },
    {
        "content": "<p>I mean that for constructive purposes you want S to be enumerated by a concrete structure (the domain of the monoid hom). Predicates have no data</p>",
        "id": 155199727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582765
    },
    {
        "content": "<p>Neil was already doing this with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo>[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>a</mi><mi>b</mi><mo>]</mo></mrow><annotation encoding=\"application/x-tex\">A[1/ab]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span><span class=\"mopen\">[</span><span class=\"mord mathrm\">1</span><span class=\"mord mathrm\">/</span><span class=\"mord mathit\">a</span><span class=\"mord mathit\">b</span><span class=\"mclose\">]</span></span></span></span> etc. When I was doing schemes I had <code>loc A S</code> and then <code>loc A (powers f)</code> came up so much that Kenny made a bunch of lemmas for it. I am now beginning to wonder whether we should be working in this generality in general.</p>",
        "id": 155199740,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582775
    },
    {
        "content": "<p>Of course for <code>powers f</code> the indexing monoid is just N</p>",
        "id": 155199766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582802
    },
    {
        "content": "<p>I think that demanding that S is a monoid is a pain, because Neil wants me to check that f(s) is invertible for all s in S, and in the case S=&lt;x&gt; I only want to check that f(x) is invertible.</p>",
        "id": 155199803,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582837
    },
    {
        "content": "<p>Sorry for over-use of f there.</p>",
        "id": 155199821,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582855
    },
    {
        "content": "<p>If S = &lt;x&gt; then the analogous monoid hom is <code>\\lam n, add_monoid.smul n x</code> (which we know is a monoid hom, I think)</p>",
        "id": 155199903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547582892
    },
    {
        "content": "<p>It also occurred to me that we could just set everything up with monoids, and then write different functions for arbitrary subsets. Mario is suggesting a different generalisation though.</p>",
        "id": 155199988,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547582959
    },
    {
        "content": "<p>I think if we actually want to do this we should forget about computation for now, or until we have an actual application</p>",
        "id": 155200767,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547583575
    },
    {
        "content": "<p>By the way, what happens in the noncommutative case? Is there anything to write down simpler than \"the map from the localization is an isomorphism\"?</p>",
        "id": 155201534,
        "sender_full_name": "Reid Barton",
        "timestamp": 1547584201
    },
    {
        "content": "<p>The real test case for localization is decimal numbers. Can mathlib handle schoolkid maths?</p>",
        "id": 155203076,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547585401
    },
    {
        "content": "<p>noncommutative fields of fractions are really complicated</p>",
        "id": 155203475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547585752
    },
    {
        "content": "<p>see <a href=\"https://en.wikipedia.org/wiki/Ore_condition\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Ore_condition\">https://en.wikipedia.org/wiki/Ore_condition</a></p>",
        "id": 155203525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1547585771
    },
    {
        "content": "<p>Eew yeah. We number theorists had to learn this stuff about a decade ago when non-commutative Iwasawa theory became a thing.</p>",
        "id": 155206004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547587744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> <a href=\"https://github.com/kckennylau/Lean/blob/master/localization_alt.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/Lean/blob/master/localization_alt.lean\">https://github.com/kckennylau/Lean/blob/master/localization_alt.lean</a></p>",
        "id": 155231190,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1547618692
    },
    {
        "content": "<p>Neil, your file has been Kennied™.</p>",
        "id": 155241502,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1547632841
    },
    {
        "content": "<p>That's great, thanks to <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> .  I am also working on a slightly different framework which I will report on later.</p>",
        "id": 155242270,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1547633675
    },
    {
        "content": "<p>Many thanks <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> ! Neil, you might either find it instructive to see how Kenny rewired your code, or intimidating, depending on how much you can make sense of it I guess. Kenny will have liked your approach because he is at heart a constructivist.</p>",
        "id": 155245575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1547637207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> I think that demanding that S is a submonoid of A is too restrictive. When I told Kenny to develop the theory of localisations of rings at multiplicative sets it was something like November 2017 and I knew nothing about Lean. I told him to assume S was multiplicative because that's what it says in the books. But I can localise A at an arbitrary subset S, just by localising at the monoid generated by S. </p>\n<p>Kenny, when I delete <code>is_submonoid S</code> your code above breaks :-)</p>",
        "id": 157621262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1549386200
    },
    {
        "content": "<p>You can see the version that I am working on sporadically at <a href=\"https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean\" target=\"_blank\" title=\"https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean\">https://github.com/NeilStrickland/lean_comm_alg/blob/master/src/localization_b.lean</a></p>\n<ul>\n<li>I did it for semirings rather than rings.  There are some applications of that kind of thing in stable homotopy theory.</li>\n<li>I have a monoid <code>S</code> with a map <code>i</code> to the multiplicative monoid of <code>R</code>, rather than a submonoid.  That's a structure that you want for log geometry anyway, and seems more natural for some other reasons as well.  </li>\n<li>We can regard <code>R × S</code> as the set of unreduced fractions.  This already has commutative and associative addition and multiplication, and the distributive laws fail in a well-controlled way.  To make everything as computable as possible, there are some advantages to setting up this structure explicitly.  So I do that.</li>\n<li>I did everything in a very bundled way.  I felt forced to do that because of some technical issue about the way that things depend on the map <code>i : S → R</code>, but I'm not sure I can reconstruct the details of that.</li>\n<li>If you want to localise with respect to something that is not a monoid, I think that it is better to do that as a separate construction layered on top of the monoid case.</li>\n</ul>\n<p>There is plenty left to do but I haven't had time to look at it for a while.  However, we will start running a working group in Sheffield next week, so I can maybe get some more people involved.</p>",
        "id": 157622801,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1549387459
    }
]
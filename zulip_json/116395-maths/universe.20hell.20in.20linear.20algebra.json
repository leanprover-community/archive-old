[
    {
        "content": "<p>Is there a user guide to universe hell fighting in linear algebra? For instance:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span>  <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n           <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n\n<span class=\"kn\">lemma</span> <span class=\"n\">le_of_linear_independent</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">K</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">findim</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 206269534,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596813345
    },
    {
        "content": "<p>It looks like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_dimensional.fintype_card_le_findim_of_linear_independent\">docs#finite_dimensional.fintype_card_le_findim_of_linear_independent</a> would help but it assumes the indexing type is in the same universe as the vector space.</p>",
        "id": 206269685,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596813402
    },
    {
        "content": "<p>what hell?</p>",
        "id": 206271656,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596814403
    },
    {
        "content": "<p>I don't see anything troubling in this snippet</p>",
        "id": 206271683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596814417
    },
    {
        "content": "<p>The trouble is in the proof.</p>",
        "id": 206271697,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596814429
    },
    {
        "content": "<p>Because <code>fin n</code> and <code>V</code> live in different universes, you cannot apply the lemma I linked to.</p>",
        "id": 206271770,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596814456
    },
    {
        "content": "<p>The lemma has the note</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">-- Note here we&#39;ve restricted the universe levels of `ι` and `V` to be the same, for convenience.</span>\n</code></pre></div>\n\n\n<p>I think generalizing this lemma to arbitrary universe levels is a better use of time than writing a user guide to work around it.</p>",
        "id": 206271941,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596814551
    },
    {
        "content": "<p>For whose convenience?</p>",
        "id": 206272021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596814577
    },
    {
        "content": "<p>The prover of the lemma, presumably.</p>",
        "id": 206272037,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596814589
    },
    {
        "content": "<p>My question is: how to prove a general version of such lemmas where it's convenient to assume universe equalities?</p>",
        "id": 206272101,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596814629
    },
    {
        "content": "<p>after you have proven the lemma, apply it to <code>ulift \\i</code> and <code>ulift V</code>, and then massage the statement along equivalences to get it for <code>\\i</code> and <code>V</code>.</p>\n<p>This assumes you have proven that every component of the (statement of the) lemma is invariant under equivalences.</p>",
        "id": 206272248,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596814693
    },
    {
        "content": "<p>Mario, what Floris wrote is what I called universe hell.</p>",
        "id": 206272358,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596814749
    },
    {
        "content": "<p>Alternatively, just use the theorem that talks about <code>lift (mk A)</code> instead of <code>mk A</code> when using the cardinal library</p>",
        "id": 206272367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596814753
    },
    {
        "content": "<p>the proof is exactly as long, you just use different lemmas</p>",
        "id": 206272390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596814765
    },
    {
        "content": "<p>This sounds promising.</p>",
        "id": 206272627,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596814867
    },
    {
        "content": "<p>Except I have no idea how to turn it into Lean code.</p>",
        "id": 206273124,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596815099
    },
    {
        "content": "<p>I'm working on it</p>",
        "id": 206273145,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596815107
    },
    {
        "content": "<p>Thanks a lot!</p>",
        "id": 206273156,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596815113
    },
    {
        "content": "<p>I think the <code>fintype.card</code> library is not as consistent as the <code>cardinal</code> library, but there is <code>fintype.​card_ulift</code> which requires one more step.</p>",
        "id": 206273206,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596815144
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"kn\">variables</span>  <span class=\"o\">{</span><span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n           <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finite_dimensional</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">down</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"bp\">⟩</span> <span class=\"bp\">⟨</span><span class=\"n\">y</span><span class=\"bp\">⟩</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">h</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">le_of_linear_independent</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">K</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"bp\">≤</span> <span class=\"n\">findim</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"k\">have</span> <span class=\"o\">:</span> <span class=\"n\">linear_independent</span> <span class=\"n\">K</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"err\">∘</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n    <span class=\"n\">linear_independent</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">h</span> <span class=\"bp\">_</span> <span class=\"n\">ulift</span><span class=\"bp\">.</span><span class=\"n\">down</span><span class=\"bp\">.</span><span class=\"n\">injective</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">fintype_card_le_findim_of_linear_independent</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206274529,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596815778
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3721\">#3721</a></p>",
        "id": 206276520,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596816760
    },
    {
        "content": "<p>Floris's suggestion is good for when you don't want to change the library, but it is better in this case to just already have the universe generalized versions of all the lemmas</p>",
        "id": 206276607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596816805
    },
    {
        "content": "<p>Sure. Thank you very much to both of you anyway.</p>",
        "id": 206276654,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596816836
    },
    {
        "content": "<p>Patrick -- come back to <code>Type</code>! All your universe problems will melt away!</p>",
        "id": 206279600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596818209
    },
    {
        "content": "<p>I think in this topic I've learned something opposite to <a href=\"#narrow/stream/113488-general/topic/Deterministic.20timeout.20for.20class.20definition/near/205055878\">the other topic</a>:</p>\n<p>Even if we can put the universe issue aside at the beginning, one day we'll have to come back to give it a proper treatment.</p>\n<p>This topic provides two methods to deal with the situation, both seem not costly, but both are hard to decipher, especially the changes in <a href=\"https://github.com/leanprover-community/mathlib/issues/3721\">#3721</a> look totally random, I'm seeing the <code>'</code>s on <code>u v w</code>, <code>Type*</code>, <code>lemma {m}</code>, <code>_</code>s and <code>max</code>s, and have no idea how the universes are arranged and by any chance <code>u</code> and <code>u'</code> (for example), <code>m</code> and others, <code>*</code> and others are related in the arrangement. There's so much magic in one page...</p>",
        "id": 206337734,
        "sender_full_name": "Utensil Song",
        "timestamp": 1596873970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206272248\">said</a>:</p>\n<blockquote>\n<p>after you have proven the lemma, apply it to <code>ulift \\i</code> and <code>ulift V</code>, and then massage the statement along equivalences to get it for <code>\\i</code> and <code>V</code>.</p>\n<p>This assumes you have proven that every component of the (statement of the) lemma is invariant under equivalences.</p>\n</blockquote>\n<p>The massage seems to have a pattern, is turning this into a reusable tactic possible?</p>",
        "id": 206337847,
        "sender_full_name": "Utensil Song",
        "timestamp": 1596874215
    },
    {
        "content": "<p>I have a variation on universe issues in linear algebras:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">fintype</span> <span class=\"n\">ι</span>\n</code></pre></div>\n\n\n<p>the universe issue is hidden a bit, but not much since there are cardinals involved.</p>",
        "id": 206398488,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596985226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> do you have a magic trick here?</p>",
        "id": 206406837,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596998534
    },
    {
        "content": "<p>what's the context?</p>",
        "id": 206406859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596998610
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span>  <span class=\"n\">fintype</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 206406985,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596998782
    },
    {
        "content": "<p>This is a combination of handling universes in cardinals and fighting <code>fintype</code></p>",
        "id": 206406994,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596998823
    },
    {
        "content": "<p>I didn't have any universe issues in the proof:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">finite_dimensional</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">K</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">is_basis</span> <span class=\"n\">K</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">lt_omega_iff_fintype</span><span class=\"o\">,</span> <span class=\"err\">←</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">findim_eq_card_basis&#39;</span> <span class=\"n\">hv</span><span class=\"o\">],</span>\n  <span class=\"n\">apply</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">nat_lt_omega</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206408092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597000613
    },
    {
        "content": "<p>I'm not sure which <code>finite_dimensional</code> theorem you were intending to use</p>",
        "id": 206408099,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597000636
    },
    {
        "content": "<p>Thanks you very much Mario. I was stuck at:</p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"n\">apply</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">of_cardinal_lt</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">c1</span> <span class=\"o\">:=</span> <span class=\"n\">finite_dimensional</span><span class=\"bp\">.</span><span class=\"n\">dim_lt_omega</span> <span class=\"n\">K</span> <span class=\"n\">V</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">c2</span> <span class=\"o\">:=</span> <span class=\"n\">hv</span><span class=\"bp\">.</span><span class=\"n\">mk_eq_dim&#39;</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>(with or without the last prime) which left me with a context having all I needed but all in wrong universes. Was it possible to salvage things from there? Is there any easy explanation of why this was the wrong road? Also I would have never guessed the first line would be this <code>apply classical.choice</code> but I guess this comes from the weirdness of <code>fintype X</code> not being in <code>Prop</code>.</p>",
        "id": 206412792,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597009216
    },
    {
        "content": "<p>Would you mind having</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">of_cardinal_lt</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">α</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">omega</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"err\">$</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">lt_omega_iff_fintype</span><span class=\"bp\">.</span><span class=\"n\">mp</span> <span class=\"n\">h</span>\n</code></pre></div>\n\n\n<p>PRed?</p>",
        "id": 206412854,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597009382
    },
    {
        "content": "<p>I makes your proof a lot less puzzling.</p>",
        "id": 206412904,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597009460
    },
    {
        "content": "<p>I have yet another example of  \"<code>fintype</code> is data\" fun:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">card</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n\n<span class=\"kn\">example</span>  <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span>\n<span class=\"c1\">--  [fintype (fin n ⊕ ι)]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"err\">⊕</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span>\n  <span class=\"o\">:</span> <span class=\"err\">∑</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"n\">n</span> <span class=\"err\">⊕</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">fintype</span><span class=\"bp\">.</span><span class=\"n\">sum_sum_type</span><span class=\"o\">,</span>\n  <span class=\"n\">admit</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>\n\n\n<p>Uncomment the commented line to see the rewrite failing. Something is really wrong in this whole <code>fintype</code> setup...</p>",
        "id": 206415137,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013416
    },
    {
        "content": "<p>why is that a reasonable thing to do? That's like having two <code>group</code> instances</p>",
        "id": 206415206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013556
    },
    {
        "content": "<p>In this case the second fintype can clearly be inferred from the first</p>",
        "id": 206415210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013574
    },
    {
        "content": "<p>The sum does not depend on the <code>fintype</code> instance.</p>",
        "id": 206415220,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013596
    },
    {
        "content": "<p>In my real example, the commented instance was used to build the uncommented one, not the other way around.</p>",
        "id": 206415224,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013624
    },
    {
        "content": "<p>I'm not saying that <code>fintype</code> is useless, I can totally believe it can be useful for programming or constructive mathematics, but it's not the right class for defining sums.</p>",
        "id": 206415271,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013665
    },
    {
        "content": "<p>how about a sum that takes no finiteness argument and returns 0 when the input function is not finitely supported</p>",
        "id": 206415352,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013796
    },
    {
        "content": "<p>I sometimes dreams about that, but I fear this will be very confusing where you think about converging series.</p>",
        "id": 206415358,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013827
    },
    {
        "content": "<p>We already have <code>tsum</code> for infinite series</p>",
        "id": 206415363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013842
    },
    {
        "content": "<p>Because such series would have a vanishing sum.</p>",
        "id": 206415365,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013849
    },
    {
        "content": "<p>Whatever this new sum is it has to work without a topology</p>",
        "id": 206415367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013860
    },
    {
        "content": "<p>But maybe this would still be better than the current situation.</p>",
        "id": 206415371,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597013873
    },
    {
        "content": "<p>(or equivalently, the discrete topology, where convergence of the infinite sum means that it is finitely supported)</p>",
        "id": 206415412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597013904
    },
    {
        "content": "<p>we can't really get rid of the existing theory of finset sums, those are still true and applicable for their domain, but we can take the notation and apply it to a different constant</p>",
        "id": 206415507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014058
    },
    {
        "content": "<p>of course, it's already a localized notation so it doesn't even have to conflict with the existing development</p>",
        "id": 206415516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014094
    },
    {
        "content": "<p>Proposal:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">finsupp</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"k\">if</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f&#39;</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span><span class=\"err\">₀</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">f&#39;</span> <span class=\"k\">then</span> <span class=\"o\">(</span><span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">some</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">finsum_in</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"n\">finsum</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"k\">then</span> <span class=\"n\">f</span> <span class=\"n\">i</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"n\">localized</span> <span class=\"s2\">&quot;notation `∑` binders `, ` r:(scoped:67 f, finsum f) := r&quot;</span> <span class=\"k\">in</span> <span class=\"n\">finsum</span>\n<span class=\"n\">localized</span> <span class=\"s2\">&quot;notation `∑` binders ` in ` s `, ` r:(scoped:67 f, finsum_in s f) := r&quot;</span> <span class=\"k\">in</span> <span class=\"n\">finsum</span>\n</code></pre></div>",
        "id": 206415746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014528
    },
    {
        "content": "<p>Yes, we should probably have something like that. But the next question is: can we avoid duplicating the whole API?</p>",
        "id": 206415849,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597014714
    },
    {
        "content": "<p>that's sort of the cost of doing business. The theorems aren't the same, so it's mostly a question of which finset sum theorems we want to forego</p>",
        "id": 206415979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014913
    },
    {
        "content": "<p>I imagine that most theorems that aren't in the <code>big_operators</code> file can just change to the new sum without being duplicated, but the old API itself still has to stay mostly intact</p>",
        "id": 206416033,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014981
    },
    {
        "content": "<p>one obvious reason being that the definition I just gave uses <code>finsupp</code>, which uses finset sums to define it</p>",
        "id": 206416041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597015014
    },
    {
        "content": "<p>so it's more like another API on top of the existing one than a replacement</p>",
        "id": 206416056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597015042
    },
    {
        "content": "<p>All theorem will be there, but some of them will have finiteness assumptions. But sure, this is business.</p>",
        "id": 206416136,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597015186
    },
    {
        "content": "<p>As consolation, I think most of the proofs will be one liners</p>",
        "id": 206416202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597015233
    },
    {
        "content": "<p>but people generally can never have enough API theorems</p>",
        "id": 206416212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597015256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> your theorem about fintype (fin n + iota) is provable with the weaker hypothesis <code>nonempty (fintype iota)</code> which I think is a more useful typeclass for people like you and me</p>",
        "id": 206454390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062244
    },
    {
        "content": "<p>And nonempty (fintype (X + Y)) implies nonempty (fintype X)</p>",
        "id": 206454477,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062328
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you have done a brilliant job of making computable finiteness in Lean but we are missing API for a good noncomputable finiteness concept. I think Reid's idea of making set.finite the fundamental Prop-valued finiteness class and then bundling it with finset2 will produce a type which is easier for reasoning and which will have a noncomputable card which cant be #eval'ed but about which you can prove theorems like Sylow's theorems</p>",
        "id": 206454770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062574
    },
    {
        "content": "<p>I think there should be a typeclass which is propositional and equivalent to nonempty (fintype X)</p>",
        "id": 206454854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062613
    },
    {
        "content": "<p>I don't know whether this should be literally <code>nonempty (fintype X)</code> or whether its actual definition should be <code>finite univ</code></p>",
        "id": 206454908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062663
    },
    {
        "content": "<p>Maybe it doesn't matter as long as it's proved equivalent to nonempty fintype X</p>",
        "id": 206454939,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062694
    },
    {
        "content": "<p>Because Patrick is reasoning not computing, he should be using this Prop-valued concept of finiteness. He is in trouble because he's trying to do reasoning using the wrong typeclass</p>",
        "id": 206455037,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597062763
    },
    {
        "content": "<p>Clearly we should do something. The current setup just doesn't work for our purposes (we should probably keep it, maybe with a more specialized name since it corresponds to very specialized purposes).</p>",
        "id": 206495516,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597084223
    },
    {
        "content": "<p>I'm making an API for a class fintype2 X := nonempty (fintype X). This will at least fix the problem where I was working with finite groups and had a complicated expression involving <code>card (bot : subgroup G)</code> but I couldn't <code>rw (card_bot : card (bot) = 1)</code> because type class inference had managed to find two non-defeq proofs of fintype bot (one coming from the fact that G was finite and one indpendent of this).</p>",
        "id": 206497335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597085087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20hell.20in.20linear.20algebra/near/206454854\">said</a>:</p>\n<blockquote>\n<p>I think there should be a typeclass which is propositional and equivalent to nonempty (fintype X)</p>\n</blockquote>\n<p>Why don't we just call it <code>is_finite X</code>?</p>",
        "id": 206502388,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597087524
    },
    {
        "content": "<p>We could even eliminate <code>set.finite</code> in favor of <code>is_finite (\\u s)</code></p>",
        "id": 206502825,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597087758
    },
    {
        "content": "<p>it's always been a bit weird that <code>set.finite</code> combines these two operations (going from type to prop and then using sets instead of types) and there is no term for the intermediate operation</p>",
        "id": 206502935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597087808
    },
    {
        "content": "<p>But I also think that for all these examples of noncomputable versions of functions like <code>card</code> you would be better served getting rid of the typeclass argument entirely rather than making it propositional</p>",
        "id": 206503158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597087918
    },
    {
        "content": "<p>So for the definition of card we should dump the typeclass, but then when we're actually proving something which does need finiteness...the idea is that we put the is_finite typeclass into the theorem statement but still use the nat-valued card?</p>",
        "id": 206506174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597089548
    },
    {
        "content": "<p>I wondered if <code>finprop X</code> was good name for it, but I think the type in fintype refers to X rather than the type of the output!</p>",
        "id": 206506252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597089586
    },
    {
        "content": "<p>We could do something like rename <code>fintype</code> to <code>finenum</code> or <code>fin_bij</code>, or something that more clearly indicates it is carrying data? Not sure.</p>",
        "id": 206529556,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597106181
    }
]
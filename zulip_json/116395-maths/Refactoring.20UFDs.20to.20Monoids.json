[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> has reviewed my PR on factorization of pnats with finsupps (<a href=\"https://github.com/leanprover-community/mathlib/issues/3291\">#3291</a>), and suggested that the finsupp generalization should be made more broadly. I think this means it's time to try <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s suggestion that UFDs be refactored to revolve around a predicate on monoids, rather than rings.</p>",
        "id": 205977613,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596588019
    },
    {
        "content": "<p>One decision that'll have to be made is how to deal with the fact that a monoid may or may not have a 0 element. I'm in favor either of this kind of definition: <span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/113488-general/topic/types.20with.200.20.3D.20bot/near/202658502\">said</a>:</p>\n<blockquote>\n<p>\"all elements that are not zero-like have a unique factorization\"</p>\n</blockquote>",
        "id": 205978050,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596588631
    },
    {
        "content": "<p>or something involving enats</p>",
        "id": 205978451,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596589097
    },
    {
        "content": "<p>I've started tinkering with casework based on <code>def zerolike (x : α) : Prop := ∀ y, x * y = x</code>, starting with normalization monoids. It works, but it's a bit of a hassle.</p>",
        "id": 205987982,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596602545
    },
    {
        "content": "<p>Does anybody have any ideas as to what classes and instances would make casework on whether we're dealing with a monoid-with-zero tractable?</p>",
        "id": 205987997,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596602589
    },
    {
        "content": "<p>Perhaps a better first step is changing the divisibility relation to work for all <code>comm_monoid</code>s instead of just <code>comm_semiring</code>s. I've started working on that at <code>mathlib:divisibility_monoid</code>. Does anybody have any objection to this?</p>",
        "id": 205990491,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596606695
    },
    {
        "content": "<p>The reason i think this is the way to go is that the nonzero ideals of a Dedekind domain have unique factorisation</p>",
        "id": 205995425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596612716
    },
    {
        "content": "<p>Given a monoid with zero and a 1, and a proof that 0 isn't 1, is there a way to extract the nonzero elements as a monoid?</p>",
        "id": 205995497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596612777
    },
    {
        "content": "<p>just make a subtype</p>",
        "id": 205995866,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596613199
    },
    {
        "content": "<p><code>{x // x \\ne 0}</code> or something like that</p>",
        "id": 205995917,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1596613216
    },
    {
        "content": "<p>I could definitely put a <code>monoid</code> instance on that subtype of a <code>monoid_with_zero</code>, but I should check first to see whether it's natural to use the submonoid API</p>",
        "id": 206040403,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596643075
    },
    {
        "content": "<p>Hmm, using subtypes could again run into problems. If I just define, say, gcd on monoids without zero, and then define gcd on monoids with zero by using my definition of gcd on the subtype, then gcd's got the wrong type, and really the gcd function should be able to work with 0 just fine</p>",
        "id": 206043609,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596644419
    },
    {
        "content": "<p>I think the correct thing to do is to define the left adjoint of the forgetful functor from monoids with zero to monoids (formally adjoin a zero). Do all the constructions for monoid_with_zero, and then it will apply to a monoid by first applying this left adjoint.</p>",
        "id": 206044651,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596644979
    },
    {
        "content": "<p>(I think the construction of adjoining a zero to a monoid already exists.)</p>",
        "id": 206045020,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596645137
    },
    {
        "content": "<p>Also, in general you cannot put a monoid structure on <code>{x // x \\ne 0}</code> because the original monoid might have zero divisors.</p>",
        "id": 206048158,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596646576
    },
    {
        "content": "<p>what about the set of all non-zero-divisors?</p>",
        "id": 206048212,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596646612
    },
    {
        "content": "<p>That should be ok.</p>",
        "id": 206048460,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596646723
    },
    {
        "content": "<p>All divisibility theory stuff should perhaps be done under the running assumption that there are no zero divisors. All of this ED, PID, UFD stuff assumes integral domain, and the ideals in a Dedekind domain have no zero divisors (but have a zero). The slick definition of UFD is a monoid M0 with zero, with no zero-divisors, such that the monoid M you get by removing the zero, when quotiented out by the units, is a free monoid.</p>",
        "id": 206049097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596647002
    },
    {
        "content": "<p>Perhaps the thing to do is to create two definitions of everything, and then prove that the with-zero versions are equivalent to the zeroless versions as applied to the submonoid obtained by deleting 0 (or all 0-divisors, depending on assumptions) and transporting lemmas that way?</p>",
        "id": 206049533,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596647210
    },
    {
        "content": "<p>I don't know of any situation where mathematicians talk about unique factorisation but don't have a zero</p>",
        "id": 206050788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596647856
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Refactoring.20UFDs.20to.20Monoids/near/206049097\">said</a>:</p>\n<blockquote>\n<p>All divisibility theory stuff should perhaps be done under the running assumption that there are no zero divisors. All of this ED, PID, UFD stuff assumes integral domain, and the ideals in a Dedekind domain have no zero divisors (but have a zero). The slick definition of UFD is a monoid M0 with zero, with no zero-divisors, such that the monoid M you get by removing the zero, when quotiented out by the units, is a free monoid.</p>\n</blockquote>\n<p>Dont remove the zero, and it's even more slick -- it's a free commutative monoid_with_zero :) (after multiplicatively modding out by units)</p>",
        "id": 206050810,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596647868
    },
    {
        "content": "<p>One could argue that pnat was one, but pnat is rarely used</p>",
        "id": 206050832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596647879
    },
    {
        "content": "<p>It has bugged me for literally decades that one of the definitions of a Dedekind domain is that it's an ID where each nonzero ideal factors uniquely into prime ideals. Often people forget to say nonzero</p>",
        "id": 206051101,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596647992
    },
    {
        "content": "<p>I suspect that at least <code>gcd_domain</code> should be at least partially property of general monoids</p>",
        "id": 206051220,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596648035
    },
    {
        "content": "<p>This is something about things ordered by divisibility.</p>",
        "id": 206051323,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596648094
    },
    {
        "content": "<p>So yeah, something should be doable with monoids / monoids_with_zeros</p>",
        "id": 206051379,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596648118
    },
    {
        "content": "<p>And a factorization is, at least partially, a function from a monoid to an add_monoid which is a homomorphism except at 0 if it exists</p>",
        "id": 206051436,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596648128
    },
    {
        "content": "<p>And this particular 0 casework pops up other places, like logarithms</p>",
        "id": 206051475,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596648145
    },
    {
        "content": "<p>everything divides zero -- it's \\top in some sense.</p>",
        "id": 206051530,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596648172
    },
    {
        "content": "<p>Adam's observation also works for Dedekind domains too then, right? It's a ring whose prime ideals (pointed by 0 = the zero ideal, hence in particular must be an integral domain) generate the ideals freely as a monoid with zero</p>",
        "id": 206051538,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596648175
    },
    {
        "content": "<p>So I don’t want to hang up the refactorization of these concepts to monoids on zero, but I think it’s still worth thinking of a good solution to that casework</p>",
        "id": 206051591,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596648199
    },
    {
        "content": "<p>(And also I would rather be able to still use the stuff I wrote with pnats, but I don’t want to make everything else an awful mess in the process)</p>",
        "id": 206051718,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596648245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I guess in this case it's the free comm_monoid_with_zero on a pointed set (where the point becomes 0).</p>",
        "id": 206052074,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596648400
    },
    {
        "content": "<p>Yes, in the Dedekind domain example, and also in nat, there are no units other than 1.</p>",
        "id": 206059434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596651652
    },
    {
        "content": "<p>I've found some trouble on <code>mathlib:divisibility_monoid</code>...</p>",
        "id": 206059481,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596651672
    },
    {
        "content": "<p>I didn't think I changed anything other than what instance is required for <code>comm_semiring_has_dvd</code>, but now some places in the library, when we refer to <code>a | b</code> where <code>a b : nat</code>,  it thinks we want to be checking divisibility of <code>comm_monoid nat</code> instances instead of nats</p>",
        "id": 206059787,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596651812
    },
    {
        "content": "<p>I don't know why it'd do that if it wasn't already assuming that we were trying ask if one <code>comm_semiring nat</code> divides another...</p>",
        "id": 206060055,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596651948
    },
    {
        "content": "<p>And it's only a problem with calc-mode proofs involving pnats.</p>",
        "id": 206060659,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596652232
    },
    {
        "content": "<p>How do I see exactly what lemmas calc is using? It's definitely using some form of transitivity, etc. without explicitly mentioning them</p>",
        "id": 206060876,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596652330
    },
    {
        "content": "<p>This reminds me of the nat.pow v monoid.pow issue</p>",
        "id": 206063731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596653727
    },
    {
        "content": "<p>calc uses lemmas tagged <code>[trans]</code></p>",
        "id": 206063926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596653833
    },
    {
        "content": "<p>Hmm, the only lemma tagged <code>[trans]</code> that I would think it would use, <code>dvd_trans</code>, is just copy-pasted</p>",
        "id": 206064496,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596654129
    },
    {
        "content": "<p>and works fine when I explicitly use <code>apply</code> instead of tactics</p>",
        "id": 206064538,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596654153
    },
    {
        "content": "<p>There will be some nat.dvd_trans and monoid.dvd_trans maybe?</p>",
        "id": 206064614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596654200
    },
    {
        "content": "<p>It appears that <code>nat.dvd_trans</code> is not tagged with <code>[trans]</code>, but <code>dvd_trans</code> (the <code>comm_semiring</code> one that I switched to work with <code>comm_monoid</code>) is</p>",
        "id": 206065007,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596654401
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">ZZZ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∣</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∣</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"err\">∣</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"k\">calc</span> <span class=\"n\">a</span> <span class=\"err\">∣</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">hab</span>\n<span class=\"bp\">...</span>    <span class=\"err\">∣</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">hbc</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">ZZZ</span> <span class=\"c1\">-- dvd_trans</span>\n</code></pre></div>\n\n\n<p>Yes, it's picking up the semiring one.</p>",
        "id": 206065466,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596654662
    },
    {
        "content": "<p>Yeah, and when I copy-paste that, I get a red squiggle under the ..., with</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">dvd_trans</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">c</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">ℕ</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">comm_monoid</span> <span class=\"bp\">ℕ</span>\n</code></pre></div>",
        "id": 206066802,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596655452
    },
    {
        "content": "<p>which is weird, because <code>dvd_trans</code> seems to still work outside of <code>calc</code></p>",
        "id": 206066907,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596655533
    },
    {
        "content": "<p>oh yeah, I can reproduce</p>",
        "id": 206067042,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596655596
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">YYZ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"err\">∣</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbc</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"err\">∣</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"err\">∣</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">dvd_trans</span> <span class=\"n\">hab</span> <span class=\"n\">hbc</span>\n</code></pre></div>\n\n\n<p>works just fine</p>",
        "id": 206067073,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596655613
    },
    {
        "content": "<p>oh wow, it was the order of the implied variables in <code>divisibility.lean</code></p>",
        "id": 206068592,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596656422
    },
    {
        "content": "<p>the <code>[comm_monoid]</code> instance has to come before <code>{a b c}</code></p>",
        "id": 206068659,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596656463
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3702\">#3702</a></p>",
        "id": 206078726,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596661829
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3714\">#3714</a></p>",
        "id": 206281162,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596819020
    },
    {
        "content": "<p>In that PR, I try to make the divisibility relation work for any (noncommutative) monoid, as I realized that every instance of divisibility in <code>mathlib</code> boils down to <code>exists c, a * c = b</code>, which we might properly call right-divisibility, and <code>associated</code> already makes the choice to use right-associated as the definition in the noncommutative case.</p>",
        "id": 206285218,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596821175
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> pointed out that that could be controversial, instead of defining left- and right-divisibility separately. Does anyone object to using right-divisibility?</p>",
        "id": 206285589,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596821387
    },
    {
        "content": "<p>I think making right divisibility the default is compatible with the fact that the default multiplicative action is an action on the left. It's saying that b is in the image of the (left) multiplicative action of a.</p>",
        "id": 206286185,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596821632
    },
    {
        "content": "<p>In fact, one could define divisibility in any situation where there is a <code>mul_action</code>.</p>",
        "id": 206286617,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596821802
    },
    {
        "content": "<p>Moreover, I would like to point out: even if we later want to introduce <code>has_left_dvd</code>, this PR would be helpful in the preparations because it identifies the parts that we would need to change.</p>",
        "id": 206286902,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596821947
    },
    {
        "content": "<p>So I'm pretty much in favour of the PR, but I would like to make sure we don't make non-canonical choices lightly.</p>",
        "id": 206287078,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596822016
    },
    {
        "content": "<p>I'm not suggesting this should be changed right now, but what are your thoughts about doing something like this at some point in the future?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_dvd</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dvd</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">M</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd</span> <span class=\"n\">M</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"err\">•</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⟩</span>\n</code></pre></div>",
        "id": 206288597,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596822629
    },
    {
        "content": "<p>This would let you speak about divisible modules, and things like this.</p>",
        "id": 206288660,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596822661
    },
    {
        "content": "<p>I would appreciate the smooth syntax for divisible groups, but I’m not sure the definitional equalities between the two instances would be easy to pull off.</p>",
        "id": 206288952,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596822795
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_dvd&#39;</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">dvd</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">M</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd&#39;</span> <span class=\"n\">M</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"err\">•</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">⟩</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_dvd&#39;</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n</code></pre></div>",
        "id": 206289100,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596822860
    },
    {
        "content": "<p>Oh, it looks like this is missing from mathlib:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">mul_action</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 206289454,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823031
    },
    {
        "content": "<p>scratch that, it's <code>mul_action.regular M</code>.</p>",
        "id": 206289546,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823081
    },
    {
        "content": "<p>I guess it would have to be a different typeclass to accomodate distinct types, so there’s no danger of overriding the existing instances</p>",
        "id": 206289863,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596823205
    },
    {
        "content": "<p>The other thing you’d have to decide is if you want the <code>mul_action</code> to be inferred or explicit</p>",
        "id": 206289931,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596823238
    },
    {
        "content": "<p>And whether if it’s inferred, you make a shortcut for the same | notation</p>",
        "id": 206290001,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596823276
    },
    {
        "content": "<p>I guess you could even edit <code>has_dvd</code> in core, but that’s so vastly above my level</p>",
        "id": 206290295,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1596823391
    },
    {
        "content": "<p>this sounds like it will make the typeclass problem for divisibilty a lot more complicated</p>",
        "id": 206290377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596823423
    },
    {
        "content": "<p>Can this be solved with notation only? </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"err\">∣</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n<span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"err\">∣</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 206290737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823607
    },
    {
        "content": "<p>no, overloaded notation is not very good in lean 3</p>",
        "id": 206290775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596823632
    },
    {
        "content": "<p>I guess that's a terrible idea.</p>",
        "id": 206290777,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823633
    },
    {
        "content": "<p>unless it can be distinguished by type (and these never will be) it always just flags an ambiguity error</p>",
        "id": 206290824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596823668
    },
    {
        "content": "<p>I see.</p>",
        "id": 206290852,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823680
    },
    {
        "content": "<p>I would just suggest using a sigil of some kind on the symbol</p>",
        "id": 206290918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596823702
    },
    {
        "content": "<p><code>\\|\\_m</code> or something</p>",
        "id": 206290942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596823717
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">notation</span> <span class=\"n\">a</span> <span class=\"bp\">`</span><span class=\"err\">∣ₘ</span><span class=\"bp\">`</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 206291004,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823751
    },
    {
        "content": "<p>That's not too awful.</p>",
        "id": 206291009,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596823758
    },
    {
        "content": "<p>What strong opinions do people have about normalization and gcd domains?</p>",
        "id": 206601115,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597165426
    },
    {
        "content": "<p>I'd like to have one structure called gcd monoid that applies to all monoids (with adequate cancellation at least), which is sort of a lattice structure with different names for the operations. However, normalization monoids have a definition which depends on 0 in the ways discussed earlier.</p>",
        "id": 206601626,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597165600
    },
    {
        "content": "<p>These were things which the computable people liked and I could never see the point of. Our definition of UFD is not a Prop, which isn't the mathematical definition. Do mathematicians really any of this stuff? Why can't you just work in the quotient of the nonzero elements by the units?</p>",
        "id": 206601987,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597165769
    },
    {
        "content": "<p>Ok, we should definitely have a notion of gcd monoid/domain at least general enough to apply to euclidean domains...</p>",
        "id": 206635830,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597182852
    },
    {
        "content": "<p>I have a tentative definition of <code>gcd_monoid</code> at <code>mathlib:gcd_monoid</code></p>",
        "id": 206646417,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597190763
    },
    {
        "content": "<p>Perhaps I'm overcomplicating things, but I think this is the best way to provide a common interface for all instances of gcd:</p>",
        "id": 206845093,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597339981
    },
    {
        "content": "<p><code>gcd_monoid</code> : a mixin on <code>comm_monoid</code> that provides <code>gcd</code> and <code>lcm</code>, only guaranteed to be unique up to associated, or maybe even mutual divisibility (whatever you can guarantee for Euclidean domains)</p>",
        "id": 206845309,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597340060
    },
    {
        "content": "<p>several normalization classes:</p>",
        "id": 206845329,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597340074
    },
    {
        "content": "<ul>\n<li><code>normalization_monoid</code> : a mixin on <code>comm_monoid</code> that provides <code>normalize</code> as a <code>monoid_hom</code></li>\n<li><code>norm_unit_monoid_with_zero</code> : basically the current definition of <code>normalization_domain</code>, implies an instance of <code>normalization_monoid</code></li>\n<li><code>normalized_monoid</code> or <code>unique_unit_monoid</code> : applies to nats and pnats, implies an instance of <code>normalization_monoid</code></li>\n</ul>",
        "id": 206845621,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597340204
    },
    {
        "content": "<p>and then<br>\n<code>normalization_gcd_monoid</code> : extends <code>gcd_monoid</code> and <code>normalization_monoid</code>, is basically equivalent to <code>gcd_domain</code> right now, except it can apply to nats, pnats, and <code>associates</code>, this is where <code>coprime</code> is defined to match <code>nat.coprime</code> from core</p>",
        "id": 206845908,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597340368
    },
    {
        "content": "<p>One obnoxious thing is that for all of these, a useful monoid-theoretic property to assume is that associated is the same thing as mutual divisibility, but the proof of that is slightly different depending on whether you have a <code>comm_cancel_monoid</code> (not yet defined) or a <code>comm_cancel_monoid_with_zero</code></p>",
        "id": 206847393,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597341073
    },
    {
        "content": "<p>Mutual divisibility is the same as associated for an integral domain and anyone trying to do any kind of factoring in a non integral domain is in for a tough time</p>",
        "id": 206882262,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597360029
    },
    {
        "content": "<p>I think we should have a mathematician's UFD which is a predicate on IDs rather than one which chooses representatives for factors. This is what comes up in commutative algebra</p>",
        "id": 206882367,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597360123
    },
    {
        "content": "<p>So, there's no problem with doing it in a <code>comm_cancel_monoid_with_zero</code>, and that should let us do factorization of <code>associates</code> or ideals of a Dedekind Domain, etc.</p>",
        "id": 206882999,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597360700
    },
    {
        "content": "<p>I'm just still here months later trying to find a way to not have to duplicate the gcd API between nats and pnats</p>",
        "id": 206883055,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597360740
    },
    {
        "content": "<p>and it seems like the only solution is to have a class of commutative monoids where all elements can either be cancelled or are self-absorbing on both sides...</p>",
        "id": 206883094,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597360780
    },
    {
        "content": "<p>I've spewed out some work on <code>mathlib:gcd_monoid</code> at <code>src/algebra/gcd_monoid</code></p>",
        "id": 206885890,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597363338
    },
    {
        "content": "<p>I'm pretty sure it contains both good and bad ideas...</p>",
        "id": 206885903,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597363370
    },
    {
        "content": "<p>I have also, however, exceeded instance depth, which means I should probably get help from somebody who knows more than me...</p>",
        "id": 206886026,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597363486
    },
    {
        "content": "<p>Ok, I think I know how to reorder my priorities on this.</p>\n<ul>\n<li>Refactor normalization and gcd to be mixins on <code>comm_cancel_monoid_with_zero</code>, which is basically an Integral Domain which has forgotten addition and subtraction. This neglects Euclidean domains and pnats for now.</li>\n<li>Turn to UFD. Find non-constructive, purely multiplicative criterion for defining <code>is_UFD</code>. Currently thinking <code>atomic :=</code> every non-zero element can be written as a product of irreducibles and units, but not necessarily in some global or constructive way, together with (irreducible iff prime).</li>\n<li>Combine that definition with a <code>normalization_monoid</code> instance to get a constructive unique factorization, where all the irreducibles in the product are normalized (e.g. positive, e.g. monic)</li>\n</ul>",
        "id": 206955000,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597426048
    },
    {
        "content": "<p>Another step in there might be monoidifying <code>multiplicity</code>, as once you have a set/type of representatives of associate classes, multiplicity should give you the factorization, for the low price of proving multiplicity is finite</p>",
        "id": 206959972,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597428894
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3779\">#3779</a> monoidifies some stuff</p>",
        "id": 206983320,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597439947
    },
    {
        "content": "<p>It makes it possible to define a <code>gcd_monoid</code> instance on nats, and start merging the nat gcd API, but I don't start doing that in that PR</p>",
        "id": 206983377,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597440003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, do you have opinions on the <code>Prop</code> definition of <code>is_UFD</code>? Another potential idea is irreducible iff prime and descending chain condition for divisibility</p>",
        "id": 206984600,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1597440765
    },
    {
        "content": "<p>I'm making some progress at <code>mathlib:ufm</code>.</p>",
        "id": 207753504,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598152694
    },
    {
        "content": "<p>I've defined a class called <code>DCC_dvd</code> for monoids in which the relation <code>(λ a b : α, a ≠ 0 ∧ ∃ x, ¬is_unit x ∧ b = a * x)</code> is well-founded. I chose that definition because we've already proven that Noetherian rings satisfy that condition, but it's equivalent to <code>&lt;</code> on associates being well-founded, and it's usually called ACCP in the literature because it's equivalent to the ACC for principal ideals. All of these equivalences are trivial on paper, and seem not too bad in Lean, but aren't yet all trivial. (Would just need one lemma about relation-preserving surjections).</p>",
        "id": 207753651,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598152932
    },
    {
        "content": "<p>I've defined <code>unique_factorization_monoid</code> to be that together with <code>irreducible_iff_prime</code>, and have renamed <code>unique_factorization_domain</code> to <code>prime_factorization</code>, because that's really the data of that definition. We also have an analogous structure already called <code>unique_irreducible_factorization</code>, that contains that data, and all of these are equivalent as properties of the ring, although not definitionally.</p>",
        "id": 207753734,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598153114
    },
    {
        "content": "<p>I am going to prove that <code>unique_factorization_monoid</code> is equivalent to \"every nonzero element is a product of primes\" is equivalent to \"every nonzero element is a product of irreducibles uniquely up to units\", but should I keep the structures of <code>prime_factorization</code> and <code>unique_irreducible_factorization</code> if those proofs work without them?</p>",
        "id": 207754345,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598154279
    },
    {
        "content": "<p>Of course, I'll still provide a canonical prime/irreducible factorization for a <code>normalization_monoid</code>, but that seems like about the only condition on which a canonical one actually exists, and works for all of our important examples.</p>",
        "id": 207754481,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598154585
    },
    {
        "content": "<p>I'm certainly skeptical that we need both <code>prime_factorization</code> and <code>unique_irreducible_factorization</code>, because any time they both exist, they're provably equivalent</p>",
        "id": 207755224,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598156009
    },
    {
        "content": "<p>They might not be constructively the same, or something?</p>",
        "id": 207759644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598165409
    },
    {
        "content": "<p>Well, any time either kind of factorization exists, you can prove both that such factorizations are unique up to units, and that irreducible is equivalent to prime</p>",
        "id": 207779173,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598198125
    },
    {
        "content": "<p>Can you give a definition of a Dedekind domain as an integral domain whose nonzero ideals satisfy unique factorisation?</p>",
        "id": 207784114,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598205395
    },
    {
        "content": "<p>The definition goes via the commutative semiring of ideals</p>",
        "id": 207784125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598205428
    },
    {
        "content": "<p>Do we actually have that commutative semiring instance on the type of ideals?</p>",
        "id": 207788981,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213072
    },
    {
        "content": "<p>I think we'd need a <code>comm_cancel_monoid_with_zero</code> instance on the type of ideals. I'm not sure if the cancel part is true for all <code>comm_ring</code>s, but should be true for every <code>integral_domain</code>, I guess, and at least it's definitely true for ideals of a Dedekind domain</p>",
        "id": 207789007,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213119
    },
    {
        "content": "<p>Then you need to show what \"prime\" and possibly \"irreducible\" mean in that monoid, but \"prime\" just means prime ideal, at least for enough rings</p>",
        "id": 207789066,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213221
    },
    {
        "content": "<p>and then you need to show either that <code>irreducible_iff_prime</code>, in the monoid of ideals, or that each nonzero ideal is a product, in some way, of primes</p>",
        "id": 207789076,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213257
    },
    {
        "content": "<p>and then you should be good</p>",
        "id": 207789078,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213262
    },
    {
        "content": "<p>once I work everything out here</p>",
        "id": 207789122,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598213295
    },
    {
        "content": "<p>That's great. A lot has already been proven about the semring of ideals I believe.</p>",
        "id": 207792555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598218643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302826\">Aaron Anderson</span> <a href=\"#narrow/stream/116395-maths/topic/Refactoring.20UFDs.20to.20Monoids/near/206984600\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>, do you have opinions on the <code>Prop</code> definition of <code>is_UFD</code>? Another potential idea is irreducible iff prime and descending chain condition for divisibility</p>\n</blockquote>\n<p>Just to reply to this (very late I'm sorry, we've been seeing relatives) -- I don't have a clue about this sort of question. I don't believe that definitional equality is so important at this level -- either that or I don't understand its importance. Any Prop which is classically equivalent to being a UFD for rings and which applies to the ideals of a Dedekind domain will be fine.</p>",
        "id": 207792615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598218758
    },
    {
        "content": "<p>Ok, I'm proving 3 props are equivalent definitions, and then all data will come after that. If someone has a different preference as to which prop should be the original definition, it shouldn't be so hard to juggle everything around.</p>",
        "id": 207793126,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598219746
    },
    {
        "content": "<p>Pushed more work. I should be done with showing the equivalence of the different prop definitions, and now I'm going to start constructing an actual prime factorization under the assumption of <code>normalization_monoid</code></p>",
        "id": 207907799,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598310465
    },
    {
        "content": "<p>Unfortunately my definition will not be computable because I'm using choice, but it should be possible to refactor it to be defined in terms of <code>multiplicity</code>, which I believe is computable.</p>",
        "id": 207907905,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598310549
    },
    {
        "content": "<p>We don't need computability for this stuff</p>",
        "id": 207929644,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1598338381
    },
    {
        "content": "<p>I just pushed a bunch more stuff connecting my work to the rest of the library</p>",
        "id": 207929768,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598338513
    },
    {
        "content": "<p>for now I’ve deleted the old associates.factor_set business, some of which I want to reimplement, but it seems we can now do pretty much everything we wanted to do before I started, but with more generality, and it’s a predicate</p>",
        "id": 207929845,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1598338566
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4156\">#4156</a></p>",
        "id": 210083288,
        "sender_full_name": "Aaron Anderson",
        "timestamp": 1600134702
    }
]
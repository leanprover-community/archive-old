[
    {
        "content": "<p>Here's a bit of a challenge, in case anyone is bored. Fill in the sorry!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.opposite</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.exact</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">w_op</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">g.op</span> <span class=\"bp\">≫</span> <span class=\"n\">f.op</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">op_comp</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">ugh</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">homology</span> <span class=\"n\">g.op</span> <span class=\"n\">f.op</span> <span class=\"o\">(</span><span class=\"n\">w_op</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">unop</span> <span class=\"bp\">≅</span> <span class=\"n\">homology</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 246255163,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626457104
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  <span aria-label=\"crazy\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"crazy\">:crazy:</span></p>",
        "id": 246255551,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1626457277
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span></p>",
        "id": 246255817,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626457381
    },
    {
        "content": "<p>I guess this is similar in spirit to <a href=\"https://github.com/TwoFX/lean-homological-algebra/blob/lean-3.8.0/src/dual_cohomology_construction.lean\">https://github.com/TwoFX/lean-homological-algebra/blob/lean-3.8.0/src/dual_cohomology_construction.lean</a>, except of course that my code has bitrotted and uses thre wrong definitions</p>",
        "id": 246256750,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1626457836
    },
    {
        "content": "<p>Yes, that's exactly the point. When you undualize the homology of the dual, you get the second construction from that file using <code>coker_to_coim</code></p>",
        "id": 246257518,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626458185
    },
    {
        "content": "<p>on a somewhat related note, maybe we should introduce a <code>Prop</code> valued class for <code>f ≫ g = 0</code> and ask that <code>exact f g</code> extend that, while also replacing the explicit assumption for <code>homology</code> with such an instance?</p>",
        "id": 246258850,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626458770
    },
    {
        "content": "<p>Can you explain the mathematical issue for those of us too lazy to try and prove this on a Friday night?</p>",
        "id": 246272721,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1626466377
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here's a summary of the issue. Suppose <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and $g : B \\to C$$ are morphisms in an abelian caategory whose composition is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, and let <code>w</code> denote a proof of this fact. This means that we have a canonically induced morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi><mo>:</mo><mi>i</mi><mi>m</mi><mi>a</mi><mi>g</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>→</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo stretchy=\"false\">(</mo><mi>g</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\gamma : image(f) \\to kernel(g)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ima</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span></span></span></span>, and <code>homology f g w</code> is defined to be the cokernel of this morphism <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>γ</mi></mrow><annotation encoding=\"application/x-tex\">\\gamma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05556em;\">γ</span></span></span></span>, as usual. </p>\n<p>Now, the opposite category is again abelian, and we have <code>w' := w_op w</code> asserting that the composition of <code>g.op</code> and <code>f.op</code> is <code>0</code>. So we can compute <code>homology g.op f.op w'</code>, and go back to the original category using <code>opposite.unop</code>. The goal is to prove that <code>(homology g.op f.op w').unop</code> is isomorphic to <code>homology f g w</code>. </p>\n<p>But kernels in the opposite category correspond to cokernels in the original category (and vice versa), so <code>(homology g.op f.op w').unop</code> is really the kernel of something (this is where the map <code>coker_to_coim</code> comes in), while <code>homology f g w</code> is the cokernel of something. The challenge is in relating these two objects, which a priori satisfy different universal properties (in the sense that one is a kernel and one is a cokernel).</p>",
        "id": 246281346,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626470239
    },
    {
        "content": "<p>Thinking more about this is making me wonder why we didn't define <code>homology</code> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f : A \\to B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">g : B \\to C</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span></span> as the cokernel of <code>kernel.lift ... : A \\to (kernel g)</code>. I feel like this whole suubobject approach is just making things more difficult in this case.</p>",
        "id": 246282161,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626470671
    },
    {
        "content": "<p>Hopefully an iso to the cokernel of the lift to the kernel is available already?</p>",
        "id": 246295073,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1626482454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Challenge.20with.20homology/near/246295073\">said</a>:</p>\n<blockquote>\n<p>Hopefully an iso to the cokernel of the lift to the kernel is available already?</p>\n</blockquote>\n<p>Is it? I didn't see such an iso, but it's very possible I missed it</p>",
        "id": 246295085,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626482492
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.opposite</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.exact</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">homology_iso_cokernel_lift</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">homology</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">w</span> <span class=\"bp\">≅</span> <span class=\"n\">cokernel</span> <span class=\"o\">(</span><span class=\"n\">kernel.lift</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">cokernel.desc</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">kernel_subobject_iso</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span>  <span class=\"bp\">≫</span> <span class=\"n\">cokernel.π</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">cokernel.desc</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">kernel_subobject_iso</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span> <span class=\"bp\">≫</span> <span class=\"n\">homology.π</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">hom_inv_id'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_hom_id'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>At least the data is easy to define, but 30 seconds of playing around got me nowhere in the proofs, which is a bit annoying...</p>",
        "id": 246295469,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1626483157
    },
    {
        "content": "<p>I agree this is a problem. The following solves it, but needs some cleaning up and mathlib-ifying:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.opposite</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.abelian.exact</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory.limits</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">abelian</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">image_to_kernel'</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">image</span> <span class=\"n\">f</span> <span class=\"bp\">⟶</span> <span class=\"n\">kernel</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">kernel.lift</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">image.ι</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simpa</span> <span class=\"n\">using</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"o\">})</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">homology</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">≅</span> <span class=\"n\">cokernel</span> <span class=\"o\">(</span><span class=\"n\">image_to_kernel'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">cokernel.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">image_subobject_iso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">kernel_subobject_iso</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">image_to_kernel'</span><span class=\"o\">],</span> <span class=\"o\">}),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">cokernel.map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">image_subobject_iso</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span> <span class=\"o\">(</span><span class=\"n\">kernel_subobject_iso</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">inv</span>\n    <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">image_to_kernel'</span><span class=\"o\">],</span> <span class=\"o\">}),</span>\n  <span class=\"n\">hom_inv_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">apply</span> <span class=\"n\">coequalizer.hom_ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">category.comp_id</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"c1\">-- yuck?</span>\n  <span class=\"n\">inv_hom_id'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span> <span class=\"n\">apply</span> <span class=\"n\">coequalizer.hom_ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"kd\">end</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">cokernel</span> <span class=\"o\">(</span><span class=\"n\">image_to_kernel'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"n\">cokernel</span> <span class=\"o\">(</span><span class=\"n\">kernel.lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">have</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">factor_thru_image</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">image_to_kernel'</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"n\">kernel.lift</span> <span class=\"n\">g</span> <span class=\"n\">f</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">image_to_kernel'</span><span class=\"o\">],</span> <span class=\"o\">},</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">cokernel_epi_comp</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">≪≫</span> <span class=\"n\">cokernel_iso_of_eq</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 246321237,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1626522858
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/8355\">#8355</a></p>",
        "id": 246363369,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1626590746
    }
]
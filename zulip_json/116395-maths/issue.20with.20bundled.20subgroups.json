[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span> has been bundling subgroups at Xena (for mathlib), and I've been doing preliminary experiments in <span class=\"user-mention\" data-user-id=\"243895\">@Shenyang Wu</span> 's repository <a href=\"https://github.com/Shenyang1995/M4R/blob/master/src/add_group_hom/basic.lean\" target=\"_blank\" title=\"https://github.com/Shenyang1995/M4R/blob/master/src/add_group_hom/basic.lean\">here</a>. Here's something I ran into.</p>\n<p>The type of monoid homomorphisms between <code>monoid</code>s <code>M</code> and <code>N</code> is just denoted <code>M →* N</code>, notation for <code>monoid_hom M N</code>. Now say <code>G</code> and <code>H</code> are <code>group</code>s. Because a group is a monoid, and a group homomorphism is just a monoid homomorphism between groups, one can just use <code>G →* H</code> to denote group homomorphisms. This initially looks like a cool idea.</p>\n<p>But now say I want to define <code>map : (G →* H) → (subgroup G) → (subgroup H)</code>, pushing forward a subgroup of <code>G</code> by taking its image under the function <code>G → H</code>. <code>monoid_hom.map</code> is already taken, and it doesn't have this type (it maps submonoids to submonoids). Because <code>subgroup</code> is not a class predicate on <code>submonoid</code> it seems to me that I need another function. Maybe it could be called <code>group_hom.map</code>. Ideally I'd like to use dot notation and have <code>f.map K</code> for <code>K : subgroup H</code>. In which case maybe I should define <code>@[reducible] def group_hom G H := monoid_hom G H</code>. But now I lose the notation <code>→*</code> for group homs. I also had problems with dot notation -- e.g. (in the additive case -- but it makes no difference)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"bp\">@</span><span class=\"n\">add_group_hom</span><span class=\"bp\">.</span><span class=\"n\">comap</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">comap :</span>\n<span class=\"cm\">  Π {G₁ : Type u_3} [_inst_3 : add_group G₁] {G₂ : Type u_4} [_inst_4 : add_group G₂],</span>\n<span class=\"cm\">    (G₁ →+ G₂) → add_subgroup G₂ → add_subgroup G₁</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">ker&#39;</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">add_group_hom</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"err\">⊥</span> <span class=\"c1\">-- fails:</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">invalid field notation, function &#39;add_group_hom.comap&#39;</span>\n<span class=\"cm\">does not have explicit argument with type (add_group_hom ...)</span>\n<span class=\"cm\">-/</span>\n<span class=\"n\">def</span> <span class=\"n\">ker</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">add_group_hom</span> <span class=\"n\">G</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add_subgroup</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">add_group_hom</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"err\">⊥</span> <span class=\"c1\">-- works fine</span>\n</pre></div>\n\n\n<p>so I seemed to have lost projection notation anyway. Is this a bug?</p>\n<p>In writing all this down it occurs to me that another solution is to define <code>add_monoid_hom.gmap</code>, <code>monoid_hom.gcomap</code>, <code>monoid_hom.gker</code> and so on, and not defining <code>group_hom</code> at all. Or even one could argue that because groups are more popular than monoids, <code>map</code> could be the group one and <code>mmap</code> could be the monoid one.</p>\n<p>Anyone have any thoughts about these issues?</p>",
        "id": 189917249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583517108
    },
    {
        "content": "<p>Shouldn't this be <code>subgroup.map</code> not <code>group_hom.map</code>. Otherwise you're insisting that <code>subgroup</code> is the only functor on the category of groups.</p>",
        "id": 189917690,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583517390
    },
    {
        "content": "<p>This was something else that occurred to me, in fact we changed Shenyang's repository today from that convention to the one I was talking about in my post above (and that's why we ran into this issue). This is currently how it works for monoids though: see <a href=\"https://github.com/leanprover-community/mathlib/blob/36b336cb81612e0c4a37181a93262fb5d1a15fbf/src/group_theory/submonoid.lean#L725\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/36b336cb81612e0c4a37181a93262fb5d1a15fbf/src/group_theory/submonoid.lean#L725\">https://github.com/leanprover-community/mathlib/blob/36b336cb81612e0c4a37181a93262fb5d1a15fbf/src/group_theory/submonoid.lean#L725</a> and note line 708. Is this a bad convention?</p>",
        "id": 189918010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583517621
    },
    {
        "content": "<p>If one can argue for your convention with <code>map</code>, let's instead talk about <code>ker</code>. I want <code>f.ker</code> to return a subgroup, and it currently returns a submonoid (actually it might not yet exist, I'm not sure, but if and when it exists it will presumably be a submonoid). Related is <code>im</code> and <code>range</code>.</p>",
        "id": 189918097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583517711
    },
    {
        "content": "<p>Usually the name is <code>name_of_functor.map</code>. So it is a bad convention</p>",
        "id": 189918178,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583517753
    },
    {
        "content": "<p>I'm not sure kernels are a particularly useful thing for <code>monoid</code>s, since the kernels being equal does not imply that the images are isomorphic. I'm not sure it should return a <code>submonoid</code>.</p>",
        "id": 189918480,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583517956
    },
    {
        "content": "<p>Well let's talk about images?</p>",
        "id": 189918552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583517982
    },
    {
        "content": "<p>The reason this came up for Shenyang was that we want to prove that group cohomology is a functor, so we need that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">f:A\\to B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a morphism of abelian additive groups and we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>A</mi><mn>0</mn></msub><mo>⊆</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A_0\\subseteq A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub><mo>⊆</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B_0\\subseteq B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> subgroups with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>A</mi><mn>0</mn></msub><mo stretchy=\"false\">)</mo><mo>⊆</mo><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">f(A_0)\\subseteq B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then we get an induced map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mi mathvariant=\"normal\">/</mi><msub><mi>A</mi><mn>0</mn></msub><mo>→</mo><mi>B</mi><mi mathvariant=\"normal\">/</mi><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">A/A_0\\to B/B_0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathdefault\">A</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. When we were proving the lemmas needed to construct this I needed stuff about comaps and kernels etc. So they (by which I mean images and kernels) are certainly needed, or at least extremely useful, for subgroups.</p>",
        "id": 189918770,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583518127
    },
    {
        "content": "<p>You just have to think of different names for images in monoids and images in groups.</p>",
        "id": 189919039,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583518318
    },
    {
        "content": "<p>Have you considered just using the category <code>AddCommGroup</code>?</p>",
        "id": 189919388,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518557
    },
    {
        "content": "<p>Your fingers will thank you</p>",
        "id": 189919419,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518562
    },
    {
        "content": "<p>Probably a bug that it isn't called <code>Ab</code></p>",
        "id": 189919438,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518569
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189919388\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189919388\">said</a>:</p>\n<blockquote>\n<p>Have you considered just using the category <code>AddCommGroup</code>?</p>\n</blockquote>\n<p>My perception is that it's much harder to work with <code>Ab</code> because there is less infrastructure, and Shenyang has to hand in his thesis in a few months. My impression is that <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> will be doing an MSc project with me next year, perhaps she'll be brave enough to try?</p>",
        "id": 189919983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583518947
    },
    {
        "content": "<p>You don't actually need any infrastructure</p>",
        "id": 189920013,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518963
    },
    {
        "content": "<p>I don't really get this perception</p>",
        "id": 189920027,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518972
    },
    {
        "content": "<p>It's literally just bundling groups and bundling morphisms</p>",
        "id": 189920043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583518982
    },
    {
        "content": "<p>I might just be completely wrong. Last time I worked with categories I was trying to do something much harder (gluing sheaves etc) and found it very slow going (perhaps partly because I was learning the library as well).</p>",
        "id": 189920254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519116
    },
    {
        "content": "<p>Yes, I agree that's a lot more involved.</p>",
        "id": 189920319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519160
    },
    {
        "content": "<p>This is bad. There are two very serious (non-Lean-related) jobs which I need to work on, and probably I should spend all weekend working on them, but all I want to do now is to see if <code>Ab</code> solves problems or creates them.</p>",
        "id": 189920433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519205
    },
    {
        "content": "<p>Can you help to start me off here? Shenyang has spent quite some time defining the group of n-cochains, and the subgroups of n-cocycles and n-coboundaries. When do we break into<code>Ab</code>?</p>",
        "id": 189920695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519340
    },
    {
        "content": "<p>I assume the second part means: defining the differentials</p>",
        "id": 189920771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519395
    },
    {
        "content": "<p>To be a bit more precise he has <code>cochain n G M</code> an additive abelian group, and <code>d : cochain n G M -&gt; cochain (n+1) G M</code> and he's proved <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>d</mi><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">d^2=0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>",
        "id": 189920832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519409
    },
    {
        "content": "<p>and that <code>d</code> is an add_monoid_hom.</p>",
        "id": 189920861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519428
    },
    {
        "content": "<p>and it will not be hard to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>M</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">f:M\\to N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> gives <code>cochain n G M -&gt;+ cochain n G N</code> commuting with <code>d</code>. Can we just leave all this work alone?</p>",
        "id": 189920928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519483
    },
    {
        "content": "<p>Yes, so all these concrete constructions make sense to do the way you have done them</p>",
        "id": 189920941,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519490
    },
    {
        "content": "<p>(assuming you don't want to build the cochains as an instance of some more general construction)</p>",
        "id": 189920969,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519509
    },
    {
        "content": "<p>But now you're proposing that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(G,M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> be defined as an object of <code>Ab</code>?</p>",
        "id": 189921025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519526
    },
    {
        "content": "<p>then you can tack on a <code>AddCommGroup.of</code> in front of your <code>cochain n G M</code> and turn <code>d</code> into a morphism (I think just definitionally)</p>",
        "id": 189921095,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519573
    },
    {
        "content": "<p>Any homological algebra like the induced map on homology from a map of chain complexes is going to be a huge mess unbundled</p>",
        "id": 189921172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519616
    },
    {
        "content": "<p>and it will be a somewhat smaller mess if you bundle the objects</p>",
        "id": 189921182,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519626
    },
    {
        "content": "<p>How do I do subgroups? Is the kernel just another object?</p>",
        "id": 189921196,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519636
    },
    {
        "content": "<p>yep, so you can compare <a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/subspace.lean\" target=\"_blank\" title=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/subspace.lean\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/subspace.lean</a></p>",
        "id": 189921279,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519673
    },
    {
        "content": "<p>I see, I need a map from Im(d_n) to ker(d_{n+1}) and then I just define cohomology to be the cokernel. Are there cokernels in <code>Ab</code>? I don't even know where to look!</p>",
        "id": 189921314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519696
    },
    {
        "content": "<p>I don't advise trying to use some general category theory notion of cokernel. Just define the object the same way you normally would, stick <code>AddCommGroup.of</code> in front of it and prove that it has the correct universal property</p>",
        "id": 189921381,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519759
    },
    {
        "content": "<p>I'm now trying to understand what problem we're solving here.</p>",
        "id": 189921651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519935
    },
    {
        "content": "<p>Basically, use the category theory library as though you only knew what the definition of a category is</p>",
        "id": 189921654,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583519937
    },
    {
        "content": "<p>I knew (or at least I thought I knew, until I ran into the issues which prompted this thread) exactly what I was doing bundling subgroups. What am I supposed to be doing with <code>Ab</code>?</p>",
        "id": 189921729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583519983
    },
    {
        "content": "<p>The main problem is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">A₁</span> <span class=\"n\">B₁</span> <span class=\"n\">C₁</span> <span class=\"n\">D₁</span> <span class=\"n\">E₁</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">A₂</span> <span class=\"n\">B₂</span> <span class=\"n\">C₂</span> <span class=\"n\">D₂</span> <span class=\"n\">E₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">variables</span>  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A₁</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">f₁</span> <span class=\"o\">:</span> <span class=\"n\">A₁</span> <span class=\"bp\">→</span> <span class=\"n\">B₁</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">B₁</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">g₁</span> <span class=\"o\">:</span> <span class=\"n\">B₁</span> <span class=\"bp\">→</span> <span class=\"n\">C₁</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">C₁</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">C₁</span> <span class=\"bp\">→</span> <span class=\"n\">D₁</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">D₁</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">i₁</span> <span class=\"o\">:</span> <span class=\"n\">D₁</span> <span class=\"bp\">→</span> <span class=\"n\">E₁</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">E₁</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">A₁</span> <span class=\"bp\">→</span> <span class=\"n\">A₂</span><span class=\"o\">}</span>                  <span class=\"o\">{</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">B₁</span> <span class=\"bp\">→</span> <span class=\"n\">B₂</span><span class=\"o\">}</span>                  <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">C₁</span> <span class=\"bp\">→</span> <span class=\"n\">C₂</span><span class=\"o\">}</span>                  <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">D₁</span> <span class=\"bp\">→</span> <span class=\"n\">D₂</span><span class=\"o\">}</span>                  <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">E₁</span> <span class=\"bp\">→</span> <span class=\"n\">E₂</span><span class=\"o\">}</span>\n<span class=\"kn\">variables</span>  <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">A₂</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">f₂</span> <span class=\"o\">:</span> <span class=\"n\">A₂</span> <span class=\"bp\">→</span> <span class=\"n\">B₂</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">B₂</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">g₂</span> <span class=\"o\">:</span> <span class=\"n\">B₂</span> <span class=\"bp\">→</span> <span class=\"n\">C₂</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">C₂</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">C₂</span> <span class=\"bp\">→</span> <span class=\"n\">D₂</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">D₂</span><span class=\"o\">]</span>    <span class=\"o\">{</span><span class=\"n\">i₂</span> <span class=\"o\">:</span> <span class=\"n\">D₂</span> <span class=\"bp\">→</span> <span class=\"n\">E₂</span><span class=\"o\">}</span>   <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">E₂</span><span class=\"o\">]</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">g₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">h₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">i₁</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">f₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">g₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">h₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">i₂</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_group_hom</span> <span class=\"n\">n</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 189921796,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520006
    },
    {
        "content": "<p>Is there an analogue of <code>map</code>, <code>comap</code>, <code>ker</code>, <code>im</code>, <code>range</code>?</p>",
        "id": 189921800,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520009
    },
    {
        "content": "<p>(thanks Johan)</p>",
        "id": 189921829,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520023
    },
    {
        "content": "<p>I didn't do the snake lemma...</p>",
        "id": 189921874,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583520058
    },
    {
        "content": "<p>Only the 5 lemma? It was what got you started though, right?</p>",
        "id": 189921901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520074
    },
    {
        "content": "<p>I guess that will be on the wishlist sometime soon.</p>",
        "id": 189921909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583520080
    },
    {
        "content": "<p>I know group homs are bundled now, so you are already halfway there</p>",
        "id": 189921915,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520084
    },
    {
        "content": "<p>Yeah, the good old times <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 189921917,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583520087
    },
    {
        "content": "<p>(what's the difference between <code>im</code> and <code>range</code>?)</p>",
        "id": 189922111,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520234
    },
    {
        "content": "<p>Oh maybe <code>im := map</code> and <code>range = map univ</code></p>",
        "id": 189922197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520275
    },
    {
        "content": "<p><code>map</code> I don't even know what it is.</p>",
        "id": 189922220,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520299
    },
    {
        "content": "<p>I would try to get away from subsets, and just use morphisms which are monos</p>",
        "id": 189922265,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520338
    },
    {
        "content": "<p><code>map</code> is supposed to be the function which pushes forward a subgroup of G to a subgroup of H under a group hom G -&gt; H.</p>",
        "id": 189922391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520408
    },
    {
        "content": "<p>I would just add some 1-2 line wrapper for whatever you need along these lines and then some lemmas which characterize it</p>",
        "id": 189922523,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520512
    },
    {
        "content": "<p>Often you can also get away with the lemmas because they are true by defeq</p>",
        "id": 189922552,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520542
    },
    {
        "content": "<p>For example I looked at <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/quotient_group.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/group_theory/quotient_group.lean\">the quotient group file</a> and thought \"right, that's the API for quotient groups, let's make it in the bundled setting\" and then my task was clear. Here I'm a bit less clear about what I should be doing. Maybe I should just try and prove that cohomology is a functor...should I make G-modules a category??</p>",
        "id": 189922567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520557
    },
    {
        "content": "<p>How else are you going to state this fact?</p>",
        "id": 189922602,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520594
    },
    {
        "content": "<p>Well I guess my plan was to literally just prove all the things which needed proving but not use categories at all.</p>",
        "id": 189922676,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520627
    },
    {
        "content": "<p>I see</p>",
        "id": 189922684,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520633
    },
    {
        "content": "<p>:-)</p>",
        "id": 189922703,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520640
    },
    {
        "content": "<p>And again I can see why I naturally shy away from categories -- I know exactly how to make a <code>G_module</code> type (indeed Anca did this last year) but I don't really know how to make a good G_module category.</p>",
        "id": 189922837,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520723
    },
    {
        "content": "<p>so define for every type M which is an add_comm_group with an action of G, a type H^n(G, M) for each n, which has an instance of add_comm_group, and then separately for every map of G-modules, a map on cohomology, and then prove some stuff commutes</p>",
        "id": 189922868,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520753
    },
    {
        "content": "<p>We have R-modules already, so it should basically be a copy-and-paste job from that. Or you could define Ext <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 189922889,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520770
    },
    {
        "content": "<p><a href=\"https://github.com/anca797/group-cohomology/blob/master/src/h0.lean\" target=\"_blank\" title=\"https://github.com/anca797/group-cohomology/blob/master/src/h0.lean\">G-modules and G-module maps</a></p>",
        "id": 189922900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520781
    },
    {
        "content": "<p>Should I make a category of G-modules, or put a G-action on an object of Ab?</p>",
        "id": 189922953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520819
    },
    {
        "content": "<p>oh yeah, maybe we already have G-modules then?</p>",
        "id": 189923043,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520862
    },
    {
        "content": "<p>in that sense</p>",
        "id": 189923044,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520864
    },
    {
        "content": "<p>That's not mathlib: I don't have the energy to show my students how to make code mathlib-acceptable so it just bitrots instead, but at least they write good projects.</p>",
        "id": 189923072,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520894
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/single_obj.lean#L61\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/single_obj.lean#L61\">https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/single_obj.lean#L61</a></p>",
        "id": 189923073,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520895
    },
    {
        "content": "<p>Where are R-modules? I don't know my way around.</p>",
        "id": 189923190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583520958
    },
    {
        "content": "<p>so you could define G-modules to be the category <code>single_obj G ⥤ Ab</code></p>",
        "id": 189923192,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520959
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Module/basic.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Module/basic.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Module/basic.lean</a></p>",
        "id": 189923277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583520997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923192\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923192\">said</a>:</p>\n<blockquote>\n<p>so you could define G-modules to be the category <code>single_obj G ⥤ Ab</code></p>\n</blockquote>\n<p>Will there be now be like 6 universes floating around?</p>",
        "id": 189923297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521015
    },
    {
        "content": "<p>What are your feelings about just sticking to <code>Type</code> and making things large/small categories as appropriate?</p>",
        "id": 189923340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521050
    },
    {
        "content": "<p>instead of this insane polymorphism that the CS guys are always going on about and which I still don't really see the point of?</p>",
        "id": 189923394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521082
    },
    {
        "content": "<p>Highly recommended if you have no particular need for the generality and just want to have a working project</p>",
        "id": 189923413,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521084
    },
    {
        "content": "<p>If you want more generality, then also recommended is to fix a single <code>Type u</code> as much as possible. But <code>u = 0</code> is also fine</p>",
        "id": 189923443,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521118
    },
    {
        "content": "<p>I can live with one universe. I don't know how much pain it will cause. I know that the first time I tried categories I had some real universe hell, but my understanding is that you and Scott have somehow managed to tame it all now.</p>",
        "id": 189923508,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923297\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923297\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923192\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189923192\">said</a>:</p>\n<blockquote>\n<p>so you could define G-modules to be the category <code>single_obj G ⥤ Ab</code></p>\n</blockquote>\n<p>Will there be now be like 6 universes floating around?</p>\n</blockquote>\n<p>To answer your question, I think you would have the same universe variables as in <code>class G_module</code> but I don't really understand <code>Type*</code></p>",
        "id": 189923549,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521191
    },
    {
        "content": "<p>In a lot of the homotopy theory project, I define <code>local notation `Top` := Top.{0}</code></p>",
        "id": 189923646,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521228
    },
    {
        "content": "<p>mainly because I want to use the real numbers and didn't feel like dealing with <code>ulift</code></p>",
        "id": 189923736,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521294
    },
    {
        "content": "<p>If you do use <code>single_obj G ⥤ Ab</code> I would encourage first defining some conversions between that and <code>G_module</code> as a sanity check</p>",
        "id": 189923836,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521347
    },
    {
        "content": "<p>and possibly this functor definition could get annoying, I'm not sure</p>",
        "id": 189923867,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521377
    },
    {
        "content": "<p>I might give this a go. I have this worry that my initial enthusiasm for having found another excuse to dip my toes into category land will soon wear off as I realise that categories are hard in Lean, but maybe each time I try them they'll be less hard. Yes I remember the <code>ulift</code> issues with the reals. We have <code>punit</code>, right? How about <code>preal</code>?</p>",
        "id": 189923872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521379
    },
    {
        "content": "<p>Okay, so looking at</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- A-&gt;B-&gt;C -/</span>\n<span class=\"n\">def</span> <span class=\"n\">is_exact</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_add_group_hom</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_add_group_hom</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">range</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"n\">g</span>\n</pre></div>\n\n\n<p>the idea is to change it to something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_exact</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"err\">⟶</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">range</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">ker</span> <span class=\"n\">g</span>\n</pre></div>\n\n\n<p>relying on the coercion from the hom types of Ab to functions</p>",
        "id": 189924207,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521569
    },
    {
        "content": "<p>or to +-homomorphisms now or whatever</p>",
        "id": 189924229,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521590
    },
    {
        "content": "<p>Will the range really <em>equal</em> the ker here?</p>",
        "id": 189924424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521717
    },
    {
        "content": "<p>yes, <code>range f : set B</code> where there is also a coercion from <code>B</code> to <code>Type</code></p>",
        "id": 189924441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521741
    },
    {
        "content": "<p>I mean the same <code>range</code> as now</p>",
        "id": 189924450,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521756
    },
    {
        "content": "<p>I've just realised that I don't understand exact sequences in an abelian category properly</p>",
        "id": 189924470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521784
    },
    {
        "content": "<p>I also had that realization</p>",
        "id": 189924479,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521797
    },
    {
        "content": "<p>Oh OK I know how to do it, it's just that's not the way we're going to do it here.</p>",
        "id": 189924582,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521852
    },
    {
        "content": "<p>I am not trying to say you should never get your hands dirty with elements and subsets and stuff, just that you can use a language where the chunk size is closer to what you are used to.</p>",
        "id": 189924661,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583521905
    },
    {
        "content": "<p>there's some induced map range f -&gt; ker g in the non-concrete setting and you want it to be an iso or whatever.</p>",
        "id": 189924666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583521911
    },
    {
        "content": "<p>Maybe for an undergraduate the <code>{A B C : Type*} [add_comm_group A] [add_comm_group B] [add_comm_group C] (f : A → B) (g : B → C) [is_add_group_hom f] [is_add_group_hom g]</code> does actually reflect their mental model, but probably not by the time you're doing homological algebra/group cohomology.</p>",
        "id": 189924877,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522029
    },
    {
        "content": "<p>(Is this on an old mathlib? Or are there still both bundled and unbundled group homomorphisms?)</p>",
        "id": 189924963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522067
    },
    {
        "content": "<p>Anca's group cohomology project is over a year old and I don't think she had access to bundled group homs.</p>",
        "id": 189925014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583522106
    },
    {
        "content": "<p>I see</p>",
        "id": 189925029,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522115
    },
    {
        "content": "<p>It's similar in topology, we do not have bundled continuous maps</p>",
        "id": 189925040,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522134
    },
    {
        "content": "<p>Shenyang is using bundled homs. The reason all this started was that group cohomology is probably the cohomology theory I understand best so I thought it would be an interesting topic, particularly when I realised that in theory it should be straightforward but actually it was really hard to find any examples of any cohomology theories at all in any theorem prover.</p>",
        "id": 189925112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583522171
    },
    {
        "content": "<p>Anca just did H^0 and H^1, she was a BSc student and I thought that the 7 term exact sequence was plenty for a Bachelors project.</p>",
        "id": 189925139,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583522198
    },
    {
        "content": "<p>Is singular cohomology formalised in any theorem prover at all?</p>",
        "id": 189925166,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583522222
    },
    {
        "content": "<p>At first I thought it was kind of pointless to define group cohomology, because you can express it as a special case of various other constructions. But then I realized that sometimes you just want to sit down with a 1-cocycle and calculate stuff with it, and then you also want to know that the thing you define using explicit cocyles calculates H^1. So you have to write down the cocycle-based group cohomology construction anyways.</p>",
        "id": 189925217,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522266
    },
    {
        "content": "<p>Oh wow, I didn't notice this H^1 stuff.</p>",
        "id": 189925307,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522322
    },
    {
        "content": "<p>I suppose you'll even have a small instance of this issue when you want to know that group cohomology H^n defined using n-cocyles specializes to H^1 using crossed homomorphisms when n=1</p>",
        "id": 189925356,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189925166\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189925166\">said</a>:</p>\n<blockquote>\n<p>Is singular cohomology formalised in any theorem prover at all?</p>\n</blockquote>\n<p>Yes, actually it is formalized in HOL Light I think</p>",
        "id": 189925375,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522389
    },
    {
        "content": "<p><a href=\"https://www.mathematics.pitt.edu/hales60/pdf/Harrison-John.pdf\" target=\"_blank\" title=\"https://www.mathematics.pitt.edu/hales60/pdf/Harrison-John.pdf\">https://www.mathematics.pitt.edu/hales60/pdf/Harrison-John.pdf</a></p>",
        "id": 189925458,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522450
    },
    {
        "content": "<p>Hard to find when you don't know how to spell HOL Light <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 189925471,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522462
    },
    {
        "content": "<p>Also Johan defined singular homology in a PR. But Harrison's formalization has actual theorems.</p>",
        "id": 189925686,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583522664
    },
    {
        "content": "<p>Aah but that's singular homology ;-)</p>",
        "id": 189926236,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189925217\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189925217\">said</a>:</p>\n<blockquote>\n<p>At first I thought it was kind of pointless to define group cohomology, because you can express it as a special case of various other constructions. </p>\n</blockquote>\n<p>Sure, but I think that nonetheless these are good projects for students, and they typically teach me stuff about Lean. One could argue that it's kind of pointless to do anything in Lean 3 and we should all just sit and wait for Lean 4, but it's just too much fun.</p>",
        "id": 189926409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523193
    },
    {
        "content": "<p>But even just thinking about what things mathlib ought to have in an ideal world, even if you define group cohomology using Ext or something, surely another of those things is \"the way you can compute group cohomology using cocycles\", and this is tantamount to defining group cohomology the way you're doing it now</p>",
        "id": 189926668,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523368
    },
    {
        "content": "<p>I'm not sure I ever got to the bottom of <a href=\"https://mathoverflow.net/questions/6950/why-is-the-standard-definition-of-cocycle-the-one-that-always-comes-up\" target=\"_blank\" title=\"https://mathoverflow.net/questions/6950/why-is-the-standard-definition-of-cocycle-the-one-that-always-comes-up\">this MO question</a></p>",
        "id": 189926825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523496
    },
    {
        "content": "<p>(Also I don't know what the right way to really understand group cohomology of a profinite group is, unless the answer is condensed sets? Related to my recent question here)</p>",
        "id": 189926974,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523623
    },
    {
        "content": "<p>or is the point you only consider discrete modules?</p>",
        "id": 189926999,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523650
    },
    {
        "content": "<p>I wonder if people understand this better now. If the module is discrete it's fine, but definitely in number theory people consider continuous cohomology with coefficients the p-adic integers, and people are dimly aware that this isn't a derived functor. I think that under mild hypotheses there's still a long exact sequence.</p>",
        "id": 189927055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523702
    },
    {
        "content": "<p>I think I just realized that I didn't understand exactly what the issue I didn't understand was</p>",
        "id": 189927128,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523737
    },
    {
        "content": "<p>I think the issue is that if you have a continuous surjection <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding=\"application/x-tex\">B\\to C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span></span></span></span> then you can't necessarily find a continuous set-theoretic splitting, so the naive attempt to define the boundary map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mn>0</mn></msup><mo stretchy=\"false\">(</mo><mi>C</mi><mo stretchy=\"false\">)</mo><mo>→</mo><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^0(C)\\to H^1(A)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">C</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span></span></span></span> fails.</p>",
        "id": 189927157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189927055\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189927055\">said</a>:</p>\n<blockquote>\n<p>people consider continuous cohomology with coefficients the p-adic integers</p>\n</blockquote>\n<p>is it defined as an inverse limit of cohomology with coefficients in Z/p^n?</p>",
        "id": 189927164,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523769
    },
    {
        "content": "<p>(if you're defining <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">H^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span></span></span></span> as continuous cocycles over continuous coboundaries)</p>",
        "id": 189927186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523785
    },
    {
        "content": "<p>People really do use this \"continuous cocycles\" definition. I think it is the same as the inverse limit definition you just suggested. Problem is that inverse limits aren't exact so you don't automatically get exactness of the long (non)-exact sequence.</p>",
        "id": 189927239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523831
    },
    {
        "content": "<p>So in the discrete coefficients case, there is still an honest abelian category right? But it's not a category of R-modules for a ring R like it would be in the finite (or discrete) group case</p>",
        "id": 189927249,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523841
    },
    {
        "content": "<p>In the discrete case it's not a category of R-modules, but you can define the cohomology groups as direct limits which do preserve exactness. I am pretty sure it's an abelian category, all I know is that the parts of the formalism I need work :-)</p>",
        "id": 189927355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583523907
    },
    {
        "content": "<p>Like a limit over the finite quotients of the group?</p>",
        "id": 189927467,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583523976
    },
    {
        "content": "<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mo lspace=\"0em\" rspace=\"0em\">→</mo></msub><msup><mi>H</mi><mi>n</mi></msup><mo stretchy=\"false\">(</mo><mi>G</mi><mi mathvariant=\"normal\">/</mi><mi>U</mi><mo separator=\"true\">,</mo><msup><mi>M</mi><mi>U</mi></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">H^n(G,M):=lim_{\\to}H^n(G/U,M^U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0913309999999998em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">i</span><span class=\"mord\"><span class=\"mord mathdefault\">m</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.10680899999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mrel mtight\">→</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">G</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>",
        "id": 189927507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583524013
    },
    {
        "content": "<p>as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> ranges over the open (and hence finite index) normal subgroups</p>",
        "id": 189927520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583524025
    },
    {
        "content": "<p>and this is fine for discrete modules.</p>",
        "id": 189927531,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583524038
    },
    {
        "content": "<p>and there's certainly a long exact sequence and almost surely a Hochschild-Serre spectral sequence but it's been a long time since I checked all the details of this.</p>",
        "id": 189927641,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583524097
    },
    {
        "content": "<p>But the moment <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is not discrete I know very little, beyond the fact that in some cases everything works out anyway.</p>",
        "id": 189927674,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583524124
    },
    {
        "content": "<p>OK so here are the exciting issues I've run into already:<br>\n1) <code>single_obj G</code> isn't a small category if <code>(G : Type u)</code> because the object of <code>single_obj</code> is <code>unit</code> not <code>punit</code><br>\n2) type class inference isn't making G-modules a category:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">single_obj</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor_category</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">group_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">single_obj</span> <span class=\"n\">G</span> <span class=\"err\">⥤</span> <span class=\"n\">AddCommGroup</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"c1\">--   by apply_instance -- fails</span>\n<span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">category</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n</pre></div>",
        "id": 189931129,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583526719
    },
    {
        "content": "<p>The second one is just normal behavior of instances</p>",
        "id": 189931248,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583526805
    },
    {
        "content": "<p>You can <code>@[derive category]</code> the instance when you define it, or prove it by <code>delta group_module; apply_instance</code>.</p>",
        "id": 189931426,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583526955
    },
    {
        "content": "<p>For the first, does it matter whether <code>single_obj G</code> is a small category?</p>",
        "id": 189931478,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583526966
    },
    {
        "content": "<p>I would perhaps do this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"n\">def</span> <span class=\"n\">group_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">single_obj</span> <span class=\"n\">G</span> <span class=\"err\">⥤</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">large_category</span> <span class=\"o\">(</span><span class=\"n\">group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">delta</span> <span class=\"n\">group_module</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n</pre></div>",
        "id": 189931649,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583527097
    },
    {
        "content": "<p>Well my plan was to stick to one universe <code>Type u</code> and then just to make all the categories have the size they'd have in ZFC -- so the single object one small, the abelian groups large, and G-module large. But <code>single_obj</code> seems to have decided that u=0. I don't know if it matters. I was just imagining that making everything the right size instead of polymorphic world instantly remove all universe issues. Of course you're both right about the second issue -- thanks</p>",
        "id": 189932499,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583527711
    },
    {
        "content": "<p>Oh apparently it doesn't matter, the G-modules are u-large anyway</p>",
        "id": 189932659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583527795
    },
    {
        "content": "<p>I think it would in fact be better to make <code>single_obj G</code> be a small category, but in this situation I don't think it will make a difference (unless you try to define M^G as the limit of this diagram)</p>",
        "id": 189932835,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583527902
    },
    {
        "content": "<p>I just PR'd limits and colimits in <code>AddCommGroup</code>, in case that is useful for Kevin's current investigations. I added a small tutorial file, which for now just contains:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">shapes</span><span class=\"bp\">.</span><span class=\"n\">kernels</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Some small examples of using limits and colimits in `Ab`, the category of additive commutative groups.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span> <span class=\"o\">:=</span> <span class=\"n\">kernel</span> <span class=\"n\">f</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">as_iso</span> <span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- TODO no images yet...</span>\n</pre></div>",
        "id": 189937876,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583531264
    },
    {
        "content": "<p>Thanks! I'm currently working on this. I don't think I want Shenyang to go down the category theory route really but I'm interested in experimenting myself.</p>",
        "id": 189938020,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583531372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189937876\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189937876\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- TODO no images yet...</span>\n</pre></div>\n\n\n</blockquote>\n<p>This.</p>",
        "id": 189938027,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583531376
    },
    {
        "content": "<p>Ha ha, since when was it called <code>Ab</code> for real? :-)</p>",
        "id": 189938140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583531441
    },
    {
        "content": "<p>Just added this in the PR. It is just an <code>abbreviation</code> for <code>AddCommGroup</code>, and the library itself still says <code>AddCommGroup</code> throughout.</p>",
        "id": 189938221,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583531521
    },
    {
        "content": "<p>What does <code>kernel f</code> end up being in this case?</p>",
        "id": 189939106,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583532218
    },
    {
        "content": "<p>In this case it will be a horrible thing, because I've just pulled things out of general limits. So in particular it will the subset of functions from the <code>walking_parallel_pair</code> type (which has two elements, called <code>left</code> and <code>right</code>) which assign to <code>left</code> an element of <code>G</code> and to <code>right</code> an element of <code>H</code>, such that the element in <code>G</code> gets sent to the element in <code>H</code>, and gets sent to zero. :-)</p>",
        "id": 189941089,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583533720
    },
    {
        "content": "<p>Use the API. :-)</p>",
        "id": 189941094,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583533722
    },
    {
        "content": "<p>And don't look under the hood.</p>",
        "id": 189941107,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583533730
    },
    {
        "content": "<p>We can add the definitionally nice shortcut instances as well if we want to.</p>",
        "id": 189941128,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583533750
    },
    {
        "content": "<p>My concern is that, particularly for the cokernel, the best way to use the API may sometimes be: define the cokernel in the obvious way, prove that it satisfies the universal property, then use the uniqueness up to isomorphism of the cokernel to transfer (at your own expense) the statement that you can check for the obvious cokernel to whatever one you get from the instance.</p>",
        "id": 189946941,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583539624
    },
    {
        "content": "<p>For example, try proving if f : G -&gt; H is a mono and G and H are finite, then <code>|cokernel f| = |H| / |G|</code>.</p>",
        "id": 189946952,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583539653
    },
    {
        "content": "<p>Yes, that sounds reasonable.</p>",
        "id": 189947042,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583539748
    },
    {
        "content": "<p>Okay, I've updated that tutorial file, as of <a href=\"https://github.com/leanprover-community/mathlib/issues/2101\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/2101\">#2101</a>. Now we have images, and defining exactness is one line away:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">shapes</span><span class=\"bp\">.</span><span class=\"n\">kernels</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Ab</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">Ab</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\">Some small examples of using limits and colimits in `Ab`, the category of additive commutative groups.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span> <span class=\"o\">:=</span> <span class=\"n\">kernel</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">epi</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">kernel</span> <span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">as_iso</span> <span class=\"o\">(</span><span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">ι</span> <span class=\"o\">(</span><span class=\"n\">cokernel</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">f</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- Since `Ab` has equalizers, we automatically get the fact that</span>\n<span class=\"c1\">-- in the factorization of `f` as `G --(factor_thru_image f)--&gt; image f --(image.ι f)--&gt; H`,</span>\n<span class=\"c1\">-- the morphism `factor_thru_image` is epic.</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">epi</span> <span class=\"o\">(</span><span class=\"n\">factor_thru_image</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span>\n\n<span class=\"c1\">-- Using this, we can build the map which is an isomorphism iff `G --f--&gt; H --g--&gt; K` is exact:</span>\n<span class=\"n\">noncomputable</span> <span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">H</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">H</span> <span class=\"err\">⟶</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"err\">≫</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">image</span> <span class=\"n\">f</span> <span class=\"err\">⟶</span> <span class=\"n\">kernel</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">kernel</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">image</span><span class=\"bp\">.</span><span class=\"n\">ι</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"o\">(</span><span class=\"n\">cancel_epi</span> <span class=\"o\">(</span><span class=\"n\">factor_thru_image</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">],</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 189957947,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583558999
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> your category theory tutorials are just way too advanced for me. The kind of questions I have are of the following nature: \"I have an object in <code>Ab</code> and as far as I can see it's a type. I have a morphism in <code>Ab</code> from this type to itself. How do I actually get hold of the map from the type to itself?\" I need some sort of \"category theory for dummies\" tutorial. Every line I write takes forever when I'm using category theory.</p>",
        "id": 189972665,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583591700
    },
    {
        "content": "<p>Ooh I've got it :-) The morphism was a heavily-disguised add_monoid_hom.</p>",
        "id": 189972717,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583591766
    },
    {
        "content": "<p>My problem is that to use category theory I instantly have to know all this exotic notation with &lt;&lt; and &lt;&lt;&lt; and so on, and somehow you have to know it all at once before you can even start. I seem to have to keep <code>category.lean</code> and <code>functor.lean</code> and <code>natural_transformation.lean</code> open at all times just so I can have access to all the notation.</p>",
        "id": 189972779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583591961
    },
    {
        "content": "<p>Maybe I should just write some basic thing and PR it.</p>",
        "id": 189973422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583593103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I added a basic section to the tutorial on <code>Ab</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">!</span>\n<span class=\"cm\"># Basic setup of the category of abelian groups</span>\n\n<span class=\"cm\">We demonstrate using the objects of `Ab`, which are bundled `add_comm_group`,</span>\n<span class=\"cm\">and the morphisms, which are `add_monoid_hom` (aka `→+`).</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">-- We decide to work in `Type 0`,</span>\n<span class=\"c1\">-- so we can work with concrete examples like `ℤ`, without using `ulift`.</span>\n<span class=\"n\">local</span> <span class=\"kn\">notation</span> <span class=\"bp\">`</span><span class=\"n\">Ab</span><span class=\"bp\">`</span> <span class=\"o\">:=</span> <span class=\"n\">Ab</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- An object of `Ab` is a bundled `add_comm_group`.</span>\n<span class=\"c1\">-- If an appropriate instance is available, we can use `AddCommGroup.of` to lift</span>\n<span class=\"c1\">-- a type to a bundled object.</span>\n<span class=\"n\">def</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span> <span class=\"o\">:=</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"bp\">ℤ</span>\n<span class=\"n\">def</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">Ab</span> <span class=\"o\">:=</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">ℚ</span>\n\n<span class=\"c1\">-- There&#39;s a coercion back from `Ab` to `Type`,</span>\n<span class=\"c1\">-- so we can just use objects in `Ab` as if they were the underlying type.</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">3</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"c1\">-- (Note in the next line we&#39;re using the usual function arrow,</span>\n<span class=\"c1\">-- not the category theory morphism arrow ⟶)</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">Q</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- Morphisms are `Ab` are just bundled morphisms, i.e. `add_monoid_hom`:</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"bp\">→+</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"err\">⟶</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"err\">⟶</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">),</span>\n  <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"c1\">-- This means we can use lemmas about `add_monoid_hom` when we need to:</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">⟶</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z₁</span> <span class=\"n\">z₂</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">z₁</span> <span class=\"bp\">+</span> <span class=\"n\">z₂</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">z₁</span> <span class=\"bp\">+</span> <span class=\"n\">f</span> <span class=\"n\">z₂</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span>\n</pre></div>\n\n\n<p>Advice (or PRs) for further content very welcome.</p>",
        "id": 189979563,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583603582
    },
    {
        "content": "<p>I'm writing basic category theory docs right now, just to let you know.</p>",
        "id": 189979574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583603609
    },
    {
        "content": "<p>Excellent! I look forward to reviewing them. :-) Thank you.</p>",
        "id": 189979581,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583603631
    },
    {
        "content": "<p>I haven't worked with bundled categories before -- <code>example : (Z →+ Q) = (Z ⟶ Q) := rfl</code> came as a pleasant surprise to me earlier today, as you probably spotted.</p>",
        "id": 189979622,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583603663
    },
    {
        "content": "<p>Curiously, I couldn't write <code>example : (Z ⟶ Q) = (Z →+ Q)  := rfl</code> (i.e. reversing the equality), which made me sad. Somehow the elaborator made bad guesses about expected types, and failed to find the category instance for <code>Z</code> and <code>Q</code>... :-(</p>",
        "id": 189979752,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583603937
    },
    {
        "content": "<p>Many thanks for this. Whilst I have got on top of the basics of categories, functors and natural transformations before, I have never used <del>bundled</del>concrete categories and from what Reid was saying this stuff is going to be critical (i.e. I really want to say \"im f = ker g\" with equality taking place in <code>set B</code> or <code>subgroup B</code> or whatever.</p>",
        "id": 189979832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583604080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189922889\" title=\"#narrow/stream/116395-maths/topic/issue.20with.20bundled.20subgroups/near/189922889\">said</a>:</p>\n<blockquote>\n<p>We have R-modules already, so it should basically be a copy-and-paste job from that. Or you could define Ext <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">single_obj</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Group</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">concrete_category</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">punit_instances</span>\n<span class=\"kn\">import</span> <span class=\"n\">G_module</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">derive</span> <span class=\"n\">large_category</span><span class=\"o\">]</span>\n<span class=\"n\">def</span> <span class=\"n\">Group_module</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">single_obj</span> <span class=\"n\">G</span> <span class=\"err\">⥤</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">unit</span><span class=\"bp\">.</span><span class=\"n\">star</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Group_module</span><span class=\"bp\">.</span><span class=\"n\">to_G_module</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G_module</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n    <span class=\"n\">intro</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"bp\">_</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">smul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"k\">show</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"err\">≫</span> <span class=\"n\">g</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">M</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">linear</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">has_scalar</span><span class=\"bp\">.</span><span class=\"n\">smul</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n  <span class=\"kn\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">G_module</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">G_module</span> <span class=\"n\">G</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">G_module_hom</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">concrete_category</span> <span class=\"o\">(</span><span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_category</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">hom</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"n\">G_module_hom</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n    <span class=\"n\">id</span>    <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n    <span class=\"n\">comp</span>  <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">C</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">forget</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n    <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n    <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">},</span>\n  <span class=\"n\">forget_faithful</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">G_module</span> <span class=\"n\">G</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">Group_module</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">{</span>\n    <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">has_scalar</span><span class=\"bp\">.</span><span class=\"n\">smul</span> <span class=\"n\">G</span> <span class=\"n\">M</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n    <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">G_module</span><span class=\"bp\">.</span><span class=\"n\">g_zero</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">G_module</span><span class=\"bp\">.</span><span class=\"n\">linear</span> <span class=\"n\">g</span>\n  <span class=\"o\">},</span>\n  <span class=\"n\">map_id&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">G_module</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">G</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_comp&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">add_monoid_hom</span><span class=\"bp\">.</span><span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">intro</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">G_module</span><span class=\"bp\">.</span><span class=\"n\">smul_smul</span> <span class=\"n\">h</span> <span class=\"n\">g</span> <span class=\"n\">m</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n  <span class=\"kn\">end</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">-- TODO: Once #1445 has merged, replace this with `has_zero_object (Module R)`</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_zero</span> <span class=\"o\">(</span><span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">of</span> <span class=\"n\">G</span> <span class=\"n\">punit</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">MM</span> <span class=\"n\">NN</span> <span class=\"n\">UU</span> <span class=\"o\">:</span> <span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">to_G_module_hom</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">MM</span> <span class=\"err\">⟶</span> <span class=\"n\">NN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">G_module_hom</span> <span class=\"n\">G</span> <span class=\"n\">MM</span> <span class=\"n\">NN</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">,</span>\n    <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">map_zero</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n    <span class=\"n\">Gmul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n      <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n      <span class=\"n\">unfold</span> <span class=\"n\">has_scalar</span><span class=\"bp\">.</span><span class=\"n\">smul</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">naturality</span> <span class=\"n\">g</span><span class=\"o\">),</span>\n        <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(),</span> <span class=\"n\">swap</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"o\">(),</span>\n      <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">MM</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"err\">≫</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">())</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n      <span class=\"n\">refl</span><span class=\"o\">,</span>\n    <span class=\"kn\">end</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">id_apply</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">MM</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">𝟙</span> <span class=\"n\">MM</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MM</span> <span class=\"bp\">→</span> <span class=\"n\">MM</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">coe_comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">MM</span> <span class=\"err\">⟶</span> <span class=\"n\">NN</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">NN</span> <span class=\"err\">⟶</span> <span class=\"n\">UU</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">f</span> <span class=\"err\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MM</span> <span class=\"bp\">→</span> <span class=\"n\">UU</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"n\">def</span> <span class=\"n\">hom_is_module_hom</span> <span class=\"o\">{</span><span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:</span> <span class=\"n\">Group_module</span> <span class=\"n\">G</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"err\">⟶</span> <span class=\"n\">M₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">G_module_hom</span> <span class=\"n\">G</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n</pre></div>\n\n\n<p>I can concrete categories! That took me a long time, and it wasn't quite as simple as it might have been because <code>M ⟶ N</code> is defeq to R-module homs in the R-module case, whereas the G-modules are defined as this functor category so we have to make the coercion to G-module homs explicitly (it took me a while to spot this subtlety).</p>\n<p>The only other thing I didn't really understand was how in mathlib they get away with <a href=\"https://github.com/leanprover-community/mathlib/blob/b7444b03574bb37a182229a3bcecf61d038d8237/src/algebra/category/Module/basic.lean#L43\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/b7444b03574bb37a182229a3bcecf61d038d8237/src/algebra/category/Module/basic.lean#L43\">this</a>. I don't understand that line. The analogous definition in the code above takes me 15 lines and I need an <code>@</code> at some point.</p>",
        "id": 190022984,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583691931
    },
    {
        "content": "<p>OK so now I can get started with the super-important things I needed to do this weekend, at 6:25pm on Sunday evening :-/ I guess I shouldn't be doing work at weekends anyway :-)</p>",
        "id": 190023032,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583691980
    },
    {
        "content": "<p><code>G_module</code> is some private thing you have?</p>",
        "id": 190023496,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583692951
    },
    {
        "content": "<p>You've done something a little strange: defined G-modules as functors from G to Ab, but then defined morphisms as some hand-rolled thing, rather than just natural transformations.</p>",
        "id": 190023552,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693078
    },
    {
        "content": "<p>Do we have group rings in mathlib?</p>",
        "id": 190023626,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693282
    },
    {
        "content": "<p>They are <code>finsupp</code></p>",
        "id": 190023806,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583693618
    },
    {
        "content": "<p>Where is the multiplication defined?</p>",
        "id": 190023810,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693632
    },
    {
        "content": "<p>It can't possibly be <code>finsupp</code>, because the only sensible multiplication there is pointwise.</p>",
        "id": 190023867,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693686
    },
    {
        "content": "<p>Surely!?</p>",
        "id": 190023871,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693694
    },
    {
        "content": "<p>Oh dear. :-)</p>",
        "id": 190023878,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693713
    },
    {
        "content": "<p>Now I remember Yury proposing that we change this.</p>",
        "id": 190023884,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693732
    },
    {
        "content": "<p>This is <a href=\"https://github.com/leanprover-community/mathlib/issues/1864\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/1864\">#1864</a>.</p>",
        "id": 190023927,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693768
    },
    {
        "content": "<p>What a mess.</p>",
        "id": 190023933,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693776
    },
    {
        "content": "<p>Ugh... the convolution product which is the current notion of multiplication on <code>finsupp</code> assumes the domain is an additive monoid.<br>\nAre we going to have two different versions, <code>monoid_algebra</code> and <code>add_monoid_algebra</code>? I guess yes. Then we'll build polynomials on top of <code>add_monoid_algebra</code>, and group rings on top of <code>monoid_algebra</code>.</p>",
        "id": 190024021,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583693944
    },
    {
        "content": "<p>Do we know what notations we would want for <code>monoid_algebra</code>?</p>",
        "id": 190024315,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583694541
    },
    {
        "content": "<p>I'd love to be able to write <code>k[G]</code>.</p>",
        "id": 190024319,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583694550
    },
    {
        "content": "<p>Actually, maybe <code>add_monoid_algebra</code> is an unnecessary distraction. How awkward would it be to say that polynomials over R are the group ring for the multiplicative monoid <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><msup><mi>t</mi><mi>n</mi></msup><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{t^n\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathdefault\">t</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span></span></span></span><span class=\"mclose\">}</span></span></span></span>?</p>",
        "id": 190024393,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583694681
    },
    {
        "content": "<p>It is quite unnatural to say that the monoid indexing monomials is an additive monoid.</p>",
        "id": 190024403,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583694716
    },
    {
        "content": "<p>Pointwise multiplication is actually not that sensible because it is generally not unital</p>",
        "id": 190025263,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583696376
    },
    {
        "content": "<p>I think <code>finsupp (multiplicative nat)</code> sounds fine for polynomials.</p>",
        "id": 190025314,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583696415
    },
    {
        "content": "<p>I agree though that Kevin did something odd. Actually, there are two category instances in this code. One from large_category and one from concrete_category.</p>",
        "id": 190025324,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583696488
    },
    {
        "content": "<p>Since you already have G_module, you could just not bother with the functor stuff.</p>",
        "id": 190025380,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583696583
    },
    {
        "content": "<p>So --- your suggestion is to ignore pointwise multiplication</p>",
        "id": 190026144,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583698039
    },
    {
        "content": "<p>but to switch the convolution product to assuming a monoid, rather than an add_monoid</p>",
        "id": 190026147,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583698058
    },
    {
        "content": "<p>and replacing <code>nat</code> with <code>multiplicative nat</code> for polynomials? (and corresponding changes for mv_polynomials)</p>",
        "id": 190026149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583698075
    },
    {
        "content": "<p>and then we can naturally define group rings?</p>",
        "id": 190026186,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583698085
    },
    {
        "content": "<p>I think so</p>",
        "id": 190026200,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583698157
    },
    {
        "content": "<p>The G-module structure is from a student project. Do I not need the concrete category instance? I was just playing around without thinking</p>",
        "id": 190026247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583698254
    },
    {
        "content": "<p>I'm not sure why you would ever need it actually. Does the rest of your code work if you delete the whole instance?</p>",
        "id": 190026361,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583698481
    },
    {
        "content": "<p>Sorry it's not runnable by anyone else though. It's currently a fork of a student project and I'm reluctant to make it public because I want the student to do the work, not me!</p>",
        "id": 190026491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583698750
    },
    {
        "content": "<p>So I guess what I was hoping to get from the concrete category construction was some way of coercing from hom sets to functions. But I think that right from the offset the definition of G-module means that the hom sets can not be defeq to functions -- but on the other hand one can use coercions. I now understand coercions sufficiently well not to be scared about this.</p>",
        "id": 190027554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583700769
    },
    {
        "content": "<p><code>multiplicative nat</code> is just a disaster. The definitional equality leaks through everywhere, and it's a mess.</p>",
        "id": 190030441,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583706179
    },
    {
        "content": "<p>At this point I think it may just be easier to define <code>monoid_algebra</code> and <code>add_monoid_algebra</code> separately. :-(</p>",
        "id": 190030448,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583706239
    },
    {
        "content": "<p>Kevin, maybe by now you've worked this out but the coercion setup is not related to the concrete_category instance</p>",
        "id": 190030709,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583706729
    },
    {
        "content": "<p>Right -- I've remind the concrete category instance and my coercions are still working fine.</p>",
        "id": 190032246,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583709667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, I just made a draft PR showing how I'd define <code>GroupModule</code> as </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">GroupModule</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">AddCommGroup</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">ρ</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"err\">⟶</span> <span class=\"n\">Group</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"n\">Aut</span> <span class=\"n\">V</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>and the obvious definitions following from that.</p>\n<p>Mostly for discussion and comparison for now.</p>",
        "id": 190144642,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1583820343
    },
    {
        "content": "<p>oh, this is my first time hearing about draft PRs, perhaps they can replace [WIP] PRs?</p>",
        "id": 190144688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583820386
    },
    {
        "content": "<p>eh, on second thought, it looks to not support some <a href=\"https://github.community/t5/How-to-use-Git-and-GitHub/Feature-Request-Switch-from-ready-to-draft-in-pull-requests/td-p/19107\" target=\"_blank\" title=\"https://github.community/t5/How-to-use-Git-and-GitHub/Feature-Request-Switch-from-ready-to-draft-in-pull-requests/td-p/19107\">basic features</a>, and <a href=\"https://github.com/wip/app\" target=\"_blank\" title=\"https://github.com/wip/app\">https://github.com/wip/app</a> is a simpler alternative</p>",
        "id": 190144875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583820800
    }
]
[
    {
        "content": "<p>I'm thinking about how to extend <code>ring_theory.ideal.basic</code> to cover two-sided ideals for non-commutative rings. Until recently, <code>ideal</code> was only defined for <code>comm_semiring</code>s, and now it is defined as left-ideals of (non-commutative) <code>semiring</code>s as <code>submodule R R</code>. What would be a good way to define two-sided ideals for <code>semiring</code>s? I can think of two options:</p>\n<ul>\n<li>Define a new structure <code>lrideal</code>, so that lots of lemmas for <code>submodule</code> would have to be copied over.</li>\n<li>Treat two-sided ideals as left-ideals (<code>ideal</code>) with an additional hypothesis that it's closed under right multiplication by ring elements.<br>\nAre there more approaches? I'm not experienced enough to tell which is a better approach.</li>\n</ul>",
        "id": 252119802,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630896433
    },
    {
        "content": "<p>To make matters worse, there is the third option of defining two sided ideals to be left ideals under the R (x) R^op action.</p>",
        "id": 252125567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630902805
    },
    {
        "content": "<p>Do you mean <code>forall (x in I) (r in R), r * x * r in I</code>? Isn't that a bit weaker than a two-sided ideal?</p>",
        "id": 252126667,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630904131
    },
    {
        "content": "<p>I might go with defining a new structure and show equivalence for other approaches</p>",
        "id": 252126773,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630904254
    },
    {
        "content": "<p>Scott means <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∀</mi><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>∈</mo><mi>R</mi><mo>×</mo><msup><mi>R</mi><mtext>op</mtext></msup><mo separator=\"true\">,</mo><mi mathvariant=\"normal\">∀</mi><mi>x</mi><mo>∈</mo><mi>I</mi><mo separator=\"true\">,</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mo separator=\"true\">,</mo><mi>s</mi><mo stretchy=\"false\">)</mo><mo>∙</mo><mi>x</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">\\forall (r,s) \\in R \\times R^{\\text{op}}, \\forall x \\in I, (r,s) \\bullet x \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∀</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord text mtight\"><span class=\"mord mtight\">op</span></span></span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∀</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∙</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, which unfolds to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo>∗</mo><mi>x</mi><mo>∗</mo><mi>s</mi><mo>∈</mo><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">r * x * s \\in I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span>.</p>",
        "id": 252127090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630904525
    },
    {
        "content": "<p>Actually I'll try using this for the moment to avoid defining new things, and see how annoying it gets down the road</p>",
        "id": 252127206,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630904673
    },
    {
        "content": "<p>I think the agreement before was that (two-sided) ideals should be defined as a special case of bimodules (like left ideals are defined as a special class of modules). Let me paste some private communication with Aaron here: \"Bimodules could be easy (<code>smul_comm_class</code> is already there) but subbimodules are confusing. Basically, I think we might have to go down to the bottom of that hierarchy, going through <code>bi_mul_action</code> etc. Here's the discussion from last December: <a href=\"#narrow/stream/116395-maths/topic/Bimodules\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bimodules</a> \"</p>",
        "id": 252129363,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1630907158
    },
    {
        "content": "<p>Hmm, that's an interesting idea, to start all the way down at <code>bi_mul_action</code>.</p>",
        "id": 252129521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630907295
    },
    {
        "content": "<p>Just looked through the thread you linked. Very interesting! So the idea is to implement <code>bi_mul_action</code>, etc, <code>bi_module</code>, as well as their corresponding sub-objects? Then, two-sided ideal would just be <code>sub_bi_module R R^op R</code>?</p>",
        "id": 252131525,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630909147
    },
    {
        "content": "<p><del> <code>bi_submodule R R^op R</code>, I guess. </del></p>",
        "id": 252131683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630909270
    },
    {
        "content": "<p>Yes, of course</p>",
        "id": 252131704,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630909297
    },
    {
        "content": "<p>Sounds like a lot of work but I'm happy to look into this a bit</p>",
        "id": 252131773,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630909327
    },
    {
        "content": "<p>And at every stage, we define type class instances for the corresponding \"non-bi\" objects for the left multiplication and right multiplication</p>",
        "id": 252131830,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630909399
    },
    {
        "content": "<p>I would be very happy to have a proper theory of bimodules. They are, of course, the fundamental objects. (The R (x) R^op trick I mentioned of course only works in a braided category. :-)</p>",
        "id": 252137102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630913388
    },
    {
        "content": "<p><a href=\"https://m.youtube.com/watch?v=GsDGvwhxq5U\">https://m.youtube.com/watch?v=GsDGvwhxq5U</a> has a discussion of right actions and bimodules in the future work section</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"GsDGvwhxq5U\" href=\"https://m.youtube.com/watch?v=GsDGvwhxq5U\"><img src=\"https://uploads.zulipusercontent.net/74fefdcaa2bdd7e18ebd5674f9ab920aa2217e0d/68747470733a2f2f692e7974696d672e636f6d2f76692f47734447767768787135552f64656661756c742e6a7067\"></a></div>",
        "id": 252144757,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630917785
    },
    {
        "content": "<p>I like your proposed notation <code>&lt;•</code> for the right scalar action. Maybe we should even introduce <code>•&gt;</code> as an alias for <code>•</code>.</p>",
        "id": 252156362,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630924253
    },
    {
        "content": "<p>Mirroring <code>module</code> and <code>submodule</code>, this would be the overall structure of <code>bimodule</code> and <code>sub_bimodule</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.defs</span>\n<span class=\"kn\">import</span> <span class=\"n\">group_theory.submonoid.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.opposites</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">notation</span> <span class=\"n\">m</span> <span class=\"bp\">`</span> <span class=\"bp\">•ᵣ</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">72</span> <span class=\"n\">a</span><span class=\"o\">:</span><span class=\"mi\">72</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">m</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bi_mul_action</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">α</span> <span class=\"n\">γ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">β</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">one_smul_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">one_smul_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"bp\">•ᵣ</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_smul_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">c</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">•</span> <span class=\"n\">y</span> <span class=\"bp\">•</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_smul_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">γ</span><span class=\"o\">),</span> <span class=\"n\">c</span> <span class=\"bp\">•ᵣ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">c</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">y</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bi_distrib_mul_action</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_monoid</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">M</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">N</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">bi_mul_action</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_add_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_zero_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_add_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_zero_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">bimodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">bi_distrib_mul_action</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_smul_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero_smul_l</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">add_smul_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">r</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">zero_smul_r</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span>\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">sub_bi_mul_action</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_mem_l'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_mem_r'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">•ᵣ</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">sub_bimodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"kd\">extends</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">sub_bi_mul_action</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lrideal</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">sub_bimodule</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>How does this look? Btw, the <code>&lt;•</code> suggestion is great!</p>",
        "id": 252158567,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630925697
    },
    {
        "content": "<p>Hopefully Eric will give an opinion: I suspect he's thought about this the most so far.</p>\n<p>A minor request: could we write <code>bimodule R M S</code> instead (i.e. the rings on either side of the bimodule), just like in the mathematical notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow></mrow><mi>R</mi></msub><msub><mi>M</mi><mi>S</mi></msub></mrow><annotation encoding=\"application/x-tex\">{}_R M_S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord\"></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>?</p>",
        "id": 252159206,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1630926063
    },
    {
        "content": "<p><a href=\"https://m.youtube.com/watch?v=GsDGvwhxq5U\">https://m.youtube.com/watch?v=GsDGvwhxq5U</a> has a discussion of right actions and bimodules in the future work section</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"GsDGvwhxq5U\" href=\"https://m.youtube.com/watch?v=GsDGvwhxq5U\"><img src=\"https://uploads.zulipusercontent.net/74fefdcaa2bdd7e18ebd5674f9ab920aa2217e0d/68747470733a2f2f692e7974696d672e636f6d2f76692f47734447767768787135552f64656661756c742e6a7067\"></a></div>",
        "id": 252170820,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630932636
    },
    {
        "content": "<p>The classes should probably extend has_scalar, similar to how mul_action does.</p>",
        "id": 252177377,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630935682
    },
    {
        "content": "<p>And should be generalized to \"mul_one_class\" etc</p>",
        "id": 252177499,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1630935738
    },
    {
        "content": "<p>(apologies, I have no idea why zulip sent that twice hours apart)</p>",
        "id": 252179063,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630936535
    },
    {
        "content": "<p>I think having a separate <code>bimodule R S M</code> typeclass is probably as reasonable as having <code>integral_domain</code> in that it is just a shorthand for a collection of typeclasses. But most lemmas would probably end up stated about the three separate typeclasses, since then you can relax them individually. If we have it, it should provide a <code>bimodule.to_module : module R M</code> and <code>bimodule.to_right_module : module Sᵒᵖ M</code></p>",
        "id": 252184870,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630939240
    },
    {
        "content": "<p>So not as you have it written above</p>",
        "id": 252185027,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630939316
    },
    {
        "content": "<p>Can we make <code>open_locale bimodule</code> change the pretty printer to use <code>•&gt;</code> for <code>•</code> and add the other notation?</p>",
        "id": 252185181,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630939378
    },
    {
        "content": "<p>Ooh, that would be sweet!</p>",
        "id": 252185444,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630939500
    },
    {
        "content": "<p>(for the record, I think that having <a href=\"https://leanprover-community.github.io/mathlib_docs/find/integral_domain\">docs#integral_domain</a> is annoying because if you have only <code>comm_ring</code>, <code>no_zero_divisors</code> and <code>nontrivial</code> you have to insert an awkward <code>letI</code> because typeclass search can't deal with the loops formed by two different ways to express the same thing; but there's clear pedagogical value to <code>integral_domain</code> as a spelling - the same view applies to <code>bimodule</code>)</p>",
        "id": 252231334,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630969827
    },
    {
        "content": "<p>My above comment about <code>bimodule.to_module</code> is wrong; it produces a dangerous instance. I think the best approach would be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">right_module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">bimodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 252231824,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1630970367
    },
    {
        "content": "<p>What I've tried so far is to define <code>bimodule</code> as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">bimodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">extends</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 252241870,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630980891
    },
    {
        "content": "<p>This way, writing <code>bimodule R M S</code> would require first <code>module R M</code> and <code>module Sᵒᵖ M</code></p>",
        "id": 252242096,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630981123
    },
    {
        "content": "<p>I then defined</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span>\n<span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">module_RM</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module_SM</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_left_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">module_RM</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_right_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">module_SM</span>\n</code></pre></div>",
        "id": 252242123,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630981161
    },
    {
        "content": "<p>Avoiding dangerous type class instances</p>",
        "id": 252242195,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630981213
    },
    {
        "content": "<p><code>sub_bimodule</code> is defined as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">sub_bimodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"kd\">extends</span> <span class=\"n\">add_submonoid</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_mem_l'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">•</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">smul_mem_r'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">},</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;•</span> <span class=\"n\">c</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Then some lemmas for <code>submodule</code> just have to be duplicated with <code>_l</code> and <code>_r</code> versions</p>",
        "id": 252242390,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630981425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"416472\">Winston Yin</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/252242123\">said</a>:</p>\n<blockquote>\n<p>I then defined</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span>\n<span class=\"bp\">...</span> <span class=\"o\">[</span><span class=\"n\">module_RM</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module_SM</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">bimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_left_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">module_RM</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_right_module</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">module_SM</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>What is the benefit of this? After all the instance was already there as assumption.<br>\nThis would make sense if you <code>extends module R M, module Sᵒᵖ M, smul_comm_class R Sᵒᵖ M</code></p>",
        "id": 252250118,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1630989378
    },
    {
        "content": "<p>You're right...</p>",
        "id": 252262921,
        "sender_full_name": "Winston Yin",
        "timestamp": 1630999884
    },
    {
        "content": "<p>I would mildly caution against having <code>bimodule</code> actually take <code>[module R M]</code> assumptions; I think there's a lower risk of pain down the road (like we experienced with the old <code>module</code>/<code>semimodule</code> split) if you simply assume <code>[has_scalar R M]</code> instead, even though that's somewhat misleading</p>",
        "id": 252263991,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1631000532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"416472\">@Winston Yin</span> Has this made it into a PR yet?</p>",
        "id": 259496034,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635496401
    },
    {
        "content": "<p>Any opinions on changing <code>compatible_smul</code> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_tmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>in the long run, given we make sure that <code>op r</code> properly simplifies to <code>r</code> in the case of commutative rings?</p>",
        "id": 259727782,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635596246
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.compatible_smul\">docs#tensor_product.compatible_smul</a> for reference</p>",
        "id": 259730014,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599231
    },
    {
        "content": "<p>Presumably once we start thinking about tensor products of bimodules, we first need to change <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.eqv.of_smul\">docs#tensor_product.eqv.of_smul</a> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">of_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">eqv</span>\n    <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and have tensor products require <code>[module Rᵒᵖ M] [module R N]</code></p>",
        "id": 259730118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599377
    },
    {
        "content": "<p>Or do I have the convention backwards? It seems natural to me to put the scalar in the middle so that <code>(m &lt;• r) ⊗ₜ n = m ⊗ₜ[R] (r •&gt; n)</code> where <code>r : R</code>, but convention wins over my personal opinion of what is natural</p>",
        "id": 259730228,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635599480
    },
    {
        "content": "<p>Hmm, I think we have a problem here. In the bimodule world where <code>M</code> is an <code>S-R</code> bimodule and <code>N</code> is an <code>R-T</code> bimodule, we presumably want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span>\n<span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>       <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, the latter case matches the former case with <code>s = op t</code>, and while probably gives a propositionally equal action in the cases where typeclasses match, certainly does not give a definitionally equal one.</p>",
        "id": 259731253,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635600648
    },
    {
        "content": "<p>I don't necessaily need bimodules, just the tensor product for modules on non-commutative rings, even if it doesn't bear an <code>R</code>-action itself</p>",
        "id": 259733947,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259730118\">said</a>:</p>\n<blockquote>\n<p>Presumably once we start thinking about tensor products of bimodules, we first need to change <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.eqv.of_smul\">docs#tensor_product.eqv.of_smul</a> to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">|</span> <span class=\"n\">of_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">eqv</span>\n    <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">free_add_monoid.of</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and have tensor products require <code>[module Rᵒᵖ M] [module R N]</code></p>\n</blockquote>\n<p>Yes, that's a change I also did locally</p>",
        "id": 259733961,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604282
    },
    {
        "content": "<p>The issue is that in the commutative case we have everything cluttered with <code>op</code> and <code>ᵒᵖ</code> then <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 259734109,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635604407
    },
    {
        "content": "<p>Maybe changing the definition of <code>tensor_product</code> but creating an instance of <code>compatible_smul R R M N</code> for the commutative case could be an option. (The instance requires transfering all sorts of classes, like <code>module R M</code> to <code>module Rᵒᵖ M</code>)</p>",
        "id": 259737851,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635609401
    },
    {
        "content": "<p>I think this issue is part of a bigger one: How do we reconcile commutative algebraic structures with their <code>op</code>s? Since <code>opposite</code> is irreducible we can't state <code>r = opposite.op r</code> without a cast...</p>",
        "id": 259748457,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635623440
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">section</span> <span class=\"n\">comm_op</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">def</span> <span class=\"n\">comm_op</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">opposite.op</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">comm_op</span>\n</code></pre></div>\n<p>This seems to be a way?</p>",
        "id": 259749718,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635625378
    },
    {
        "content": "<p>That's solving the wrong problem</p>",
        "id": 259752346,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629165
    },
    {
        "content": "<p>You want lean to know that <code>op r • m = r • m</code></p>",
        "id": 259752353,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629182
    },
    {
        "content": "<p>Rewriting <code>op r</code> to <code>r</code> just makes things worse, because your statement was originally</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">opposite.has_scalar</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>but your lemma turns it into the very wrong</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">opposite.has_scalar</span> <span class=\"n\">r</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">_</span> <span class=\"n\">r</span> <span class=\"n\">m</span>\n</code></pre></div>\n<p>which is using <code>R</code>, but the action from <code>opposite R</code></p>",
        "id": 259752433,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629300
    },
    {
        "content": "<p>We need a typeclass that says the left and right actions are the same</p>",
        "id": 259752437,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629313
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n<li><code>is_symmetric_smul R (prod A B)</code> when <code>is_symmetric_smul R A</code> and <code>is_symmetric_smul R B</code></li>\n<li><code>pi</code></li>\n<li><code>ulift</code></li>\n<li>...</li>\n<li>probably most of the things we currently have <code>has_scalar</code> instances for.</li>\n</ul>",
        "id": 259752553,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635629506
    },
    {
        "content": "<p>Do you think it's still reasonable to have both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul_op</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_tmul_op</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">compatible_smul</span> <span class=\"o\">[</span><span class=\"n\">distrib_mul_action</span> <span class=\"n\">R'</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">smul_tmul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>with <code>is_symmetric_smul</code> present?</p>",
        "id": 259778794,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635672205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259752553\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n</ul>\n</blockquote>\n<p>You mean what we need is the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>But then at this point we do need a (low priority? local?) instance for<code>has_scalar (opposite R) α</code></p>",
        "id": 259782218,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635677887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259752553\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"k\">forall</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>You'll then want to add instances for:</p>\n<ul>\n<li><code>is_symmetric_smul R R</code> when <code>comm_semigroup R</code></li>\n</ul>\n</blockquote>\n<p>You mean what we need is the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>But then at this point we do need a (low priority? local? we want to keep the option of having a right action that's different from the left action, even if <code>R</code> is commutative, right?) instance for<code>has_scalar (opposite R) α</code></p>",
        "id": 259782241,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635677952
    },
    {
        "content": "<p>I'm not sure we need both, I'd focus on adding the first one and then reassess</p>",
        "id": 259782716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678616
    },
    {
        "content": "<p>The <code>is_symmetric_smul R α</code> instance you suggest doesn't type check, there's no <code>has_scalar Rᵒᵖ α</code> for it to be about</p>",
        "id": 259782737,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678668
    },
    {
        "content": "<p>Which is why I said you only want the <code>R R</code> instance</p>",
        "id": 259782740,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635678690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259782737\">said</a>:</p>\n<blockquote>\n<p>The <code>is_symmetric_smul R α</code> instance you suggest doesn't type check, there's no <code>has_scalar Rᵒᵖ α</code> for it to be about</p>\n</blockquote>\n<p>Yes, an instance for <code>has_scalar Rᵒᵖ α</code> given <code>has_scalar R α</code> what I suggested adding...</p>",
        "id": 259782966,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635679049
    },
    {
        "content": "<p>Oh, we do not need that instance</p>",
        "id": 259783051,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679202
    },
    {
        "content": "<p><code>has_scalar Rᵒᵖ R</code> is enough, and we already have that</p>",
        "id": 259783091,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679227
    },
    {
        "content": "<p>For instance, <code>has_scalar Rᵒᵖ (fin 3 → R)</code> can be found today via <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 259783101,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635679261
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259733947\">said</a>:</p>\n<blockquote>\n<p>I don't necessaily need bimodules, just the tensor product for modules on non-commutative rings, even if it doesn't bear an <code>R</code>-action itself</p>\n</blockquote>\n<p>Right, just like for linear maps. Even when the scalars are non-commuative we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.add_comm_monoid\">docs#linear_map.add_comm_monoid</a> but we need some form of commutativity for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.module\">docs#linear_map.module</a></p>",
        "id": 259783353,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1635679654
    },
    {
        "content": "<p>I haven't studied this thread carefully enough to understand your objectives beyond noting you want tensor product with non-commutative scalars (which I too would love to have) but this old thread of mine might also be food for thought:<br>\n<a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929318</a></p>",
        "id": 259783472,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1635679844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783091\">said</a>:</p>\n<blockquote>\n<p><code>has_scalar Rᵒᵖ R</code> is enough, and we already have that</p>\n</blockquote>\n<p>I think I don't quite get the connection yet. Does this involve defining <code>op r • m</code> by <code>(op r • (1 : R)) • m</code>?</p>",
        "id": 259783526,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635679968
    },
    {
        "content": "<p>No, what I said above doesn't; but we can use that to almost get away without <code>is_symmetric_smul</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">group_theory.group_action.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.opposites</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.module.prod</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">opposite</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">comm_semigroup.op_is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">opposite.rec</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">a'</span><span class=\"o\">,</span> <span class=\"n\">mul_right_comm</span> <span class=\"n\">b</span> <span class=\"n\">a'</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- this works around a typeclass bug in pi types</span>\n<span class=\"kd\">instance</span> <span class=\"n\">comm_monoid.op_is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"n\">comm_semigroup.op_is_scalar_tower</span>\n\n<span class=\"c1\">-- we were able to prove this without `is_symmetric_smul`</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_assoc</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">r</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">smul_smul</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"n\">mul_one</span><span class=\"o\">]</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">×</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"mi\">3</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"o\">:=</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span>  <span class=\"c1\">-- needs the workaround above</span>\n</code></pre></div>\n<p>we still need it if we want to talk about actions by non-monoids</p>",
        "id": 259783586,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680099
    },
    {
        "content": "<blockquote>\n<p>I think I don't quite get the connection yet</p>\n</blockquote>\n<p>Can you give me an example of something that doesn't have a right action today, but should?</p>",
        "id": 259783599,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680124
    },
    {
        "content": "<p>My claim is that the instance you suggest would just conflict with ones we already have, and there's no situation that you need it anyway</p>",
        "id": 259783603,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783599\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think I don't quite get the connection yet</p>\n</blockquote>\n<p>Can you give me an example of something that doesn't have a right action today, but should?</p>\n</blockquote>\n<p>No I was just saying that I don't quite understand yet how the <code>has_scalar Rᵒᵖ R</code> instance actually helps making sense of <code>op r • m</code></p>",
        "id": 259783679,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680276
    },
    {
        "content": "<p>Because for almost every choice of <code>m</code> you make, there's already an action<code>has_scalar Rᵒᵖ M</code> defined in terms of <code>has_scalar Rᵒᵖ R</code></p>",
        "id": 259783723,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680311
    },
    {
        "content": "<p>Where is it defined?</p>",
        "id": 259783733,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680366
    },
    {
        "content": "<p>In the same place as <code>has_scalar R M</code></p>",
        "id": 259783744,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680389
    },
    {
        "content": "<p>The location of which depends on your choice of <code>M</code>. See for instance <a href=\"https://leanprover-community.github.io/mathlib_docs/find/prod.has_scalar\">docs#prod.has_scalar</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.has_scalar\">docs#pi.has_scalar</a></p>",
        "id": 259783746,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680394
    },
    {
        "content": "<p>I'm completely lost.</p>",
        "id": 259783840,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680533
    },
    {
        "content": "<p>Pick a concrete example of R and M and I can show you</p>",
        "id": 259783847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635680553
    },
    {
        "content": "<p>What do you mean by concrete? I want to <code>M</code> to be an arbitrary <code>R</code>-module</p>",
        "id": 259784082,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680785
    },
    {
        "content": "<p>I just don't get what <code>has_scalar Rᵒᵖ R</code> has to do with this if we don't have a full <code>scalar_tower Rᵒᵖ R M</code></p>",
        "id": 259784092,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635680862
    },
    {
        "content": "<p>By concrete I mean <code>M = R × R</code>, <code>M = polynomial R</code> etc. I don't understand the question you're asking</p>",
        "id": 259784214,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681084
    },
    {
        "content": "<p>Under the original proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"o\">(</span><span class=\"n\">opposite</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">comm_semigroup.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">mul_comm</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">prod.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">β</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">×</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">prod.ext</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">pi.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩</span>\n\n<span class=\"c1\">-- hack that hopefully lean4 doesn't need</span>\n<span class=\"kd\">instance</span> <span class=\"n\">function.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">pi.is_symmetric_smul</span>\n</code></pre></div>\n<p>Any lemma about a symmetric bimodule would be stated as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">some_lemma</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 259784279,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681178
    },
    {
        "content": "<p>You don't need to worry about where <code>module Rᵒᵖ M</code> comes from, that's the caller's problem</p>",
        "id": 259784292,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681236
    },
    {
        "content": "<p>And the caller either:</p>\n<ol>\n<li>Is working with a concrete type, and so has the instance available</li>\n<li>Is working on a variable type, so passes the obligation on to <em>their</em> caller</li>\n</ol>",
        "id": 259784338,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681278
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 259784346,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681299
    },
    {
        "content": "<p>I thought you meant that in order to have</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semigroup</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>instead of adding an argument <code>has_scalar Rᵒᵖ α</code>, an argument <code>has_scalar Rᵒᵖ R</code> would be enough.</p>",
        "id": 259784411,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681449
    },
    {
        "content": "<p>But I guess you said we shouldn't have that instance at all? So everyone using tensor products as before would have to supply the <code>is_symmetric_smul</code>?</p>",
        "id": 259784483,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681595
    },
    {
        "content": "<p>You don't need <code>is_symmetric_smul</code> to use <code>tensor_product</code>; only the lemmas that require it</p>",
        "id": 259784605,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681674
    },
    {
        "content": "<p>Okay, I guess now I get it. I'll see how much need for refactoring this causes outside of <code>linear_algebra.tensor_product</code>...</p>",
        "id": 259784651,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635681726
    },
    {
        "content": "<p>Unfortunately there's <a href=\"#narrow/stream/113488-general/topic/instance.20lookup.20on.20function.20types/near/259784151\">a nasty typeclass issue</a> that looks like it makes both <code>is_symmetric_smul</code> and <code>[is_scalar_tower Rᵒᵖ R M]</code> <del>non-viable</del> quite annoying (until lean4)</p>",
        "id": 259784728,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635681908
    },
    {
        "content": "<p>I edited the message above with some <code>is_symmetric_smul</code> instances to get you started</p>",
        "id": 259784793,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635682017
    },
    {
        "content": "<p>Thanks for all the help!</p>",
        "id": 259843662,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635759942
    },
    {
        "content": "<p>One thing that's not obvious to me is how to fix the following: The current construction of <code>compatible_smul.is_scalar_tower</code> now needs the following instance to go through:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">has_scalar_op_op</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">R'</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R'</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_scalar</span> <span class=\"n\">R'</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r'</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">opposite.op</span> <span class=\"o\">(</span><span class=\"n\">opposite.unop</span> <span class=\"n\">r'</span> <span class=\"bp\">•</span> <span class=\"n\">opposite.unop</span> <span class=\"n\">r</span><span class=\"o\">)⟩</span>\n</code></pre></div>\n<p>It fails if the instance of <code>has_scalar R'ᵒᵖ Rᵒᵖ</code> is anything other than this, because we need <code>op (r • b) = op r • op b</code>. But then,  <code>compatible_smul.is_scalar_tower</code> doesn't generalise to <code>compatible_smul R R M N</code> anymore because <code>mul_action.is_scalar_tower.left</code> uses an instance of <code>has_scalar Rᵒᵖ Rᵒᵖ</code> which is not defeq to <code>has_scalar_op_op</code>. I solved this by just adding a manual <code>compatible_smul.self : compatible_smul R R M N</code>, but the previous construction was obviously a bit nicer...</p>",
        "id": 259844105,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635760256
    },
    {
        "content": "<p>Your <code>has_scalar_op_op</code> instance looks dangerous to me</p>",
        "id": 259857909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635769956
    },
    {
        "content": "<p>Well it's needed to make sense of <code>is_scalar_tower R'ᵒᵖ Rᵒᵖ N</code> in this context. But maybe we should keep it local?</p>",
        "id": 259861521,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635772403
    },
    {
        "content": "<p>My hunch is that you probably should take <code>[has_scalar R'ᵒᵖ R ]</code> as an argument there too; and if you need it to satisfy <code>op (r • b) = op r • op b</code>, then work out a way to express that with typeclasses</p>",
        "id": 259882663,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635782701
    },
    {
        "content": "<p>Adding <code>compatible_smul.self</code> seems like a much more conservative bet than adding your instance</p>",
        "id": 259882826,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635782770
    },
    {
        "content": "<blockquote>\n<p>then work out a way to express that with typeclasses</p>\n</blockquote>\n<p>Here's that way:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c1\">-- you need this instance</span>\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">unop_injective</span> <span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">r</span> <span class=\"n\">m.unop</span> <span class=\"o\">:</span> <span class=\"n\">_</span><span class=\"o\">)⟩</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">op</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">op</span> <span class=\"n\">m</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">op_smul_eq_smul</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">m</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n</code></pre></div>",
        "id": 259883823,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635783237
    },
    {
        "content": "<p>Perhaps it's worth pointing out the difference between your \"add an instance\" and my \"add an instance\"; you're adding data instances which can introduce diamonds and incompatible actions, my instances are only proofs, so can't introduce these things.</p>",
        "id": 259884025,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635783341
    },
    {
        "content": "<p>That's a neat idea.</p>",
        "id": 259890542,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635786080
    },
    {
        "content": "<p>It does away with the need for the double-op instance. I doesn't solve the issue of needing a separate <code>compatible_smul.self : compatible_smul R R M N</code>, though since that would require <code>is_symmetric_smul R R</code> which sounds like a bad idea for non-commutative rings</p>",
        "id": 259891672,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635786590
    },
    {
        "content": "<p><code>is_symmetric_smul R R</code> isn't true on non-commutative rings</p>",
        "id": 259898913,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790202
    },
    {
        "content": "<p>And I don't think <code>compatible_smul R R M N</code> is either, although I don't know what your new definition of <code>compatible_smul</code> is</p>",
        "id": 259899030,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790241
    },
    {
        "content": "<p>Do you have a branch you're working on this in?</p>",
        "id": 259899601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1635790531
    },
    {
        "content": "<p>Not yet, I'll push it later on</p>",
        "id": 259904007,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635792510
    },
    {
        "content": "<p>I pushed my state of things <a href=\"https://github.com/javra/mathlib/tree/noncomm_tensor_product\">here</a>, but there's so much left do be done, and I haven't even started to check where things break in other files</p>",
        "id": 260111791,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1635934109
    },
    {
        "content": "<p>Ah, I just noticed it's more canonical to assume that <code>R</code> operates on the right on <code>M</code> and not on <code>N</code>, so I made some bad choices here...</p>",
        "id": 260262759,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636029197
    },
    {
        "content": "<p>I thought that was what you had?</p>",
        "id": 260271828,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636033923
    },
    {
        "content": "<p>Ah nevermind, you fixed it in <a href=\"https://github.com/javra/mathlib/commit/efea1e30f00a9237590e134bb029ee2d67a5d75b\">https://github.com/javra/mathlib/commit/efea1e30f00a9237590e134bb029ee2d67a5d75b</a></p>",
        "id": 260271939,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636033970
    },
    {
        "content": "<p>Now for <code>add_comm_monoid</code> we'd need a right action of <code>ℕ</code> on <code>M</code>, that doesen't seems unnatural either <span aria-label=\"unamused\" class=\"emoji emoji-1f612\" role=\"img\" title=\"unamused\">:unamused:</span></p>",
        "id": 260279337,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636037094
    },
    {
        "content": "<p>Will this create yet another diamond in case <code>M = nat</code>?</p>",
        "id": 260317672,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052110
    },
    {
        "content": "<p>Because we already have an action of <code>opposite nat</code> on <code>nat</code>.</p>",
        "id": 260317697,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052123
    },
    {
        "content": "<p>I wonder if there is a way to deal with these diamonds without adding lots of fields to <code>monoid</code>.</p>",
        "id": 260318544,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636052442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"214703\">Yury G. Kudryashov</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/260317672\">said</a>:</p>\n<blockquote>\n<p>Will this create yet another diamond in case <code>M = nat</code>?</p>\n</blockquote>\n<p>I think they both reduce to the inverted multiplication, so should be definitionally equal</p>",
        "id": 260319443,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636052824
    },
    {
        "content": "<p>How do you define the new action?</p>",
        "id": 260319924,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636053098
    },
    {
        "content": "<p>Isn't it just <code>nsmul</code>?</p>",
        "id": 260319939,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1636053107
    },
    {
        "content": "<p>Good question. That _does_ yield the wrong operation on <code>M = nat</code>...</p>",
        "id": 260320387,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636053329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259731253\">said</a>:</p>\n<blockquote>\n<p>Hmm, I think we have a problem here. In the bimodule world where <code>M</code> is an <code>S-R</code> bimodule and <code>N</code> is an <code>R-T</code> bimodule, we presumably want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>   <span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span>\n<span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span>       <span class=\"n\">m</span> <span class=\"bp\">⊗ₜ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">t</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>However, the latter case matches the former case with <code>s = op t</code>, and while probably gives a propositionally equal action in the cases where typeclasses match, certainly does not give a definitionally equal one.</p>\n</blockquote>\n<p>I think my message above was describing a more general case of this diamond?</p>\n<p>Edit: nevermind, but this is another diamond to worry about.</p>",
        "id": 260321763,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636054042
    },
    {
        "content": "<p>This topic was moved by <span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> to <a class=\"stream-topic\" data-stream-id=\"113488\" href=\"/#narrow/stream/113488-general/topic/right.20actions.20by.20nat\">#general &gt; right actions by nat</a></p>",
        "id": 260325187,
        "sender_full_name": "Notification Bot",
        "timestamp": 1636055656
    },
    {
        "content": "<p>(to clarify, just the nat diamond bit was)</p>",
        "id": 260327299,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636056566
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 260327536,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636056672
    },
    {
        "content": "<p>It's still super hard to adapt that file. The annoying thing is that the most general conditions for the tensor product having a left action and having a right action are so asymmetric. There's one of the actions on <code>M</code> and <code>N</code> thats requirted to be a <code>distrib_mul_action</code> while the other one can be an arbitrary <code>has_scalar</code>, depending on whether it comes from <code>tensor_product.left_has_scalar</code> or from <code>tensor_product.right_has_scalar</code>, and these are of course not separated well in the current state of the file <span aria-label=\"tired\" class=\"emoji emoji-1f614\" role=\"img\" title=\"tired\">:tired:</span></p>",
        "id": 260327728,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636056749
    },
    {
        "content": "<p>Currently thinking of just splitting the files. I had to separate <code>linear_algebra.tensor_product</code> and <code>linear_algebra.tensor_product_basis</code> a while ago anyway due to cyclic dependencies, might as well make a folder with a file for the defn, the left module structure coming from the left module <code>N</code>, the right module structure coming from the right module <code>M</code></p>",
        "id": 260340068,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636062928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/260327728\">said</a>:</p>\n<blockquote>\n<p>It's still super hard to adapt that file. The annoying thing is that the most general conditions for the tensor product having a left action and having a right action are so asymmetric. There's one of the actions on <code>M</code> and <code>N</code> thats requirted to be a <code>distrib_mul_action</code> while the other one can be an arbitrary <code>has_scalar</code>, depending on whether it comes from <code>tensor_product.left_has_scalar</code> or from <code>tensor_product.right_has_scalar</code>, and these are of course not separated well in the current state of the file <span aria-label=\"tired\" class=\"emoji emoji-1f614\" role=\"img\" title=\"tired\">:tired:</span></p>\n</blockquote>\n<p>Oh right, that's exactly the diamond you were talking about, <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span></p>",
        "id": 260382404,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636104756
    },
    {
        "content": "<p>The overlap <em>could</em> be solved in the manner we solved additive vs multiplicative operations. Stating lemmas for <code>smul</code> explicitely and transfer them automatically to lemmas about <code>rsmul</code>...</p>",
        "id": 260382605,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636104879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/259783051\">said</a>:</p>\n<blockquote>\n<p>Oh, we do not need that instance</p>\n</blockquote>\n<p>Are you sure about that? I still think in the commutative algebra world such an instance should be at least inferrable since user will not want to worry about which side of a module a commutative ring acts on?</p>",
        "id": 260775165,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636451725
    },
    {
        "content": "<p>Yes, I'm pretty sure, because having that instance would create diamonds. Can you give an <code>example</code> of a case you're thinking of?</p>",
        "id": 260781428,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636455567
    },
    {
        "content": "<p>I meant from a user point of view where the current approach would be to require <code>[has_scalar R M] [has_scalar (opposite R) M] [is_symmetric_smul R M]</code> every time, which does seem unwieldy. This would e.g. pop up every time one wants <code>(r • m) ⊗ₜ n = m ⊗ₜ (r • m)</code> instead of <code>(m &lt;• r) ⊗ₜ n = m ⊗ₜ (r • m)</code>. I'm not depp into commutative algebra, but I think that's what they want?</p>",
        "id": 260782821,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636456457
    },
    {
        "content": "<p>Yes, they would indeed need to do that when working over an arbitrary R and M</p>",
        "id": 260786404,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636458598
    },
    {
        "content": "<p>Maybe collecting the three instances into <code>has_symmetric_scalar R M</code> could be an option. It's just a use case that pops up a lot in mathlib</p>",
        "id": 260790658,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636461143
    },
    {
        "content": "<p>That would be super annoying, because you'd then need <code>has_symmetric_mul_action</code>, <code>has_symmetric_distrib_mul_action</code>, <code>has_symmetric_module</code>, ...</p>",
        "id": 260791088,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636461375
    },
    {
        "content": "<p>Hm, you're right</p>",
        "id": 260791550,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636461615
    },
    {
        "content": "<p>Maybe all that users really care about is <code>has_symmetric_module</code>, but if we had that we'd still end up stating the lemmas in mathlib about <code>is_symmetric_smul</code> to be maximally general</p>",
        "id": 260793960,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636462963
    },
    {
        "content": "<p>This is probably quite a useful instance, right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">is_scalar_tower.is_symmetric_smul</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">one_smul</span> <span class=\"n\">R</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">←</span><span class=\"n\">smul_assoc</span><span class=\"o\">,</span> <span class=\"n\">one_smul</span><span class=\"o\">,</span> <span class=\"n\">op_smul_eq_mul</span><span class=\"o\">,</span> <span class=\"n\">one_mul</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 260982849,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636547945
    },
    {
        "content": "<p>Do you think it's okay for users who use right scalars to be confronted with the fact that if they want to prove something about all <code>r : Rᵒᵖ</code>, they'll be confronted with left scalars instead until they rewrite along <code>←op_unop</code>?</p>",
        "id": 260983091,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636548083
    },
    {
        "content": "<p>I'm not sure; is it also true in the other direction?</p>",
        "id": 261003257,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636557049
    },
    {
        "content": "<p>Only in the commutative case</p>",
        "id": 261017439,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636562768
    },
    {
        "content": "<p>Are all the other assumptions equally strong, or can some be weakened?</p>",
        "id": 261017548,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636562819
    },
    {
        "content": "<p>I think we need them all:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">is_symmetric_smul.is_scalar_tower</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_monoid</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">mul_action</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_scalar</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_scalar_tower</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"n\">R</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">r'</span> <span class=\"n\">r</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span><span class=\"n\">unop_smul_eq_smul</span> <span class=\"n\">r'</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"n\">smul_smul</span><span class=\"o\">],</span>\n                <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">_</span> <span class=\"bp\">*</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">•</span> <span class=\"n\">_</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mul_comm</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 261018373,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636563143
    },
    {
        "content": "<p>Then it sounds like the first instance is harmless, but I'm not sure how useful it is</p>",
        "id": 261019919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636563686
    },
    {
        "content": "<p>It wasn't harmless <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 261144462,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643100
    },
    {
        "content": "<p>I'm slowly making progress. One thing I'm not too happy about is that <code>tensor_product.left_has_scalar</code> in the commutative case automatically induces an action of <code>opposite R</code> (a right action on the tensor product by a right action on <code>M</code>), while it only induces a left action if <code>M</code> is really a bimodule. I think that's a bit confusing.</p>",
        "id": 261145160,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643443
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative, do people still want asymmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodules?</p>",
        "id": 261145432,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636643579
    },
    {
        "content": "<p>Probably not, but remember you need to not create instance diamonds in places where you don't know if R is commutative</p>",
        "id": 261145772,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636643721
    },
    {
        "content": "<p>Well, this is about deleting instances, not adding some...</p>",
        "id": 261147176,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644380
    },
    {
        "content": "<p>Which instance are you considering deleting?</p>",
        "id": 261148224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1636644891
    },
    {
        "content": "<p><code>smul_comm_class R R M</code> for commutative <code>R</code>, that would solve the issue...</p>",
        "id": 261148310,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644929
    },
    {
        "content": "<p>...but probably cause other issues</p>",
        "id": 261148430,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636644973
    },
    {
        "content": "<p>The alternative is to just make all the constructions in the commutative case depend on an instance <code>[is_symmetric_smul R M]</code>, which prevents us from ending up in the confusing situation I described above</p>",
        "id": 261148665,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636645090
    },
    {
        "content": "<p>Regarding the question whether one wants asymmetric actions for R-R-bimodules even if R is commutative, definitely yes for some people. A typical example I'm not an expert on, but have seen is if R is a field of characteristic p and the right action is given by twisting with the Frobenius <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> while the left action is regular. Another example I am more familiar with is to consider k-linear categories with finitely many objects as monoid objects in the category of L-L-bimodules where L is a product of fields, as many as objects in the category. Also the action here is not central.</p>",
        "id": 261162994,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1636651929
    },
    {
        "content": "<p>Okay, I now did some changes based on the following situation:</p>\n<ul>\n<li>In some situations, even when <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is commutative, we want a left action on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a potentially asymmetric <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule.</li>\n<li>In other cases we want to have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">(</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>r</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r (m \\otimes n) = (rm) \\otimes n (= (mr) \\otimes n) = m \\otimes (rn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>, this is encapsulated in the fact that we have an instance of <code>is_symmetric_smul</code> on the tensor product whenever we have one on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</li>\n</ul>\n<p>I do think this accomodates all users, but since some constructions, especially the UMP of the tensor product, seem to lie in the second case, this sometimes requires a ridiculous amount of instance arguments, like <a href=\"https://github.com/javra/mathlib/blob/noncomm_tensor_product/src/linear_algebra/tensor_product/left_action.lean#L347-L355\">here</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">ext_fourfold</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">Q</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Q</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">is_symmetric_smul</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Q</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">M</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">Q</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">w</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(((</span><span class=\"n\">w</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">(((</span><span class=\"n\">w</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">z</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">h</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">w</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"n\">w</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>What's your thoughts on this?</p>",
        "id": 261236482,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1636714262
    },
    {
        "content": "<p>So the current state is <a href=\"https://github.com/javra/mathlib/tree/noncomm_tensor_product/src/linear_algebra/tensor_product\">this</a>. There's just one lemma missing from the old file, which requires me to come up with a good solution on how to derive <code>has_scalar (opposite (units S)) M</code> from <code>has_scalar (opposite S) M</code>(probably can't avoid to do it manually)...</p>\n<p>Do you think I should PR this already to get more people to look at it? I'm afraid of already putting too much time in this...</p>",
        "id": 261620446,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> I see you're working from a fork. Are you aware that you can request permission to create branches on the Mathlib repo and save yourself the overhead of managing a fork?</p>",
        "id": 261620641,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058182
    },
    {
        "content": "<p>Glancing at your work, I see it already comprises over 1000 lines. The code looks great so I'm sure we'll be able to get this merged but this is a large amount of code so the sooner you start PRing the better. For example the results about bases of tensor products (which I actually wanted for something else recently) look like a PR on their own.</p>",
        "id": 261621034,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058435
    },
    {
        "content": "<p>Yes, I do have the permission</p>",
        "id": 261621037,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058436
    },
    {
        "content": "<p>OK cool, if you prefer a fork then that's fine too!</p>",
        "id": 261621053,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261621034\">said</a>:</p>\n<blockquote>\n<p>Glancing at your work, I see it already comprises over 1000 lines. The code looks great so I'm sure we'll be able to get this merged but this is a large amount of code so the sooner you start PRing the better. For example the results about bases of tensor products (which I actually wanted for something else recently) look like a PR on their own.</p>\n</blockquote>\n<p>None of this is new, it's just the old <code>linear_algebra.tensor_product</code> and <code>linear_algebra.tensor_product_basis</code> reorganized and partly generalised to non-commutative rings. Some proofs had to be adapted by most of it is just copied over.</p>",
        "id": 261621172,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058519
    },
    {
        "content": "<p>Ah OK I see. I couldn't easily figure out how to get a diff and made the wrong assumption.</p>",
        "id": 261621275,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058602
    },
    {
        "content": "<p>Incidentally since we're finally talking seriously about tensor products over non-commutative rings, is anyone thinking about the corresponding results for linear maps?</p>",
        "id": 261621370,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058640
    },
    {
        "content": "<p>E.g.,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- works</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- fails because `R` not commutative!</span>\n</code></pre></div>",
        "id": 261621400,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058652
    },
    {
        "content": "<p>I wondered if this would come up as part of the tensor product work. Did it?</p>",
        "id": 261621444,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637058681
    },
    {
        "content": "<p>The fact that these are missing actually prevents some generalisations!</p>",
        "id": 261621903,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637058972
    },
    {
        "content": "<p>The current implementation doesn't really depend on <code>R</code> being commutative, but having a commutative action on <code>N</code>.</p>",
        "id": 261622764,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637059503
    },
    {
        "content": "<p>Yes but if <code>R</code> is not commutative the definition will not provide a linear map.</p>",
        "id": 261622833,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637059548
    },
    {
        "content": "<p>Oh sorry, misread your remark.</p>",
        "id": 261622854,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637059560
    },
    {
        "content": "<p>Made <a href=\"https://github.com/leanprover-community/mathlib/pull/10345\">a pull request</a>.</p>",
        "id": 261623472,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637059930
    },
    {
        "content": "<p>Mathematically, if <code>R</code>, <code>S</code>, <code>T</code> are rings, <code>M</code> is an <code>(R, S)</code>-bimodule, and <code>N</code> is an <code>(R, T)</code>-bimodule then we can speak of <code>R</code>-linear maps <code>M → N</code> and these are an <code>(S, T)</code>-bimodule. I'd love to have this in Mathlib.</p>",
        "id": 261623550,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261623472\">said</a>:</p>\n<blockquote>\n<p>Made <a href=\"https://github.com/leanprover-community/mathlib/pull/10345\">a pull request</a>.</p>\n</blockquote>\n<p>Thanks! I'll review this evening.</p>",
        "id": 261623648,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060064
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261623550\">said</a>:</p>\n<blockquote>\n<p>Mathematically, if <code>R</code>, <code>S</code>, <code>T</code> are rings, <code>M</code> is an <code>(R, S)</code>-bimodule, and <code>N</code> is an <code>(R, T)</code>-bimodule then we can speak of <code>R</code>-linear maps <code>M → N</code> and these are an <code>(S, T)</code>-bimodule. I'd love to have this in Mathlib.</p>\n</blockquote>\n<p>Isn't this <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/module/linear_map.lean#L607\">here</a>?</p>",
        "id": 261623855,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060201
    },
    {
        "content": "<p>Ah, nevermind, that's weaker than what you said.</p>",
        "id": 261623959,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060266
    },
    {
        "content": "<p>I'm definitely a bit of out date as I haven't touched this stuff in ages. We might be much closer to this than I realise.</p>",
        "id": 261624081,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060320
    },
    {
        "content": "<p>Staring at it a bit more it does use the left action on both the domain and the codomain, which prevents your generalisation, it's roughly the same problem as with the tensor product.</p>",
        "id": 261624520,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060513
    },
    {
        "content": "<p>(Which I guess shouldn't be surprising with them being adjoints and all...)</p>",
        "id": 261624598,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060527
    },
    {
        "content": "<p>I suspected this might be a prerequisite for tensor products but perhaps not.</p>",
        "id": 261624728,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060594
    },
    {
        "content": "<p>I guess it's a prerequesite from freeing the lemmas which mix tensor products and linear maps from the commutativity presumption, which I haven't done. Maybe it should be done and both go in the same huge PR <span aria-label=\"scared\" class=\"emoji emoji-1f628\" role=\"img\" title=\"scared\">:scared:</span></p>",
        "id": 261624980,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637060699
    },
    {
        "content": "<p>Huge PRs should be a last resort. I've often been surprised at how easy it is to package up something like this into smaller pieces.</p>",
        "id": 261625256,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060824
    },
    {
        "content": "<p>Btw this generalisation is well worth fighting for and very valuable. I suspect many people here are quite excited about the theory of bimodules coming to life.</p>",
        "id": 261625353,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637060866
    },
    {
        "content": "<p>Thanks for the encouragement! this actually came out of me wanting to teach Lean to some non-commutative algebraists, and I was a bit suprised about how much of mathlib relies on commutativity.</p>",
        "id": 261626255,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637061310
    },
    {
        "content": "<p>In order to fix the files depending on the tensor product: Is there a way to get a list of all files that depend on a certain file by transitivity?</p>",
        "id": 261627874,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637062177
    },
    {
        "content": "<p>This is probably possible with <a href=\"https://github.com/leanprover-community/leancrawler\">https://github.com/leanprover-community/leancrawler</a> but I think you'll probably end up with a far bigger list than you want because if one little lemma in a file low down in the dependency tree uses tensor products you'll get a huge chunk of Mathlib.</p>",
        "id": 261628226,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637062386
    },
    {
        "content": "<p>You can also use leanproject for this and run some tools on the output of <a href=\"https://leanprover-community.github.io/leanproject.html#import-graphs\">https://leanprover-community.github.io/leanproject.html#import-graphs</a></p>",
        "id": 261628606,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637062653
    },
    {
        "content": "<p>If you tell me a specific list of filenames I can do this for you too fairly easily, me and Johan have some WIP tools that will help with this, and I'm happy to run them</p>",
        "id": 261628882,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637062836
    },
    {
        "content": "<p>It's just <code>linear_algebra.tensor_product</code> on the current master branch</p>",
        "id": 261633894,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637066206
    },
    {
        "content": "<p>I think that list is way too big to do anything useful with, there are 590 files there</p>",
        "id": 261634425,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066547
    },
    {
        "content": "<p>I can't even paste it into a zulip message</p>",
        "id": 261634440,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066559
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/pc9IqOI8iJ5ZTNUvYzxpjraj/tensorlist\">tensorlist</a></p>",
        "id": 261634539,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066626
    },
    {
        "content": "<p>Probably you're best off just letting <code>lean --make src</code> or CI tell you what breaks</p>",
        "id": 261634621,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637066669
    },
    {
        "content": "<p>That's what would have been my plan otherwise. I guess it does trigger a lot of big recompilations to just start at at random spot, though. Maybe the best heuristic is to start with the direct descendants and hope that most of the indirect imports don't break.</p>",
        "id": 261635435,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637067132
    },
    {
        "content": "<p>Those are:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"n\">linear_algebra.direct_sum.tensor_product</span><span class=\"o\">,</span>\n <span class=\"n\">algebra.category.Module.monoidal</span><span class=\"o\">,</span>\n <span class=\"n\">topology.algebra.affine</span><span class=\"o\">,</span>\n <span class=\"n\">linear_algebra.affine_space.affine_equiv</span><span class=\"o\">,</span>\n <span class=\"n\">algebra.algebra.bilinear</span><span class=\"o\">,</span>\n <span class=\"n\">topology.algebra.continuous_affine_map</span><span class=\"o\">,</span>\n <span class=\"n\">linear_algebra.multilinear.tensor_product</span>\n</code></pre></div>\n<p>I guess grep can also find this list though!</p>",
        "id": 261635726,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1637067296
    },
    {
        "content": "<p>The mathlibs docs show them as well :)</p>",
        "id": 261635989,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637067416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261626255\">said</a>:</p>\n<blockquote>\n<p>Thanks for the encouragement! this actually came out of me wanting to teach Lean to some non-commutative algebraists, and I was a bit suprised about how much of mathlib relies on commutativity.</p>\n</blockquote>\n<p>Certain people wandering around on zulip, pretending they've never met a noncommutative ring...</p>",
        "id": 261702246,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637094575
    },
    {
        "content": "<p>One thing I noticed is that at many points it would be more elegant to separate the lemmas about commutative rings from the non-commutative ones, if e.g. instead of <code>semiring R</code> we would assume <code>comm_semigroup R</code> and <code>the_other_ring_axioms R</code> separately, with the drawback that this would make usage more verbose.<br>\n<span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> mentioned that in Lean 4 it should be possible to infer one of these from the other <strong>and vice versa</strong> which seems to make separating the assumptions more attractive...</p>",
        "id": 261706956,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637096879
    },
    {
        "content": "<p>Commutative ring theory has been one of the success stories of mathlib.</p>",
        "id": 261709445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098143
    },
    {
        "content": "<p>I wonder whether this would have been the case if we'd tried to take the noncommutative story into account at the time. Historically what happened was that very early on I was pushing for schemes, a story where we needed a lot of commutative ring stuff, and there was nobody arguing for the noncommutative case at the time so me and my minions just defined ideals of commutative rings and then prime ideals etc etc and just kept PRing stuff</p>",
        "id": 261709786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098320
    },
    {
        "content": "<p>It was pointed out that there would be trouble ahead but I could never get straight from the noncommutative people whether ideal was supposed to mean left ideal or bi-ideal so I just kept pushing the commutative story, and then other people showed up and joined in (Justus Springer, Devon Tuma, the Berkeley graduate students, others I've forgotten, and now the new crowd doing products of schemes) and the commutative story just kept growing</p>",
        "id": 261710097,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637098448
    },
    {
        "content": "<p>Kevin has a good point. I think a great way to build a good library is to build an extremely tall and pointy lopsided one, and then hope that people come along to stop it from falling over. :-)</p>",
        "id": 261711463,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099219
    },
    {
        "content": "<p>Happily in mathlib that happens.</p>",
        "id": 261711523,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099255
    },
    {
        "content": "<p>This happens only if the tower builders PR to mathlib... <span aria-label=\"rolling eyes\" class=\"emoji emoji-1f644\" role=\"img\" title=\"rolling eyes\">:rolling_eyes:</span></p>",
        "id": 261711700,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637099358
    },
    {
        "content": "<p>I do genuinely feel guilty that this approach has caused trouble down the line, especially as I was warned that this would happen, but ultimately as Scott says we made some really tall stuff and that has had advantages because it got us noticed.</p>",
        "id": 261711714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637099367
    },
    {
        "content": "<p>(I wasn't even counting non-mathlib stuff as part of the tower. They are just ephemeral dreams. :-)</p>",
        "id": 261712061,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099537
    },
    {
        "content": "<p>I know, I was only trying to remind the perfectoid spaces projects authors that they should feel guilty.</p>",
        "id": 261712145,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1637099586
    },
    {
        "content": "<p>But I also feel very attacked with my two 5k lines branches.</p>",
        "id": 261712202,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637099618
    },
    {
        "content": "<p>Hopefully \"attacked\" in the most constructive and loving way. :-) Otherwise, sorry!</p>",
        "id": 261712404,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1637099714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261710097\">said</a>:</p>\n<blockquote>\n<p>It was pointed out that there would be trouble ahead but I could never get straight from the noncommutative people whether ideal was supposed to mean left ideal or bi-ideal so I just kept pushing the commutative story, and then other people showed up and joined in (Justus Springer, Devon Tuma, the Berkeley graduate students, others I've forgotten, and now the new crowd doing products of schemes) and the commutative story just kept growing</p>\n</blockquote>\n<p>I will definitvely quiz additional non-commutative people on their customs :D</p>",
        "id": 261713251,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637100088
    },
    {
        "content": "<p>Oh thanks!</p>",
        "id": 261713482,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637100202
    },
    {
        "content": "<p>I need to write a version of the bundled <code>Module</code> with a symmetric action (i.e. <code>Module</code> extended by an <code>is_symmetric_smul</code>). Any naming ideas?</p>",
        "id": 261794895,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637160859
    },
    {
        "content": "<p><code>SymmetricBiModule</code>?</p>",
        "id": 261797532,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637161967
    },
    {
        "content": "<p>How about this: I shelve the current PR for now and do the following PRs separately and in order:</p>\n<ol>\n<li>Create a PR fixing the use of modules towards more compatibility with non-comm algebra, meaning replacing occurrences of <code>module R M</code> by a symmetric  <code>R</code>-<code>R</code>-action or (weaker) an <code>R</code>-<code>R</code>-bimodule wherever the non-comm generalisation would currently require it.</li>\n<li>Generalise the module structure on linear maps in the way <span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> proposed it above.</li>\n<li>Generalise the tensor product (the current PR).</li>\n</ol>",
        "id": 261943834,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637249961
    },
    {
        "content": "<p>Will this mean that whenever an undergraduate wants to talk about a vector space they'll have to say a k-k-bimodule?</p>",
        "id": 261944352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1637250157
    },
    {
        "content": "<p>This sounds like a very good plan to me except that I don't have a clear picture of what you have in mind for 1. Is there a simple example of such a fix?</p>",
        "id": 261944355,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250159
    },
    {
        "content": "<p>(Or rather of such a situation, requiring a fix.)</p>",
        "id": 261944379,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250171
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944352\">said</a>:</p>\n<blockquote>\n<p>Will this mean that whenever an undergraduate wants to talk about a vector space they'll have to say a k-k-bimodule?</p>\n</blockquote>\n<p>Would <code>symm_module k V</code> be acceptable?</p>",
        "id": 261944531,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250234
    },
    {
        "content": "<p>I presume we could have typeclass instances that provide <code>symm_module k V</code> from <code>module k V</code> + <code>comm_ring k</code>?</p>",
        "id": 261944766,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944379\">said</a>:</p>\n<blockquote>\n<p>(Or rather of such a situation, requiring a fix.)</p>\n</blockquote>\n<p>Well a good part of this entire thread is about such a situation: Every point where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">r (m \\otimes n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> would mean <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>r</mi><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(r m) \\otimes n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> instead of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>m</mi><mi>r</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">(m r) \\otimes n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>, for example, and by exension any situation which requires the tensor product of two <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-modules to be an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module.</p>",
        "id": 261945130,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261944766\">said</a>:</p>\n<blockquote>\n<p>I presume we could have typeclass instances that provide <code>symm_module k V</code> from <code>module k V</code> + <code>comm_ring k</code>?</p>\n</blockquote>\n<p>It would be a great help in the usage if we could have such an instance. <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> above said, that we might have situations, even with commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, where the canonical left and right action don't coincide. So if at all, we'd make your proposed instance low priority?</p>",
        "id": 261945363,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261945363\">said</a>:</p>\n<blockquote>\n<p>It would be a great help in the usage if we could have such an instance. <span class=\"user-mention silent\" data-user-id=\"317890\">Julian Külshammer</span> above said, that we might have situations, even with commutative <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>, where the canonical left and right action don't coincide. So if at all, we'd make your proposed instance low priority?</p>\n</blockquote>\n<p>Hmm this is a good point. I'm less confident we could do this and it would indeed require some care with priorities.</p>",
        "id": 261945818,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637250722
    },
    {
        "content": "<p>(It would make all the fixes needed for the current tensor product PR tremendously easier ;))</p>",
        "id": 261945930,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250770
    },
    {
        "content": "<p>(And the usage by people like <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>'s linear algebra students, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> is commutative)</p>",
        "id": 261946531,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637250985
    },
    {
        "content": "<p>Wait though, why won't we still have just plain left modules still?</p>",
        "id": 261946696,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251060
    },
    {
        "content": "<p>We will, we just don't have the instance of their tensor product or the space of linear maps being a plain left module.</p>",
        "id": 261947432,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251280
    },
    {
        "content": "<p>Right!</p>",
        "id": 261947452,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251286
    },
    {
        "content": "<p>OK so the problem to be solved should only be at the level of the instances and not at the types.</p>",
        "id": 261947606,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251337
    },
    {
        "content": "<p>I think this should work, subject to carefully-chosen instance priorities.</p>",
        "id": 261947850,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251431
    },
    {
        "content": "<p>The core of the problem is that we have two different conventions in the commutative and the non-commutative world, and the best way to solve the dilemma seems to be to say \"okay, let's assume the commutative case as a special situation of bimodules where needed\"</p>",
        "id": 261948061,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261947850\">said</a>:</p>\n<blockquote>\n<p>I think this should work, subject to carefully-chosen instance priorities.</p>\n</blockquote>\n<p>Do you mean the whole thing or the symmetry-instance in the commutative case?</p>",
        "id": 261948120,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251514
    },
    {
        "content": "<p>I meant the whole thing but of course it's hard to really be sure.</p>",
        "id": 261948199,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637251548
    },
    {
        "content": "<p>Something concrete that needs to be made symmetric in order for the changes <code>linear_algebra.tensor_product</code> to go through is to have the <code>ℤ</code> action on a module to be symmetric, since otherwise <code>compatible_smul.int</code> and thus the <code>ℤ</code> actiono n the tensor product doesn't work.</p>",
        "id": 261948757,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637251734
    },
    {
        "content": "<p>I'm not precisely sure what this means. If <code>m</code>, <code>n</code> are elements of additive groups <code>M</code>, <code>N</code>, then there are three different things that are all mathematically equal:</p>\n<ul>\n<li><code>m ⊗ₜ n + m ⊗ₜ n + ... + m ⊗ₜ n</code></li>\n<li><code>m ⊗ₜ (n + n + ... + n)</code></li>\n<li><code>(m + m + ... + m) ⊗ₜ n</code></li>\n</ul>\n<p>and at most two of these can be definitionally equal. Is this related to your question?</p>",
        "id": 261949811,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637252141
    },
    {
        "content": "<p>Not entirely. The definitional equality will always be between the first and the third term. It's just that this equality comes out of the general statement of \"if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-bimodule, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>-module\", so we need <code>ℤ</code> to play the role of both <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> and thus act symmetrically on the left and on the right of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 261950606,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252460
    },
    {
        "content": "<p>I haven't been following this discussion closely but it seems like this encoding using <code>opposite</code> is causing a lot of trouble, how about having <code>left_module</code>, <code>right_module</code> with separate operations, <code>bimodule</code>, and then <code>module R M</code> extends <code>bimodule R R M</code> with the \"symmetry\" compatibility law?</p>",
        "id": 261950851,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252559
    },
    {
        "content": "<p>this is a slightly weird definition in the commutative case but it's similar to \"a metric space has a metric and a topology that agree\"</p>",
        "id": 261951107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252650
    },
    {
        "content": "<p>The intuitive argument against that for me was that it is a way bigger change. But maybe that's not a good argument.</p>",
        "id": 261951441,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252781
    },
    {
        "content": "<p>The annoying thing then is: <code>module R M</code> and <code>left_module R M</code> are equivalent and differ only by notation. For which one do we proof all the lemmas about arbitrary modules?</p>",
        "id": 261951575,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252849
    },
    {
        "content": "<p><code>module</code> would be only for commutative rings</p>",
        "id": 261951710,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637252899
    },
    {
        "content": "<p>That then complicates the cases <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> mentions above, where we do want differeent left and right actions even if the ring is commutative.</p>",
        "id": 261951909,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637252988
    },
    {
        "content": "<p>I don't think so, they'd just be <code>bimodule</code>s.</p>",
        "id": 261952005,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637253013
    },
    {
        "content": "<p>I didn't really answer your question but my intended answer would be something like \"if you're doing commutative algebra, use <code>module</code> otherwise use <code>left_module</code>\"</p>",
        "id": 261952247,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253118
    },
    {
        "content": "<p>There's probably problems with this idea because I haven't thought this through at all</p>",
        "id": 261952447,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952005\">said</a>:</p>\n<blockquote>\n<p>I don't think so, they'd just be <code>bimodule</code>s.</p>\n</blockquote>\n<p>But if both the left and the right action are somewhat canonical structures on some <code>M</code>, each will make <code>M</code> a module and to get the desired bimodule, we'll have to locally downgrade them to a <code>left_module</code> and a <code>right_module</code> respectively, right?</p>",
        "id": 261952567,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952447\">said</a>:</p>\n<blockquote>\n<p>There's probably problems with this idea because I haven't thought this through at all</p>\n</blockquote>\n<p>I think it would be the preferred idea if there was less overlap between non-commutative and commutative algebra. The overlap, I guess, is where things can go wrong.</p>",
        "id": 261952724,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253322
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952447\">said</a>:</p>\n<blockquote>\n<p>There's probably problems with this idea because I haven't thought this through at all</p>\n</blockquote>\n<p>I think it's very hard / impossible to foresee what problems any approach may encounter. Your suggestion has the very tempting sociological advantage that it's how most / all of us actually think about this.</p>",
        "id": 261952750,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1637253336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261950851\">said</a>:</p>\n<blockquote>\n<p>I haven't been following this discussion closely but it seems like this encoding using <code>opposite</code> is causing a lot of trouble, how about having <code>left_module</code>, <code>right_module</code> with separate operations, <code>bimodule</code>, and then <code>module R M</code> extends <code>bimodule R R M</code> with the \"symmetry\" compatibility law?</p>\n</blockquote>\n<p>This raises the question on whether we'd need a transfer command to create <code>right_module</code> lemmas from left module lemmas?</p>",
        "id": 261952953,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253427
    },
    {
        "content": "<p>Maybe I should head over to <a class=\"stream\" data-stream-id=\"287929\" href=\"/#narrow/stream/287929-mathlib4\">#mathlib4</a> and ask whether <code>to_additive</code> has been ported already...</p>",
        "id": 261953425,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261952005\">said</a>:</p>\n<blockquote>\n<p>I don't think so, they'd just be <code>bimodule</code>s.</p>\n</blockquote>\n<p>But if both the left and the right action are somewhat canonical structures on some <code>M</code>, each will make <code>M</code> a module and to get the desired bimodule, we'll have to locally downgrade them to a <code>left_module</code> and a <code>right_module</code> respectively, right?</p>\n</blockquote>\n<p>I don't think this one is a problem in practice, basically because the math situation is the same. You just won't define a <code>module</code> structure for one or both of the actions</p>",
        "id": 261953645,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637253731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261953645\">said</a>:</p>\n<blockquote>\n<p>I don't think this one is a problem in practice, basically because the math situation is the same. You just won't define a <code>module</code> structure for one or both of the actions</p>\n</blockquote>\n<p>If it's not already there. Maybe you first want to tread each action separately and happily use <code>module</code> before, in a more specialised setting, wanting to use both. But yes, there are ways around this and it might be a super rare occasion anyway.</p>",
        "id": 261954114,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637253960
    },
    {
        "content": "<p><code>M</code> would be something you just created to describe this specific object, though.</p>",
        "id": 261954257,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254013
    },
    {
        "content": "<p>So the instances aren't there</p>",
        "id": 261954277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254022
    },
    {
        "content": "<p>Like one construction is you have a complex vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and you let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> act by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> on the left and by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>z</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6306em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> on the right. You need a new name for this guy no matter what, and that's what gets the <code>bimodule</code> instance</p>",
        "id": 261954442,
        "sender_full_name": "Reid Barton",
        "timestamp": 1637254086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"317890\">Julian Külshammer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261162994\">said</a>:</p>\n<blockquote>\n<p>A typical example I'm not an expert on, but have seen is if R is a field of characteristic p and the right action is given by twisting with the Frobenius <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mi>p</mi></msup></mrow><annotation encoding=\"application/x-tex\">x\\mapsto x^p</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6644em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6644em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span> while the left action is regular.</p>\n</blockquote>\n<p>Here maybe the left action is the one that's already a full module already, right?</p>",
        "id": 261954712,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637254190
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261954442\">said</a>:</p>\n<blockquote>\n<p>Like one construction is you have a complex vector space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> and you let <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> act by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>z</mi></mrow><annotation encoding=\"application/x-tex\">z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span></span> on the left and by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>z</mi><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6306em;\"></span><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6306em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span></span><span style=\"top:-3.5506em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> on the right. You need a new name for this guy no matter what, and that's what gets the <code>bimodule</code> instance</p>\n</blockquote>\n<p>Ah, okay, yes, changing the name of the carrier is a good solution.</p>",
        "id": 261954895,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637254243
    },
    {
        "content": "<p>On a slight tangent, am I the only one who thinks that <code>smul_comm_class</code> is a really bad name? We usually dont include \"class\" in the name of a type class?</p>",
        "id": 261973992,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262286
    },
    {
        "content": "<p>I agree. But the lemma is already called <code>smul_comm</code>. So we need another name for the class. Suggestions welcome!</p>",
        "id": 261974245,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1637262399
    },
    {
        "content": "<p>To be fair, I much more regret <code>has_scalar_tower</code>. I'd be happy to have them called <code>smul_comm_class</code> and <code>smul_assoc_class</code>. But if you want to get rid of the <code>_class</code> we can go for <code>is_smul_comm</code>/<code>is_comm_smul</code> and <code>is_smul_assoc</code>/<code>is_assoc_smul</code>.</p>",
        "id": 261974400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637262470
    },
    {
        "content": "<p>It follows the principle that Prop-valued classes should be called <code>is_</code>.</p>",
        "id": 261974851,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637262565
    },
    {
        "content": "<p>Isn't it <code>is_scalar_tower</code>?</p>",
        "id": 261975053,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262617
    },
    {
        "content": "<p>Since it's <code>has_scalar</code>, maybe <code>scalar_comm</code> could be a name for the class, while <code>smul_comm</code> is the lemma?</p>",
        "id": 261975161,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637262670
    },
    {
        "content": "<p>I think we should rename <code>has_scalar</code> to <code>has_smul</code>. It's <code>has_add</code>, not <code>has_addition</code>.</p>",
        "id": 261976176,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637263095
    },
    {
        "content": "<p>I think \"rename all the typeclasses\" is reasonable, but probably deserves it's own thread</p>",
        "id": 261981655,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265359
    },
    {
        "content": "<p>Also it will mean my scalar actions paper refers to things that no longer exist!</p>",
        "id": 261981750,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265399
    },
    {
        "content": "<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>",
        "id": 261985036,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637266919
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261981750\">said</a>:</p>\n<blockquote>\n<p>Also it will mean my scalar actions paper refers to things that no longer exist!</p>\n</blockquote>\n<p>Paper rot <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 261988077,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637268330
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261985036\">said</a>:</p>\n<blockquote>\n<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>\n</blockquote>\n<p>Sounds reasonable</p>",
        "id": 261988425,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637268499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261985036\">said</a>:</p>\n<blockquote>\n<p><code>has_lsmul</code> and <code>has_rsmul</code>?</p>\n</blockquote>\n<p>Before embarking on such a change, I'd recommend collecting the rationale for doing so into a chunk of prose and making a github issue about it.</p>",
        "id": 261989178,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637268860
    },
    {
        "content": "<p>(my current stance is mild opposition, mainly because I think we need a clear argument for it being useful before doubling the amount of work we do)</p>",
        "id": 261989328,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637268949
    },
    {
        "content": "<p>I'd also be tempted to go ahead and PR the <code>is_symmetric_smul</code> stuff, since I found a number of other places where I wanted it</p>",
        "id": 261989514,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637269057
    },
    {
        "content": "<p>Did you read the thread above? What's your opinion in changing the current definition of <code>module</code>?</p>",
        "id": 261989745,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637269188
    },
    {
        "content": "<p>Are you actually suggesting changing <code>module</code>, or just renaming it to <code>left_module</code> and creating something new to replace <code>module</code>?</p>",
        "id": 261991473,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637269957
    },
    {
        "content": "<p>Well it was <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>'s suggestion at first, but I tend to agree with it the more I think about where I'd otherwise need to plug in <code>is_symmetric_smul R M</code>. Make <code>module R M</code> mean symmetric <code>R</code>-<code>R</code>-bimodule, and derive an instance for it from <code>left_module R M</code> whenever <code>R</code> is commutative.</p>",
        "id": 261992399,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637270402
    },
    {
        "content": "<p>Surely we want to derive a <code>left_module</code> instance from <code>module</code> though too (<code>module.to_left_module</code>), since all bi-modules are unimodules? We can't have both directions.</p>",
        "id": 261996837,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637272575
    },
    {
        "content": "<p>Ah, damn, you're right. Sounds pretty promising that in Lean 4 we will be able to have both...</p>",
        "id": 261997687,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272927
    },
    {
        "content": "<p>But then maybe we should stick to the previous plan and lazily add <code>is_symmetric_smul</code> where needed?</p>",
        "id": 261997752,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261989514\">said</a>:</p>\n<blockquote>\n<p>I'd also be tempted to go ahead and PR the <code>is_symmetric_smul</code> stuff, since I found a number of other places where I wanted it</p>\n</blockquote>\n<p>What other places for example?</p>",
        "id": 261997795,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637272979
    },
    {
        "content": "<p>But I'd be happy for you to PR it, happy for everything that breaks my PR into smaller pieces ^^</p>",
        "id": 261998082,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637273121
    },
    {
        "content": "<p>There's a few additional closure properties in <a href=\"https://github.com/leanprover-community/mathlib/blob/53172fa65edafc41d08ff451ed023d8a46b01b32/src/group_theory/group_action/symmetric.lean\">here</a></p>",
        "id": 261998526,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637273348
    },
    {
        "content": "<blockquote>\n<p>what other places for example?</p>\n</blockquote>\n<p>IMO <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_module\">docs#star_module</a> should be stated in terms of a right action on one side, but that's annoying in commutative actions without <code>is_symmetric_smul</code></p>",
        "id": 261999943,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637273972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/261999943\">said</a>:</p>\n<blockquote>\n<p>IMO <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_module\">docs#star_module</a> should be stated in terms of a right action on one side, but that's annoying in commutative actions without <code>is_symmetric_smul</code></p>\n</blockquote>\n<p>Oh, does that also contain the potential of having  issues <code>opposite (opposite R)</code>when applied twice? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 262000629,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637274346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110789\">Jakob von Raumer</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/262000629\">said</a>:</p>\n<blockquote>\n<p>Oh, does that also contain the potential of having  issues <code>opposite (opposite R)</code>when applied twice? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>Let me advertise two theories for a refactor that could deal with this:</p>\n<ul>\n<li><a href=\"#narrow/stream/113488-general/topic/with_top.20irreducible/near/260803354\">eta for structures</a></li>\n<li>some class <a href=\"https://github.com/leanprover-community/mathlib/pull/9840#discussion_r738695610\"><code>is_opposite R S</code></a> packaging an isomorphism between <code>Rᵒᵖ</code> and <code>S</code></li>\n</ul>",
        "id": 262001227,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637274665
    },
    {
        "content": "<p>Ah, thanks. is \"eta for structures\" really a solution? We won't have eta for structures in Lean 4 either</p>",
        "id": 262001983,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637275161
    },
    {
        "content": "<p>I think it was under consideration?<br>\n<a href=\"https://github.com/leanprover/lean4/issues/777#issuecomment-964207928\">https://github.com/leanprover/lean4/issues/777#issuecomment-964207928</a></p>",
        "id": 262002104,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637275219
    },
    {
        "content": "<p>Oh cool :) I proposed it to Sebastian a while ago, and he didn't sound like Leo and him liked it</p>",
        "id": 262038593,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1637310121
    },
    {
        "content": "<p>See the topic on <a href=\"#narrow/stream/116395-maths/topic/left.20vs.20right.20modules.20in.20tensor.20products/near/259727782\">left vs right modules in tensor products</a> for some related discussion about left and right modules (which was moved from here)</p>",
        "id": 262058631,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637323976
    },
    {
        "content": "<p>What's the current status of this discussion? It would be nice to have a way to talk about bimodules and two-sided ideals in non-commutative rings sometime soon.</p>",
        "id": 275132235,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647144890
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"373192\">@Christopher Hoskin</span> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 275152784,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1647177155
    },
    {
        "content": "<p>R-S-Bimodules are possible as <code>[module R M] [module Sᵐᵒᵖ M] [smul_comm_class R Sᵐᵒᵖ M]</code>, what we're missing is sub-bimodules</p>",
        "id": 275160955,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647186561
    },
    {
        "content": "<p>Ah, okay. I only looked for two-sided ideals. Silly me. Should I define those, or wait for something else someone is working on?</p>",
        "id": 275162218,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647188103
    },
    {
        "content": "<p>I think we probably want <code>subbimodule R S M</code> and then can define <code>biideal R</code> as <code>subbimodule R R R</code></p>",
        "id": 275174306,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647204608
    },
    {
        "content": "<p>Likely with better names</p>",
        "id": 275174310,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1647204618
    },
    {
        "content": "<p>ah, I was thinking just <code>bimodule R R I</code> but I see now why sub-bimodule makes more sense.</p>",
        "id": 275175581,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1647206375
    },
    {
        "content": "<p>I just opened <a href=\"https://github.com/leanprover-community/mathlib/pull/14399\">#14399</a> which defines right ideals. I confess I have lost track of where we are with this. Other than code duplication, is there any reason why this is a silly approach?</p>\n<p>Actually I just wanted the result that a division ring is Artinian but I got annoyed when I realised I could only handle the left case so I copied near-minimal amount of left <code>ideal</code> API to allow me do what I wanted. The PR is thus a silly mixture of two things; I'm happy to split it up but first I thought I'd check here.</p>\n<p>Is this crazy? Do we actually want to go in this direction?</p>",
        "id": 284039475,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653588046
    },
    {
        "content": "<p>(the obvious alternative is just to work with <code>ideal Rᵐᵒᵖ</code> but then all elements live in a different type which will be pain)</p>",
        "id": 284044306,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653590521
    },
    {
        "content": "<p>Coming from the order theory library where everything is dualized by hand (still longing for a <code>to_dual</code> attribute), I would say that you should duplicate everything. It's not twice harder to write twice almost the same thing.</p>",
        "id": 284044565,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653590652
    },
    {
        "content": "<p>The only problem I see is that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_opposite\">docs#mul_opposite</a> is irreducible, so you can't use it to easily dualize lemmas as we do with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual\">docs#order_dual</a>.</p>",
        "id": 284044651,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653590717
    },
    {
        "content": "<p>Maybe you can make it locally reducible when dualizing lemmas?</p>",
        "id": 284044701,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653590741
    },
    {
        "content": "<p>... and <code>left_ideal</code> and <code>right_ideal</code> are different structures, so you can't rely on that trick when the statement mentions them.</p>",
        "id": 284044840,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653590812
    },
    {
        "content": "<blockquote>\n<p>the obvious alternative is just to work with <code>ideal Rᵐᵒᵖ</code> but then all elements live in a different type which will be pain</p>\n</blockquote>\n<p>My vague memory was that this doesn't actually mean the right thing; but perhaps I told <span class=\"user-mention\" data-user-id=\"419946\">@Haruhisa Enomoto</span> something wrong in their PR</p>",
        "id": 284061036,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653599020
    },
    {
        "content": "<p>IIUC, you are referring to <a href=\"https://github.com/leanprover-community/mathlib/pull/13862#discussion_r862521248\">this comment</a> on <a href=\"https://github.com/leanprover-community/mathlib/pull/13862\">#13862</a>. I agree with your comment there.</p>",
        "id": 284119474,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650111
    },
    {
        "content": "<p>For the sake of definiteness, given a (semi)ring <code>R</code> there are four things one can consider:</p>\n<ol>\n<li><code>submodule R R</code>        -- Left ideal of <code>R</code></li>\n<li><code>submodule Rᵐᵒᵖ R</code>     -- Right ideal of <code>R</code></li>\n<li><code>submodule Rᵐᵒᵖ Rᵐᵒᵖ</code>  -- Left ideal of <code>Rᵐᵒᵖ</code>  (corresponds to right ideal of <code>R</code>)</li>\n<li><code>submodule R Rᵐᵒᵖ</code>     -- Right ideal of <code>Rᵐᵒᵖ</code> (corresponds to left ideal of <code>R</code>)</li>\n</ol>",
        "id": 284119511,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650151
    },
    {
        "content": "<p>And you were correctly pointing out that 2 and 3 are not equal (though they do \"correspond\" --- mathematically, the point is that when <code>Rᵐᵒᵖ</code> appears as the second argument in <code>submodule</code>, its multiplicative structure has been forgotten so there's no difference between it and <code>R</code>).</p>",
        "id": 284119584,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650192
    },
    {
        "content": "<p>Looking this morning, we are very nearly able to work with sub-bimodules. The only missing piece is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.tensor_product</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_i</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span> <span class=\"c1\">-- Currently fails</span>\n</code></pre></div>",
        "id": 284119732,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650314
    },
    {
        "content": "<p>I'll try to PR something that fixes this (today if I get time, though I'm travelling so it could be Monday).</p>",
        "id": 284119844,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650421
    },
    {
        "content": "<p>For emphasis, we just need to fill the <code>sorry</code> below:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.tensor_product</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">_i</span> <span class=\"o\">:</span> <span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"c1\">-- YAY: a subbimodule:</span>\n<span class=\"k\">#check</span> <span class=\"n\">submodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"n\">S</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"n\">M</span>\n\n<span class=\"sd\">/-- A two-sided ideal. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">bi_ideal</span> <span class=\"o\">:=</span> <span class=\"n\">submodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"n\">R</span>\n</code></pre></div>",
        "id": 284119936,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650512
    },
    {
        "content": "<p>However I think we should still have a definition of <code>def right_ideal := submodule Rᵐᵒᵖ R</code> as proposed in my <a href=\"https://github.com/leanprover-community/mathlib/pull/14399\">#14399</a>.</p>",
        "id": 284120040,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650580
    },
    {
        "content": "<p>(my only mild concern is that when we have true <code>ring</code>s as opposed to <code>semiring</code>s we might want to work with <code>R ⊗[ℤ] Sᵐᵒᵖ</code> but I think this shouldn't really be a problem)</p>",
        "id": 284120175,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653650668
    },
    {
        "content": "<p>Do we run into trouble with diamonds when <code>M = (R ⊗[ℕ] Sᵐᵒᵖ)</code>?</p>",
        "id": 284123987,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653653409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/284119584\">said</a>:</p>\n<blockquote>\n<p>And you were correctly pointing out that 2 and 3 are not equal (though they do \"correspond\" --- mathematically, the point is that when <code>Rᵐᵒᵖ</code> appears as the second argument in <code>submodule</code>, its multiplicative structure has been forgotten so there's no difference between it and <code>R</code>).</p>\n</blockquote>\n<p>I think I was confused when I wrote this and thought they didn't even correspond, but you're obviously right that they do. Indeed, the definition of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_opposite.has_scalar\">docs#mul_opposite.has_scalar</a> confirms that the multiplicative structure is forgotten.</p>",
        "id": 284124118,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1653653492
    },
    {
        "content": "<p>I should probably emphasise again that a two-sided ideal should not be called a bi-ideal. That is something else: <a href=\"https://ncatlab.org/nlab/show/biideal\">https://ncatlab.org/nlab/show/biideal</a> Personally, my preference would be to to rename the current ideal to left_ideal, and name a two-sided ideal just ideal, but if that is not wished for, just call it a two_sided_ideal.</p>",
        "id": 284141555,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1653662316
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> I do now remember you making this important point before. I'm hoping finally to push through definitions of right- and two-sided ideals in the next few days and will make sure to remember not to say \"bi-ideal\" anywhere.</p>",
        "id": 284144487,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653663547
    },
    {
        "content": "<p>As to the terminology, I wonder if we could have notation, localized to commutative/non-commutative locales that controlled whether <code>ideal</code> meant two-sided or left. For now I think we'll probably have to stick with <code>ideal</code> meaning left though.</p>",
        "id": 284144753,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653663665
    },
    {
        "content": "<p>I've just pushed <a href=\"https://github.com/leanprover-community/mathlib/pull/14465\">#14465</a> which I think should provide a convenient theory for two-sided submodules of bimodules and in particular allow us to define two-sided ideals easily.</p>",
        "id": 284386825,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653927881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/284123987\">said</a>:</p>\n<blockquote>\n<p>Do we run into trouble with diamonds when <code>M = (R ⊗[ℕ] Sᵐᵒᵖ)</code>?</p>\n</blockquote>\n<p>In fact we don't because <code>(R ⊗[ℕ] Sᵐᵒᵖ)</code> is not a module over <code>Sᵐᵒᵖ</code> because our definition of tensor product only picks up auxiliary actions from the left factor. However even if we did I think this would be a diamond we could live with.</p>",
        "id": 284387024,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1653928009
    },
    {
        "content": "<p>Highlighting a related discussion <a href=\"https://github.com/leanprover-community/mathlib/pull/14465#discussion_r898892696\">from GitHub</a> in case anyone wants to comment.</p>",
        "id": 286353351,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1655386595
    },
    {
        "content": "<p>The nub is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-modules and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module in two different ways, depending on whether we define: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⋅</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a \\cdot (m \\otimes n) = (a \\cdot m) ⊗ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (the \"left option\") or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⋅</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a \\cdot (m \\otimes n) = m \\otimes (a \\cdot n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> (the \"right option\").</p>\n<p>If we want to work with these two different <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module structures using typeclasses, we need two different types indicating whether we want to pick up the left or right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-action. Currently in Mathlib, we just arbitrarily always take the left action (thus ignoring the action of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>).</p>\n<p>I sketched out some thoughts about how to resolve this ages ago here <a href=\"#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929258\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.234773.20base.20change/near/240929258</a></p>",
        "id": 286354930,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1655387301
    },
    {
        "content": "<p>In the case at hand, we are defining an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes_R B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-module structure on a module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that carries commuting <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>-module structures (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebras <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> over a commutative ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>). This fine except for the case <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>=</mo><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">M = A \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> (for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> commutative) when our left-only convention makes <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> admissible and get a weird module structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>⋅</mo><mo stretchy=\"false\">(</mo><msup><mi>a</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>⊗</mo><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mi>b</mi><msup><mi>a</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">)</mo><mo>⊗</mo><msup><mi>b</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">(a \\otimes b) \\cdot (a&#x27; \\otimes b&#x27;) = (aba&#x27;) \\otimes b&#x27;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0019em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">ab</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7519em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7519em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 286355768,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1655387725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/286354930\">said</a>:</p>\n<blockquote>\n<p>The nub is that if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-modules and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra, then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> is naturally an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module in two different ways, depending on whether we define: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⋅</mo><mi>m</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">a \\cdot (m \\otimes n) = (a \\cdot m) ⊗ n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> (the \"left option\") or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>⋅</mo><mo stretchy=\"false\">(</mo><mi>m</mi><mo>⊗</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>a</mi><mo>⋅</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">a \\cdot (m \\otimes n) = m \\otimes (a \\cdot n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4445em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⋅</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> (the \"right option\").</p>\n</blockquote>\n<p>My naive mathematical feeling is that, in this case,  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M \\otimes_R N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> should be considered as a left <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-module, and picking up left or right <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span>-action corresponds to considering ring morphisms <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A \\to A \\otimes_R A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mbin\">⊗</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> defined by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>↦</mo><mi>a</mi><mo>⊗</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a \\mapsto a \\otimes 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>↦</mo><mn>1</mn><mo>⊗</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a \\mapsto 1 \\otimes a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.522em;vertical-align:-0.011em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">↦</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>.</p>",
        "id": 286628574,
        "sender_full_name": "Haruhisa Enomoto",
        "timestamp": 1655527464
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"419946\">@Haruhisa Enomoto</span> I agree and I have a plan that should make this work (though it's not my current priority).</p>",
        "id": 286769083,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1655716687
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/ideals.20in.20non-comm.20rings/near/284386825\">said</a>:</p>\n<blockquote>\n<p>I've just pushed <a href=\"https://github.com/leanprover-community/mathlib/pull/14465\">#14465</a> which I think should [...] allow us to define two-sided ideals easily.</p>\n</blockquote>\n<p>I just returned to this PR and have put it up for review again.</p>",
        "id": 291688860,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1659434869
    },
    {
        "content": "<p>I missed this during my hiatus. I'm super excited. I'll review it, but I'm not sure I'll have anything intelligent to say. I definitely would have missed that diamond previously mentioned.</p>",
        "id": 291715932,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1659450068
    },
    {
        "content": "<p>I should have some time to look on Thursday</p>",
        "id": 291716218,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1659450183
    },
    {
        "content": "<p>Thank you both. No rush but any comments very gratefully received!</p>",
        "id": 291719534,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1659451620
    },
    {
        "content": "<p>Now that <a href=\"https://github.com/leanprover-community/mathlib/pull/14465\">#14465</a> has been merged, it might be a good time for somebody to develop the theory of two-sided ideals. Here is how I imagine one might start:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.bimodule</span>\n\n<span class=\"n\">open_locale</span> <span class=\"n\">tensor_product</span>\n<span class=\"kn\">open</span> <span class=\"n\">mul_opposite</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">tensor_product.algebra.module</span>\n\n<span class=\"sd\">/-- A two-sided ideal in a semiring `R` is a left `submodule` of `R` as a `module` over</span>\n<span class=\"sd\">`R ⊗[ℕ] Rᵐᵒᵖ`. -/</span>\n<span class=\"kd\">@[reducible]</span> <span class=\"kd\">def</span> <span class=\"n\">two_sided_ideal</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">submodule</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">⊗</span><span class=\"o\">[</span><span class=\"n\">ℕ</span><span class=\"o\">]</span> <span class=\"n\">R</span><span class=\"bp\">ᵐᵒᵖ</span><span class=\"o\">)</span> <span class=\"n\">R</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">two_sided_ideal</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">two_sided_ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_mem_left</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">I.smul_mem</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⊗ₜ</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">tensor_product.algebra.smul_def</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_mem_right</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">convert</span> <span class=\"n\">I.smul_mem</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"bp\">⊗ₜ</span> <span class=\"n\">op</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">tensor_product.algebra.smul_def</span><span class=\"o\">],</span>\n<span class=\"kd\">end</span>\n\n<span class=\"sd\">/-- Forgetting the right action, a `two_sided_ideal` is just a left `ideal`. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">to_ideal</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"n\">subbimodule.to_submodule</span> <span class=\"n\">I</span>\n\n<span class=\"c1\">-- TODO Lots more boilerplate, presumably can be modelled on existing `ideal` API.</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">two_sided_ideal</span>\n</code></pre></div>",
        "id": 293167433,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660328246
    },
    {
        "content": "<p>Note that these still require the ring to be unital but it's still some progress.</p>",
        "id": 293167521,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660328278
    },
    {
        "content": "<p>Speaking of needing the rings to be unital: this is because of the module restriction, right? We also need modules over non-unital rings. My student is currently developing the theory of Hilbert modules but currently she is doing it over a unital C*-algebra because of this requirement.</p>",
        "id": 293173254,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660330385
    },
    {
        "content": "<p>Yes, unitality is forced on us with the proposed setup because <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module\">docs#module</a> requires a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semiring\">docs#semiring</a> rather than a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/non_unital_semiring\">docs#non_unital_semiring</a> . To remove this I suppose we'd have to  introduce some sort of <code>non_unital_module</code> class with the same axioms as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module\">docs#module</a> except without the <code>one_smul</code> axiom (ultimately coming from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mul_action\">docs#mul_action</a>). And then I guess <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> would then be redefined using <code>non_unital_module</code> (since the identity plays no role for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a>) and then we would be able to have non-unital <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> and left <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal\">docs#ideal</a> s.</p>",
        "id": 293195224,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660339376
    },
    {
        "content": "<p>I <strong>think</strong> that should do it in terms of changes to the typeclass hierarchy (just one new class) but there would also be some more work to do so that we know that <code>A ⊗[R] B</code> is a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/non_unital_comm_semiring\">docs#non_unital_comm_semiring</a> when <code>A</code> and <code>B</code> are: we currently only know this for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/comm_semiring\">docs#comm_semiring</a>.</p>",
        "id": 293195522,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660339510
    },
    {
        "content": "<p>Hopefully that's all correct, I'm typing this off the top of my head late just before I fall asleep.</p>",
        "id": 293195554,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660339532
    },
    {
        "content": "<p>Is it likely that we need to generalize mul_actions too?</p>",
        "id": 293201884,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1660342564
    },
    {
        "content": "<p>Let's only define non-unital mul_actions if we need to. I suspect it's less (or not at all?) necessary, but I've been wrong before!</p>",
        "id": 293204009,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660343724
    },
    {
        "content": "<p>How about simply define <code>non_unital_module R M</code> as <code>module (unitization ℕ R) M</code>? By the way someone should fix <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unitization.comm_semiring/src\">src#unitization.comm_semiring</a> now that we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/non_unital_comm_semiring\">docs#non_unital_comm_semiring</a>.</p>",
        "id": 293207196,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660345662
    },
    {
        "content": "<p>I'll fix <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unitization.comm_semiring\">docs#unitization.comm_semiring</a> tonight. I think the unitization trick might work, and it could actually be fairly convenient.</p>",
        "id": 293212329,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660350054
    },
    {
        "content": "<p>If unitization is a trick then defining bimodules using action of the tensor product is definitely a bigger trick :)</p>",
        "id": 293220459,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1660359275
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/16048\">#16048</a> for the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/unitization.comm_semiring\">docs#unitization.comm_semiring</a> fix. Somebody can pop it on the queue once it passes CI (just waiting for the linter).</p>",
        "id": 293347432,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660459226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240862\">@Oliver Nash</span> How much of the boilerplate do you think is necessary to make your draft a valid PR? I'm imagening that some stuff would already benefit from just being able to talk about two-sided ideals, e. g.  the definition of the Jacobson radical of a two-sided ideal in <a href=\"https://github.com/leanprover-community/mathlib/pull/13862\">#13862</a>.</p>",
        "id": 293771713,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1660673069
    },
    {
        "content": "<p>Regarding the unitization trick for modules over non-unital rings: what I really want in order to make this nice is an instance <code>module (unitization 𝕜 R) M</code> given a hypothesis <code>module (unitization ℕ R) M</code> where <code>𝕜</code> is a <code>comm_ring</code>. In other words, in practice I want to be able to replace the ring unitization with the C⋆-algebra unitization (where <code>𝕜 = ℂ</code> and <code>R</code> is a non-unital C⋆-algebra). Is this feasible?</p>",
        "id": 293773971,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660673856
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"317890\">@Julian Külshammer</span> I'm not sure. Certainly such a PR should include lemmas like <code>zero_mem</code>, <code>add_mem</code>, <code>sub_mem</code>, <code>ext</code>, ... I'd take a careful look at the existing API for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule\">docs#submodule</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ideal\">docs#ideal</a> and probably add quite a lot of what they have since code like this is fairly uncontroversial (and easy to write).</p>\n<p>However I think there are two questions to answer before embarking on such a task:</p>\n<ol>\n<li>Should we make <code>two_sided_ideal</code> a specialisation of a new <code>subbimodule R S M</code> structure? [probably]</li>\n<li>Should we wait till we've resolved the issue that <code>submodule R M</code> currently requires <code>R</code> to be unital? [probably not]</li>\n</ol>",
        "id": 293778015,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675252
    },
    {
        "content": "<p>If I ever get a chance to return to this PR <a href=\"https://github.com/leanprover-community/mathlib/pull/14399\">#14399</a> (defining right ideals) then it should give an example of a minimal API for a new definition like this.</p>",
        "id": 293778279,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"197836\">@Jireh Loreaux</span> I think that would not be feasible because the carrier type <code>𝕜</code> in such an instance would be undetermined.</p>",
        "id": 293779294,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675718
    },
    {
        "content": "<p>IIUC if you wanted to pursue this you would have to introduce a type synonym for <code>M</code> and use that in the instance.</p>",
        "id": 293779476,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675792
    },
    {
        "content": "<p>Yeah, it definitely felt like this instance was \"going the wrong way\"</p>",
        "id": 293779618,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660675837
    },
    {
        "content": "<p>It makes mathematical sense though and I <strong>think</strong> we'll be able to do this sort of thing in Lean 4.</p>",
        "id": 293779715,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675876
    },
    {
        "content": "<p>For now a type synonym (that captures <code>𝕜</code>) should work.</p>",
        "id": 293779802,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1660675904
    },
    {
        "content": "<p>Well, I'm certainly wondering at what point it makes sense to specialize all (okay, I only mean most) of the C⋆-algebra theory to <code>ℂ</code>, and this might be one situation.</p>",
        "id": 293780201,
        "sender_full_name": "Jireh Loreaux",
        "timestamp": 1660676034
    }
]
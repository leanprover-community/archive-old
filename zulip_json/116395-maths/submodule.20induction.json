[
    {
        "content": "<p>I found that I had the need of a more general  induction procedure for ideals or submodules, similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.induction_on\">docs#submodule.induction_on</a>, when one already knows that the submodule will be contained in a given submodule. In this case, the hypotheses can be weakened. Here is an example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">}</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">submodule.smul_induction_on'</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hQ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"bp\">•</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span> <span class=\"bp\">•</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">Hb</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">∈</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">N</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">H1</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">Q</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">Q</span> <span class=\"bp\">∧</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">this.2</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">submodule.smul_induction_on</span> <span class=\"n\">H</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">hQ</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">submodule.smul_mem_smul</span> <span class=\"n\">ha</span> <span class=\"n\">hx</span><span class=\"o\">)),</span> <span class=\"n\">Hb</span> <span class=\"n\">a</span> <span class=\"n\">ha</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">⟩)</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">Q.add_mem</span> <span class=\"n\">hx.1</span> <span class=\"n\">hy.1</span><span class=\"o\">,</span> <span class=\"n\">H1</span> <span class=\"n\">x</span> <span class=\"n\">hx.1</span> <span class=\"n\">y</span> <span class=\"n\">hy.1</span> <span class=\"n\">hx.2</span> <span class=\"n\">hy.2</span><span class=\"o\">⟩),</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>On the other hand one can mimick this everytime. Do you believe that the more general procedure should be added to mathlib ?</p>",
        "id": 300307149,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1663920298
    },
    {
        "content": "<p>Yes, induction principles are good.</p>",
        "id": 300307292,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1663920350
    },
    {
        "content": "<p>In fact, I realize that <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.supr_induction\">docs#submodule.supr_induction</a> should be generalized from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">supr_induction</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">supr_induction'</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">submodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hadd</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"bp\">⨆</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">i</span><span class=\"o\">),</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>(the proof is easy, up to a similar modification of <code>add_submonoid.supr_induction</code> and possibly going on inductively…)</p>",
        "id": 300313880,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1663922597
    },
    {
        "content": "<p>(The present statement requires that the predicate <code>C</code> be additive, while it is sufficient that it is additive on <code>⨆ i, p i</code>.</p>",
        "id": 300314039,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1663922655
    },
    {
        "content": "<p>I think that suggestion is the same as how we extended <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.span_induction\">docs#submodule.span_induction</a> with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.span_induction'\">docs#submodule.span_induction'</a>?</p>",
        "id": 300316615,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663923546
    },
    {
        "content": "<p>In fact, <code>submodule.span_induction'</code> suggests a more general form where even the motive depends on <code>(∈ ⨆ i, p i)</code></p>",
        "id": 300316703,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663923575
    },
    {
        "content": "<p>... Which exists already, it's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submodule.supr_induction'\">docs#submodule.supr_induction'</a> and I wrote it at the same time as the unprimed version in <a href=\"https://github.com/leanprover-community/mathlib/pull/11556\">#11556</a>!</p>",
        "id": 300316889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663923613
    },
    {
        "content": "<p>Based on that, I would say that <code>submodule.smul_induction_on'</code> is  a good idea to PR, but it should be generalized to <code>{p : Π (x : M), x ∈ I • N → Prop}</code></p>",
        "id": 300317878,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663923858
    },
    {
        "content": "<p>OK, I'll push something. <br>\nOne remark : it seems to me that the order of the arguments for doc#submodule.span_induction'  is a bit strange : since <code>{x} (hx : x ∈ submodule.span R s)</code> are the last one, the function requires four <code>_</code> to be easily applied. The other induction lemmas have <code>{x} (hx)</code> for their first argument.</p>",
        "id": 300392764,
        "sender_full_name": "Antoine Chambert-Loir",
        "timestamp": 1663946856
    },
    {
        "content": "<p>Lemmas tagged with <code>elab_as_eliminator</code> shouldn't be used with <code>apply</code> anyway, as they tend not to infer the motive correctly</p>",
        "id": 300403286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663949864
    },
    {
        "content": "<p>They behave better with <code>refine</code>, but at that point the argument order is irrelevant</p>",
        "id": 300403409,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1663949885
    }
]
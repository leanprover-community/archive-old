[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> needs non-increasing maps: <a href=\"https://github.com/leanprover-community/mathlib/pull/4707/files#diff-7988ec8f11293ebdbc60170c32d15458910725a0f10ee3333b5b60134e745ccaR23\">https://github.com/leanprover-community/mathlib/pull/4707/files#diff-7988ec8f11293ebdbc60170c32d15458910725a0f10ee3333b5b60134e745ccaR23</a></p>\n<p>We've talked a lot about this before. I think we should find some definitive solution, and implement it. (Either code, or guidelines on what to do.) Options that I see:</p>\n<ol>\n<li>Define a predicate for non-increasing maps</li>\n<li>Use the dual order.</li>\n<li>Use some rel_hom.</li>\n</ol>\n<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"302826\">@Aaron Anderson</span> <br>\n(I think Aaron did something with (3) recently, but I'm not up to speed with what's there and what works.)</p>",
        "id": 213877419,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603172930
    },
    {
        "content": "<p>I would like 2 to at least be usable</p>",
        "id": 213877436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603172985
    },
    {
        "content": "<p>Thanks for the thread!</p>\n<p>I tried 2, but was unable to get Lean to accept that the same type (\\N in my case) had two different orders...  This is my inability and it can probably be done already, but I do not know how...</p>",
        "id": 213877492,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603173038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I think there is a <code>dual_order</code> type synonym. Or maybe it is called <code>order_dual</code>?</p>",
        "id": 213877502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603173074
    },
    {
        "content": "<p>I got to the stage where I realized, I think, that <code>order_dual X</code> (or something similar) was simply a type synonym for <code>X</code> but I was not able to give it the opposite order...</p>",
        "id": 213877505,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603173095
    },
    {
        "content": "<p>it should already exist</p>",
        "id": 213877547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603173128
    },
    {
        "content": "<p><code>src/order/basic.lean</code></p>\n<p>As far as I understand, <code>order_dual X</code> is a type synonym for <code>X</code>.   How do I produce an <code>X'</code> that is \"<code>X</code> with the dual order\"?  I believe that this is simply a question of what command to give Lean, since in the cited file <code>dual_le</code> seems to exactly be the mathematical \"dual order\".</p>",
        "id": 213878140,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174182
    },
    {
        "content": "<p>There should be a <code>to_dual</code> function that is a synonym for the identity function</p>",
        "id": 213878200,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174237
    },
    {
        "content": "<p>Er, wait are you asking how to make a type that is \"<code>X</code> with the dual order\"? That's <code>order_dual X</code></p>",
        "id": 213878215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174283
    },
    {
        "content": "<p>it is a type synonym for <code>X</code> but it's order is the dual order</p>",
        "id": 213878233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174313
    },
    {
        "content": "<p>Ok, maybe this is not literally what I meant.  I would like to \"use the dual order on <code>X</code>\", but Lean keeps using the \"usual\" order on <code>X</code>, even if I call it <code>order_dual X</code>.  Is this clearer?</p>",
        "id": 213878292,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174350
    },
    {
        "content": "<p>If you have <code>a b : order_dual X</code> and write <code>a &lt;= b</code>, that will come out the same as <code>b &lt;= a</code> in the order on X</p>",
        "id": 213878310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174386
    },
    {
        "content": "<p>I will try again: maybe I got confused and Lean was doing the right thing, but I did not have it straight in my mind.</p>",
        "id": 213878311,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878310\">said</a>:</p>\n<blockquote>\n<p>If you have <code>a b : order_dual X</code> and write <code>a &lt;= b</code>, that will come out the same as <code>b &lt;= a</code> in the order on X</p>\n</blockquote>\n<p>Ok, this is exactly what I want: I will try again!</p>",
        "id": 213878318,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174412
    },
    {
        "content": "<p>If you have <code>a b : X</code> and write <code>(a : order_dual X) &lt;= b</code> though, it will still come out as <code>a &lt;= b</code></p>",
        "id": 213878364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174444
    },
    {
        "content": "<p>which is why it's useful to have an identity function here: if you write <code>@id (order_dual X) a &lt;= @id (order_dual X) b</code> then that comes out as <code>b &lt;= a</code></p>",
        "id": 213878384,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174491
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878384\">said</a>:</p>\n<blockquote>\n<p>which is why it's useful to have an identity function here: if you write <code>@id (order_dual X) a &lt;= @id (order_dual X) b</code> then that comes out as <code>b &lt;= a</code></p>\n</blockquote>\n<p>I believe that this is exactly the command that I was missing!</p>",
        "id": 213878483,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174605
    },
    {
        "content": "<p>Usually we define <code>to_dual : X -&gt; order_dual X := id</code> and then use <code>to_dual</code> instead of that <code>@id</code> application</p>",
        "id": 213878506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174649
    },
    {
        "content": "<p>but I don't know if that's in the library</p>",
        "id": 213878514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174663
    },
    {
        "content": "<p>I had produced a new type with an order and defined an \"order reversing function\".  Now I should be able to use the <code>order_dual</code> type and this <code>@id (order_dual X)</code></p>",
        "id": 213878524,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/(anti)-monotone/near/213878506\">said</a>:</p>\n<blockquote>\n<p>Usually we define <code>to_dual : X -&gt; order_dual X := id</code> and then use <code>to_dual</code> instead of that <code>@id</code> application</p>\n</blockquote>\n<p>I searched for \"<code>to_dual</code>\" and it was not in the file above.</p>",
        "id": 213878575,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174705
    },
    {
        "content": "<p>Our practices in defining type synonyms have changed over the years</p>",
        "id": 213878592,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174735
    },
    {
        "content": "<p>see for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/opposite.op/src\">src#opposite.op</a></p>",
        "id": 213878622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174796
    },
    {
        "content": "<p>It's possible to avoid using these identity functions, but you have to assert a lot more type annotations and you get more \"leakage\" of the instance from X instead of order_dual X</p>",
        "id": 213878683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603174852
    },
    {
        "content": "<p>I was not expecting to find a <code>to_dual</code>, since I am not sure yet what to expect with Lean!  However, what you mentioned is highly likely to solve my problems!</p>",
        "id": 213878788,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603174945
    },
    {
        "content": "<p>I seem to have the same problem: I would like the <code>min'</code> to be computed using the dual order, but it seems to be still the old order...</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_dual</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">monotone_max'_min'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">min'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nonempty.image</span> <span class=\"n\">hs</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"n\">α</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">sorry</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213879774,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603176029
    },
    {
        "content": "<p>You probably want</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_dual</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_dual</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">monotone_max'_min'</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">=</span> <span class=\"n\">of_dual</span> <span class=\"o\">(</span><span class=\"n\">min'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">to_dual</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nonempty.image</span> <span class=\"n\">hs</span> <span class=\"n\">to_dual</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213880046,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603176302
    },
    {
        "content": "<p>(In case it is helpful, this is my earlier question on the topic:<br>\n<a href=\"#narrow/stream/113489-new-members/topic/monotone.20decreasing.20.60.60.60.E2.84.95.20.E2.86.92.20.E2.84.95.60.60.60\">https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/monotone.20decreasing.20.60.60.60.E2.84.95.20.E2.86.92.20.E2.84.95.60.60.60</a>)</p>",
        "id": 213880086,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603176346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> In your example, Lean was looking at the <code>=</code>, and thinking</p>\n<blockquote>\n<p>hmmm, where does this <code>=</code> live? Let's look at the LHS: <code>max' s hs</code>. Ok, that's in <code>\\alpha</code>. So then the RHS must also live in <code>\\alpha</code>, so I'm going to take that <code>min'</code> in <code>\\alpha</code> with the order coming from <code>\\alpha</code>.<br>\nAah, I see that the user wrote <code>to_dual</code>, but I'm going to ignore that.</p>\n</blockquote>",
        "id": 213880165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603176406
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> thanks for the explanation!  I will use your code!</p>",
        "id": 213880179,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603176433
    },
    {
        "content": "<p>Because I added the <code>of_dual</code> in front of the RHS, Lean will think</p>\n<blockquote>\n<p>Ok, so the RHS has to live in <code>\\alpha</code>. That means that the argument to <code>of_dual</code> must live in <code>order_dual \\alpha</code>. Let me take the <code>min'</code> in the order dual of <code>\\alpha</code>.</p>\n</blockquote>",
        "id": 213880208,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603176475
    },
    {
        "content": "<p>Yes, please define, if they don't exist already, explicit <code>to_dual</code> and <code>of_dual</code> functions, and use those. Ideally after defining those you can mark <code>order_dual</code> as <code>[irreducible]</code>, which will guard against \"accidentally\" changing between the type and its <code>order_dual</code>.</p>",
        "id": 213881362,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1603177564
    },
    {
        "content": "<p>This still breaks through a little bit of abstraction. But it is a start.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.finsupp.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">to_dual</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_dual</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">id</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_dual_of_dual</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">to_dual</span> <span class=\"o\">(</span><span class=\"n\">of_dual</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_dual_to_dual</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_dual</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">section</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_dual_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">to_dual</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.injective_id</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_dual_inj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_dual</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">to_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_dual_le_to_dual</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_dual</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">to_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">to_dual_lt_to_dual</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_dual</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">to_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_dual_injective</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">of_dual</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">function.injective_id</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_dual_inj</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">of_dual</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">of_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_dual_le_of_dual</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">of_dual</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">of_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">@[simp]</span> <span class=\"kd\">lemma</span> <span class=\"n\">of_dual_lt_of_dual</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">of_dual</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">of_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">le_to_dual</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">to_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">of_dual</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lt_to_dual</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">to_dual</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">of_dual</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_dual_le</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_dual</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">of_dual</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">to_dual_lt</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">order_dual</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">to_dual</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">of_dual</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">monotone_max'_min'</span> <span class=\"o\">[</span><span class=\"n\">decidable_linear_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s.nonempty</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">max'</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">=</span> <span class=\"n\">of_dual</span> <span class=\"o\">(</span><span class=\"n\">min'</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">to_dual</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">nonempty.image</span> <span class=\"n\">hs</span> <span class=\"n\">to_dual</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">max'_le</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">le_to_dual</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">min'_le</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">mem_image</span><span class=\"o\">],</span>\n    <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">to_dual_le</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_min'</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">to_dual_le</span><span class=\"o\">],</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_max'</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mem_image</span> <span class=\"n\">at</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">H</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">H</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 213881455,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603177673
    },
    {
        "content": "<p>the last proof would be simpler if you prove <code>of_dual (min' x y) = max' (of_dual x) (of_dual y)</code> and variations</p>",
        "id": 213881580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603177788
    },
    {
        "content": "<p>well, I guess that's already what it is</p>",
        "id": 213881708,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603177912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <br>\nThank you for spelling everything out for me!</p>\n<p>What I needed indeed was the statement that <code>max'</code> and <code>min'</code> are exchanged after going through the order dual!  I was going to prove as an exercise the analogous statement about <code>max</code> and <code>min</code> of individual elements, but I had to leave and left all for later!</p>",
        "id": 213884173,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603179756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <code>max</code> and <code>min</code> are defined so that <code>max a b = min (to_dual a) (to_dual b)</code> is a <code>rfl</code>.</p>",
        "id": 213901350,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603190881
    },
    {
        "content": "<p>I think that we should rename <code>monotone</code> to <code>mono_incr</code> and define <code>mono_decr</code>.</p>",
        "id": 213901408,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603190903
    },
    {
        "content": "<p><code>mono_decr α β</code> should be defeq <code>mono_incr α (order_dual β)</code></p>",
        "id": 213901480,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603190955
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">mono_decr</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">{{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}},</span> <span class=\"n\">x</span> <span class=\"bp\">≤</span> <span class=\"n\">y</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n</code></pre></div>",
        "id": 213901506,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603190981
    },
    {
        "content": "<p>Most proofs about <code>mono_decr</code> should be <code>:= @(thm_about_mono_incr) _ (order_dual _) _ _ _</code></p>",
        "id": 213901571,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603191009
    },
    {
        "content": "<p>See <code>strict_mono_decr_on</code> for an example.</p>",
        "id": 213901582,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603191025
    },
    {
        "content": "<p>In general mathlib has got a very long way with its philosophy that the nicest structures and ideas are the ones which preserve notation. For example we have a gigantic theory about functions satisfying f(a+b)=f(a)+f(b). On the other hand it seems we have essentially nothing about functions satisfying f(a*b)=f(a)+f(b), because we have noticed that the mathematician's conventions for addition and multiplication often seem to be going on in some kind of consistent and compatible way (surprise surprise) -- but not always (see e.g. additive valuations, which don't exist in mathlib yet). There is some kind of \"exponential / log\" bridge which takes you from the multiplicative to the additive structure and back, but we don't have a general class of functions with this property, we just have <code>multiplicative.to_add</code> and are expected to build everything upon that.</p>\n<p>The argument against adding some kind of <code>+→*</code> notation is that \"it won't scale\". Fortunately, in the 2000 years since we've known about <code>+</code> and <code>*</code> we've not invented any more fundamental operations which are valid in vast generality, so these things won't have to scale much. The ever-increasing pile of -&gt; and \\equiv notation is of course a bit disturbing (and makes mathlib harder to read for mathematicians with no background), but this is perhaps a different question.</p>\n<p>I've always thought of this &lt;= v &gt;= thing as being a similar sort of thing. Thus far we have stuck with the order-preserving concept <code>monotone</code>, and because the universe is in some sort of harmony we've been able to get a long way with it. However there is this fundamental fact that if &lt;= is a partial order then so is &gt;=, and furthermore in the kind of MSc level stuff we're doing now we do see this duality showing up; many natural constructions relating algebra and geometry e.g. the contravariant Galois connection between subsets of affine n-space and subsets of polynomial rings (subspace goes to functions vanishing on the subspace; set of functions goes to subset where they all vanish) (edit: perhaps it's also worth mentioning Galois' original Galois connection! An order-reversing one between subsets of a field and subsets of a Galois group, a very natural example of a <code>mono_decr</code> and one which we will be needing very soon in mathlib). Thus far we've been expected to rely on <code>order_dual</code> and do everything by hand, but one wonders whether now it is time to experiment with these classes which don't preserve a notation but instead map it to another notation. I'm definitely for the experiment.</p>",
        "id": 213902264,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603191610
    },
    {
        "content": "<p>I have read your suggestions, and I am happy with them!  I just do not trust my understanding of Lean enough to actually perform such a major revision of <code>monotone</code>.  What I needed was really just the proof above.  I will try to see <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>'s solution using <code>order_dual</code>s but already the comment about <code>irreducible</code> is very opaque to me...</p>",
        "id": 213902711,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603191943
    },
    {
        "content": "<p>Those of us who don't want these hybrid functions will end up having to ask for the monoid hom <code>exp' : multiplicative(real) -&gt; real</code> because they will be restricted to the classes that we currently have. Similarly if we don't inroduce this then we'll end up with subfields -&gt; order_dual (subgroups) in Galois theory, and perhaps order_dual(subgroups) -&gt; subfields as well (even moving between those two \"identical\" maps will be a slight pain, and of course we have the same question for the inverses). With this proposal we just get one <code>mono_decr</code>.</p>",
        "id": 213902797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603191988
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> Mathlib is \"weird\" when it comes to groups. The founders decided to set up the entire theory twice, once with <code>group</code> for group law <code>*</code> and once with <code>add_group</code> with group law <code>+</code>. On the face of it, this sounds like a terrible idea! I think it came out of the way notation is used in typeclasses. But actually it seems to work fine in practice. However it does mean that the concept of an isomorphism between a multiplicative and an additive group is a new concept, different to isomorphisms of multiplicative groups (which we have already). We have sort of been resisting making these bridges and this is what has held up valuations on a DVR (that and the fact that I had to make a whole bunch of vlogs for the new Imperial students, something which has taken me 6 weeks of solid work). I now know what I'm doing (I'm just going to mimic what Rob did for p-adic valuations) but this doesn't mean that that questions go away in general. A lot of stuff is order-reversing once you start doing algebraic geometry. Yury is just suggesting hard coding some special case of a contravariant functor to see if it makes life better -- instead of being a covariant functor to the dual category (or is it from the dual category? Same thing to us, different thing to Lean), it's perhaps time to experiment directly. This stuff has all come up before, and people have just been playing with what to do about it in general.</p>",
        "id": 213903328,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603192355
    },
    {
        "content": "<p>I am perfectly happy with having commands for <code>monotone_decreasing</code>!  Most of the PRs that I put in were to deal with <code>trailing_coefficient</code>s which is simply the <code>leading_coefficients</code> for the opposite order!!  So I am all in favour of making this a simpler procedure!  I just had no idea where to start.  Now, I think that I know where to start, but do not feel that I am able to produce code like the one that <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> produced as quickly and efficiently...</p>",
        "id": 213903869,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603192760
    },
    {
        "content": "<p>yes, setting up the foundations should perhaps be done by an expert.</p>",
        "id": 213903959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1603192808
    },
    {
        "content": "<p>Could I suggest making a PR with the code that <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> wrote above in a separate file in the <code>order</code> folder, maybe in a file called <code>mon_decr.lean</code>, so that <a href=\"https://github.com/leanprover-community/mathlib/issues/4707\">#4707</a> can then proceed?  The lemma there is the only \"monotone-decreasing\" information that I need...</p>",
        "id": 213923630,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603202722
    },
    {
        "content": "<p>I think that apart from the min-max lemma, all the stuff that I wrote should be close to the definition of <code>order_dual</code></p>",
        "id": 213928215,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603204577
    },
    {
        "content": "<p>The min-max lemma can probably go close to the definition of <code>min'</code> and <code>max'</code></p>",
        "id": 213928262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603204597
    },
    {
        "content": "<p>In case you are interested, I created this PR: <a href=\"https://github.com/leanprover-community/mathlib/issues/4715\">#4715</a>.  I simply merged <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> 's code where it seemed appropriate!</p>",
        "id": 213932128,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603206201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> I think the <code>monotone_max'_min'</code> should get a different name, though</p>",
        "id": 213932660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603206406
    },
    {
        "content": "<p>And we need a different reviewer, because I wrote too much of this PR</p>",
        "id": 213932720,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603206428
    },
    {
        "content": "<p>Also, I think you don't need the linear order assumption, right?</p>",
        "id": 213932798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603206469
    },
    {
        "content": "<p>Under which assumptions are <code>min'</code> and <code>max'</code> defined? I dunno</p>",
        "id": 213932869,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603206487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/(anti)-monotone/near/213932660\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> I think the <code>monotone_max'_min'</code> should get a different name, though</p>\n</blockquote>\n<p><code>max'_eq_dual_min'</code>?</p>",
        "id": 213934870,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603207223
    },
    {
        "content": "<p>I think that's better</p>",
        "id": 213935577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603207545
    },
    {
        "content": "<p>Maybe we can reverse the equality and think of it as a <code>simp</code> lemma?</p>",
        "id": 213936574,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603207979
    },
    {
        "content": "<p>(and call it <code>dual_min'_eq_max'</code>)</p>",
        "id": 213936691,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1603208025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I agree that antitone functions or whatever we call them are important and on a fairly short list of permutations on the symbols we have available so there isn't too much risk of combinatorial growth, but I would still like to see it grow \"organically\", waiting until we have a critical mass of theorems about order_dual homs so that we know what's important</p>",
        "id": 213936782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603208052
    },
    {
        "content": "<p>I think the max/min simp lemmas should be <code>of_dual (max a b) = min (of_dual a) (of_dual b)</code> and the four variations on this with min/max swapped and <code>to_dual</code> instead of <code>of_dual</code></p>",
        "id": 213936957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603208140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> If you carefully define <code>max'</code> and <code>min'</code>, then the duality is a <code>rfl</code>.</p>",
        "id": 213939862,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603209483
    },
    {
        "content": "<p>But then we need to redefine them, I guess?</p>",
        "id": 213943709,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1603211077
    },
    {
        "content": "<p>Where are they defined? I'm on the phone.</p>",
        "id": 213945267,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603211768
    },
    {
        "content": "<p>I've redefined min and max in stdlib to get rfl some time ago</p>",
        "id": 213945684,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1603211974
    },
    {
        "content": "<p>I would like to flag an analogy:  working with anti-monotone functions as monotone functions for the order-dual (defined via a type synonym) on one of the sets, is quite similar to what <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> is currently working on in <a href=\"https://github.com/leanprover-community/mathlib/issues/4379\">#4379</a>, working with conjugate-linear maps as linear maps for the conjugate-space (defined via a type synonym) of one of the two vector spaces.</p>",
        "id": 213945720,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603211995
    },
    {
        "content": "<p>I haven't had time to read this thread and think through whether there are any lessons that can be taken from it for <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> ' situation (or vice versa).  But I'll try later (or maybe someone more experienced can do so immediately).</p>",
        "id": 213945953,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1603212091
    },
    {
        "content": "<p>To add a bit more details: <a href=\"https://github.com/leanprover-community/mathlib/issues/4379\">#4379</a> basically introduces the dual of a Hilbert space, and we want to show that the map that takes a vector to its dual is semilinear. Since we don't have semilinear maps, we can instead view it as a linear map from the conjugate vector space to the dual, so conjugate vector spaces are also defined there as a type synonym with the right instances.</p>",
        "id": 213977866,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603227108
    },
    {
        "content": "<p>As for <code>order_dual</code>, my experience with it has been that it's a great way to get one-line proofs, for example see all the lemmas about <code>concave_on</code> in <code>analysis/convex/basic</code>.</p>",
        "id": 213978832,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603227631
    },
    {
        "content": "<p>But when one has to convert back and forth all the time between a type and its synonym it's quite painful.</p>",
        "id": 213979029,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1603227729
    },
    {
        "content": "<p>Dear All,</p>\n<p>I have been struggling to use the new version of monotone, using <code>order_dual</code> and I am ready to give up!  I find it incredibly difficult to even understand if <code>max'</code> is using the \"natural order\" or the <code>order_dual</code>.  In proofs, I constantly face goals of the form <code>a=a</code> where <code>a : ℕ</code> and <code>a : order_dual ℕ</code>.  Almost never I am able to get Lean to realize that they are the same, since then <code>rw</code>, <code>simp_rw</code>, <code>congr</code>, <code>convert ...</code> all appear to fail.</p>\n<p>It would be nice to have orders and their duals to work, but I am unable to understand how.  In particular, I no longer know how to prove that <code>nat_degree (reverse f)</code> equals <code>nat_degree f - nat_trailing_degree f</code>.</p>\n<p>If someone is willing to give it a try, I would be happy to see this method succeed!  Otherwise, I would prefer to go back to the clunky-but-workable strategy of not introducing <code>order_dual</code> and instead using <code>max</code> and <code>min</code> on the same order.</p>",
        "id": 217385897,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605869399
    },
    {
        "content": "<p>Thanks a lot for trying. And I'm sorry to hear that the experiment failed.</p>",
        "id": 217386201,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605869619
    },
    {
        "content": "<p>Would you mind posting the file with your experiment?</p>",
        "id": 217386280,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605869650
    },
    {
        "content": "<p>sure, I will clean up the junk and produce a template to try out!</p>",
        "id": 217386306,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605869674
    },
    {
        "content": "<p>Merci!</p>",
        "id": 217386514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1605869797
    },
    {
        "content": "<p>you should be able to find the file here:</p>\n<p><a href=\"https://gist.github.com/adomani/6f82a36069e60b318741bdf8d3bcbf76\">https://gist.github.com/adomani/6f82a36069e60b318741bdf8d3bcbf76</a></p>\n<p>The file is quite long, but everything up to line 290 is essentially already in mathlib.  My first change has been on line 291, with the introduction of <code>order_dual</code> and <code>to_dual</code>.  After that, it has been a lot of pain to make progress.  Lemma <code>typ</code> on line 349 is an extracted goal to see if things work out: you can safely ignore it!  However, those are the kind of issues that sometimes I was able to overcome, but often stumped me!</p>\n<p>Do ask questions: I am more than happy to learn from them!</p>",
        "id": 217387695,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605870539
    },
    {
        "content": "<p>I suspect that things might be easier if <code>reverse</code> and <code>reflect</code> were also defined using <code>order_dual</code>, but I am not sure that this would really be an improvement: I find it very hard to \"switch on and off\" order instances in Lean.</p>",
        "id": 217387844,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605870640
    },
    {
        "content": "<p>I'm confused - isn't <code>to_dual</code> already in mathlib? If so, why do you redefine it in your gist?</p>",
        "id": 217387917,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605870698
    },
    {
        "content": "<p>It is already in mathlib, but since not all the statements that follow are in mathlib, I included all that I knew was needed in order to produce a working (highly non-minimal) example!</p>",
        "id": 217388002,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605870750
    },
    {
        "content": "<p>(You will find other definitions and lemmas that are already in mathlib, but if you use this file with its imports, it seems to compile with no problems on my version of lean, up to line 360.  In fact, up to 366, but I am not sure that my attempt really leads in a good direction.)</p>",
        "id": 217388172,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1605870854
    },
    {
        "content": "<p>I just found out that we have <code>strict_mono_decr_on</code> in mathlib.<br>\nIt seems really weird that we have that specific special case, but not <code>mono_decr</code> or <code>strict_mono_decr</code> in general.</p>",
        "id": 218064890,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606464210
    },
    {
        "content": "<p>I think that we are coming to the conclusion that <code>order_dual</code> is useful, but doesn't scale as a solution.</p>",
        "id": 218064907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606464234
    },
    {
        "content": "<p>I'm starting to lean (no pun) towards the position that we should refactor to have separate notions of <code>mono_incr</code> and <code>mono_decr</code> with solid APIs for both of them. (One can be defined using <code>order_dual</code>, in terms of the other. I don't care.)</p>",
        "id": 218064998,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1606464306
    },
    {
        "content": "<p>After a conversation with <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> in <a href=\"#narrow/stream/116395-maths/topic/Friday.20afternoon.20puzzle.20--.2037.20.E2.88.88.2037.3F/near/217494354\">this thread</a>, I think that the suggestion was to prove a bunch of results with a \"flabby\" <code>order_dual</code>, so as to have a solid API.  Eventually, though, making <code>order_dual</code> <code>irreducible</code> (something that I do not understand, so this might be nonsense) should give a workable setup.</p>\n<p>To be honest, I am not entirely sure how this would work.  For instance, I am very happy to have both <code>min</code> and <code>max</code> defined on <code>ℕ</code> and I would rather not have to switch to <code>order_dual</code> twice to convert a <code>min</code> to a <code>max</code> or vice-versa.</p>\n<p>Also, if I have been following the various \"galois connection\" discussions, I suspect that this might be one, right?</p>",
        "id": 218067012,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606466132
    },
    {
        "content": "<p>Galois connections are all covariant in Lean! So in particular none of the ones I knew about before coming here (subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi mathvariant=\"double-struck\">A</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">\\mathbb{A}^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathbb\">A</span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> and subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi><mo stretchy=\"false\">[</mo><msub><mi>X</mi><mn>1</mn></msub><mo separator=\"true\">,</mo><mo>…</mo><mo separator=\"true\">,</mo><msub><mi>X</mi><mi>n</mi></msub><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">k[X_1,\\ldots,X_n]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>, and, erm, Galois theory) are in Lean :-)</p>",
        "id": 218067258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606466307
    },
    {
        "content": "<p>The ones in Lean right now are things like subsets of a group and subgroups of a group</p>",
        "id": 218067277,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606466336
    },
    {
        "content": "<p>Ahhhh!!!  It had not clicked in me the issue with covariance/contravariance!  In my mind, affine schemes \"were essentially\" in Lean, since there is a lot of commutative algebra!!  Now that I had so much trouble getting results about leading coefficients imply results on trailing coefficients, I appreciate better the chasm that still exists!</p>",
        "id": 218067398,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606466431
    },
    {
        "content": "<p>Now that I am slightly more Lean-versed, I have a question.</p>\n<p>When using the <em>same</em> type with different relations, I can see that this might cause confusion and introducing a type-synonym might make things worse: having two types for the natural numbers, one called ℕ and the other called <code>order_dual ℕ</code> is not so useful when you want to talk about <code>max</code> and <code>min</code> simultaneously.</p>\n<p>However, when the relations are on \"really\" different types, like homomorphisms of <code>comm_rings</code> and morphisms of <code>affine schemes</code>, why is it a problem to set up the relations at the beginning, so that they match?</p>\n<p>In the specific case of Galois theory, I might even go further and say that in Lean it might therefore be simpler to establish the Galois connection between subgroups and spectra of fields!!</p>",
        "id": 218068266,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606467152
    },
    {
        "content": "<p>Galois connection: that's an interesting idea :-) The issue with contravariant Galois connections is literally that the definition is not there.</p>",
        "id": 218068775,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606467602
    },
    {
        "content": "<p>Still, I am not sure that I understand this issue with covariance/contravariance too well.  (The discussion below is likely a rambling based on a misconception.)</p>\n<p>\"In set theory\", by construction, given any two mathematical objects <code>A</code> and <code>B</code>, they are sets and at least the question \"is <code>A</code> a subset of <code>B</code> makes sense.  Thus, the proper class of all mathematical objects is a poset (!).  This is then abused and moved around identifications, but everyone always has a lingering feeling of what \"containment\" means, at least in local contexts.  For instance, subgroups of Galois group are ordered by inclusion, fields are ordered by inclusion, these two natural orders, clash.</p>\n<p>However, \"in type theory\", the poset structure needs to be provided externally.  So, what is the problem with covariance/contravariance, if we get to choose which way the arrows point?</p>",
        "id": 218068817,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606467607
    },
    {
        "content": "<p>The computer scientists are always scared about the way things scale, at least this is my impression. If we define contravariant Galois connections then we have to define contravariant poset maps (a &lt;= b -&gt; f(a) &gt;= f(b)) etc etc, and they say \"we can just use <code>order_dual</code> and that's only one function so it scales\". But it also makes things more complicated.</p>",
        "id": 218068969,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606467738
    },
    {
        "content": "<p>Ok, but then whichever one of <code>min</code> or <code>max</code> you define first, already implies the other, right?</p>",
        "id": 218069038,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606467799
    },
    {
        "content": "<p>(I am trying to undestand the basic principles, I am not trying to be snappy, in case the chat gives a wrong impression!)</p>",
        "id": 218069093,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606467838
    },
    {
        "content": "<p>min and max are still both defined on one type, they didn't go that far :-)</p>",
        "id": 218069187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606467901
    },
    {
        "content": "<p>Would it then be the case that there should be an \"orderless\" bijection between <code>ℕ</code> and <code>order_dual ℕ</code>?</p>",
        "id": 218069218,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606467921
    },
    {
        "content": "<p>Sure, and that map should even have a name. If <code>order_dual</code> is semireducible then people might even use <code>id</code> for that name, but if it's irreducible then it would have an explicit name like <code>to_dual</code> or whatever.</p>",
        "id": 218069335,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606467990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/(anti)-monotone/near/218069187\">said</a>:</p>\n<blockquote>\n<p>min and max are still both defined on one type, they didn't go that far :-)</p>\n</blockquote>\n<p>To be fair, I think that this is the right choice!  But then, I would like to be able to say that a linear function is monotone increasing/decreasing, rather than having to define it from the correctly ordered type so that it is always monotone increasing!</p>",
        "id": 218069372,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606468034
    },
    {
        "content": "<p>I guess some people are defining <code>antimono</code> functions, but we don't have contravariant Galois connections or insertions yet, like we don't have functions from A to B such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(xy)=f(x)+f(y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>. People look at definitions like this and are scared that such a definition will lead to some chaos, but I'm not convinced it will. Another example is contravariant functors. You have to decide which category to put the \"op\" on and there is no canonical answer. Another way of doing it would just to have been to define contravariant_functor to be a map between the categories and write down the axioms rather than opping something. The disadvantage with this approach is that then there's a risk you have to develop the entire functor API again in the contravariant setting. Perhaps a solution to this would be to write a tactic using a <code>@[to_contravariant]</code> tag, but this would be hard work.</p>",
        "id": 218081616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606476551
    },
    {
        "content": "<p>It is a little frustrating that the innocent-looking assertion \"reverse all the arrows in your category\" causes so much trouble in formalization</p>",
        "id": 218082482,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606477179
    },
    {
        "content": "<p>However, even the consequences for intuition of such a change are <strong>huge</strong>: no one had realized that commutative rings with 1 are affine schemes, until Grothendieck, I think!</p>",
        "id": 218082604,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606477264
    },
    {
        "content": "<p>Think about it this way. Is a contravariant functor actually equal to (a) a covariant functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>→</mo><msup><mi>D</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">C\\to D^{op}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span></span></span></span> (b) a covariant functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C^{op}\\to D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">o</span><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> (c) a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">C\\to D</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span> with some properties? All of these are \"the same\" but in fact none of them are the same. Machinery should be able to cover this up, whether it's a good API or good tactics, but this machinery needs to be made.</p>",
        "id": 218082608,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606477267
    },
    {
        "content": "<p>I agree: I personally like to have the opposite and place it on the category that I am less familiar with!  I can see how this is somewhat difficult to formalize...  <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 218082864,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1606477452
    },
    {
        "content": "<p>There's a <code>galois_connection</code> using <code>order_dual</code> in <code>analysis.normed_space.inner_product</code> for orthogonal complements of subspaces. (Immediately followed by a series of lemmas with one-line proofs, so that you don't need to think about two different orders on subspaces at the same time in order to use those properties of orthogonal subspaces.)</p>",
        "id": 218142565,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1606530203
    }
]
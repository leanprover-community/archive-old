[
    {
        "content": "<p>I am struggling with a proof for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code> <span class=\"bp\">⁅</span><span class=\"n\">H₁.prod</span> <span class=\"n\">H₂</span><span class=\"o\">,</span> <span class=\"n\">K₁.prod</span> <span class=\"n\">K₂</span><span class=\"bp\">⁆</span> <span class=\"bp\">=</span> <span class=\"bp\">⁅</span><span class=\"n\">H₁</span><span class=\"o\">,</span> <span class=\"n\">K₁</span><span class=\"bp\">⁆.</span><span class=\"n\">prod</span> <span class=\"bp\">⁅</span><span class=\"n\">H₂</span><span class=\"o\">,</span> <span class=\"n\">K₂</span><span class=\"bp\">⁆</span>\n</code></pre></div>\n<p>(which I hope is true) that doesn’t end up with a horribly involved double induction on the <code>closure</code> that’s in the definitions of the general commutator. Is there no simple argument? ( <code>≤ </code> is the easy direction.)</p>",
        "id": 270601447,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643915339
    },
    {
        "content": "<p>Maybe a helpful step would be a nice lemma that shows <code>H.prod K ≤ J</code> from assumptions of he form <code>H ≤ …</code> and <code>K ≤ …</code> , but I have no good idea yet.</p>",
        "id": 270601966,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643915536
    },
    {
        "content": "<p>Hmm, maybe it makes sense to start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">S1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"o\">(</span><span class=\"n\">closure</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">S1</span> <span class=\"bp\">×ˢ</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">\\</span><span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">S2</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>But that, too, needs ugly double induction.</p>",
        "id": 270603114,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643916064
    },
    {
        "content": "<p>I think this is the right general idea</p>",
        "id": 270608707,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643918374
    },
    {
        "content": "<p><del>You can prove that the abelianization commutes with products, and use the fact that the commutator subgroup is the kernel of the abelianization.</del></p>",
        "id": 270608935,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918434
    },
    {
        "content": "<p>Oh wait, I don't actually know what those symbols mean</p>",
        "id": 270609044,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918489
    },
    {
        "content": "<p>Ignore me.</p>",
        "id": 270609050,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1643918491
    },
    {
        "content": "<p>I think this should boil down to the fact that <code>H.prod K</code> is the subgroup generated by elements of the form <code>(h, 1)</code> and <code>(1, k)</code></p>",
        "id": 270609281,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643918588
    },
    {
        "content": "<p>(whoops, pretend I wrote <code>H₁.prod H₂</code> is ...)</p>",
        "id": 270609339,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643918622
    },
    {
        "content": "<p>Ah, indeed, if I start with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">H.prod</span> <span class=\"n\">K</span> <span class=\"bp\">=</span> <span class=\"n\">closure</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"bp\">×ˢ</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">\\</span><span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"bp\">×ˢ</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>I avoid juggling with so many closures.</p>\n<p>And then <code>⁅H₁, K₁⁆.prod ⁅H₂, K₂⁆ ≤ ⁅H₁.prod H₂, K₁.prod K₂⁆</code> suddenly has a closure on the left, and that’s easier.</p>\n<p>Hmm, in the end that would be as useful as the following lemma, which would avoid talking about closure explicitly.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">le_prod_iff</span> <span class=\"o\">:</span> <span class=\"n\">H.prod</span> <span class=\"n\">K</span> <span class=\"bp\">≤</span> <span class=\"n\">J</span> <span class=\"bp\">\\</span><span class=\"n\">iff</span> <span class=\"o\">(</span><span class=\"n\">H.prod</span> <span class=\"bp\">\\</span><span class=\"n\">bot</span> <span class=\"bp\">≤</span> <span class=\"n\">J</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"bp\">\\</span><span class=\"n\">bot.prod</span> <span class=\"n\">K</span>  <span class=\"bp\">≤</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Worth exploring, although I am not 100% sure yet that it will help in the end, and how easily this idea generalizes to Pi subgroups. Anyways, I’ll leave that for tomorrow .</p>",
        "id": 270610646,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643919221
    },
    {
        "content": "<p>It seems to me that it doesn't, unless you use the \"direct sum\" (not product) of subgroups.</p>",
        "id": 270611452,
        "sender_full_name": "Reid Barton",
        "timestamp": 1643919599
    },
    {
        "content": "<p>It might actually,  if I rephrase <code>H.prod \\bot</code> as <code>map (λ x, (x,1)) H</code>. Then I’d be faced with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">map</span> <span class=\"bp\">…</span> <span class=\"bp\">⁅</span><span class=\"n\">H₁</span><span class=\"o\">,</span> <span class=\"n\">K₁</span><span class=\"bp\">⁆</span> <span class=\"bp\">≤</span> <span class=\"bp\">⁅</span><span class=\"n\">H₁.prod</span> <span class=\"n\">H₂</span><span class=\"o\">,</span> <span class=\"n\">K₁.prod</span> <span class=\"n\">K₂</span><span class=\"bp\">⁆</span>\n</code></pre></div>\n<p>then I can apply <code>subgroup.comap_map_eq_self_of_injective</code> to have <code>⁅H₁, K₁⁆ ≤ …</code> and then it’s just a simple calculation. <br>\nAnd this actually has a chance to generalize to Pi-types.<br>\nHopefully I won’t find a flaw in this plan before I go to bed :-)</p>",
        "id": 270615622,
        "sender_full_name": "Joachim Breitner",
        "timestamp": 1643921450
    }
]
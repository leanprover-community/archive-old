[
    {
        "content": "<p>Here's an example of an arithmetic fact that's somewhat harder to prove in <code>ℕ</code> than <code>ℤ</code>. It's also clear to a mathematician that the latter one implies the former.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_add_left</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">ring_exp</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 197998841,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589837942
    },
    {
        "content": "<p>After a bit of thought, it seems the reason it's clear that one implies the other is because there's an embedding of semirings <code>ℕ → ℤ</code>. Is it feasible to make a tactic that helps you figure out that that's what you need? (And then, is typeclass instance search able to find that embedding?)</p>",
        "id": 197999038,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838056
    },
    {
        "content": "<p>I'm imagining that at the commented point in this proof you say something like <code>transfer key</code> and the goal gets replaced with asking you for a semiring embedding (or maybe it asks for separate embeddings for the <code>has_add</code> and <code>has_pow</code>)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"k\">have</span> <span class=\"n\">key</span> <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">ring_exp</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">},</span>\n<span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span>\n<span class=\"c1\">-- apply an embedding of semirings ℕ → ℤ?</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 197999191,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838167
    },
    {
        "content": "<p>I am now strongly of the opinion that one should not even be proving results like your example</p>",
        "id": 197999316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838248
    },
    {
        "content": "<p>I don't think that your question should typecheck because I don't think subtraction should be defined on nat</p>",
        "id": 197999401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838305
    },
    {
        "content": "<p>Here's where it came from</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">big_operators</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"n\">theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">big_operators</span>\n<span class=\"kn\">open</span> <span class=\"n\">finset</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">p1</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">≤</span> <span class=\"err\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))),</span> <span class=\"o\">(</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">ℚ</span><span class=\"o\">)</span><span class=\"bp\">/</span><span class=\"n\">k</span>  <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">transitivity</span> <span class=\"err\">∑</span> <span class=\"n\">k</span> <span class=\"k\">in</span> <span class=\"o\">(</span><span class=\"n\">finset</span><span class=\"bp\">.</span><span class=\"n\">Ico</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">))),</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span><span class=\"bp\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">sum_const</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">Ico</span><span class=\"bp\">.</span><span class=\"n\">card</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">le_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">field_simp</span><span class=\"o\">,</span>\n\n    <span class=\"k\">have</span> <span class=\"n\">calc2</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">),</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"n\">ring_exp</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n    <span class=\"n\">ring_exp</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_le_mul_right</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"n\">refine</span> <span class=\"n\">pow_pos</span> <span class=\"bp\">_</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 197999403,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838310
    },
    {
        "content": "<p>oh, I guess finset.Ico would be fine working with integers!</p>",
        "id": 197999426,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838333
    },
    {
        "content": "<p>hmm no, it's defined for nats</p>",
        "id": 197999514,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838376
    },
    {
        "content": "<p>There is more to it than your claim that the inclusion is a morphism of semirings. The problem is that the inclusion does not commute with <code>-</code> and the reason for this is that if mathematicians were in charge then subtraction on naturals would not make sense</p>",
        "id": 197999547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838399
    },
    {
        "content": "<p>It's also clear to a mathematician that <code>(1 : int) - 2 + 2 = 1</code> implies <code>(1 : nat) - 2 + 2 = 1</code> but this is false</p>",
        "id": 197999603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589838448
    },
    {
        "content": "<p>I think my question still makes sense after <code>rw nat.sub_eq_iff_eq_add</code> so that there's no subtraction</p>",
        "id": 197999611,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838461
    },
    {
        "content": "<p>But presumably there's a side condition of the form \"we're in the region where natural subtraction is not a pathological operation\"</p>",
        "id": 197999731,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838539
    },
    {
        "content": "<p>I think in this pair of examples, the second proof is still harder than the first</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">):=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">rw</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">pow_succ</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">ring_exp</span><span class=\"o\">,</span> <span class=\"n\">norm_num</span><span class=\"o\">,</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 197999744,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838548
    },
    {
        "content": "<p>You can freely move between nat and int versions of a theorem provided you have assumptions saying that all subterms are well defined</p>",
        "id": 197999752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589838557
    },
    {
        "content": "<p>I think <code>field_simp</code> is doing something similar</p>",
        "id": 197999761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589838565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/197999752\">said</a>:</p>\n<blockquote>\n<p>You can freely move between nat and int versions of a theorem provided you have assumptions saying that all subterms are well defined</p>\n</blockquote>\n<p>That sounds like what I'm trying to learn about, can you say more?</p>",
        "id": 197999789,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838584
    },
    {
        "content": "<p>For every subterm<code>a - b</code> of the theorem, <code>a &gt;= b</code> must be in the context or otherwise provable</p>",
        "id": 197999869,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589838620
    },
    {
        "content": "<p>sure, but how do you do actually do the moving between nat and int?</p>",
        "id": 197999938,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838670
    },
    {
        "content": "<p>I think you can apply <code>int.coe_nat_inj</code> and then use <code>simp [*]</code> to push the coercions to the leaves</p>",
        "id": 197999979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589838708
    },
    {
        "content": "<p>I can't get anything to compile. Can you supply the imports?</p>",
        "id": 197999983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838710
    },
    {
        "content": "<p>(I mean the \"Here's where it came from\" post)</p>",
        "id": 198000060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589838735
    },
    {
        "content": "<p>fixed</p>",
        "id": 198000064,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589838742
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/197999979\">said</a>:</p>\n<blockquote>\n<p>I think you can apply <code>int.coe_nat_inj</code> and then use <code>simp [*]</code> to push the coercions to the leaves</p>\n</blockquote>\n<p>Yes, this works</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span><span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span>  <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">2</span> <span class=\"bp\">^</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n    <span class=\"n\">apply</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_inj</span><span class=\"o\">,</span> <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 198000436,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839000
    },
    {
        "content": "<p>wait, that's the easy version</p>",
        "id": 198000463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839032
    },
    {
        "content": "<p>there are no subtracts</p>",
        "id": 198000467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839036
    },
    {
        "content": "<p>Yeah, we xy'ed the subtraction away</p>",
        "id": 198000500,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839060
    },
    {
        "content": "<p>the easy version is the thing I wanted</p>",
        "id": 198000518,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839074
    },
    {
        "content": "<p>I'm saying, if you have a goal with subtracts in it and want to get rid of them by casting to int, that's the procedure</p>",
        "id": 198000583,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839096
    },
    {
        "content": "<p>And I'm saying, if you have a goal with <code>nat.sub</code> in it then you already made a mistake.</p>",
        "id": 198000614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839122
    },
    {
        "content": "<p>In your case you get a subtract from <code>Ico.card</code>, which actually has a genuine use for the <code>nat.sub</code> because it is actually a truncated subtraction</p>",
        "id": 198000644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839144
    },
    {
        "content": "<p>And I know that Mario will know counterexamples in CS, but in maths I am sticking to my guns</p>",
        "id": 198000649,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839147
    },
    {
        "content": "<p>Mathematician speak for the theorem would be <code>|{a..b}| = max(0, b - a)</code>, and so there is an extra step to rewrite the <code>max(0, b-a)</code> into <code>b-a</code></p>",
        "id": 198000775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839205
    },
    {
        "content": "<p>I think <code>Ico.card</code> is useful for maths, so maybe we can think of an API that doesn't expose the nat substract</p>",
        "id": 198000778,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839206
    },
    {
        "content": "<p>Mathematicians would not use <code>Ico x y</code> if <code>y&lt;&lt;x</code>. We have certain conventions which preclude this.</p>",
        "id": 198000819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839243
    },
    {
        "content": "<p>I think the a maths-ier version of Ico carries a proof of <code>a \\le b</code><br>\n(Edit: this is exactly what kevin just said)</p>",
        "id": 198000820,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839243
    },
    {
        "content": "<p>Right, it's like division. I'm not complaining about division on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span></span></span></span> because we never divide by 0.</p>",
        "id": 198000861,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839267
    },
    {
        "content": "<p>I will only write <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><mi>b</mi></msubsup></mrow><annotation encoding=\"application/x-tex\">\\sum_{x=a}^b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2887179999999998em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9890079999999999em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">x</span><span class=\"mrel mtight\">=</span><span class=\"mord mathdefault mtight\">a</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span></span></span></span> if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≥</mo><mi>a</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">b\\geq a-1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>.</p>",
        "id": 198000887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839292
    },
    {
        "content": "<p>But we still need to be able to talk about the cardinality of <code>{x \\in int | a &lt;= x &lt; b}</code></p>",
        "id": 198000909,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839309
    },
    {
        "content": "<p>I'm happy with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=1}^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.253718em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span></span></span></span> but <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mn>0</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\sum_{i=2}^0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.253718em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.954008em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span></span></span></span> is \"not allowed\" as part of math interface.</p>",
        "id": 198000971,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839324
    },
    {
        "content": "<p>that's a mathematical question independent of whether that is called <code>Ico</code> or not</p>",
        "id": 198000977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839327
    },
    {
        "content": "<p>In mathematics one does not usually find oneself in the situation where you need the cardinality of that set and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">b\\leq a</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83041em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>.</p>",
        "id": 198001066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839394
    },
    {
        "content": "<p>but it's not an ill formed question</p>",
        "id": 198001084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839415
    },
    {
        "content": "<p>It's just the way it works. And if you do, then yeah rotten luck, it's some <code>max</code>.</p>",
        "id": 198001088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839419
    },
    {
        "content": "<p>maybe we can leave Ico as is and have something math friendly like <code>∑ from a to b</code></p>",
        "id": 198001184,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839468
    },
    {
        "content": "<p>We could have a theorem about <code>Ico.card</code> in the presence of a le assumption, but there isn't much the theorem can say that is more informative</p>",
        "id": 198001194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839472
    },
    {
        "content": "<p>Right, it's not an ill-formed question, and the well-formed answer is that it's a max. There is this weird thing going on which I still don't really understand, where mathematicians only really see objects when they are at some certain level of \"decency\" which is hard to quantify.</p>",
        "id": 198001203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839482
    },
    {
        "content": "<p>Maybe a better version of the theorem is <code>a + c = b -&gt; (Ico b a).card = c</code></p>",
        "id": 198001242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839508
    },
    {
        "content": "<p>That's interesting.</p>",
        "id": 198001260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198001194\">said</a>:</p>\n<blockquote>\n<p>We could have a theorem about <code>Ico.card</code> in the presence of a le assumption, but there isn't much the theorem can say that is more informative</p>\n</blockquote>\n<p>it can say that the length is <code>(a:ℤ) - (b:ℤ)</code></p>",
        "id": 198001271,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589839533
    },
    {
        "content": "<p>Yeah this is a really funny situation. Nat subtraction is clearly made for this kind of question.</p>",
        "id": 198001303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839559
    },
    {
        "content": "<p>no, it can say that the length casted to <code>int</code> is that</p>",
        "id": 198001311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839562
    },
    {
        "content": "<p>so you can't rewrite with that</p>",
        "id": 198001354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839572
    },
    {
        "content": "<p>Oh I see. The original question is \"mathematical\" so it carries an <em>implicit assumption</em> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>≤</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{n+1}\\leq 2^{n+2}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 198001392,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839611
    },
    {
        "content": "<p>The very fact that you're summing over that range means that the subtraction is going to be OK.</p>",
        "id": 198001422,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839634
    },
    {
        "content": "<p>It is implicit in the question itself that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>≤</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{n+1}\\leq 2^{n+2}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>, and mathematicians would not state this because ass Jalex says, it is \"obvious to us\".</p>",
        "id": 198001537,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839716
    },
    {
        "content": "<p>but formalising the proof has brought this out explicitly.</p>",
        "id": 198001547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839727
    },
    {
        "content": "<p>sure, but if you have the necessary in range assumptions, then <code>a - b</code> is not a bad thing to write, and it is exactly as bad as <code>Ico b a</code> itself, so the theorem <code>Ico.card</code> is fine</p>",
        "id": 198001587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839758
    },
    {
        "content": "<p>But <code>Ico b a</code> is a \"mathematically\" bad thing to write if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a&lt;b</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>, like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">1/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> is a bad thing to write</p>",
        "id": 198001629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839793
    },
    {
        "content": "<p>Mathematicians do not write these things.</p>",
        "id": 198001687,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839805
    },
    {
        "content": "<p>Yes, but we aren't in that situation</p>",
        "id": 198001705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839814
    },
    {
        "content": "<p>Indeed!</p>",
        "id": 198001714,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839822
    },
    {
        "content": "<p><code>Ico.card</code> has applicability to that situation but that doesn't matter here</p>",
        "id": 198001718,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839827
    },
    {
        "content": "<p>I'm saying that it's not necessary to ban <code>nat.sub</code> even in the places where it is well defined</p>",
        "id": 198001769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839862
    },
    {
        "content": "<p>which your comments seem to suggest</p>",
        "id": 198001820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839898
    },
    {
        "content": "<p>Sure. But I want to argue that if a mathematician has run into it then either they've done something wrong or the inequality which enables you to rewrite as an addition is \"in the context somewhere\".</p>",
        "id": 198001844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589839919
    },
    {
        "content": "<p>the original question, <code>2 ^ (n + 2) - 2 ^ (n + 1) = 2 ^ (n + 1)</code>, is within the mathematician strike zone</p>",
        "id": 198001913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839951
    },
    {
        "content": "<p>and the assumption that this is a mathematically reasonable assertion allows you to assume that <code>2 ^ (n + 1) &lt;= 2 ^ (n + 2)</code> is provable</p>",
        "id": 198001959,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839989
    },
    {
        "content": "<p>which of course it is in this case</p>",
        "id": 198001967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589839997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/197999979\">said</a>:</p>\n<blockquote>\n<p>I think you can apply <code>int.coe_nat_inj</code> and then use <code>simp [*]</code> to push the coercions to the leaves</p>\n</blockquote>\n<p>This is how you deal with mathematically reasonable questions involving <code>nat.sub</code></p>",
        "id": 198002073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589840061
    },
    {
        "content": "<p>It seems that you're going to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><mfrac><mn>1</mn><mi>n</mi></mfrac></mrow><annotation encoding=\"application/x-tex\">\\sum \\frac{1}{n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> diverges. I think that it should come with the <code>p</code>-series test.</p>",
        "id": 198002466,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589840348
    },
    {
        "content": "<p>I've had to apply <code>int.coe_nat_inj</code> before, when I wanted to use proper subtraction. I wonder if there should be a shortcut for this? I always have to look up the name because I can never remember (a) whether it's coe or cast and (b) which namespace it's in</p>",
        "id": 198002563,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589840408
    },
    {
        "content": "<p>You can also generalize the proof method to the <a href=\"https://en.wikipedia.org/wiki/Cauchy_condensation_test\">Cauchy condensation test</a></p>",
        "id": 198002566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589840411
    },
    {
        "content": "<p>BTW, you can easily prove the integral test without actual integrals using MVT.</p>",
        "id": 198002613,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589840453
    },
    {
        "content": "<p>You can do it with the integral test as well, which would be simple if the infrastructure was there</p>",
        "id": 198002651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589840473
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> If you start with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>F</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo>=</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">F'=f</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span>, then you only need MVT, and it's there.</p>",
        "id": 198002765,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589840538
    },
    {
        "content": "<p>Do we know the derivative of log is 1/x?</p>",
        "id": 198002829,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589840587
    },
    {
        "content": "<p>The integral test method might be useful if we want to define the Euler-Mascheroni constant, but otherwise I would say the condensation test is quite simple and elementary</p>",
        "id": 198002998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589840685
    },
    {
        "content": "<p>Someday we'll need both of them anyway</p>",
        "id": 198003339,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589840926
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Yes, search for <code>deriv_log</code></p>",
        "id": 198003405,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589840978
    },
    {
        "content": "<p>In metamath I've advocated for never using integrals at all, in favor of antiderivatives, because when the antiderivative is elementary you are writing both sides anyway</p>",
        "id": 198003581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589841085
    },
    {
        "content": "<p>for all the usual analysis applications all you use about intervals is additivity, breaking one along a partition and bounding by constants, and all these things are also true of antiderivatives using the MVT</p>",
        "id": 198003735,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589841184
    },
    {
        "content": "<p>(you also need countable choice to define the lebesgue integral but not derivatives)</p>",
        "id": 198003843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589841248
    },
    {
        "content": "<p>(mathematician voice) <code>nat.sub</code> is the most natural operation in the world ... being simply the adjoint to addition operators in a poset <code>x + a ≥ y iff  x ≥ y - a</code> (playing devil's advocate and hoping Kevin won't notice this is the lambda abstraction rule in disguise <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> )</p>",
        "id": 198004215,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589841477
    },
    {
        "content": "<p>on a more serious note, I have been wondering if this work would provide the foundations for a useful tactic <a href=\"https://arxiv.org/abs/math/0212377\">https://arxiv.org/abs/math/0212377</a></p>",
        "id": 198004473,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589841627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247064\">Matt Earnshaw</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198004473\">said</a>:</p>\n<blockquote>\n<p>I have been wondering if this work would provide the foundations for a useful tactic &lt;link&gt;</p>\n</blockquote>\n<p>This is the kind of message spammers should send :D</p>",
        "id": 198004544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589841672
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247064\">Matt Earnshaw</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198004473\">said</a>:</p>\n<blockquote>\n<p>on a more serious note, I have been wondering if this work would provide the foundations for a useful tactic <a href=\"https://arxiv.org/abs/math/0212377\">https://arxiv.org/abs/math/0212377</a></p>\n</blockquote>\n<p>Do you mean just the part about lifting identities from rings to rigs (Theorem 5.1), or the whole rig category stuff?</p>",
        "id": 198005046,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589842070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198005046\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247064\">Matt Earnshaw</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198004473\">said</a>:</p>\n<blockquote>\n<p>on a more serious note, I have been wondering if this work would provide the foundations for a useful tactic <a href=\"https://arxiv.org/abs/math/0212377\">https://arxiv.org/abs/math/0212377</a></p>\n</blockquote>\n<p>Do you mean just the part about lifting identities from rings to rigs (Theorem 5.1), or the whole rig category stuff?</p>\n</blockquote>\n<p>the former really, though I have a personal interest in the rig category side of things</p>",
        "id": 198005224,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589842235
    },
    {
        "content": "<p>and they said semirings were useless ;)</p>",
        "id": 198005248,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589842294
    },
    {
        "content": "<p>What's the tactic? Don't you just need the theorem?</p>",
        "id": 198005250,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589842297
    },
    {
        "content": "<p>(Or, if there might eventually be a useful tactic, then the theorem on its own should be useful?)</p>",
        "id": 198005310,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589842331
    },
    {
        "content": "<p>yeah, I suppose the theorem would suffice</p>",
        "id": 198005385,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589842389
    },
    {
        "content": "<p>I'll try and have a crack at the lemmas this week, for a bit of fun even if it would seldom find application</p>",
        "id": 198006136,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1589843014
    },
    {
        "content": "<p>doing math for fun? crazy</p>",
        "id": 198006602,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589843489
    },
    {
        "content": "<p>Someone on Twitter had the gall to suggest that funding agencies did not consider \"PI will have fun doing this\" as evidence that a project should be funded</p>",
        "id": 198006729,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589843584
    },
    {
        "content": "<p>It's pretty much the only reason I've ever done anything</p>",
        "id": 198006815,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589843646
    },
    {
        "content": "<p>If <code>-</code> on <code>nat</code> were a partial function, you would always have the information you need to reduce questions about it to <code>int</code> on hand.</p>",
        "id": 198020816,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589861885
    },
    {
        "content": "<p>Obviously as a mathematician I am biased, but I suspect that using partial functions is generally better than totalizing in principle, it's just not that practical without better automation than we currently have.</p>",
        "id": 198020904,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589862023
    },
    {
        "content": "<p>My impression is that it is this thinking that leads to the general huge difference in sizes of terms between DTT and ZFC. Obviously I am also biased, but I would like to see if it is possible to instead implement type theory with an undefinedness logic where bad applications evaluate to a bottom value</p>",
        "id": 198021085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589862351
    },
    {
        "content": "<p>so a type theory where the option monad is always open?</p>",
        "id": 198021160,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589862414
    },
    {
        "content": "<p>right</p>",
        "id": 198021163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589862421
    },
    {
        "content": "<p>yeah i think that's closer to how i think than Lean's type theory is</p>",
        "id": 198021170,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589862440
    },
    {
        "content": "<p>possibly also done in a way where you can \"invert\" well definedness assumptions, i.e. x+y is well defined implies that x and y are</p>",
        "id": 198021188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589862455
    },
    {
        "content": "<p>because this really cuts down on the number of assumptions you have to keep around</p>",
        "id": 198021198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589862480
    },
    {
        "content": "<p>But this doesn't really solve the issue here because then you still need to synthesize a proof that the <code>-</code>s are well-formed to convert to <code>int</code>.</p>",
        "id": 198021236,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589862485
    },
    {
        "content": "<p>I guess maybe not with this latest idea.</p>",
        "id": 198021237,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589862491
    },
    {
        "content": "<p>The term size issue is indeed awkward. One would like to say that we can just forget the proof term by definitional proof irrelevance. We just need to keep track of the fact that <code>x &gt;= y</code>, we don't need to remember how to prove it.</p>",
        "id": 198021256,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589862555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252300\">Jalex Stark</span> <a href=\"#narrow/stream/116395-maths/topic/lifting.20arithmetic/near/198005250\">said</a>:</p>\n<blockquote>\n<p>What's the tactic? Don't you just need the theorem?</p>\n</blockquote>\n<p>I guess, once you have the theorem, the tactic could try to automatically show that in the special case of <code>nat</code> all the <code>a &lt; b</code> conditions for <code>nat.cast_sub</code> are satisfied.</p>",
        "id": 198022933,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589865226
    },
    {
        "content": "<p>uh by \"the theorem\" i meant theorem 5.1 in the \"a tree is seven trees\" paper</p>",
        "id": 198023867,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589866652
    },
    {
        "content": "<p>which says that under mild assumptions, for polynomials <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo separator=\"true\">,</mo><mi>q</mi><mo separator=\"true\">,</mo><msup><mi>q</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup></mrow><annotation encoding=\"application/x-tex\">p,q,q'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span>, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>=</mo><mi>p</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>q</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>q</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">′</mo></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">x = p(x) \\implies q(x) = q'(x) </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⟹</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.001892em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span></span></span></span> in arbitrary rings, then the same implication holds in arbitrary rigs</p>",
        "id": 198023944,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589866798
    },
    {
        "content": "<p>I think you would have difficulty applying this theorem directly in the context of categories though, because it's an isomorphism not an equality</p>",
        "id": 198025119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1589868458
    },
    {
        "content": "<p>yes, I think matt's aim was mostly to use it for bare rigs and rings</p>",
        "id": 198025201,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1589868567
    }
]
[
    {
        "content": "<p>Currently limit-like classes in category theory are defs, because they care some data (things like <code>has_limits</code>, <code>has_kernels</code>, and all their friends). However, we also proclaim the category-theoretical philosophy, that really you shouldn't care how those limits are constructed/defined.<br>\nWould it be an option to make all those classes <code>Prop</code>s and simply use <code>classical.choice</code> to extract objects/morphisms. This would solve all the diamond and inheritance issues.<br>\nWe would then need things like <code>is_product Type (X \\times Y)</code> to relate the \"nice\" objects/definitions to whatever <code>classical.choice</code> spits out. But that isn't different from today, because currently <code>X \\times Y</code> is <em>not</em> the categorical product in <code>Type</code>.<br>\n(I think Reid at some point suggested to me that we might want to consider something like <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span>)</p>",
        "id": 205318262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595998534
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span></p>",
        "id": 205318302,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1595998563
    },
    {
        "content": "<p>Why would we need <code>is_product</code>? Right now we use <code>is_limit</code> for this (i.e., <code>is_limit</code> says that some cone is a limit cone. <code>has_limit</code> then says that we have chosen a particular limit cone). Are you suggesting to change/remove <code>is_limit</code>?</p>",
        "id": 205318850,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1595999373
    },
    {
        "content": "<p>Sure, but we also need specialised versions, because you don't want to build a cone for a product by hand, you just want to give two morphisms.</p>",
        "id": 205320596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596001804
    },
    {
        "content": "<p>Right, but I think this is orthogonal to the question whether <code>has_limit</code> should be a <code>Prop</code>.</p>",
        "id": 205320811,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596002069
    },
    {
        "content": "<p>Right... but it becomes more important because we really can't fall back on the definition anymore.</p>",
        "id": 205321544,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596003119
    },
    {
        "content": "<p>And making <code>has_limit</code> a <code>Prop</code> will solve a bunch of defeq issues.</p>",
        "id": 205321591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596003134
    },
    {
        "content": "<p>I disagree that this matches the category theoretical philosophy, since that usually tries to avoid choice anyway. I also haven't had any issues with defeq in has_limit, so I don't see much of an advantage to this, and it has the cost of making the category library different from the standard maths way of doing it</p>",
        "id": 205361192,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596031731
    },
    {
        "content": "<p>Plus as you say, there would need to be statements relating the nice definitions to the ones choice gives, which is no nicer than what we have now</p>",
        "id": 205361547,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596031888
    },
    {
        "content": "<p>I think the right way of doing this is just to make it easy to move along equivalences and isomorphisms (some of Scott's recent PRs do this already)</p>",
        "id": 205362004,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596032087
    },
    {
        "content": "<p>It would be nicer for type class inference</p>",
        "id": 205362010,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596032090
    },
    {
        "content": "<p>But I haven't had any problems with type class inference - my point of view is that I've used the category theory library a lot, and I've done at least graduate level maths using it and at no point did I have any issues like these</p>",
        "id": 205362206,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596032180
    },
    {
        "content": "<p>That's partly because we are making things defs that could be instances in the <code>Prop</code> scenario, I guess.</p>",
        "id": 205362510,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596032298
    },
    {
        "content": "<p>Right - my point is it hasn't made doing the maths any harder than it would be outside of Lean</p>",
        "id": 205365718,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596033726
    },
    {
        "content": "<p>It has though</p>",
        "id": 205375349,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596037880
    },
    {
        "content": "<p>For example, <a href=\"#narrow/stream/113488-general/topic/typeclass.20instances.20help/near/195185198\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/typeclass.20instances.20help/near/195185198</a></p>",
        "id": 205375926,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596038176
    },
    {
        "content": "<p>Thanks for digging that one up</p>",
        "id": 205376265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596038342
    },
    {
        "content": "<p>Right, but that was me not understanding what extends does rather than something fundamental about Prop</p>",
        "id": 205376442,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596038421
    },
    {
        "content": "<p>Huh? wasn't it a standard example of too many instances?</p>",
        "id": 205376506,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596038450
    },
    {
        "content": "<p>I don't think so - I fixed it just by shuffling how I used extends and everything worked like I wanted</p>",
        "id": 205376728,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596038562
    },
    {
        "content": "<p>This is just by chance though</p>",
        "id": 205376746,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596038570
    },
    {
        "content": "<p>Perhaps, but it's not an example of the proof being harder than outside lean, it's an example of me working with extends for the first time</p>",
        "id": 205376943,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596038664
    },
    {
        "content": "<p>There's no shortage of other examples but I don't feel like digging them up.</p>",
        "id": 205377642,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596039002
    },
    {
        "content": "<p>Seems like almost every category theory PR adds another bad instance. It's obvious that the people writing the library think they want these instances but it simply won't work unless you make these classes <code>Prop</code>s or delete all the instances.</p>",
        "id": 205377785,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596039072
    },
    {
        "content": "<p>Also, regarding choice, I think it's incorrect to say that we know how to do category theory without choice, but I don't want to go through this argument again.</p>",
        "id": 205377871,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596039111
    },
    {
        "content": "<p>In any case, it is a lot less convenient than using choice.</p>",
        "id": 205377944,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596039125
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> What do you think about this? How much value do you see in data-carrying instances over <code>Prop</code>-versions?</p>",
        "id": 205401719,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1596050493
    },
    {
        "content": "<p>I think it could be valuable to have a branch of mathlib in which the Prop-versions are used to see how they compare - my view right now is that I don't see any advantage to switching since in my experience I haven't had any issues, but there could well be disadvantages which we're not yet aware of, and of course the code breakage that would come with a refactor</p>",
        "id": 205402990,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596051147
    },
    {
        "content": "<p>Sorry, I'll be off zulip for a couple of days. I think we should investigate this, though.</p>",
        "id": 205413404,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596056644
    },
    {
        "content": "<p>Something I would like to do soon is refactor the <code>limits/limits.lean</code> file, separating the \"is\" and \"has\" stuff into (at least) to files. Perhaps after that it will be easier to try things out.</p>",
        "id": 205413540,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596056742
    },
    {
        "content": "<p>I'm absolutely sympathetic to Reid's complaints, but also don't really know how to \"get from here to there\" --- I'm happy to take suggestions about concrete things to try out that would start improving the situation.</p>",
        "id": 205413841,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596056897
    },
    {
        "content": "<p>I started experimenting on the <code>prop_limits</code> branch. I went with the following: The class that is called <code>has_limits</code> on master was changed into a structure <code>limit_data</code> (which should probably be ranamed to <code>limit_cone</code>):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">limit_data</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cone</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_limit</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"n\">cone</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p><code>has_limits</code> now refers to the fact that there is some <code>limit_data</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">has_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">mk&#39;</span> <span class=\"bp\">::</span> <span class=\"o\">(</span><span class=\"n\">exists_limit</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">limit_data</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>Using choice, we can then recover the usual API:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">get_limit_data</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">limit_data</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"n\">classical</span><span class=\"bp\">.</span><span class=\"n\">choice</span> <span class=\"n\">has_limit</span><span class=\"bp\">.</span><span class=\"n\">exists_limit</span>\n\n<span class=\"n\">def</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">cone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">cone</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">get_limit_data</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">cone</span>\n\n<span class=\"n\">def</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_limit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_limit</span> <span class=\"o\">(</span><span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">get_limit_data</span> <span class=\"n\">F</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_limit</span>\n</code></pre></div>\n\n\n<p>There is also a new convenience function <code>has_limit.mk</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">has_limit</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">limit_data</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">has_limit</span> <span class=\"n\">F</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨</span><span class=\"n\">nonempty</span><span class=\"bp\">.</span><span class=\"n\">intro</span> <span class=\"n\">d</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n<p>Now, as long as no definitional properties are used, everything stays the same, except that</p>\n<ol>\n<li>we have to write <code>instance : has_limit F := has_limit.mk { ... }</code> instead of <code>instance : has_limit F := { ... }</code>.</li>\n<li>every definition that uses a limit in some way becomes <code>noncomputable</code>.</li>\n</ol>\n<p>I have fixed all errors in <code>category_theory/limits/*</code> and also some other files. Observations:</p>\n<ul>\n<li>Few things break</li>\n<li>\n<p>So far, I have found three areas that would need serious attention:</p>\n<ol>\n<li>Biproducts were set up in a way that relies heavily on definitional properties of low-priority instances for <code>has_product</code> and <code>has_coproduct</code>. Personally, I think this abused the limits API, but I admit that it allowed to reuse some simp lemmas from <code>binary_products.lean</code>. I have rewritten this file to use <code>is_limit</code> rather than <code>has_limit</code> (after all, this is what <code>is_limit</code> is for: we care about a specific limit cone) and it works fine.</li>\n<li>Concrete limits might have to be rewritten (again). I only looked at <code>algebra/category/Mon/limits.lean</code>, but it uses lemmas like <code>types.types_limit_\\pi</code>, who make general statement about <code>has_limit</code> in <code>Type</code> which simply don't make sense if we interpret  <code>has_limit</code> as \"there is some limit\". In my opinion these lemmas should be rephrased to concern the <code>is_limit</code> we explicitly construct for <code>Type</code>, and then <code>Mon/limits.lean</code> would have to be rewritten to use <code>is_limit</code> rather than <code>has_limit</code> from <code>Type</code>.</li>\n<li>Similarly, <code>monoidal/of_has_finite_products.lean</code> doesn't make any sense any more and would have to be rewritten to be <code>monoidal/of_is_finite_product.lean</code>.</li>\n</ol>\n</li>\n</ul>",
        "id": 205487043,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596120172
    },
    {
        "content": "<p>Personally, I believe that finishing this refactor would be worthwhile, but I realize that my interpretation of <code>has_limit</code> is rather extreme and that the fact that everything is noncomputable might be a problem for some people (it isn't for me). I'd be happy to hear everyone's thoughts.</p>",
        "id": 205487780,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596120483
    },
    {
        "content": "<p>One advantage of this is that we can get the result that binary products + terminal gives finite products</p>",
        "id": 205588980,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596201555
    },
    {
        "content": "<p>If this change goes through, will <code>is_left_adjoint</code> also change to an exists? I would think so, so that we can express the equivalence between having limits and the diagonal having an adjoint</p>",
        "id": 205591919,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596203471
    },
    {
        "content": "<p>Relatedly for <code>ess_surj</code> (though I'm in favour of this becoming a Prop regardless of whether <code>has_limits</code> is a Prop)</p>",
        "id": 205592091,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596203567
    },
    {
        "content": "<p>In some weird way I like the idea that limits should be noncomputable, won't this encourage people to use only their universal properties? Which is what we want when we want to rewrite along canonical isomorphisms</p>",
        "id": 205595121,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596204984
    },
    {
        "content": "<p>It makes stuff like <code>prod_functor</code> noncomputable though, which means <code>cartesian_closed</code> needs choice to be defined</p>",
        "id": 205595673,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596205298
    },
    {
        "content": "<p>If you want your definition of <code>cartesian_closed</code> to depend on a specific product, you can still change the definition to take the limit cones you want rather than requiring <code>has_finite_products</code></p>",
        "id": 205596011,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596205454
    },
    {
        "content": "<p>Yeah I think this is a good option conceptually, I wonder how nice it would be in practice though</p>",
        "id": 205596094,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596205505
    },
    {
        "content": "<p>isn't making it <code>irreducible</code> enough to make people use the universal properties?</p>",
        "id": 205605175,
        "sender_full_name": "Jalex Stark",
        "timestamp": 1596209492
    },
    {
        "content": "<p>Yes, but the advantage of also making it a <code>Prop</code> is that we can stop worrying about typeclass diamonds or multiple instances in general</p>",
        "id": 205605931,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596209885
    },
    {
        "content": "<p>Another consequence of this is that it would make the monadicity theorems (in particular both 1.3 and crude version here: <a href=\"https://ncatlab.org/nlab/show/monadicity+theorem\">https://ncatlab.org/nlab/show/monadicity+theorem</a>, and my Lean implementation of the latter <a href=\"https://github.com/b-mehta/topos/blob/master/src/beck2.lean#L386\">here</a>) use the axiom of choice - I highlight this example in particular because most category theory texts state this without saying that choice is used while explicitly singling out the use of choice to show that full faithful essentially surjective functors define an equivalence</p>",
        "id": 205616957,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1596215957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>, thank you for this experiment! It sounds really promising, and I'd love to see it finished.</p>",
        "id": 205674794,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596276268
    },
    {
        "content": "<p>I'm not exactly sure from your report where you're up to. I'm very happy if you want to take charge --- and if there are concrete things I can do on a branch \"rewrite this file to do XYZ\", please tell me!</p>",
        "id": 205674852,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1596276382
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I've been thinking about <code>biproducts.lean</code> and <code>monoidal/of_finite_products.lean</code>. When I started working on the refactor, I thought that the only \"correct\" way to use <code>has_limit</code> is to express that there exists some limit, and we're not going to assume any definitional properties about it. However now I realize that another way to interpret <code>has_limit</code> is to just use it to avoid having to pass in limit cones as explicit parameters all the time. This is how it is used in the two files mentioned above.</p>\n<p>I converted <code>biproducts.lean</code> to pass in the limit cones explicitly, and it wasn't horrible, but one thing we did lose is that some lemmas that formerly could just be reused from finite (co)products had to be restated for biproducts.</p>\n<p>So far, I haven't been able to come up with a construction that also allows for the second use case of <code>has_limit</code> (i.e., a new type class called something like <code>chose_limit</code>) that avoids having to state the entire API twice (or three times, depending on whether you count the theorems stated in terms of <code>is_limit</code>). If you can think of some way to do this, I'd be very interested to hear it.</p>\n<p>The alternative would be to explore how tedious it really is to pass in all limit cones. I think starting to rewrite <code>monoidal/*</code> (starting with <code>monoidal/of_finite_products.lean</code>) could be a good indicator of whether this approach is feasible, but I'm not at all familiar with that directory, so if you could have a look, that would be very helpful. If you do have a look at this, make sure to merge master first; there was a bug in the <code>simps</code> tactic that was triggered by the new <code>has_limit</code> typeclass, but it is fixed in master.</p>",
        "id": 205675530,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1596277688
    },
    {
        "content": "<p>Sorry I haven't got to this yet. I haven't forgotten, and would really like to see if we can make this work!</p>",
        "id": 206542618,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597125500
    },
    {
        "content": "<p>I just merged master and resolved conflicts.</p>",
        "id": 206543134,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597126239
    },
    {
        "content": "<p>Hmm... Yeah. While I'm absolutely sympathetic to the idea that we want to distinguish between merely existing limits and chosen limits, I don't think we're going to be able to survive entirely without chosen limits.</p>",
        "id": 206544936,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597128679
    },
    {
        "content": "<p>I definitely want to be able to choose limits sometimes. It should be like localisation -- we should follow <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> . One should be able to choose limits but also have an existence statement, an API for limits developed entirely from the universal property, and a proof that the limits satisfy the universal property. I am hoping that this covers all use cases in a reasonable way.</p>",
        "id": 206550627,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597134019
    },
    {
        "content": "<p>The question is whether you want a type class that provides chosen limits, and if so, is there any way to get people to stop writing instances for that class.</p>",
        "id": 206557967,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597139906
    },
    {
        "content": "<p>How about we</p>\n<ol>\n<li>keep <code>has_limit</code> as in Markus' branch, as a <code>Prop</code></li>\n<li>introduce a <code>chosen_limit</code> typeclass</li>\n<li>write all the <code>limit F</code> and friends definitions in terms of <code>chosen_limit</code> (don't panic yet!)</li>\n<li>provide an instance <code>has_limit ---&gt; chosen_limit</code> that uses choice</li>\n<li>forbid (perhaps even in the linter) creating any other global instances of <code>chosen_limit</code></li>\n</ol>\n<p>This would mean that when you just write <code>limit F</code>, Lean will go looking for a <code>chosen_limit F</code>, and in most circumstances obtain this from a <code>has_limit F</code> class. </p>\n<p>However you would have the option, in a single file, to introduce some particular <code>chosen_limit</code> instances locally, and then <code>limit F</code> would be definitionally whatever is provided by those?</p>",
        "id": 206558556,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597140452
    },
    {
        "content": "<p>So how would this work in the context of something like <code>cartesian_closed</code>? We take a category with <code>has_products</code> and not <code>chosen_products</code> right?</p>",
        "id": 206608297,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597168633
    },
    {
        "content": "<p>in the definition of <code>cartesian_closed</code> itself</p>",
        "id": 206608354,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597168655
    },
    {
        "content": "<p>Otherwise, when you go and prove that <code>Type</code> is cartesian closed, you're liable to inadvertently leak your <code>chosen_products</code> in the instance argument of <code>cartesian_closed</code></p>",
        "id": 206608504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597168715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> The analogy that comes to my mind is <code>fintype</code>: locally we might want to know what instance we have so that we can compute explicitly, but globally we know the choices don't matter and don't want to be bothered with the coherence issues.<br>\nIn category theory the coherence issues ought to be even worse because the different possible instances of <code>has_limits</code> are not even equal; but we haven't seen them in practice because category theory is not used much compared to <code>fintype</code>.</p>",
        "id": 206611425,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597170044
    },
    {
        "content": "<p>I think that I am fully aware as a mathematician that the two universal modules for trilinear maps are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>M</mi><mo>⊗</mo><mi>N</mi><mo stretchy=\"false\">)</mo><mo>⊗</mo><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">(M\\otimes N)\\otimes P</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>N</mi><mo>⊗</mo><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M\\otimes (N\\otimes P)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> and that I have to be careful because these things are not equal. Isn't there a whole theory of coherence here, which people actually do research into instead of just being annoyed by?</p>\n<p>I can see that in theory <code>has_limits</code> has the potential to be annoying. However it doesn't seem to have annoyed people in practice yet, in contrast to <code>fintype</code>, and the \"fix\" is clear -- for unsubtle coherence issues the trick is to build the API so that it works on anything with the right universal property, and for subtle ones you're interested in the lack of coherence anyway.</p>",
        "id": 206615677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597172013
    },
    {
        "content": "<p>It's annoyed me a heck of a lot</p>",
        "id": 206615931,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597172116
    },
    {
        "content": "<p>e.g. for schemes we used <code>R[1/fg]</code> and then when we needed <code>R[1/f][1/g]</code> we just showed that it satisfied the universal property of <code>R[1/fg]</code> and because we weren't pushing things too far it worked fine. But we really needed concrete limits to define affine schemes; the thought of trying to make them well-defined \"up to isomorphism\" sounds a bit terrifying.</p>",
        "id": 206615943,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597172120
    },
    {
        "content": "<p>I see -- so you're using category theory in your own work and are seeing problems? :-/</p>",
        "id": 206616039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597172155
    },
    {
        "content": "<p>No, it seems clear to me that the same story as with <code>fintype</code> will play out but I was apparently unable to prevent people from going down this path, so I pretty much gave up on formalizing category theory for now.</p>",
        "id": 206616277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597172268
    },
    {
        "content": "<p>Let's say a category is \"good\" if binary products commute with colimits in each variable--surely there are no subtle coherence issues here, and this is just a property of a category. But in Lean the meaning of this statement depends on which colimits and which products are the \"chosen\" ones. If you somehow end up with a different choice of products, then you've got coherence problems.</p>",
        "id": 206617527,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597172852
    },
    {
        "content": "<p>And there are loads of instances like \"any category with X and Y limits also has Z limits\", so it's quite likely you could end up with different instances.</p>",
        "id": 206617561,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597172874
    },
    {
        "content": "<p>To be fair there really is an easy theorem to be proved here, namely that this property doesn't depend on the choice of products and colimits.</p>",
        "id": 206617903,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597173049
    },
    {
        "content": "<p>When I've used statements like this, the point is just to state them in terms of <code>is_limit</code> and <code>is_colimit</code> - which is the usual mathematical meaning of this sort of statement anyway, for instance: <a href=\"https://ncatlab.org/nlab/show/pullback-stable+colimit\">https://ncatlab.org/nlab/show/pullback-stable+colimit</a>, alternatively <a href=\"https://ncatlab.org/nlab/show/commutativity+of+limits+and+colimits\">here</a></p>",
        "id": 206618050,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597173138
    },
    {
        "content": "<p>I agree that the <code>is_*</code> notions are in general much better, but this was just a random example and I'm not sure it is really always convenient to phrase things in terms of them--take <code>cartesian_closed</code> for example</p>",
        "id": 206618194,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597173224
    },
    {
        "content": "<p>Let me be clear that I don't know what the best way is to handle these issues with limits, and in general things that are determined uniquely (up to unique isomorphism) by universal properties; and there are real problems to be solved about how to express and/or automate the invariance of notions under isomorphism. I only know that the current mathlib approach of writing loads of overlapping instances and using priorities and <code>local instance</code> is the wrong one.</p>",
        "id": 206620660,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597174490
    },
    {
        "content": "<p>I see -- with these recent messages I've now understood far better what the situation is. </p>\n<p>In the definition of the Picard group of a ring you first make the category of modules over that ring, and then quotient it by isomorphism, so you lose information here but you do gain a monoid structure. All your limits are defeq in this quotient structure. Aah.</p>",
        "id": 206621895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597175079
    },
    {
        "content": "<p>I'm not sure if you saw, <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, but things did hopefully get a bit better recently in <a href=\"https://github.com/leanprover-community/mathlib/issues/3603\">#3603</a>, which removed lots of the <code>has_X</code> typeclasses, replacing them with abbreviations for pi-types producing a <code>has_limit</code>.</p>",
        "id": 206643703,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188544
    },
    {
        "content": "<p>Have you had a look at the <code>prop_limits</code> branch?</p>",
        "id": 206643728,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188572
    },
    {
        "content": "<p>It seems pretty close to working. The two things that we'll lose / have to redo from scratch are:</p>\n<ol>\n<li>the constructions of limits in Mon/Group/Ring, etc, (which relies on looking at the definition of limits in Type)</li>\n<li>the equivalence <code>Mon_ (Type) ~ Mon</code>, which relies on looking at the particular choice of binary products and terminal object used when putting a monoidal structure on <code>Type</code>.</li>\n</ol>",
        "id": 206643854,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188674
    },
    {
        "content": "<p>Otherwise it looks like <code>prop_limits</code> is viable. I'm guessing you agree it would be a step in the right direction?</p>",
        "id": 206643892,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188714
    },
    {
        "content": "<p>Of course there's no harm in just ditching <code>Mon_ (Type) ~ Mon</code> at this point; it's a new addition not used anywhere.</p>",
        "id": 206643949,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188746
    },
    {
        "content": "<p>We can redo it by building a bit more API around limits in concrete categories, I guess, and just rely on the universal properties without using the definition of the tensor product in Type as cartesian product.</p>",
        "id": 206644007,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188821
    },
    {
        "content": "<p>If you wanted to have a look at how we could redo the constructions of limits in concrete categories in the <code>prop_limits</code> branch, that would be great!</p>",
        "id": 206644081,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188857
    },
    {
        "content": "<p>Oh, and I guess there are still problems in </p>\n<ol start=\"3\">\n<li><code>cartesian_closed</code>, which I didn't look at.</li>\n</ol>",
        "id": 206644140,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597188925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/limits.20and.20choice/near/206608297\">said</a>:</p>\n<blockquote>\n<p>So how would this work in the context of something like <code>cartesian_closed</code>? We take a category with <code>has_products</code> and not <code>chosen_products</code> right?</p>\n</blockquote>\n<p>Yes.</p>\n<p>But on the other hand in <code>monoidal_of_has_finite_products</code> I think we would want <code>chosen_products</code>, so that when someone uses that <code>def</code> to make a particular instance, they can specify definitionally exactly which product they want to use.</p>",
        "id": 206644632,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597189364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, I'm not sure if I should proceed with my suggestion (that is, a propositional <code>has_limit</code>, and an evil non-unique data-carrying <code>chosen_limit</code>, with instance using classical.choice from <code>has_limit</code> to <code>chosen_limit</code>, but other instances forbidden, except for local overrides).</p>\n<p>I would really like to get this all to a state you're happy with, but if I'm going to be writing the code it would be good to know ahead of time if you think it's a plausible route.</p>\n<p>The other alternative as I understand is to _only_ have a propositional <code>has_limit</code>, which will then require complete rewrites of the <code>has_limits</code> instances for algebraic categories, and (very minor) redoing <code>Mon_ (Type) ~ Mon</code>.</p>",
        "id": 206882750,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597360477
    },
    {
        "content": "<p>Obviously I'd do this in a branch forking off Markus' <code>prop_limits</code> branch, so there's no commitment, I just want to know whether I'd be wasting my time.</p>",
        "id": 206883505,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597361118
    },
    {
        "content": "<p>In the meantime, I'll see if I can get <code>algebra/category/Mon/limits.lean</code> to work with the purely propositional version of <code>has_limits</code>. It seems doable, but I've get derailed in debugging a problem with <code>transport</code>.</p>",
        "id": 206903321,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597387922
    },
    {
        "content": "<p>I'm not there yet, but I'm now pretty confident that <code>algebra/category/Mon/limits.lean</code> and all its descendants will work just fine with the propositional <code>has_limit</code>.</p>",
        "id": 207010681,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597478353
    },
    {
        "content": "<p>Vaguely related to this, is there a reason <code>equivalence_of_fully_faithfully_ess_surj</code> uses a definition of essentially surjective which contains the data of an inverse functor rather than the mere existence as \"essentially surjective\" usually means? More specifically, are there any objections to changing this to match the standard definition?</p>",
        "id": 207025078,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597503261
    },
    {
        "content": "<p>None at all.</p>",
        "id": 207044975,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597534534
    },
    {
        "content": "<p>In that case: <a href=\"https://github.com/leanprover-community/mathlib/pull/3821\">https://github.com/leanprover-community/mathlib/pull/3821</a></p>",
        "id": 207048998,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1597542268
    },
    {
        "content": "<p>I've now managed to make all the constructions of limits in concrete categories avoid needing to look at the definitions of limits at prior steps. This works in the <code>prop_limits</code> branch, but I also just made <a href=\"https://github.com/leanprover-community/mathlib/issues/3860\">#3860</a> which backports these changes (without touching the definition of <code>has_limits). Hopefully this makes it easier to work on and test </code>prop_limits` or alternatives.</p>",
        "id": 207369317,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597811434
    },
    {
        "content": "<p>Thanks so much for doing this!</p>",
        "id": 207371128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597813958
    },
    {
        "content": "<p>The <code>prop_limits</code> branch itself still has a way to go, I think. I'll try to look at it more soon and write a summary of the remaining obstacles, but if anyone feels like hacking on it, that would be fantastic!</p>",
        "id": 207373690,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597817758
    },
    {
        "content": "<p>I wish I could help, but there are too many projects going on atm</p>",
        "id": 207373895,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597818012
    },
    {
        "content": "<p>Looks like I made life unnecessarily difficult for myself, and <span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span> has explained a simpler way. I'll try again later. :-)</p>",
        "id": 207391471,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597832982
    },
    {
        "content": "<p>Okay, this is done properly, per Markus's suggestion, at <a href=\"https://github.com/leanprover-community/mathlib/issues/3873\">#3873</a>.</p>",
        "id": 207483807,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1597891523
    }
]
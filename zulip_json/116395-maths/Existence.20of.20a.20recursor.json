[
    {
        "content": "<p>What is the best way to prove this?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">succ</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">zero</span> <span class=\"bp\">≠</span> <span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">succ</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">succ</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h₃</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n    <span class=\"n\">P</span> <span class=\"n\">zero</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">P</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">→</span> <span class=\"n\">P</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">nat</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">rec</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">zero</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span> <span class=\"n\">rec</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">rec</span> <span class=\"n\">z</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>I managed to prove this in another theorem prover, but the proof is very long. The proof goes like this: first define <code>m ≤ n</code> to be true iff there exists a function <code>f : nat → nat</code> such that <code>f zero = m</code>, <code>f (succ k) = succ (f k)</code> for all <code>k</code>, and there exists <code>x</code> such that <code>f x = n</code>. We define <code>m &lt; n</code> as <code>m ≤ n ∧ m ≠ n</code>. Then we prove many useful theorems about those two relations. After that, we prove that for each <code>N : nat</code> there exists function <code>rec'</code> such that <code>rec' N z f zero = z</code> and for all <code>n &lt; N</code>, <code>rec' N z f (succ n) = f z (rec' N z f n)</code>. Then we prove that for any <code>N₁ N₂ n : nat</code>, if <code>n &lt; N₁</code> and <code>n &lt; N₂</code>, then <code>rec' N₁ z f n = rec' N₂ z f n</code>. After that, we define <code>rec z f n</code> as <code>rec' (succ n) z f n</code> and finally prove the theorem.</p>\n<p>Is there an easier way?</p>",
        "id": 301827517,
        "sender_full_name": "Patrick Johnson",
        "timestamp": 1664633830
    },
    {
        "content": "<p>Using <code>zero, succ, h₁, h₂, h₃</code> you should be able to construct a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv\">docs#equiv</a> with ℕ, and you can just use <code>nat.rec</code>. If you don't want to use the inductive type ℕ, I think you can take <code>rec z f</code> to be the \"union\" of all partial functions <code>g</code> satisfying <code>g zero = z ∧ ∀ (n : nat), g (succ n) = f n (g n)</code>; you won't get rid of inductive types completely (∃, ∧ and subtypes are all inductive types in Lean), but you could avoid the more \"powerful\" inductive types like ℕ.</p>",
        "id": 301860903,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1664653995
    }
]
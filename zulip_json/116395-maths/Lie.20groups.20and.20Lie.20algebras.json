[
    {
        "content": "<p>Anthony Bordg was asking me about Lie algebras and Lie groups. I see we have Lie algebras now. Do we have the tangent vector space of a smooth manifold at a point? I would imagine that the abstract definition of Lie group <del>was</del>would be easy. Is the structure of a Lie algebra on the tangent space of a Lie group within reach?</p>",
        "id": 198650086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590398916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125073\">@Anthony Bordg</span></p>",
        "id": 198650108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590398942
    },
    {
        "content": "<p>I think you have at least the tense wrong in \"the abstract definition of Lie group was easy\"...</p>",
        "id": 198650319,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590399117
    },
    {
        "content": "<p>I briefly looked at this back in January or so. I view the Lie algebra structure on the tangent space to a Lie group at the identity arising because  the invariant vector fields are a Lie subalgebra of the Lie algebra of all vector fields on the group.</p>",
        "id": 198650376,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1590399141
    },
    {
        "content": "<p>If we go that route, then we first need the Lie algebra structure on vector fields so I looked into defining that and when I last looked, we didn't even have the vector space structure on sections of a vector bundle.</p>",
        "id": 198650420,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1590399188
    },
    {
        "content": "<p>Things may have changed but it looked like there was still a bit of work to do till we had this. Not huge, but not quite trivial.</p>",
        "id": 198650453,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1590399235
    },
    {
        "content": "<p>Presumably we need Yury's work on the implicit function theorem before we even unlock the Lie group level, as one of the very first theorems should be that you don't need to check smoothness of the inverse.</p>",
        "id": 198650518,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590399274
    },
    {
        "content": "<p>There might be a case to be made for developing some theory for closed subgroups of the general linear group. If we had the exponential map for matrices then we could probably get quite far.</p>",
        "id": 198650828,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1590399498
    },
    {
        "content": "<p>Is the right route to the exponential map for matrices just a functional calculus? I was thinking about attempting Stone-Weierstrauss in any case.</p>",
        "id": 198651652,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590400192
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"240862\">Oliver Nash</span> <a href=\"#narrow/stream/116395-maths/topic/Lie.20groups.20and.20Lie.20algebras/near/198650420\">said</a>:</p>\n<blockquote>\n<p>If we go that route, then we first need the Lie algebra structure on vector fields so I looked into defining that and when I last looked, we didn't even have the vector space structure on sections of a vector bundle.</p>\n</blockquote>\n<p>That's correct. There are several design questions here, the main one being: how does one register a vector bundle? Possible definitions would be: </p>\n<ul>\n<li>a manifold <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> with charts taking values in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, and the changes of coordinates send fibers of the projection on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> to fibers in a linear way (i.e., prescribing the groupoid as the one of linear maps in the second coordinate). Then you have a quotient manifold, and a vector bundle. This is probably a bad choice to use a quotient manifold like that, because for instance in the tangent bundle the manifold is not defeq to the quotient manifold obtained by quotienting the tangent bundle by its fibers</li>\n<li>more data: a manifold <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> as above, but also a manifold <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and a projection <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span> from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> that behaves nicely. Then the fibers of the projection can be endowed with a vector space structure in a canonical way. But there is the difficulty that, in the tangent bundle case, the fibers of the projection (written as <code>{y // pi y = x}</code>) are not defeq to the tangent space.</li>\n<li>Even more data: <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi></mrow><annotation encoding=\"application/x-tex\">\\pi</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span></span>, but also a family of vector spaces <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> indexed by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">x \\in M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> and isomorphisms between the fiber above <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">x</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>?</li>\n<li>Or just a manifold structure on a Pi type of the form <code>Π (x : M), F x</code>, with the right groupoid.</li>\n<li>Or, even simpler, a manifold structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">M \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>. This may seem crazy, but this is the underlying type of the tangent bundle for now, and it works pretty well.</li>\n</ul>",
        "id": 198654172,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402305
    },
    {
        "content": "<p>My guess is that it will be more flexible to have some kind of predicate, instead of sticking to one specific type-theoretic construction.</p>",
        "id": 198654312,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402430
    },
    {
        "content": "<p>Also, once you have vector bundles you will quickly ask for more general types of bundles, so should category theory be involved already, one way or another?</p>",
        "id": 198654423,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402534
    },
    {
        "content": "<p>And should one define (locally trivial) vector bundles first over a general topological space, and then specialize to manifolds, or do only the manifold case?</p>",
        "id": 198654449,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402572
    },
    {
        "content": "<p>I don't know how one should answer this sort of question. There are e.g. undergraduates who want to think about Lie groups and Lie algebras, and then there are Bochner integral people who say that the best way is the most general way.</p>",
        "id": 198654552,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590402642
    },
    {
        "content": "<p>I think these are difficult and important questions, that should be discussed throughly here on Zulip.</p>",
        "id": 198654665,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402734
    },
    {
        "content": "<p>It's the same kind of questions as for schemes. Which are not yet in mathlib for the same kind of reason, but at some point we will have to make a choice and move forward.</p>",
        "id": 198654719,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590402818
    },
    {
        "content": "<p>We made some design decisions about presheaves in the repo, and then mathlib made some different design decisions, but the reason they're not in mathlib is just because nobody is trying to put them in there. I am hoping to get back to this in August or September</p>",
        "id": 198655167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590403251
    },
    {
        "content": "<p>We definitely want vector bundles over topological spaces. <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> and I started thinking about how to represent these at some point, but we didn't go very far with them. Some but not all of the approaches listed above work there. There are also other sorts of fiber bundles of course.</p>\n<p>On the other hand, I don't know whether it matters if a smooth vector bundle on a manifold is a topological vector bundle plus some extra stuff. It's probably good enough just to have a way to convert back and forth between the two representations.</p>",
        "id": 198655679,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590403788
    },
    {
        "content": "<p>Also, <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for Stone-Weierstrass. I remember thinking it should be easy.</p>",
        "id": 198655764,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590403859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Lie.20groups.20and.20Lie.20algebras/near/198654312\">said</a>:</p>\n<blockquote>\n<p>My guess is that it will be more flexible to have some kind of predicate, instead of sticking to one specific type-theoretic construction.</p>\n</blockquote>\n<p>Do you have an idea of what this would look like? Do you mean a characteristic predicate for \"being a vector bundle over a manifold\", or for \"being the type of vector bundles over a manifold\"? In the first case, you first have to write down the data somehow and then you're already committing to one of your list of representations. In the second case, I would be very interested to hear what you have in mind!</p>",
        "id": 198656706,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590404765
    },
    {
        "content": "<p>I mean the former, i.e., you have a type, a projection, and you want to express the fact that this projection corresponds to a vector bundle. So you want to express that you have a vector space structure on the fibers, continuous and locally trivial. How to write this data? What I want to avoid is requiring that the underlying type is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma (x : E), F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with some topology: the setup should cover both situations (and other natural situations), just like the predicate for topological fiber bundles does. For instance, the two following definitions would work.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_fiber_bundle</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector_bundle1</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">proj</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">bundle_trivialization</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">base_set</span><span class=\"o\">,</span> <span class=\"n\">is_linear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}),</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_topological_vector_bundle</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span> <span class=\"n\">proj</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector_bundle1</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector_bundle2</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">proj</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">fiber_triv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"err\">≃</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">})</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">bundle_trivialization</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">base_set</span><span class=\"o\">,</span> <span class=\"n\">is_linear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">fiber_triv</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_topological_vector_bundle</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"n\">fiber_triv</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector_bundle2</span>\n</code></pre></div>\n\n\n<p>In the first one, I require that typeclass inference knows about the topological vector space structure on the fibers of the projection, written as <code>{y // proj y = x}</code> (which is not defeq to <code>proj ⁻¹' {x}</code>, so one should choose a representation and use it constantly). In the second one, instead I choose for each fiber a bijection with the model vector space <code>F</code>, and I require that the trivialization is linear when seen through this (non-canonical) bijection. </p>\n<p>The first one is arguably more natural, but when you work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> note that the fibers are not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, they are some other type which has a priori no vector space structure, so you need to register a whole bunch of typeclasses on these fibers, which is not very nice. With the second definition, you just use the canonical identification between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">\\{x\\} \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and you're done. So I feel the second definition would be easier to work with.</p>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> , do you remember what you had tried with <span class=\"user-mention\" data-user-id=\"116045\">@Jesse Michael Han</span> ?</p>",
        "id": 198686982,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590425793
    },
    {
        "content": "<p>What if rather than having projections, you had a sigma type as data? That is, a vector bundle is a topological space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi></mrow><annotation encoding=\"application/x-tex\">Z</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">Z</span></span></span></span> equipped with a homeomorphism to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma(x:E),F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></p>",
        "id": 198694390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590432976
    },
    {
        "content": "<p>I have always thought that the approach of defining Sigma types via sections of a projection is backwards and unnatural; and in type theory it is much worse since you get these weird noncanonical types</p>",
        "id": 198694468,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590433064
    },
    {
        "content": "<p>In the data, you would also need to put a topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma(x : E), F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and a vector space structure on each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> and so on. The gain compared to using <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>y</mi><mo>∣</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>j</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">\\{y \\mid proj(y) =x\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">}</span></span></span></span> is not obious to me yet.</p>",
        "id": 198695083,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590433602
    },
    {
        "content": "<p>Where is the topology on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma(x : E), F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> required? I guess the natural one doesn't always make sense in this context, but there is a topology induced by the one on Z and you can use that to state any required continuity assumptions between this topology and the ones on E and F_x. But the whole point here is that E, F_x, and Z all need to be specifiable independently of each other, and everything else is constraints</p>",
        "id": 198720635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590468958
    },
    {
        "content": "<p>Of course in specific cases you might be able to simplify this, e.g. by saying that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Z</mi><mo>=</mo><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">Z =\\Sigma(x : E), F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">Z</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> in one case or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>F</mi><mi>x</mi></msub><mo>=</mo><mo stretchy=\"false\">{</mo><mi>y</mi><mo>∣</mo><mi>p</mi><mi>r</mi><mi>o</mi><mi>j</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>x</mi><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">F_x=\\{y\\mid proj(y)=x\\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">p</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.05724em;\">j</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">}</span></span></span></span> in another; but having three types means that you have the flexibility to make this choice</p>",
        "id": 198720720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590469066
    },
    {
        "content": "<p>Oh, I see you provided code. Here's an implementation of my suggestion:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_fiber_bundle</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector_bundle3</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">topological_space</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">as_sigma</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_sigma</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"err\">≃</span> <span class=\"err\">Σ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">cont</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">to_sigma</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">cont_inv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">continuous</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">//</span> <span class=\"o\">(</span><span class=\"n\">to_sigma</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">},</span>\n  <span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">to_sigma</span> <span class=\"n\">y</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"n\">E</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">as_sigma</span><span class=\"bp\">.</span><span class=\"n\">proj</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">as_sigma</span> <span class=\"n\">Z</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">B</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">to_sigma</span> <span class=\"n\">z</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n<span class=\"n\">def</span> <span class=\"n\">as_sigma</span><span class=\"bp\">.</span><span class=\"n\">slice</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">as_sigma</span> <span class=\"n\">Z</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"o\">:=</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">to_sigma</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">variables</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">)]</span>\n  <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">as_sigma</span> <span class=\"n\">Z</span> <span class=\"n\">E</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">local_homeomorph</span> <span class=\"n\">Z</span> <span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"bp\">×</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">base_set</span>      <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">open_base_set</span> <span class=\"o\">:</span> <span class=\"n\">is_open</span> <span class=\"n\">base_set</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">source_eq</span>     <span class=\"o\">:</span> <span class=\"n\">source</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">proj</span> <span class=\"bp\">⁻¹</span><span class=\"err\">&#39;</span> <span class=\"n\">base_set</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">target_eq</span>     <span class=\"o\">:</span> <span class=\"n\">target</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">base_set</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">univ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">proj_to_fun</span>   <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"err\">∈</span> <span class=\"n\">source</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">p</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">proj</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">bundle_trivialization</span> <span class=\"n\">F</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">base_set</span><span class=\"o\">,</span> <span class=\"n\">is_linear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">slice</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_topological_vector_bundle</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector_bundle3</span>\n</code></pre></div>",
        "id": 198723201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590472935
    },
    {
        "content": "<p>There are some messy casts in <code>as_sigma.cont_inv</code>, but these can be avoided if you unfold the definition of continuity. Together <code>cont</code> and <code>cont_inv</code> are asserting that <code>to_sigma</code> induces a homeomorphism between <code>E x</code> and <code>{y // (to_sigma y).1 = x}</code></p>",
        "id": 198723292,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590473098
    },
    {
        "content": "<p>I don't know the maths of <code>bundle_trivialization</code> so I haven't done much with it except make it typecheck</p>",
        "id": 198723316,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590473143
    },
    {
        "content": "<p>I remember someone saying somewhere that there could be a problem in using a normed vector space as a fiber for a smooth vector bundle as this norm creates a conflict in the definition of a Riemannian vector bundle (or maybe I dreamed it? I can't find this message back). I was wondering if someone has a solution to propose in case this is actually a problem. I understand this is a quite abstract question as there is no agreement yet on how the definition of vector bundle could be given, but maybe this problem can be solved abstractly no matter what the actual definition will be? On a finite dimensional vector space there is a unique manifold structure (same for all norms), so in this case could there be a way of creating an instance of manifold on the vector space without mentioning any norm?</p>",
        "id": 203090375,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1594120808
    },
    {
        "content": "<p>You just need to use a topological vector space for the fiber, instead of a normed vector space.</p>",
        "id": 203090490,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594120931
    },
    {
        "content": "<p>Sorry if this is a stupid question but isn't there only one topology on a vector space that agrees with the manifold structure? Can there be a canonical instance of a topological space as a smooth manifold? In order to make it into a smooth bundle I need the vector space to be a manifold don't I?</p>",
        "id": 203090688,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1594121145
    },
    {
        "content": "<p>On a given finite-dimensional real vector space, there is a single topological vector space structure, and a unique norm up to equivalence. However, this is in the mathematical sense of unique: give me two vector spaces topologies on this vector space, I can prove they are unique. But, from the point of view of Lean's kernel, they may not coincide, and so a lot of care is required to get things right. This is the difference between equality and definitional equality. <a href=\"https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/\">https://xenaproject.wordpress.com/2020/07/03/equality-specifications-and-implementations/</a> may be enlightening about this.</p>",
        "id": 203091016,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594121457
    },
    {
        "content": "<p>But I am still unsure how this helps me to make a generic topological vector space into a manifold.</p>",
        "id": 203091282,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1594121713
    },
    {
        "content": "<p>Rather, if you start from a normed vector space, it is a manifold over itself. Then a copy of this normed vector space, in which you will only register the topology but not the norm, can be endowed with a manifold structure over the initial normed vector space.</p>\n<p>This doesn't really answer your question: if you just start from a topological vector space, I don't think we have means currently to construct a norm creating the topology. (And this is impossible in general, unless your space is finite-dimensional and your field is complete).</p>",
        "id": 203091597,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1594121950
    },
    {
        "content": "<p>Yes what you wrote in the first paragraph is what I was trying to say in my first message, even if wasn't thinking about making a copy of the normed space but recreating the topology and the manifold structure in some other way (for example by choosing a basis and using an isomorphism with K^n), but in any case I am not really sure about what is a good way to implement this so I might start with trying to do things with normed spaces and then change it later in case I manage to get somethings done</p>",
        "id": 203103564,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1594129354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Lie.20groups.20and.20Lie.20algebras/near/198686982\">said</a>:</p>\n<blockquote>\n<p>I mean the former, i.e., you have a type, a projection, and you want to express the fact that this projection corresponds to a vector bundle. So you want to express that you have a vector space structure on the fibers, continuous and locally trivial. How to write this data? What I want to avoid is requiring that the underlying type is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Σ</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><msub><mi>F</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\Sigma (x : E), F_x</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Σ</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> with some topology: the setup should cover both situations (and other natural situations), just like the predicate for topological fiber bundles does. For instance, the two following definitions would work.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">topological_fiber_bundle</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector_bundle1</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">proj</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span>\n  <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}]</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">bundle_trivialization</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">base_set</span><span class=\"o\">,</span> <span class=\"n\">is_linear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}),</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_topological_vector_bundle</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span> <span class=\"n\">proj</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector_bundle1</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">vector_bundle2</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"err\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">Z</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"err\">𝕜</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">topological_module</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">proj</span> <span class=\"o\">:</span> <span class=\"n\">Z</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">fiber_triv</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"n\">F</span> <span class=\"err\">≃</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"bp\">//</span> <span class=\"n\">proj</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">})</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"kn\">extends</span> <span class=\"n\">bundle_trivialization</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">linear</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">base_set</span><span class=\"o\">,</span> <span class=\"n\">is_linear_map</span> <span class=\"err\">𝕜</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">fiber_triv</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">))</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_topological_vector_bundle</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">Z</span><span class=\"o\">,</span> <span class=\"bp\">∃</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">vector_bundle_trivialization</span> <span class=\"err\">𝕜</span> <span class=\"n\">F</span> <span class=\"n\">proj</span> <span class=\"n\">fiber_triv</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">source</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">vector_bundle2</span>\n</code></pre></div>\n\n\n<p>In the first one, I require that typeclass inference knows about the topological vector space structure on the fibers of the projection, written as <code>{y // proj y = x}</code> (which is defeq to <code>proj ⁻¹' {x}</code>, but synctactically different so one should choose a representation and use it constantly if one wants typeclass inference to succeed). In the second one, instead I choose for each fiber a bijection with the model vector space <code>F</code>, and I require that the trivialization is linear when seen through this (non-canonical) bijection. </p>\n<p>The first one is arguably more natural, but when you work with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">E \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> note that the fibers are not <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span>, they are some other type which has a priori no vector space structure, so you need to register a whole bunch of typeclasses on these fibers, which is not very nice. With the second definition, you just use the canonical identification between <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">{</mo><mi>x</mi><mo stretchy=\"false\">}</mo><mo>×</mo><mi>F</mi></mrow><annotation encoding=\"application/x-tex\">\\{x\\} \\times F</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span></span></span></span> and you're done. So I feel the second definition would be easier to work with.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> , do you remember what you had tried with <span class=\"user-mention silent\" data-user-id=\"116045\">Jesse Michael Han</span> ?</p>\n</blockquote>\n<p>In this message I am not really sure I unerstand the sentence \"one should choose a representation and use it constantly if one wants typeclass inference to succeed\": in particular I do not know what the word \"representation\" refers to. Is there somewhere I can read that could make things clearer?</p>",
        "id": 203114741,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1594134449
    },
    {
        "content": "<p>In the past month I played both with Sébastien's definition with fibers <code>{y // proj y = x}</code> and with Mario's definition. I still do not know what exactly Sébastien meant with <em>representation</em> (and I would still be curious) but I defined canonical equivalences between the two fibers and defined a way to lift structures for equivalences, so in the end it's not that much of a pain to work with it (you literally have to write two more lines) and things get smooth by defining enough canonical instances. All the same I must say that to me Mario's definition results very natural since the beginning and in particular it is very easy to define naturally the cotangent bundle and exterior bundles and to work with them. Its only defect is that I do not see how it can be easily used with the current tangent bundle, which should still be the main \"goal\": I used it only for bundles defined directly with sigma types: that is how I imagine most vector bundles would be defined. For this reason I would be interested to hear <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> 's opinion on the possibility of using that definition for the tangent bundle, before discarding it, also after having seen Mario's code. I'd be interested to hear if there were a possibility to make Lean recognize the current tangent bundle as a sigma type, since the total space is, below, a product, which is in turn a constant sigma type, or if, because another name is used for such product, this is impossible.</p>",
        "id": 207945008,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1598350971
    },
    {
        "content": "<p>I agree that a Sigma type is more natural than a product for the tangent bundle. I have initially defined the tangent bundle as a product to get something nice for vector spaces, but this is only an implementation detail. I will try toredefine it to be a Sigma type, as this should be more handy for Riemannian spaces.</p>",
        "id": 208060457,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1598427105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Lie.20groups.20and.20Lie.20algebras/near/208060457\">said</a>:</p>\n<blockquote>\n<p>I agree that a Sigma type is more natural than a product for the tangent bundle. I have initially defined the tangent bundle as a product to get something nice for vector spaces, but this is only an implementation detail. I will try toredefine it to be a Sigma type, as this should be more handy for Riemannian spaces.</p>\n</blockquote>\n<p>I think it is perfect as it is if we could make Lean recognize a product as a Sigma type. If this is not possible are you planning to change the base type from product to constant sigma type? That would probably be enough I guess, or are you thinking of changing more?</p>",
        "id": 208068717,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1598433421
    },
    {
        "content": "<p>I am planning to redefine the total space of a topological fiber bundle core as <code>Σ (x : B), Z.fiber x</code> (where <code>Z</code> is the bundled topological fiber bundle core). Since all the fibers are the same type <code>F</code>, this is indeed a constant sigma type, but from the point of view of typeclass inference this is a little bit better, as one might register additional structures on <code>Z.fiber x</code>, for instance a euclidean space structure that might depend on <code>x</code>, and Lean shouldn't get confused.</p>\n<p>And no, making Lean recognize a product as a Sigma type doesn't seem reasonable, they are really different things from the point of view of type theory.</p>",
        "id": 208070943,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1598434983
    },
    {
        "content": "<p>Ok cool as soon as you have a working definition let me know (I mean even if it just a branch and not yet ready for PR) so that I can try to adapt and test the second vector bundle experiment to it!</p>",
        "id": 208071332,
        "sender_full_name": "Nicolò Cavalleri",
        "timestamp": 1598435264
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3966\">#3966</a></p>",
        "id": 208366552,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1598632915
    },
    {
        "content": "<p>Does it mean we now have dependent type hell when comparing two vectors at two propositionaly equal points?</p>",
        "id": 208367027,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598633131
    },
    {
        "content": "<p>No, if you just take the vector, it belongs to the tangent space at <code>x</code>, which is just a copy of the model vector space, so comparing two vectors at two propositionally equal points (or even at different points!) is not a problem for Lean. The difference is only how these tangent spaces are put together to form the tangent bundle.</p>",
        "id": 208389866,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1598645474
    },
    {
        "content": "<p>Ok, good.</p>",
        "id": 208389895,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1598645495
    }
]
[
    {
        "content": "<p>I think we have an overlapping ...cluster... of problems, centred around <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.shift_functor\">docs#category_theory.shift_functor</a>. I've made several recent attempts to clean this up, and always found myself dealing with trying to solve multiple problems at once, and getting frustrated. This is an attempt to list all the problems I've noticed, in the hope that this helps me understand what order they should be fixed in!</p>\n<p>I think these problems are important to solve, as <code>shift_functor</code> is used all over the homological algebra in LTE, and at the moment I can't bring myself to work on things in LTE that involve it, not wanting to build on shaky foundations.</p>\n<p>To recall, a <code>shift_functor A C</code> is currently defined as a monoidal functor from a monoid <code>A</code> (thought of as a discrete monoidal category) to the endofunctors of <code>C</code>.</p>\n<p>Although this sounds complicated, I think it is fundamentally sound: equations in the monoid <code>A</code> are going to be reflected by something \"equational\" (i.e. equations, or natural isomorphisms) between the corresponding endofunctors, and it is better and saner to handle this explicitly as part of the structure of a monoidal functor, rather than risking dealing with <code>eq.rec</code>.</p>\n<p>This version of <code>shift_functor</code> was introduced in <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a> by <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> and <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>. Previous to that, we described shift functors just by a single auto-equivalence of the category, corresponding to shift-by-one.</p>\n<p>Okay, so what is currently wrong?</p>\n<ol>\n<li><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.endofunctor_monoidal_category\">docs#category_theory.endofunctor_monoidal_category</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.discrete.monoidal\">docs#category_theory.discrete.monoidal</a> are presumably missing <code>@[simp]</code> lemmas, because there are places where we are compelled to write <code>local attribute [reducible]</code> on them; to me this is a bad code smell.</li>\n<li>There is some unfortunate tension between different <code>simp</code> lemmas involving inverses, sometimes pushing inverses down and sometimes pulling them up. There's no well-defined simp normal form, and so we're often left with nasty goals where manual rewriting is needed to cancel inverses. As an example, we distribute <code>inv</code> over <code>≫</code>, but pull <code>inv</code> out from inside <code>F.map</code>, so the simplifier can't cope with <code>inv (F.map (inv f ≫ inv g))</code>.</li>\n<li>In <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.shift_mk_core\">docs#category_theory.shift_mk_core</a>, we provide a helper lemma for constructing a shift functor, but really it should be generalised to construct a lax monoidal functor from a <code>-&gt;+</code>. (EDIT: maybe not.)</li>\n<li><code>category_theory.opaque_eq_to_iso</code>is a weird hack, that ideally we could avoid, because it is a weird hack?</li>\n<li><code>monoidal_functor</code> contains an <code>is_iso</code> field for both <code>μ</code> and <code>ε</code>, the tensorator and unitor of the underlying lax monoidal functor. However we're then erratic about whether we refer to the inverse via something like <code>inv μ</code>, or via something like <code>μ_iso.inv</code>, where <code>μ_iso := as_iso μ</code>. This results in some unnecessary and painful rewriting, and bad simp normal forms. </li>\n<li>In <code>category_theory.triangulated.rotate</code>, we show that rotating triangles is an equivalence of categories. A while back, the proofs here were short and sensible. Now they are big and fragile. (See e.g. this sort of <a href=\"https://github.com/leanprover-community/mathlib/commit/8d24a1fe324e8610dbefa95b281bffbd0b79c78d#diff-5372d6bee45992c4307443b80d71d1662dcc5fc1dad21fe2a52ad6dfd0cc6a43R202\">diff</a>.) Most of my attempts to fix problems above have foundered on not being able to get these proofs to work again. Hopefully the explanation for this change is that previously they were solely in terms of the shift-by-one equivalence, and now are exposed to the full complexity of the monoidal functor. It doesn't seem impossible that we could recover the previous clean situation.</li>\n</ol>",
        "id": 283012039,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653008915
    },
    {
        "content": "<p>Problem 6. feels like the fundamental one to me, and it prevents me from making progress on the others, it seems. Any attempt to fix other problems results in these fragile proofs breaking, and then I can't fix them. So far my best idea is do revert <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a> and try again, this time with the requirement that we don't ever write <code>local reducible</code>, and that one-liner proofs stay that way. This would cast LTE adrift for a while, but I'm running out of ideas. I just spent another hour on this with nothing to show for it. Help, or alternatively saying that reverting <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a> is not insane, very much appreciated.</p>",
        "id": 283018645,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653015427
    },
    {
        "content": "<p>How reliable are the simp lemmas around pseudofunctors? I haven't been following these recent developments around bicategories too closely, but IIRC there was some PR recently adjusting some simp lemmas for the better (I assume...). Would changing <code>has_shift</code> to use pseudofunctors as opposed to a monoidal functor help at all?</p>",
        "id": 283019564,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653016311
    },
    {
        "content": "<p>Hmm, I don't know there's much difference on the monoida functor / pseudofunctor front, although I will have a think about this. The formalisation of <code>bicategory</code> we have in mathlib has a nice advantage over <code>monoidal_category</code> because it doesn't allow horizontal composition (corresponding to tensor product) as an elementary operation, only whiskering. This seems to have a nice juicy payoff in better simp lemmas.</p>",
        "id": 283024505,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653022868
    },
    {
        "content": "<p>But that's all at the category level, not the functor level.</p>",
        "id": 283024510,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653022880
    },
    {
        "content": "<p>Scott, thanks a lot for this very coherent summary of the situation.</p>\n<p>Trying to understand what's going on here (not that I'm convinced I can help much, but I'm obviously interested). I don't have a good understanding of <code>simp</code> normal form. We spent a long time in the past trying to make <code>simp</code> do the job of both <code>norm_cast</code> and <code>push_cast</code> despite <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> being adamant that it wasn't the tool for the job, and ultimately this was fixed by writing <code>norm_cast</code> and <code>push_cast</code> instead. One of the issues is that sometimes the user wants to push one way and sometimes the other; neither is \"simpler\". I've seen other situations where I've been confused about whether to make something into a <code>simp</code> lemma: it seems like a good idea for when you're making some basic API but then when that's made you don't want the lemma to be <code>simp</code> any more. As a result I always feel a bit confused about <code>simp</code> and simp normal form. Is the issue here that no global coherent decision has been made about a <code>simp</code> normal form or that there is no \"best\" normal form and that one sometimes wants to push and sometimes pull? I appreciate that this seems not to be the main issue but I thought I'd start somewhere.</p>",
        "id": 283025819,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024419
    },
    {
        "content": "<p><code>push_inv</code> and <code>pull_inv</code>?</p>",
        "id": 283025900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024500
    },
    {
        "content": "<p>I'm pretty sure there's just no plausible normal form that will make everyone happy.</p>",
        "id": 283025903,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024503
    },
    {
        "content": "<p>I think some generic push and pull tactics would be amazing.</p>",
        "id": 283025907,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024512
    },
    {
        "content": "<p>I'm imagining some lookup table (controllable by attributes?) that informs the tactic \"if the user has asked you to push the symbol ◫, perhaps try these lemmas\", and then it just blindly rewrites by those lemmas, accepting any successful rewrites that increase/decrease the depth of ◫.</p>",
        "id": 283025950,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024590
    },
    {
        "content": "<p>So your opinion seems to be consistent with what we've seen with nat/int/real, where sometimes you just want all the coercions to go away but at other times you want them to happen as soon as they can ie every natural immediately gets coerced to a real</p>",
        "id": 283025953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024593
    },
    {
        "content": "<p>Yes. The category theory library is full of these: do we want functors in or out, natural transformations to the left or right, inverses in or out? There's no hope of consistently deciding all of these. (That's far from saying that our current simp lemmas are optimal, or even seriously thought about...)</p>",
        "id": 283026034,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024656
    },
    {
        "content": "<p>Right, and my understanding of Mario's point of view was that perhaps one shouldn't be using <code>simp</code> at all to do this job</p>",
        "id": 283026060,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024706
    },
    {
        "content": "<p>Because we don't know what we want, we want access to both directions</p>",
        "id": 283026104,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024727
    },
    {
        "content": "<p>Specifically on the subject of inverses, I have a branch (another failure because of this <code>shift_functor</code> problem) that introduces a <code>has_syntactic_inv</code>, a \"syntactic typeclass\" that says \"this expression has an <code>inv</code> deep inside it, and if you want to take <code>inv</code> of the whole expression, I know how to make them cancel\". I think it's fun, and maybe useful, and would like to return to it again later. :-)</p>",
        "id": 283026136,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024775
    },
    {
        "content": "<p>This would allow simplification of expressions like <code>inv (F.map (inv f ≫ inv g))</code> mentioned above, because <code>F.map (inv f ≫ inv g)</code> would easily acquire a <code>has_syntactic_inv</code> instance!</p>",
        "id": 283026172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653024836
    },
    {
        "content": "<p>Trying to understand the meat of your post -- my first naive thought was \"well maybe forget about this whole monoidal stuff and just define a <code>has_scalar</code> action of a monoid on a category\". Are your comments about <code>eq.rec</code> explaining why this is a bad idea? Is this the whole \"<code>A (n-1+1)</code> isn't <code>A n</code>\" thing?</p>",
        "id": 283026239,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653024905
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.opaque_eq_to_iso\">docs#category_theory.opaque_eq_to_iso</a></p>",
        "id": 283026354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653025046
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.eq_to_iso\">docs#category_theory.eq_to_iso</a></p>",
        "id": 283026427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653025137
    },
    {
        "content": "<p>Thanks for writing down this list! Now that I read it, I recognize these pain points, but I hadn't distilled them into such an articulate form.<br>\nConcerning (2). I think we have <code>(F.map_iso e).inv = F.map e.inv</code> as simp-lemma for <code>iso.inv</code>. So it would be good to have the same direction for <code>is_iso.inv</code>.</p>",
        "id": 283026437,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653025155
    },
    {
        "content": "<p>Aaah, internet is back. I see I missed a lot of messages</p>",
        "id": 283026532,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653025236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>, yes, this is basically the dependent type theory hell problem. Johan might have a more detailed explanation in this particular case. But the argument is that you inevitably have these \"transports\" either way, and it's better to have them as explicit morphisms, which are easier to keep track of (and there are fewer things to do with them) than arbitrary eq.recs.</p>",
        "id": 283032228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653030676
    },
    {
        "content": "<p>In that specific case, why can't <code>F.map (inv f ≫ inv g)</code> be rewritten to <code>F.map (inv f) ≫ F.map (inv g)</code>. Distributivity simp lemmas seem to be very useful.</p>",
        "id": 283035738,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1653033422
    },
    {
        "content": "<p>Hmm, maybe I picked a terrible example.. :-) That is just <code>functor.map_comp</code>, hopefully.</p>",
        "id": 283045417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653039261
    },
    {
        "content": "<p>Another example of \"distant <code>inv</code>s\" that I've met in the wild is <code>inv (H.map (α.inv.app X)) = H.map (α.hom.app X)</code>.</p>",
        "id": 283047315,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653040489
    },
    {
        "content": "<p>Okay, hopefully <a href=\"https://github.com/leanprover-community/mathlib/pull/14262\">#14262</a> deals with <a href=\"https://github.com/leanprover-community/mathlib/pull/4\">#4</a>, by killing off <code>opaque_eq_to_iso</code>. It depends on <a href=\"https://github.com/leanprover-community/mathlib/pull/14260\">#14260</a>, so if review of both of those could happen, that would be lovely. :-)</p>",
        "id": 283057868,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653047584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks. <code>eq_to_hom_map</code> is indeed a very bad lemma for the default simp-set.</p>",
        "id": 283058754,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653048103
    },
    {
        "content": "<p>Yes, and surely my fault that it is in the simp set. Sorry about that. :-) I do like <code>simp</code> to work when it can.</p>",
        "id": 283058853,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653048152
    },
    {
        "content": "<p>I would like to rename it to <code>functor.map_eq_to_hom</code>, but I'll keep that for a separate PR.</p>",
        "id": 283058883,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653048178
    },
    {
        "content": "<p>No worries. It's all part of the experiment. We learn as we go.</p>",
        "id": 283058884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653048179
    },
    {
        "content": "<p>I am on the edge of seriously proposing that we revert <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a>. I am trying to solve the problems in <code>shift_functor</code>, but having to make incremental changes while maintaining the proofs in <code>pretriangulated/rotate.lean</code> is simply too painful.</p>",
        "id": 283226987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653218112
    },
    {
        "content": "<p>Could we just try again with <code>shift_functor</code>, next time being more careful?</p>",
        "id": 283226999,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653218146
    },
    {
        "content": "<p>Oh no you deleted <code>eq_to_hom_map</code> again?</p>",
        "id": 283246586,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653246313
    },
    {
        "content": "<p>I still don't understand why one wouldn't want it by default, and the PR gives no indication</p>",
        "id": 283246733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653246500
    },
    {
        "content": "<p>I realize it's biased to be looking at existing mathlib proofs but <a href=\"https://github.com/leanprover-community/mathlib/pull/14260\">#14260</a> doesn't look very good to me, it broke about 30 proofs, and the ones that it fixed were mostly using nonterminal <code>simp</code></p>",
        "id": 283248223,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653248651
    },
    {
        "content": "<p>I understand in principle how there could be an issue with naturality, but isn't naturality not a simp lemma anyways?</p>",
        "id": 283248255,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653248710
    },
    {
        "content": "<p>What about just writing <code>local attribute [-simp]</code> where you don't want it?</p>",
        "id": 283248317,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653248785
    },
    {
        "content": "<p>We could also add the simp-normal-form of naturality applied to <code>eq_to_hom</code> of something as a new lemma</p>",
        "id": 283248412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653248908
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.nat_trans.naturality\">docs#category_theory.nat_trans.naturality</a></p>",
        "id": 283249008,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653249699
    },
    {
        "content": "<p>Yeah, it's a simp lemma.</p>",
        "id": 283249015,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653249714
    },
    {
        "content": "<p>I think I agree with Scott in this case. In practice, it seems that <code>eq_to_hom</code> is easier to work with when it's as deeply nested as possible. I.e. I would indeed prefer <code>F.map (eq_to_hom h)</code> as opposed to <code>eq_to_hom (congr_arg ...)</code> because with <code>F.map</code> on the outside you at least have some hope of progress if you have some other <code>F.map</code>s around or <code>e.app</code> where <code>e</code> is a nat trans.</p>",
        "id": 283249138,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1653249889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, would you be interested in</p>\n<ol>\n<li>either removing, or finding an alternative to, <code>opaque_eq_to_iso</code> in <code>shift_functor.lean</code>, as <a href=\"https://github.com/leanprover-community/mathlib/pull/14262\">#14262</a> does (but this depends on <a href=\"https://github.com/leanprover-community/mathlib/pull/14260\">#14260</a>)</li>\n<li>restoring the proofs in <code>pretriangulated/rotate.lean</code> to something similar to the state they were in prior to <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a>? (<a href=\"https://github.com/leanprover-community/mathlib/pull/14258\">#14258</a> is a draft PR which shows what reverting <a href=\"https://github.com/leanprover-community/mathlib/pull/10573\">#10573</a> does relative to current master)</li>\n</ol>\n<p>Alternatively resolving points 1. or 5. in my list above would be very helpful.</p>\n<p>The basic problem with allowing <code>simp</code> to use <code>eq_to_hom_map</code> is that afterwards you can't use naturality, functoriality, etc, because the functors have disappeared into a proof.</p>",
        "id": 283255695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653259150
    },
    {
        "content": "<p>I am certainly open to attempting to restore <code>eq_to_hom_map</code> to the default simp later, if we can first bring <code>shift_functor</code> and <code>rotate</code> back to a maintainable state, and then restore it to the simp set without rebreaking them.</p>",
        "id": 283255799,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653259229
    },
    {
        "content": "<p>But to be honest at this point I am very frustrated by the issues around <code>shift_functor</code>, and my enthusiasm for dealing with it is vanishing, and so when I find steps that go partially towards repairing these problems, if there are problems with those steps I would like concrete (ideally in the form of PRs) alternatives.</p>",
        "id": 283255900,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653259388
    },
    {
        "content": "<p>I find <code>eq_to_hom_map</code> very dubious as simp-lemma. And get shift to work well is certainly higher on my list of \"important things\" than supporting this simp-lemma.</p>",
        "id": 283267456,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653276208
    },
    {
        "content": "<p>OK, I can't really imagine why it should not be a simp lemma (and I think the PR diff speaks for itself) but if it looks like progress to you, then carry on!</p>",
        "id": 283274628,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653285667
    },
    {
        "content": "<p>I'm mainly annoyed because we already went through one round of this with <a href=\"https://github.com/leanprover-community/mathlib/pull/1346\">#1346</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/2713\">#2713</a>. I feel something else is wrong here.</p>",
        "id": 283274974,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653286059
    },
    {
        "content": "<p>Hmm, as simp-lemmas that certainly prevent other chains of simp-lemmas to fire. So it seems to me that the simp-set is not confluent.</p>",
        "id": 283275324,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653286420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land/near/283248412\">said</a>:</p>\n<blockquote>\n<p>We could also add the simp-normal-form of naturality applied to <code>eq_to_hom</code> of something as a new lemma</p>\n</blockquote>\n<p>I guess this would allow some progress.<br>\nMaybe the biggest show-stopper is that you have no idea what to do when you see <code>eq_to_hom _</code> in the goal view. So you prefer to have that <code>_</code> be as small as possible.</p>",
        "id": 283275451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653286540
    },
    {
        "content": "<p>Personally I always feel some relief when I get <code>eq_to_hom_refl</code> to fire, so that I'm back in \"honest\" category theory land.</p>",
        "id": 283275502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653286571
    },
    {
        "content": "<p>I didn't realize naturality was a simp lemma. That means there are two non-confluent simp rewrites from whatever the left hand side of naturality is applied to <code>eq_to_hom</code>. The way to fix it is to add another simp lemma.</p>",
        "id": 283275621,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653286706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/trouble.20in.20.60shift_functor.60.20land/near/283275502\">said</a>:</p>\n<blockquote>\n<p>Personally I always feel some relief when I get <code>eq_to_hom_refl</code> to fire, so that I'm back in \"honest\" category theory land.</p>\n</blockquote>\n<p>Yes, that's exactly the purpose of lemmas like <code>eq_to_hom_map</code>--you want to compose all the <code>eq_to_hom</code>s appearing in your expression into one place, so that if at the end of the day you are talking about the same object, they will all cancel with <code>eq_to_hom_refl</code>. This doesn't require looking at the proofs in any way.</p>",
        "id": 283275676,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653286801
    },
    {
        "content": "<p>It's kind of silly to be talking about naturality--if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>X</mi></msub><mo>:</mo><mi>F</mi><mi>X</mi><mo>→</mo><mi>G</mi><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">t_{X} : FX \\to GX</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">FX</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">GX</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A = B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> then up to equalities of objects we have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>t</mi><mi>A</mi></msub><mo>=</mo><msub><mi>t</mi><mi>B</mi></msub></mrow><annotation encoding=\"application/x-tex\">t_A = t_B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7651em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3283em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, and this doesn't require any kind of functoriality or naturality assumptions.</p>",
        "id": 283275860,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653286967
    },
    {
        "content": "<p>Haha, I had forgotten about <a href=\"https://github.com/leanprover-community/mathlib/pull/1346\">#1346</a> and <a href=\"https://github.com/leanprover-community/mathlib/pull/2713\">#2713</a>. Very reasonable to be annoyed. :-) I'm away from my desktop at the moment and don't have the branch, but I'll try to post some examples where <code>eq_to_hom_map</code> was annoying me later.</p>",
        "id": 283277537,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653288515
    },
    {
        "content": "<p>Regarding <code>def shift_functor (n : ℤ) : differential_object C ⥤ differential_object C</code>--first I'll have to apologize that this is very far from the way I usually think about these things.</p>",
        "id": 283279974,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653290486
    },
    {
        "content": "<p>Don't you want a sign in this definition?</p>",
        "id": 283279982,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653290490
    },
    {
        "content": "<p><a href=\"https://stacks.math.columbia.edu/tag/0119\">https://stacks.math.columbia.edu/tag/0119</a></p>",
        "id": 283280001,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653290513
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">abbreviation</span> <span class=\"n\">shift_functor_comp_shift_functor_neg</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">shift_functor</span> <span class=\"n\">C</span> <span class=\"n\">i</span> <span class=\"bp\">⋙</span> <span class=\"n\">shift_functor</span> <span class=\"n\">C</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">≅</span> <span class=\"mi\">𝟭</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"n\">unit_of_tensor_iso_unit</span> <span class=\"o\">(</span><span class=\"n\">shift_monoidal_functor</span> <span class=\"n\">C</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">⟩</span> <span class=\"o\">⟨(</span><span class=\"bp\">-</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)⟩</span>\n<span class=\"c1\">--(opaque_eq_to_iso (add_neg_self i))</span>\n  <span class=\"o\">(</span><span class=\"n\">discrete.eq_to_iso</span> <span class=\"o\">(</span><span class=\"n\">add_neg_self</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>I think the problem is in this definition, we should be thinking of <code>discrete int</code> as having an \"inversor\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>⊕</mo><mo stretchy=\"false\">(</mo><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>≅</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">i \\oplus (-i) \\cong 0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7429em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span> which should be part of its structure as a \"groupoidal\" category. We should not directly expose that this inversor is defined in terms of <code>eq_to_iso</code> (especially not in an <code>abbreviation</code>!)</p>",
        "id": 283280924,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653291191
    },
    {
        "content": "<p>At a higher level, I think it is not that easy to prove that <code>discrete nat</code> is equivalent to the free monoidal category on one object, right? The latter would have objects like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊗</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>⊗</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>⊗</mo><mo stretchy=\"false\">(</mo><mi>X</mi><mo>⊗</mo><mi>X</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(X \\otimes 1) \\otimes (1 \\otimes (X \\otimes X))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">))</span></span></span></span>, and then all the maps we can build from the associators and unitors.</p>",
        "id": 283281239,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653291401
    },
    {
        "content": "<p>If we formed the free monoidal category on an invertible object, the objects <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>⊗</mo><msup><mi>X</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">X \\otimes X^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span> wouldn't be <em>equal</em>. So, you shouldn't be exposing this inversor as built from <code>eq_to_hom</code>.</p>",
        "id": 283281669,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653291706
    },
    {
        "content": "<p>Re the sign: you're not going to have this with an arbitrary group action on a category. Or should the group come equipped with a map to Z/2?</p>",
        "id": 283290488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1653297256
    },
    {
        "content": "<p>Well <code>differential_object</code> is specialized to <code>int</code>. A <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">G</span></span></span></span>-graded object can just be shifted without needing any extra data, but for a differential object you need to specify how to identify <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">X[n][1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">X[1][n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> in order to get the differential on the shifted object.</p>",
        "id": 283301028,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653303539
    },
    {
        "content": "<p>I found <a href=\"#narrow/stream/267928-condensed-mathematics/topic/shift.20of.20complexes/near/229303000\">a discussion</a> about signs in a shifted complex from last year, but it seems LTE still uses the \"non-mathsy\" definition, unless I'm missing something</p>",
        "id": 283307576,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653307112
    },
    {
        "content": "<p>If we're going to have the shift with no signs in mathlib then it would be good to find at least one source using this convention; I suspect it won't be easy.</p>",
        "id": 283308428,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653307543
    },
    {
        "content": "<p>This is the mathsy def, right: <a href=\"https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_shift.lean#L34\">https://github.com/leanprover-community/lean-liquid/blob/master/src/for_mathlib/homological_complex_shift.lean#L34</a></p>",
        "id": 283308776,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653307704
    },
    {
        "content": "<p>oh yes</p>",
        "id": 283308928,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653307796
    },
    {
        "content": "<p>I was looking at the derived category or something, but I guess it unwinds to that definition</p>",
        "id": 283309277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1653307966
    },
    {
        "content": "<p>I would be very happy to just delete the current <code>differential_object</code>, particularly if it induces anyone to redo <code>shift_functor</code>!</p>",
        "id": 283311683,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1653309269
    },
    {
        "content": "<p>I don't know of any uses of <code>differential_object</code> atm. So deleting it to aid this refactor is fine with me. It should be very easy to add it back afterwards.</p>",
        "id": 283312488,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1653309646
    }
]
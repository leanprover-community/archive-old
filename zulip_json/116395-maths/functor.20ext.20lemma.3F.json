[
    {
        "content": "<p>Is this just what I'm stuck with in dependent type theory? I want to prove two functors are equal.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">opens</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">structure functor (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] :</span>\n<span class=\"cm\">  Type (max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ) :=</span>\n<span class=\"cm\">(obj       : C ‚Üí D)</span>\n<span class=\"cm\">(map       : Œ† {X Y : C}, (X ‚ü∂ Y) ‚Üí ((obj X) ‚ü∂ (obj Y)))</span>\n<span class=\"cm\">(map_id&#39;   : ‚àÄ (X : C), map (ùüô X) = ùüô (obj X) . obviously)</span>\n<span class=\"cm\">(map_comp&#39; : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = (map f) ‚â´ (map g) . obviously)</span>\n\n<span class=\"cm\">infixr ` ‚•§ `:26 := functor       -- type as \\func --</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n\n<span class=\"n\">def</span> <span class=\"n\">res_functor</span> <span class=\"o\">{</span><span class=\"n\">Y‚ÇÅ</span> <span class=\"n\">Y‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hY</span> <span class=\"o\">:</span> <span class=\"n\">Y‚ÇÇ</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">Y‚ÇÅ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n    <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">Y‚ÇÅ</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"err\">‚•§</span> <span class=\"o\">{</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span> <span class=\"bp\">//</span> <span class=\"n\">Y‚ÇÇ</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">V</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"bp\">‚ü®</span><span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">hY</span> <span class=\"n\">V</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">Œª</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">id</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- is this supposed to be a such a kerfuffle</span>\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">res_functor</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">res_functor</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span><span class=\"o\">,</span> <span class=\"c1\">-- is there an ext lemma missing?</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">ext</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">eq</span><span class=\"o\">,</span>\n    <span class=\"n\">refl</span><span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"c1\">-- aargh I have heqs</span>\n    <span class=\"n\">apply</span> <span class=\"n\">heq_of_eq</span><span class=\"o\">,</span>\n    <span class=\"n\">ext</span><span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 184052269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577017001
    },
    {
        "content": "<p>The reason I get <code>heq</code>s is I guess because <code>(obj X) ‚ü∂ (obj Y)</code> changes when I change <code>obj</code> to something equal to <code>obj</code>. I would be happy with some kind of procedure where I am first asked to prove that the two <code>obj</code> maps are equal and then after that I'm asked to prove that the <code>map</code> maps are equal (rather than hequal). Does that even make sense in Lean's type theory?</p>",
        "id": 184052467,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577017333
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> to do the kind of algebraic geometry I want to do, I really want to make this category theory stuff work. But I still don't really understand the limitations of dependent type theory in this context. It's clear as an end user what I want to do here -- the objs are the same, the maps are the same, so the functors are the same. The above example is distilled from some proof that pushforwards and pullbacks for sheaves of objects in a category are adjoint functors, and it's what is stopping automation from taking over in some diagram chase. <a href=\"https://github.com/ramonfmir/lean-scheme/blob/sheaves_of_categories/src/sheaves_of_categories/pushforward.lean\" target=\"_blank\" title=\"https://github.com/ramonfmir/lean-scheme/blob/sheaves_of_categories/src/sheaves_of_categories/pushforward.lean\">Here's what I'm doing</a> in case anyone is interested.</p>",
        "id": 184052626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577017650
    },
    {
        "content": "<p>I don't know what the \"correct\" way is but </p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">unfold</span> <span class=\"n\">res_functor</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">tidy</span>\n</pre></div>\n\n\n<p>is a lot easier on the eye (and brain)!</p>",
        "id": 184052814,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577017960
    },
    {
        "content": "<p>I tidied too early! I just try tidy and obviously (not really knowing what they do yet) and then go back to first principles. I think I need some crash course in when to use <code>tidy</code>. Thanks!</p>",
        "id": 184052832,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577018029
    },
    {
        "content": "<p>Oh but \"tidy says\" just</p>\n<div class=\"codehilite\"><pre><span></span>  <span class=\"n\">simp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 184052836,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577018038
    },
    {
        "content": "<p>Yeah I'm also slightly surprised that tidy doesn't work if unfolding needs doing in this case</p>",
        "id": 184052887,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577018102
    },
    {
        "content": "<p>There's maybe either a missing simp lemma or a missing ext lemma, but I'm too much of a beginner in this area to know how to fix this properly.</p>",
        "id": 184052908,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577018128
    },
    {
        "content": "<p>I can't rewrite this lemma in my application anyway :-( (motive is not type correct, and neither <code>erw</code> nor <code>simp only</code> fixes it). Am I not supposed to be proving that functors are equal? Functors are terms not types, I thought equality would be a good idea...</p>",
        "id": 184053330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577018767
    },
    {
        "content": "<p>Can you get away with just constructing a natural isomorphism of your functors?</p>",
        "id": 184053746,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577019509
    },
    {
        "content": "<p>Yes, that's the standard answer in category theory: do you really mean <em>equal</em> here?</p>",
        "id": 184053763,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1577019549
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">res_functor</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"err\">‚âÖ</span> <span class=\"mi\">ùü≠</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">obviously</span>\n</pre></div>",
        "id": 184053925,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577019796
    },
    {
        "content": "<p>I am a mere mathematician and hence don't understand equality properly, but for two functors from C to D to be equal I mean that F(o) = G(o) for all objects o of C and F(f) = G(f) for all morphisms (this makes sense only because of the condition on the objects). Is this a bad notion of equality in Lean's set-up of category theory? Is it a mathematically irrelevant notion?</p>",
        "id": 184056088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577023728
    },
    {
        "content": "<p>I am trying to do a very mundane thing -- pull back a presheaf. I want to prove that pullback is a functor and checking that it sends identities to identities involves checking that two morphisms are equal. However constructing the morphisms involves constructing maps between colimits if one is pulling back presheaves and this involves limit cones which are made from functors. I wanted to argue that two functors were equal to proceed but perhaps this is not the right approach</p>",
        "id": 184056432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577024357
    },
    {
        "content": "<p>It looks like there is precedent for using natural iso even if equality holds in fact: in line 62 of category_theory/precedent.lean <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  wrote about two constant functors \"These are actually equal, of course, but not definitionally equal (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is  more convenient than an equality between functors\"</p>",
        "id": 184056822,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1577025061
    },
    {
        "content": "<p>Oh good catch Alex. I will then consider switching to nat isos. Here are some more details of why I thought I needed this. I type them as much for myself as for anyone else. Trying to define pullback of presheaves (taking values in a general category e.g. cat of comm rings) on a top space. Have <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>‚Üí</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">f:X\\to Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚Üí</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> continuous. Definition is <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msub><mo><mi>lim</mi><mo>‚Å°</mo></mo><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow></msub><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>V</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^*\\mathcal{F}(U)=\\lim_{f(U)\\subseteq V}\\mathcal{F}(V)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1052em;vertical-align:-0.3551999999999999em;\"></span><span class=\"mop\"><span class=\"mop\">lim</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose mtight\">)</span><span class=\"mrel mtight\">‚äÜ</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.22222em;\">V</span></span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>lim</mi><mo>‚Å°</mo></mrow><annotation encoding=\"application/x-tex\">\\lim</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mop\">lim</span></span></span></span> is a (filtered) colimit. Need to check it's a presheaf, so need to check that the restriction map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^*\\mathcal{F}(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> to itself is equal to the identity map. This is a map between colimits and I defined it using</p>\n<div class=\"codehilite\"><pre><span></span>limits.colimit.pre :\n  Œ† {J K : Type u_1} [_inst_1 : small_category J] [_inst_2 : small_category K] {C : Type u_2}\n  [ùíû : category_theory.category C] (F : J ‚•§ C) [_inst_3 : limits.has_colimit F] (E : K ‚•§ J)\n  [_inst_4 : limits.has_colimit (E ‚ãô F)], limits.colimit (E ‚ãô F) ‚ü∂ limits.colimit F\n</pre></div>\n\n\n<p>What I have in my situation is a functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> which is \"equal\" to the identity functor in the sense that it is a functor from a small category to itself which is equal to the identity functor whichever way you look at it: with notation above, <code>J</code> and <code>K</code> are both the category of open subsets of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> which contain <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> and <code>E</code> is a functor which should be equal to the identity functor but which I can quite believe is not defeq to the identity functor (indeed <code>rfl</code> fails).</p>",
        "id": 184057107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577025646
    },
    {
        "content": "<p>One last thing before I stop randomly posting my thoughts and actually go away and think: I am specifically avoiding all mentions of categories for <code>opens X</code> and the definition of a presheaf; the only category in sight is the one where the presheaf is taking values:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">presheaf</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">ùíû</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"bp\">Œ†</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"c1\">-- ‚Ñ±</span>\n<span class=\"o\">(</span><span class=\"n\">res</span>   <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">val</span> <span class=\"n\">U</span> <span class=\"err\">‚ü∂</span> <span class=\"n\">val</span> <span class=\"n\">V</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">Hid</span>   <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">ùüô</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"n\">U</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">Hcomp</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">W</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HWV</span> <span class=\"o\">:</span> <span class=\"n\">W</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">HVU</span> <span class=\"o\">:</span> <span class=\"n\">V</span> <span class=\"err\">‚äÜ</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">W</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">HWV</span> <span class=\"n\">HVU</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">res</span> <span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"n\">HVU</span> <span class=\"err\">‚â´</span> <span class=\"n\">res</span> <span class=\"n\">V</span> <span class=\"n\">W</span> <span class=\"n\">HWV</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I am doing it because people have experimented with the definition of a presheaf as a functor on the category whose objects are opens (these definitions are already in mathlib I believe) but I find this approach hard to work with because one is immediately launched head first into the category theory library. With this more mundane method the category theory is more limited and there is more of a separation of concerns (there is only one category involved, for example), and I've found it much easier to learn how to use the limits library etc. It's as much a learning exercise as anything else, and as you can see from the above I still have plenty to learn. I'm not suggesting we should do it like this in mathlib, but it seems to me to be a great set-up for experimentation and trying to work out what works and what doesn't work.</p>",
        "id": 184057314,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577026058
    },
    {
        "content": "<blockquote>\n<p>It looks like there is precedent for using natural iso even if equality holds in fact: in line 62 of category_theory/precedent.lean <span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span>  wrote about two constant functors \"These are actually equal, of course, but not definitionally equal (the equality requires F.map (ùüô _) = ùüô _). A natural isomorphism is  more convenient than an equality between functors\"</p>\n</blockquote>\n<p><a href=\"#narrow/stream/116395-maths/topic/Category.20theory/near/148666324\" title=\"#narrow/stream/116395-maths/topic/Category.20theory/near/148666324\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Category.20theory/near/148666324</a></p>",
        "id": 184076783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577063113
    },
    {
        "content": "<p>OK so there is something going on which I don't understand.</p>\n<p>I'm trying to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup></mrow><annotation encoding=\"application/x-tex\">f^*</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span></span></span></span> is a functor from (<code>ùíû</code>-valued) presheaves on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> to presheaves on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi></mrow><annotation encoding=\"application/x-tex\">X</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">X</span></span></span></span> with notation as above. The restriction map is as follows: if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>‚äÜ</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1\\subseteq U_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> then there's a (forgetful) functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> from the category of open subsets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">f(U_2)\\subseteq V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> to the category of open subsets <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span> of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><msub><mi>U</mi><mn>1</mn></msub><mo stretchy=\"false\">)</mo><mo>‚äÜ</mo><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">f(U_1)\\subseteq V</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">‚äÜ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.22222em;\">V</span></span></span></span>. In <code>category_theory/limits/limits.lean</code> there is <code>colimit.pre</code> which defines a morphism from the colimit of <code>E ‚ãô F</code> to the colimit of <code>F</code> and this is what I used for the restiction map for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">f^*\\mathcal{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span></span>. Now say <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>U</mi><mn>1</mn></msub><mo>=</mo><msub><mi>U</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">U_1=U_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">‚Äã</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> equals the identity functor, except that apparently this is not what we are supposed to say. OK so Alex above noted that <code>obviously</code> proves that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> is isomorphic to the identity functor, and everyone is telling me that this is the correct thing to say. But I'm trying to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">f^*\\mathcal{F}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span></span> is a sheaf, and axiom <code>Hid</code> for sheaves says that restriction from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> has to be equal to the identity map. However if I only know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> is isomorphic to the identity functor then I can only deduce that <code>E ‚ãô F</code> is isomorphic to <code>F</code> and so their colimits will only be isomorphic and have no reason to be equal; hence I can't even talk about the identity map between these things. </p>\n<p>I want to conclude that in this case I <em>have</em> to prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">E</span></span></span></span> is equal to, not just isomorphic to, the identity functor, flying in the face of much of what has gone before.</p>",
        "id": 184078039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577065893
    },
    {
        "content": "<p>Am I allowed to prove that functors from a small category to itself are equal?</p>",
        "id": 184078095,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066008
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">res_functor</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"err\">‚âÖ</span> <span class=\"mi\">ùü≠</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> `tidy` says -/</span>\n  <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X_1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">X_1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">X_1_val</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X_1</span> <span class=\"n\">Y_1</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">}},</span>\n    <span class=\"o\">{</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X_1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">X_1</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">X_1_val</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span> <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">fsplit</span><span class=\"o\">,</span> <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">a_1</span><span class=\"o\">,</span> <span class=\"n\">assumption</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">X_1</span> <span class=\"n\">Y_1</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">},</span>\n      <span class=\"o\">{</span> <span class=\"n\">apply_auto_param</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">res_functor</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">ùü≠</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">res_functor</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p><code>tidy</code> makes a meal of proving they're isomorphic but has little trouble proving they're equal after the <code>unfold</code> hint.</p>",
        "id": 184078203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066281
    },
    {
        "content": "<p>In short, the issue is that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>f</mi><mo>‚àó</mo></msup><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f^*(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">‚àó</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> is a colimit of a functor, and if I replace the functor with an isomorphic functor (e.g. because I replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> with an equal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>U</mi><mo lspace=\"0em\" mathvariant=\"normal\" rspace=\"0em\">‚Ä≤</mo></msup></mrow><annotation encoding=\"application/x-tex\">U'</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.751892em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">‚Ä≤</span></span></span></span></span></span></span></span></span></span></span></span>) then the colimit gets (presumably) replaced by an isomorphic colimit, so it no longer makes sense to talk about a map between the two colimits being equal to the identity map, which is what one of the axioms of a presheaf is.</p>",
        "id": 184078332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066445
    },
    {
        "content": "<p>I cannot see any way of proceeding short of proving that the functors are equal.</p>",
        "id": 184078432,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066645
    },
    {
        "content": "<p>AARGH MY MOTIVE IS NOT TYPE CORRECT</p>",
        "id": 184078511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066847
    },
    {
        "content": "<p>You only need equality of the objects for everything else to work, not the homs right? So maybe that's the in between that you need?</p>",
        "id": 184078519,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1577066876
    },
    {
        "content": "<p>I need that two colimits are equal and that a map between them is the identity</p>",
        "id": 184078562,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066906
    },
    {
        "content": "<p>The problem is that one is the colimit of a functor F and the other is the colimit of <code>E &gt;&gt;&gt; F</code> where <code>E</code> is (not definitionally) equal to the identity functor.</p>",
        "id": 184078576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577066975
    },
    {
        "content": "<p>Maybe I should try to make <code>E</code> defeq to the identity functor :-/</p>",
        "id": 184078639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577067105
    },
    {
        "content": "<p>That looks impossible.</p>",
        "id": 184078692,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1577067175
    },
    {
        "content": "<p>My proof of equality uses <code>subtype.eta</code></p>",
        "id": 184078699,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577067192
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>h : res_functor _ = ùü≠ {V // f &#39;&#39; U.val ‚äÜ ‚ÜëV}\n‚ä¢ limits.colimit.pre (to_aux_functor ‚Ñ± (f &#39;&#39; U.val)) (res_functor _) = ùüô (aux_colimit ‚Ñ± (f &#39;&#39; ‚ÜëU))\n</pre></div>\n\n\n<p>I can't <code>rw h</code> or <code>erw h</code> or <code>simp only [h]</code>. So I can't work with equality and I can't work with isomorphism :-/</p>",
        "id": 184078874,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577067580
    },
    {
        "content": "<p>The standard way to do this is to prove the rewrite you want to do except with <code>res_functor _</code> replaced with a variable so <code>subst</code> works, and then apply it to this case.</p>",
        "id": 184078986,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1577067837
    },
    {
        "content": "<p>No idea if this is a sustainable strategy.</p>",
        "id": 184079026,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1577067855
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"n\">K</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">K</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"err\">ùíû</span> <span class=\"o\">:</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">‚•§</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_colimit</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">E‚ÇÅ</span> <span class=\"n\">E‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"n\">K</span> <span class=\"err\">‚•§</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_colimit</span> <span class=\"o\">(</span><span class=\"n\">E‚ÇÅ</span> <span class=\"err\">‚ãô</span> <span class=\"n\">F</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">has_colimit</span> <span class=\"o\">(</span><span class=\"n\">E‚ÇÇ</span> <span class=\"err\">‚ãô</span> <span class=\"n\">F</span><span class=\"o\">)]</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">E‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">E‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">colimit</span><span class=\"bp\">.</span><span class=\"n\">pre</span> <span class=\"n\">F</span> <span class=\"n\">E‚ÇÅ</span> <span class=\"bp\">=</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">colimit</span><span class=\"bp\">.</span><span class=\"n\">pre</span> <span class=\"n\">F</span> <span class=\"n\">E‚ÇÇ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>doesn't compile: Lean complains that they can't be equal because they have different types :-/ </p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at application\n  limits.colimit.pre F E‚ÇÅ = limits.colimit.pre F E‚ÇÇ\nterm\n  limits.colimit.pre F E‚ÇÇ\nhas type\n  limits.colimit (E‚ÇÇ ‚ãô F) ‚ü∂ limits.colimit F\nbut is expected to have type\n  limits.colimit (E‚ÇÅ ‚ãô F) ‚ü∂ limits.colimit F\n</pre></div>",
        "id": 184079250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577068367
    },
    {
        "content": "<p>[note that <code>‚ü∂</code> is a category theory hom]</p>",
        "id": 184079313,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577068512
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/ef4d927b65359221488eb55ad298e9bb\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/ef4d927b65359221488eb55ad298e9bb\">self-contained gist</a></p>",
        "id": 184079479,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577068805
    },
    {
        "content": "<p>I think the best idea is just to give up on using limits.colimits.pre completely and just do everything from first principles</p>",
        "id": 184080085,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577070230
    },
    {
        "content": "<p>That doesn't generalise...</p>",
        "id": 184091117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577091079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Note that natural iso's contain data, and hence should be <code>def</code>. Also, the data-parts should probably not be filled in by <code>tidy</code> (even though you can use <code>tidy?</code> to see what to do, but should be filled in with term mode. Hopefully, you would then get two (canonically <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span>) isomorphic functors, that are defeq on objects. It would then make sense to talk about an identity morphism between them (after evaluation on some object).</p>",
        "id": 184091269,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577091255
    },
    {
        "content": "<p>This proves your <code>Hid</code> challenge:</p>\n<div class=\"codehilite\"><pre><span></span>      <span class=\"n\">ext</span><span class=\"o\">,</span>\n      <span class=\"n\">rw</span> <span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">colimit</span><span class=\"bp\">.</span><span class=\"n\">Œπ_pre</span><span class=\"o\">,</span>\n      <span class=\"n\">erw</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span><span class=\"o\">,</span>\n      <span class=\"n\">tidy</span><span class=\"o\">,</span>\n</pre></div>",
        "id": 184097577,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577099239
    },
    {
        "content": "<p>as does this:</p>\n<div class=\"codehilite\"><pre><span></span>        unfold limits.colimit.pre,\n        dsimp,\n        ext V,\n        dsimp,\n        rw limits.colimit.Œπ_desc,\n        dsimp,\n        erw category_theory.category.comp_id,\n        tidy,\n</pre></div>\n\n\n<p>but yours is better ;-) Thanks!</p>",
        "id": 184097804,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577099556
    },
    {
        "content": "<p>I see that both of us need an <code>erw</code> in a situation where it's completely clear that a <code>rw</code> will work ;-)</p>",
        "id": 184097818,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577099580
    },
    {
        "content": "<p>In fact my proof simplifies to yours. I unfold something and do some other rewrite, and after simplification I end up where you were.</p>",
        "id": 184097981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577099771
    },
    {
        "content": "<p><code>ext</code>, in this context, seems to be taking a goal of the form <code>m1=m2</code> where the m_i are morphisms in a category, and replacing it with a goal of the form <code>F(j)&gt;&gt;m1 = F(j)&gt;&gt;m2</code>. It seems to be explicitly using the fact that the source or target of the m_i is a colimit and it's somehow using a universal property of colimits?</p>",
        "id": 184098377,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577100312
    },
    {
        "content": "<p>Pretty smart, right?</p>",
        "id": 184099636,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577102161
    },
    {
        "content": "<p>Yes! Hey, I just managed to do a definitional rewrite which none of <code>rw</code>, <code>erw</code> or <code>simp only</code> would let me do, using <code>conv</code> mode</p>",
        "id": 184099866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577102438
    },
    {
        "content": "<p>ooh I just did it again, and the first time I tried it it failed, so I replaced a proof of something with a different proof and then it worked. I think that's the first time I've seen Lean care about what proof I offer of a proposition.</p>",
        "id": 184100662,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577103544
    }
]
[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260921\">@Markus Himmel</span>  and me have found many ove the universe level restrictions in <code>category_theory.limits.preserves</code> to be too strong in that they require both categories to live in the same universe. I started to work on a generalization at <a href=\"https://github.com/leanprover-community/mathlib/tree/preserves-universes\">preserves-universes</a> but for many of the more specific type classes, e.g. <code>preserves_binary_products</code>, the fix needs to pin the universe level of the diagram category. In general it seems more consistent with other parts of mathlib to have things like the <code>walking_pair</code>in <code>Type</code> instead of being universe polymorphic. Edge cases like <code>preserves_finite_limits</code> are harder to decide on. Any comments on these changes, esp <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ? I seem to have fixed most files, but there's still some work to do...</p>",
        "id": 285026265,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1654419681
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110789\">@Jakob von Raumer</span> I guess you know the back story, that the indexing diagram used to be a small category at the same universe level as that of the morphisms of category in which you take limits. This was decoupled a while ago. So I agree that it's now a good idea for <code>walking_pair</code> and friends to simply live in <code>Type</code>.<br>\nFor things like <code>preserves_finite_limits</code>, I think we should at least support a universe polymorphic version. It could be called <code>preserves_finite_limits_of_size</code> for example.</p>",
        "id": 285074083,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1654488800
    },
    {
        "content": "<p>I'm concerned that these more relaxed universe parameters will mean the<br>\n<code>preserves</code> instances will almost never fire automatically. We are already running into some issues in LTE where we have to provide universes explicitly to <code>has_limit</code> (or similar) instances. Is that better than dealing with <code>ulift</code> once in a while? I don't know...</p>",
        "id": 285075948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1654491251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/285074083\">said</a>:</p>\n<blockquote>\n<p>For things like <code>preserves_finite_limits</code>, I think we should at least support a universe polymorphic version. It could be called <code>preserves_finite_limits_of_size</code> for example.</p>\n</blockquote>\n<p>Yes, that's what it's like on the branch now. There's a sparate lemma  <code>preserves_smallest_finite_limits_of_preserves_limits</code>reflecting it down to <code>Type</code> which we can locally make an instance.</p>",
        "id": 285077901,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1654494124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/285075948\">said</a>:</p>\n<blockquote>\n<p>I'm concerned that these more relaxed universe parameters will mean the<br>\n<code>preserves</code> instances will almost never fire automatically. We are already running into some issues in LTE where we have to provide universes explicitly to <code>has_limit</code> (or similar) instances. Is that better than dealing with <code>ulift</code> once in a while? I don't know...</p>\n</blockquote>\n<p>Since I'm almost through refactoring mathlib, I can say that it does require a few explicit universes but then it removes some others (partially because now the index categories have fixed universes).</p>",
        "id": 285077954,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1654494242
    },
    {
        "content": "<p>Going from an index level &gt; 0 to 0 in order to have e.g. binary products is not completely painless, but in most places we will have <code>has_finite_limits</code> which maybe should default to 0 (as opposed to a <code>has_finite_limits_of_size</code>)</p>",
        "id": 285078070,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1654494440
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> One point I'm stuck at is <code>Lan_preserves_finite_limits_of_flat</code> in <code>category_theory.functor.flat</code>, can you help me? I'm on branch <code>preserves-universes</code></p>",
        "id": 285947751,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655134961
    },
    {
        "content": "<p>I think there should not be a need for <code>has_finite_limits_of_size</code>. Since we have <code>fin_category.equiv_as_type</code> and <code>has_limits_of_shape_of_equivalence</code>, <code>has_finite_limits</code> should suffice.</p>\n<p>I believe <code>Lan_preserves_finite_limits_of_flat</code> should work if the two are merged and we have the instances</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">has_limits_of_shape_of_has_finite_limits</span> <span class=\"o\">[</span><span class=\"n\">has_finite_limits</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fin_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">has_limits_of_shape</span> <span class=\"n\">J</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">preserves_limits_of_shape_of_preserves_finite_limits</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">preserves_finite_limits</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n  <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">fin_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">preserves_limits_of_shape</span> <span class=\"n\">J</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 285956119,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1655138318
    },
    {
        "content": "<p>Thanks! I'll have a look at it tomorrow :)</p>",
        "id": 285976484,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655147939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/285956119\">said</a>:</p>\n<blockquote>\n<p>I think there should not be a need for <code>has_finite_limits_of_size</code>. Since we have <code>fin_category.equiv_as_type</code> and <code>has_limits_of_shape_of_equivalence</code>, <code>has_finite_limits</code> should suffice.</p>\n</blockquote>\n<p>It's a tough decision. I think I'll keep it for now, and we can consider removing it in a second refactor step.</p>",
        "id": 286030818,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655191182
    },
    {
        "content": "<p>Maybe I can get some help from the community with this: On the <code>preserves-universes</code> I'm currently trying to relax all sorts of universe constraints, which in turn suggests changing constant index categories like <code>walking_parallel_pair</code> and the like to not be universe polymorphic but instead live in <code>Type</code>. This causes a problem with <code>over B</code> categories, though: In those we only derive connected limits in the universe <code>v</code> of the morphisms instead of in universe <code>0</code>. One should think that this is not a problem, but the issue is that connectedness is not preserved by <code>ulift</code> (since the space of discrete categories we use to test the functor's being constant grows), so we can't derive that <code>over B</code> has e.g. pullbacks because we miss the instance <code>is_connected (ulift_hom (ulift walking_cospan))</code>, and it's not really easy to derive this instance in a general way. Any ideas on how to solve this? <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> ?</p>",
        "id": 287180652,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655986535
    },
    {
        "content": "<p>(<a href=\"https://github.com/leanprover-community/mathlib/blob/c479d3736b98fbe1dfd580d19c7fd484b990ac4a/src/category_theory/limits/constructions/over/default.lean\">this</a> is the file)</p>",
        "id": 287180820,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655986647
    },
    {
        "content": "<p>The definition of <code>is_connected</code> should really just be that if you quotient the objects by <code>nonempty (A --&gt; B)</code>, you get a singleton. I'm not sure why we have this complicated definition instead.</p>",
        "id": 287183999,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655988437
    },
    {
        "content": "<p>Certainly connectedness really is preserved by any kind of universe lifting.</p>",
        "id": 287184055,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655988480
    },
    {
        "content": "<p>With the current complicated definition, is it really?</p>",
        "id": 287185090,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655989005
    },
    {
        "content": "<p>Yes, because it is equivalent to the simple definition</p>",
        "id": 287185978,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655989384
    },
    {
        "content": "<p>If it isn't, then it's wrong!</p>",
        "id": 287185990,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655989391
    },
    {
        "content": "<p>All these ulift constructiions should provide some equivalence of caategories, and connectedness is preserves under equivalences (the complicateed definition makes it not so bad to prove that!)</p>",
        "id": 287186499,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1655989615
    },
    {
        "content": "<p>see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_connected_of_equivalent\">docs#category_theory.is_connected_of_equivalent</a></p>",
        "id": 287186543,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1655989638
    },
    {
        "content": "<p>And I think we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_connected_of_zigzag\">docs#category_theory.is_connected_of_zigzag</a></p>",
        "id": 287186624,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1655989669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/287186543\">said</a>:</p>\n<blockquote>\n<p>see <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.is_connected_of_equivalent\">docs#category_theory.is_connected_of_equivalent</a></p>\n</blockquote>\n<p>This one only covers categories with objects in the same universe</p>",
        "id": 287186798,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655989743
    },
    {
        "content": "<p>That seems wrong...</p>",
        "id": 287186972,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1655989811
    },
    {
        "content": "<p>It's the easy case for this definition because you are eliminating into the same discrete categories</p>",
        "id": 287188538,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655990525
    },
    {
        "content": "<p>If you have different object universes then you run into what Jakob mentioned, and usually the easiest way to prove something like this is to prove equivalence to the \"predicative\" definition</p>",
        "id": 287188584,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655990557
    },
    {
        "content": "<p>Seems about right. I think the equivalence to the existence of zigzags is such a predicative definition which could be used. I'll try to go that route and see how much hassle it is to deal with lifts of zigzags <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 287190141,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655991182
    },
    {
        "content": "<p>You don't necessarily even need to deal with zigzags, you can just take a <code>quot</code></p>",
        "id": 287190379,
        "sender_full_name": "Reid Barton",
        "timestamp": 1655991277
    },
    {
        "content": "<p>With zigzags the advantage would be that the equivalence to the currrent <code>is_connected</code> is already there</p>",
        "id": 287190597,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655991357
    },
    {
        "content": "<p>Ah, I think <code>induct_on_objects</code> might be enough to prove it, still a bit messy though</p>",
        "id": 287203494,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655996629
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">[</span><span class=\"n\">is_connected</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">is_connected</span> <span class=\"o\">(</span><span class=\"n\">ulift_hom.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"n\">J</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">ulift_hom.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u₂</span><span class=\"o\">}</span> <span class=\"n\">J</span><span class=\"o\">)),</span> <span class=\"o\">{</span> <span class=\"n\">simpa</span> <span class=\"o\">[</span><span class=\"n\">ulift_hom</span><span class=\"o\">]</span> <span class=\"o\">},</span>\n  <span class=\"k\">let</span> <span class=\"n\">j₀</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">hn</span><span class=\"o\">,</span>\n  <span class=\"n\">fapply</span> <span class=\"n\">is_connected.of_induct</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">⟨</span><span class=\"n\">j₀</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">p</span> <span class=\"n\">hj₀</span> <span class=\"n\">h</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">j</span> <span class=\"k\">with</span> <span class=\"n\">j</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">p'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">J</span> <span class=\"o\">:=</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"o\">{</span><span class=\"n\">down</span> <span class=\"o\">:=</span> <span class=\"n\">j</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">J</span><span class=\"o\">),</span>\n    <span class=\"k\">have</span> <span class=\"n\">hj₀'</span> <span class=\"o\">:</span> <span class=\"n\">j₀</span> <span class=\"bp\">∈</span> <span class=\"n\">p'</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">p'</span><span class=\"o\">],</span> <span class=\"n\">exact</span> <span class=\"n\">hj₀</span> <span class=\"o\">},</span>\n    <span class=\"n\">apply</span> <span class=\"n\">induct_on_objects</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">:</span> <span class=\"n\">J</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"o\">{</span><span class=\"n\">down</span> <span class=\"o\">:=</span> <span class=\"n\">j</span><span class=\"o\">})</span> <span class=\"n\">hj₀'</span><span class=\"o\">,</span>\n    <span class=\"n\">intros</span> <span class=\"n\">j₁</span> <span class=\"n\">j₂</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">ulift_hom_ulift_category.equiv</span> <span class=\"n\">J</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">functor.map</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 287204607,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1655997140
    },
    {
        "content": "<p>Nice!</p>",
        "id": 287238844,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1656013353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/287183999\">said</a>:</p>\n<blockquote>\n<p>The definition of <code>is_connected</code> should really just be that if you quotient the objects by <code>nonempty (A --&gt; B)</code>, you get a singleton. I'm not sure why we have this complicated definition instead.</p>\n</blockquote>\n<p>My hope was that I could pick any one definition in which the universe choices were obvious then show that the others are equivalent, it would be good enough (which is eg why I didn't pick <code>of_constant_of_preserves_morphisms</code> as the definition), and then the quotient definition vs the functor definition differ only in whether you care more about a slightly more complex definition, or more things needed to define before the main definition, and I picked arbitrarily. I have no objection to switching the definition!</p>",
        "id": 287263313,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1656021212
    },
    {
        "content": "<p>In the end it doesn't matter that much, if we have all the right equivalences...</p>",
        "id": 287297937,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656055289
    },
    {
        "content": "<p>Status report (to help myself remember, too <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> ): Made some progress, now <code>category_theory.graded_object.lean</code> cannot derive an instance <code>mono (colimit.ι (discrete.functor (λ (i : β), Y i)) {as := i})</code> where before it had</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"n\">caching</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span> <span class=\"bp\">@</span><span class=\"n\">mono</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">colim</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">))</span>\n     <span class=\"n\">_</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.mk</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ulift.up</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n<span class=\"bp\">@</span><span class=\"n\">split_mono.mono</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">Y</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"o\">((</span><span class=\"bp\">@</span><span class=\"n\">colim</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">_inst_2</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">obj</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">colimit.ι</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">))</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_colimit_of_has_colimits_of_shape</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">_inst_2</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">)))</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.mk</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ulift.up</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">)))</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.split_mono_sigma_ι</span> <span class=\"o\">((</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">_x</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"n\">_inst_3</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">)</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_colimit_of_has_colimits_of_shape</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">discrete</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">category_theory.discrete_category</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"n\">_inst_2</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">))</span>\n        <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">discrete.functor</span> <span class=\"n\">C</span> <span class=\"n\">_inst_1</span> <span class=\"o\">(</span><span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ulift</span> <span class=\"n\">β</span><span class=\"o\">),</span> <span class=\"n\">Y</span> <span class=\"n\">i.down</span><span class=\"o\">)))</span>\n     <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ulift.up</span> <span class=\"n\">β</span> <span class=\"n\">i</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>and I'm still stuck at one universe conflict at <code>category_theory.sites.sheaf.lean</code>.</p>",
        "id": 287332908,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656078602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> Can you have a look at <code>locally_ringed_space/has_colimits.lean</code> on the branch? Without a universe polymorphic <code>walking_parallel_pair</code>, the argument about the locally ringed space having colimits doesn't really work the same any more, because we cannot seem to generalise <code>presheafed_space/has_colimits.lean</code> to support index categories on any other universe level than the one of the morphisms of <code>C</code>...</p>",
        "id": 287869042,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656515355
    },
    {
        "content": "<p>With the PR being at 1,080 additions and 758 deletions, there's still any help welcome! <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span></p>",
        "id": 287869735,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656515583
    },
    {
        "content": "<p>I have not yet looked into the problem, but doesn't <code>has_finite_limits_of_has_limits_of_size</code> (or some more universe-general version of it) solve the problem?</p>",
        "id": 287869999,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656515676
    },
    {
        "content": "<p>Also I would strongly suggest you to do the refactor a small portion at a time. That seems like a large diff to keep up with. Maybe one shape at a time if it is possible.</p>",
        "id": 287870278,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656515783
    },
    {
        "content": "<p>Not really possible, because the generalisation of <code>preserves_limits</code> is the big chunk that breaks everything.</p>",
        "id": 287870818,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/287869999\">said</a>:</p>\n<blockquote>\n<p>I have not yet looked into the problem, but doesn't <code>has_finite_limits_of_has_limits_of_size</code> (or some more universe-general version of it) solve the problem?</p>\n</blockquote>\n<p>No, the lies more in some auxiliary constructions from which <code>has_coequalizers</code> is derived. Since we don't want <code>walking_parallel_pair</code> to be universe polymorphic anymore, it seems this is one of the places where we <em>do</em> have to insert ulifts</p>",
        "id": 287871310,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516206
    },
    {
        "content": "<p>Is there a core statement that you want to generalize, and all the other changes are just to prevent it from breaking?</p>",
        "id": 287871538,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656516288
    },
    {
        "content": "<p>I want <code>preserves_limits</code>, <code>preserves_products</code>, etc, and co to be compatible with functors between categories of different universe levels.</p>",
        "id": 287872140,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516514
    },
    {
        "content": "<p>I do feel like I'm at least 80% to 90% through the critical files, it's mostly been straightforward fixes. The only critcal areas were sheaves and biproducts</p>",
        "id": 287872295,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516571
    },
    {
        "content": "<p>Could you not generalize the universe for each of the definitions one at a time?<br>\nNote that the original PR <a href=\"https://github.com/leanprover-community/mathlib/pull/10736\">#10736</a> that changed <code>preserves_limits</code> to <code>preserves_limits_of_shape</code> only has a diff of +208, -157.</p>",
        "id": 287872471,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656516623
    },
    {
        "content": "<p>I never fixed anything I didn't need to. The issue is that once one changes one limit over a fixed, finite index category like coequalizers, all of the others need to be changed, too.</p>",
        "id": 287872773,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516738
    },
    {
        "content": "<p>Fixing the universe level for, say, <code>walking_pair</code> would be one first PR, but it does require all the fixes that make it so tedious right now.</p>",
        "id": 287873231,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656516918
    },
    {
        "content": "<p>Is there a reason that you couldn't leave <code>presheafed_space.lean</code> alone?<br>\nSince the file should not depend on any particular shapes, it shouldn't break when the other files upstream provides strictly stronger statements?</p>",
        "id": 287873591,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656517053
    },
    {
        "content": "<p><code>presheafed_space.lean</code> itself is fine. it's <code>presheafed_space/has_colimits.lean</code> which <em>does</em> depend on a particular shape in that references coequalizers.</p>",
        "id": 287875721,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656517815
    },
    {
        "content": "<p>The file upstream is not strictly stronger because to have a maximally universe polymorphic <code>preserves_coequalizers</code> statement, we need to fix <code>walking_parallel_pair</code>s universe level and not pin it on the one of the category it's used for. This in turn causes (mostly trivial) need for fixes down the tree.</p>",
        "id": 287876375,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656518079
    },
    {
        "content": "<p>I pushed a attempt that seems to make both <code>presheafed_space/has_colimits.lean</code> and <code>locally_ringed_space/has_colimits.lean</code> both compile.</p>",
        "id": 287905874,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656530845
    },
    {
        "content": "<p>Cool, thanks a lot!!!</p>",
        "id": 287910577,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656533096
    },
    {
        "content": "<p>I think that's it, only lint errors remaining! :)</p>",
        "id": 287924589,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656536441
    },
    {
        "content": "<p>PR'ed: <a href=\"https://github.com/leanprover-community/mathlib/pull/15067\">#15067</a></p>",
        "id": 287995256,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656579409
    },
    {
        "content": "<p>So if anyone volunteers to review this, I'm happy to make it a proper interactive video call review <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 287995725,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656579674
    },
    {
        "content": "<p>So everything about finite (co)limits now happens with index categories in <code>Type</code>, right?</p>",
        "id": 287996988,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1656580265
    },
    {
        "content": "<p>And in the occasional moment where we have a finite type in a higher universe, we just have to forcefully bump it down.</p>",
        "id": 287997055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1656580310
    },
    {
        "content": "<p>Exactly. This can always be done with the equivalence to <code>finset</code>.</p>",
        "id": 287997262,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656580408
    },
    {
        "content": "<p>Will we ever need a <code>PresheafedSpace</code> valued in <code>C : Type u</code> with <code>[category.{v} C]</code> where the topological space is not in <code>Top.{v}</code>? The downside of this that we would always need to write <code>PresheafedSpace.{v}</code>.</p>",
        "id": 288166720,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1656680965
    },
    {
        "content": "<p>/cc <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span></p>",
        "id": 288225859,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656710827
    },
    {
        "content": "<p>I mean it does look like a place where in the light of topos theory etc the size matters and the universes diverges...</p>",
        "id": 288226048,
        "sender_full_name": "Jakob von Raumer",
        "timestamp": 1656710964
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/universe.20levels.20in.20preserves.20statements/near/288166720\">said</a>:</p>\n<blockquote>\n<p>Will we ever need a <code>PresheafedSpace</code> valued in <code>C : Type u</code> with <code>[category.{v} C]</code> where the topological space is not in <code>Top.{v}</code>? The downside of this that we would always need to write <code>PresheafedSpace.{v}</code>.</p>\n</blockquote>\n<p>In mathematical practice: most likely not. But sometimes Lean forces a situation on you where it might be natural to have differing universes.</p>",
        "id": 288251012,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1656740695
    },
    {
        "content": "<p>I wouldn't bother generalizing it atm.</p>",
        "id": 288251020,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1656740705
    },
    {
        "content": "<p>Jakob already generalized it, so the question is whether to un-generalize it</p>",
        "id": 288252592,
        "sender_full_name": "Markus Himmel",
        "timestamp": 1656743120
    },
    {
        "content": "<p>I think I wouldn't bother with that either <span aria-label=\"lol\" class=\"emoji emoji-1f606\" role=\"img\" title=\"lol\">:lol:</span></p>",
        "id": 288253646,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1656744935
    }
]
[
    {
        "content": "<p>If I want access to all the API of int for my brand spanking new type <code>int2</code>, a ring which I can prove is an initial object in the category of rings but which is not defeq to <code>int</code>, how can I get it? Is the idea that we should write automation like for to-additive? Somehow to-additive is the solution for X -&gt; X -&gt; X and I'm asking for a solution for the initial object? Should automation be porting all the constructions so that they apply to an arbitrary type with the right constructor and eliminator? Does one have to write different code for each constant in mathlib? When an inductive type is made, the recursor is given as an axiom and then some computer program makes about ten more functions using it, with names like mk_inj or whatever. Should other algorithms be run later on. Hey there should be a linter for checking to see that properties and definitions are canonical, in the sense that we might be explaining them for the irreducible <code>real</code> but the results remain true for any object with the right recursor (the reals are uniquely defined up to unique isomorphism by some purely topological/ring-theoretic properties).If I have <code>real2</code> and a proof that it has the right recursor, can use Lean's theory of real manifolds with my reals?</p>",
        "id": 206404616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596995089
    },
    {
        "content": "<p>This is <code>transfer</code></p>",
        "id": 206404703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596995246
    },
    {
        "content": "<p>Lean can definitely use its theory of manifolds for your type, because everything is set up for general (normed) fields :-)</p>",
        "id": 206405084,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1596995821
    },
    {
        "content": "<p>oh did I mention that my real2 has a real2-valued norm?</p>",
        "id": 206405550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596996564
    },
    {
        "content": "<p>so when do I get <code>transfer</code> in Lean? I'm now beginning to see the point of it. What are the obstructions for getting it working in Lean 3? Will Lean 4 be any different? How much of a problem is the <code>g ^ n</code> v <code>n \\bub g</code> order issue?</p>",
        "id": 206405864,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596997060
    },
    {
        "content": "<p>We need a bunch of lemmas to be marked in the library</p>",
        "id": 206405908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997087
    },
    {
        "content": "<p>I think the tactic itself works fine, although it is a bit raw</p>",
        "id": 206405917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997098
    },
    {
        "content": "<p>for example how could i get a proof of B\\'ezout's theorem for <code>int2</code>?</p>",
        "id": 206405929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596997146
    },
    {
        "content": "<p>(NB searching for Bezout without the accent gives no results in mathlib -- is this expected behaviour?)</p>",
        "id": 206405945,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596997188
    },
    {
        "content": "<p>we need better docs on the theorem, I guess</p>",
        "id": 206405987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997206
    },
    {
        "content": "<p>I think it has the very natural and obvious name of <code>gcd_eq_gcd_ab</code></p>",
        "id": 206405999,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997241
    },
    {
        "content": "<p>I think the best demo of <code>transfer</code> in mathlib right now is the derivation of lemmas about <code>num</code> using the isomorphism to <code>nat</code></p>",
        "id": 206406014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997293
    },
    {
        "content": "<p>actually that's not really true, it uses <code>transfer</code> in the abstract but it's a homegrown version</p>",
        "id": 206406068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997360
    },
    {
        "content": "<p>I recall there being a proof of <code>int</code> properties using <code>transfer</code> in core but I think it has since been replaced by an elementary proof</p>",
        "id": 206406091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596997399
    },
    {
        "content": "<p>Here's a proof of bezout's theorem for <code>int2</code> written in a way that makes the boilerplate parts obvious:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">transfer</span>\n\n<span class=\"c1\">-- this should be in the library already</span>\n<span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"n\">class</span><span class=\"o\">]</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span>\n\n<span class=\"n\">def</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">e</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">apply_symm_apply</span> <span class=\"bp\">_⟩⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">),</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h2</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- int2 is a type, suppose we have proven an equivalence to int</span>\n<span class=\"kn\">constant</span> <span class=\"n\">int2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kn\">constant</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">:</span> <span class=\"n\">int2</span> <span class=\"err\">≃</span> <span class=\"bp\">ℤ</span>\n\n<span class=\"c1\">-- and we know it is a ring and the equivalence respects the ring ops</span>\n<span class=\"c1\">-- (the ring structure may or may not be directly induced by int2.equiv, but we are proving here</span>\n<span class=\"c1\">-- that it may as well be)</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"kn\">constant</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">ring</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">int2</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_zero</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_one</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_mul</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n\n<span class=\"c1\">-- we also need a gcd function in order to state bezout</span>\n<span class=\"kn\">constant</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"o\">:</span> <span class=\"n\">int2</span> <span class=\"bp\">→</span> <span class=\"n\">int2</span> <span class=\"bp\">→</span> <span class=\"n\">int2</span>\n<span class=\"kn\">axiom</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_gcd</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"o\">(</span><span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"n\">a</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"o\">(</span><span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- surprisingly not a one liner from mathlib, but let&#39;s suppose this is somewhere</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">bezout</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">-- Here we begin the setup for transfer. The core concept is a relation between the types we</span>\n<span class=\"c1\">-- want to transfer. One natural source of transfer relations is equivs, but they can also</span>\n<span class=\"c1\">-- come from general injective / surjective functions. But equivs have the nicest properties</span>\n<span class=\"n\">def</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">int2</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv</span>\n<span class=\"kn\">instance</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_total</span> <span class=\"bp\">_</span>\n<span class=\"kn\">instance</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">:=</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span> <span class=\"bp\">_</span>\n\n<span class=\"c1\">-- Now to each equiv lemma we associate the corresponding relational lemma</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"mi\">0</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_zero</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"mi\">1</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_one</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">{{</span><span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">)</span> <span class=\"o\">{{</span><span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x&#39;</span> <span class=\"bp\">+</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_add</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"o\">{{</span><span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">)</span> <span class=\"o\">{{</span><span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x&#39;</span> <span class=\"bp\">*</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_mul</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"o\">{{</span><span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">x</span> <span class=\"n\">x&#39;</span><span class=\"o\">)</span> <span class=\"o\">{{</span><span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">}}</span> <span class=\"o\">(</span><span class=\"n\">hy</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">y</span> <span class=\"n\">y&#39;</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">x&#39;</span> <span class=\"n\">y&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_gcd</span>\n\n<span class=\"c1\">-- Finally, the proof of int2.bezout itself is performed by structural recursion on the term</span>\n<span class=\"c1\">-- (this is what the `transfer` tactic should be able to automate)</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">bezout</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">int2</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">mpr</span> <span class=\"bp\">_</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">bezout</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_forall_of_total</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">x&#39;</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span> <span class=\"c1\">-- ∀ x,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_forall_of_total</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">y</span> <span class=\"n\">y&#39;</span> <span class=\"n\">hy</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span> <span class=\"c1\">-- ∀ y,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_exists_of_total</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">a&#39;</span> <span class=\"n\">ha</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span> <span class=\"c1\">-- ∃ a,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_exists_of_total</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">b</span> <span class=\"n\">b&#39;</span> <span class=\"n\">hb</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"o\">),</span> <span class=\"c1\">-- ∃ b,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">rel_eq</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">bi_unique</span><span class=\"o\">,</span> <span class=\"c1\">-- eq</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"n\">hx</span> <span class=\"n\">hy</span> <span class=\"o\">},</span> <span class=\"c1\">-- gcd x y</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">add</span><span class=\"o\">,</span> <span class=\"c1\">-- +</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">hx</span> <span class=\"n\">ha</span> <span class=\"o\">},</span> <span class=\"c1\">-- x * a</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">mul</span> <span class=\"n\">hy</span> <span class=\"n\">hb</span> <span class=\"o\">}</span> <span class=\"o\">},</span> <span class=\"c1\">-- y * b</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206407211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1596999228
    },
    {
        "content": "<p>Is this related to <a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#equiv_rw\">tactic#equiv_rw</a> ?</p>",
        "id": 206408142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597000688
    },
    {
        "content": "<p>This takes me to a link with messed up style in duck duck go browser on Android</p>",
        "id": 206408167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597000785
    },
    {
        "content": "<p>So all the constants in the statement of the theorem, you need analogous constants in your rel machine</p>",
        "id": 206408342,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597001043
    },
    {
        "content": "<p>definitions too, although those (like <code>gcd</code>) can be proven using the same process recursively</p>",
        "id": 206408358,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001110
    },
    {
        "content": "<p>In fact this also has a great deal of similarity to (my understanding of) Cyril's parametricity tactic</p>",
        "id": 206408371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001139
    },
    {
        "content": "<p>Here's a harder one. Int has functions called things like gcd_a and gcd_b. We can use nat if you like, I don't know what's easier. But then there's a theorem that Bezout is realised by these two functions. Can we pull back these functions whilst maintaining computability and prove the corresponding theorem about int2?</p>",
        "id": 206408425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597001190
    },
    {
        "content": "<p>Are you okay with the implementation <code>e o gcd_a o e^-1</code> for <code>int2.gcd_a</code>? That will be computable if <code>e</code> is</p>",
        "id": 206408434,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001249
    },
    {
        "content": "<p>Most of the time this is not actually the definition we want, so the framework lets the user supply a separate definition for things like <code>int2.gcd_a</code></p>",
        "id": 206408474,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001288
    },
    {
        "content": "<p>but any definition will be equal to that one</p>",
        "id": 206408476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001299
    },
    {
        "content": "<p>the procedure for pulling back <code>gcd_eq_gcd_ab</code> directly instead of the existential one follows exactly the same recipe, in fact it's a bit easier since there are fewer quantifiers to deal with</p>",
        "id": 206408486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001385
    },
    {
        "content": "<p>for a purely universal formula, you can often do it by a simp set (this is what the poor-mans <code>transfer</code> in <code>data.num.lemmas</code> is doing)</p>",
        "id": 206408533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001433
    },
    {
        "content": "<p>the real power of relations shows up when you are pulling full first order formulas like <code>bezout</code> here</p>",
        "id": 206408541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001477
    },
    {
        "content": "<p>in fact you can even quantify over higher order things as long as you have a system of relations that covers all the types you want to talk about</p>",
        "id": 206408549,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001521
    },
    {
        "content": "<p>The funny arrow notation you see in the relator file (for example</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">rel_and</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"err\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"err\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">∧</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">∧</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>) is that system of relations</p>",
        "id": 206408596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001569
    },
    {
        "content": "<p>In this case <code>((↔) ⇒ (↔) ⇒ (↔))</code> is a relation that relates elements of <code>Prop -&gt; Prop -&gt; Prop</code> to itself</p>",
        "id": 206408648,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001645
    },
    {
        "content": "<p>I could have written <code>int2.rel.add</code> et al using this relator notation but it's pretty impenetrable when you see it for the first time</p>",
        "id": 206408664,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001701
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"bp\">.</span><span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"err\">⇒</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">rel</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hy</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">int2</span><span class=\"bp\">.</span><span class=\"n\">equiv_add</span>\n</code></pre></div>",
        "id": 206408726,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597001804
    },
    {
        "content": "<p>So there should be some tag which triggers an auto generation of a proof/definition which takes as input any initial object in the category of rings and spits out a theorem/definition in this int_recursor namespace?</p>",
        "id": 206408823,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597001984
    },
    {
        "content": "<p>It depends on the goal. I should look into what isabelle's <code>transfer</code> front end does</p>",
        "id": 206408886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597002085
    },
    {
        "content": "<p>For this proof, you want <code>int2.rel</code> theorems about all the constants in your theorems, but that's not general enough for <code>int3</code></p>",
        "id": 206408893,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597002119
    },
    {
        "content": "<p>the library needs to be marked up for all the transfers it is meant to support</p>",
        "id": 206408941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597002150
    },
    {
        "content": "<p>in this case, one reasonable transfer would be to go from <code>int</code> to any <code>ring</code>, and maybe the other way around under some <code>is_int</code> typeclass</p>",
        "id": 206408962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597002241
    },
    {
        "content": "<p>I see, there could be a typeclass for \"I'm an initial object in rings\" and an automated method to prove generalisations of int theorems for any object with the is_int typeclass</p>",
        "id": 206413833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597011156
    },
    {
        "content": "<p>right</p>",
        "id": 206413846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597011202
    },
    {
        "content": "<p>How would you phrase this typeclass without universe issues?</p>",
        "id": 206415754,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597014547
    },
    {
        "content": "<p>there is no universe issue</p>",
        "id": 206415766,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014581
    },
    {
        "content": "<p>it can be as simple as the assertion of a ring equiv to <code>int</code></p>",
        "id": 206415769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014594
    },
    {
        "content": "<p>Oh ok.</p>",
        "id": 206415830,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597014651
    },
    {
        "content": "<p>Well, if you take Kevin's approach there might be an issue with stating \"I'm an initial object\" if you want to do that by stating a universal property</p>",
        "id": 206415832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014658
    },
    {
        "content": "<p>I guess if it's initial with respect to universe level 0 rings, then it's initial with respect to any universe level, but that requires proof</p>",
        "id": 206415844,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597014691
    },
    {
        "content": "<p>more to the point, that requires the existence of an actual initial object in the universe in question</p>",
        "id": 206415851,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014719
    },
    {
        "content": "<p>Right</p>",
        "id": 206415892,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597014731
    },
    {
        "content": "<p>luckily lean supplies such objects using the <code>inductive</code> schema</p>",
        "id": 206415899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014746
    },
    {
        "content": "<p>so basically you can't get away from using a concrete implementation like <code>int</code></p>",
        "id": 206415905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597014760
    },
    {
        "content": "<p>I am annoyed that I can't make int without using nat. Is there a way of making int an inductive type directly? Oh -- I can make it into a quotient of an inductive type, like <code>zero : int | succ : int -&gt; int | pred : int -&gt; int</code> modulo <code>succ pred = id = pred succ</code>. Is it somehow a theorem that it cannot be an inductive type? Oh wait, I can just define it as nat can't I :-/ and then put an exotic zero and 1 and add on it.</p>",
        "id": 206497652,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597085221
    },
    {
        "content": "<p>Yes, that construction will work</p>",
        "id": 206514850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597094432
    },
    {
        "content": "<p>The problem is that int is not naturally presented as an inductive type, unlike nat</p>",
        "id": 206514984,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597094504
    },
    {
        "content": "<p>But quotients of free algebras give you quite a lot of structures. Especially if you want to show it is initial in the category of rings</p>",
        "id": 206515214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597094598
    },
    {
        "content": "<p>it's a higher inductive type <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 206515450,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597094716
    },
    {
        "content": "<p>well, I guess I had in mind the quotient of <code>int \\x int</code> which is a two-step construction</p>",
        "id": 206515652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597094820
    },
    {
        "content": "<p>but you can also naturally express it as a single higher (or quotient) inductive type</p>",
        "id": 206515701,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597094849
    },
    {
        "content": "<p>Here is some sketchy cubical agda</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">data</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">ℓ</span> <span class=\"n\">where</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n  <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">Int</span>\n  <span class=\"n\">add</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n  <span class=\"n\">neg</span> <span class=\"o\">:</span> <span class=\"n\">Int</span> <span class=\"o\">{</span><span class=\"n\">ℓ</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">Int</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">≡</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">≡</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">a</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">add</span> <span class=\"n\">zero</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">a</span>\n  <span class=\"n\">add_neg_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">neg</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">zero</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">≡</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">one</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">a</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">one</span> <span class=\"bp\">≡</span> <span class=\"n\">a</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">≡</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"o\">(</span><span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"bp\">≡</span> <span class=\"n\">add</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n  <span class=\"n\">add_compat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">add</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">≡</span> <span class=\"n\">add</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n  <span class=\"n\">mul_compat_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">c</span> <span class=\"bp\">≡</span> <span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span>\n  <span class=\"n\">mul_compat_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">mul</span> <span class=\"n\">c</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">mul</span> <span class=\"n\">c</span> <span class=\"n\">b</span>\n  <span class=\"n\">neg_compat</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">neg</span> <span class=\"n\">a</span> <span class=\"bp\">≡</span> <span class=\"n\">neg</span> <span class=\"n\">b</span>\n  <span class=\"n\">is_set</span> <span class=\"o\">:</span> <span class=\"n\">isSet</span> <span class=\"n\">Int</span>\n</code></pre></div>",
        "id": 206518948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597096989
    },
    {
        "content": "<p>But it's \"obviously\" the initial ring :)</p>",
        "id": 206519159,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597097134
    },
    {
        "content": "<p>I quite enjoyed this LICS talk on the topic <a href=\"https://www.youtube.com/watch?v=Fov95A2bGDI\">https://www.youtube.com/watch?v=Fov95A2bGDI</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Fov95A2bGDI\" href=\"https://www.youtube.com/watch?v=Fov95A2bGDI\"><img src=\"https://i.ytimg.com/vi/Fov95A2bGDI/default.jpg\"></a></div>",
        "id": 206519261,
        "sender_full_name": "Alex J. Best",
        "timestamp": 1597097205
    },
    {
        "content": "<p>Haven't seen that lecture, thanks!</p>",
        "id": 206519375,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1597097290
    }
]
[
    {
        "content": "<p>Rumor has it that an algorithm is a valid proof. Is there an example of an algorithmic proof in Lean?</p>",
        "id": 178824955,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571810499
    },
    {
        "content": "<p>we have algorithms, and proofs that they work</p>",
        "id": 178825412,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571811098
    },
    {
        "content": "<p>for example <code>gcd</code> is an algorithm</p>",
        "id": 178825473,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571811151
    },
    {
        "content": "<p>Tactics are algorithmic proofs. I would guess that <code>norm_num</code>, <code>ring</code>, <code>linarith</code> and <code>omega</code> are all good examples of proof-by-algorithm</p>",
        "id": 178901846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571868800
    },
    {
        "content": "<p>I was thinking more along the lines of... Here is a theorem and here, an algorithm (in python? since proof-irrelevance)</p>",
        "id": 178915637,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571884165
    },
    {
        "content": "<p>I don't know what that means</p>",
        "id": 178915808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571884412
    },
    {
        "content": "<p>I don't either, actually. But I have heard many times that \"Programs are proofs\" and \"Constructive Proofs are programs\" by Curry Howard. I can \"sort-of, maybe, sometimes (SMS) \" agree with constructive proofs being programs, under a lot of assumptions. But \"programs are proofs\" is a direction that I'm \"sort-of, maybe, sometimes\" wresting with. I have many working GCD algorithms (e.g. NAT, POlYNOMIALS, etc.) and I'm trying to prove them \"correct\". That is, I'm trying to prove that they fulfill a specification. The specification is \"sort-of, maybe, sometimes\" a set of logical definitions and axioms, (e.g. gcd(x,y) == gcd(y,x) )</p>\n<p>The language of the program (in this case, lisp) is irrelevant since it should be possible to translate a proof into a lambda form expressible in lisp. Given that the lambda form came from a proof with its associated definitions and axioms, it should be possible to \"prove\" the lambda form, that is, to prove the program.</p>\n<p>So the fundamental tasks are to (1) turn a gcd proof into a program and (2) to turn the program into a gcd proof. I am pondering a way to take the lowest level Lean output format into lisp.</p>\n<p>Given that this is research (aka creative reuse :-) ) I was hoping for working examples to SMS reasoning.</p>\n<p>The other working assumption is that I'm just confused but that's more of an axiom than an assumption.</p>",
        "id": 178928346,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903162
    },
    {
        "content": "<p>\"programs are proofs\" (i.e. Curry--Howard correspondence) has nothing to do with algorithmic proofs</p>",
        "id": 178928415,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1571903223
    },
    {
        "content": "<p>I'm listening. Can you give me a reference I can study?</p>",
        "id": 178928447,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903279
    },
    {
        "content": "<p>I'm sorry to tell you that by the Curry Howard isomorphism, the only thing you learn proof-wise from the existence of an algorithm in lisp is that the type of lisp s-expressions is inhabited</p>",
        "id": 178928505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903312
    },
    {
        "content": "<p>In order to get anything nontrivial out of curry howard, you need a really strong type system</p>",
        "id": 178928569,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903394
    },
    {
        "content": "<p>So a constructive proof is only evidence that the type is inhabited? Then what does it mean to \"generate program\" from ITP?</p>",
        "id": 178928619,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903413
    },
    {
        "content": "<p>Terms in lean have a \"computational interpretation\", aka an operational semantics, so you can run them</p>",
        "id": 178928651,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903457
    },
    {
        "content": "<p>Axiom has \"First Class Dynamic Types\", so I have a really strong type system.</p>",
        "id": 178928652,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903458
    },
    {
        "content": "<p>Dynamic types don't cut it</p>",
        "id": 178928672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903487
    },
    {
        "content": "<p>well, they sort of do, but you have to run the program to obtain a proof, and you only get a proof for that particular input</p>",
        "id": 178928701,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903521
    },
    {
        "content": "<p>So if I generate a lisp program using the computational interpretation then it has a corresponding proof.</p>",
        "id": 178928740,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903528
    },
    {
        "content": "<p>so you won't be able to prove <code>gcd(x,y) = gcd(y,x)</code>, only <code>gcd(3,6) = gcd(6,3)</code> and similar</p>",
        "id": 178928749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903546
    },
    {
        "content": "<p>\"You only get a proof for that particular input\"... But Axiom is symbolic so \"that particular input\" is actually a class of inputs.</p>",
        "id": 178928758,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903577
    },
    {
        "content": "<p>you presumably can't symbolically execute all code paths though</p>",
        "id": 178928776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903608
    },
    {
        "content": "<p>you might operate <em>on</em> symbolic expressions, but to prove facts about the program that is doing the manipulation you need to work a meta level above that</p>",
        "id": 178928836,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903656
    },
    {
        "content": "<p>GCD(x:NAT,y:NAT) == GCD(y:NAT,x:NAT)</p>",
        "id": 178928844,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903666
    },
    {
        "content": "<p>Have you looked at ACL2? That sounds like it bears much more relation to what you are doing than lean</p>",
        "id": 178928872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903734
    },
    {
        "content": "<p>NAT has a lot of axioms and definitions (which, in the latest Axiom I'm building) are inherited from the Categories (aka typeclasses)</p>",
        "id": 178928896,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903750
    },
    {
        "content": "<p>Yes, I've used ACL2. It isn't strong enough.</p>",
        "id": 178928953,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903786
    },
    {
        "content": "<p>Have you looked at the <code>gcd</code> function in lean, and the proof that <code>gcd x y = gcd y x</code>?</p>",
        "id": 178928980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903833
    },
    {
        "content": "<p>lean's <code>gcd</code> function is computable, it has code and you can run it on given inputs</p>",
        "id": 178928993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903872
    },
    {
        "content": "<p>I'm not really sure what you are trying to do that is not covered by this approach</p>",
        "id": 178929048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571903907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> mentioned there is a gcd proof but not which file it lives in. I haven't searched for it yet. Do you know where it lives?</p>",
        "id": 178929092,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571903995
    },
    {
        "content": "<p>Does lean's GCD work for polynomials over a field generated by its coefficients?</p>",
        "id": 178929210,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904065
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/nat/gcd.lean#L31-L34\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/data/nat/gcd.lean#L31-L34\">https://github.com/leanprover-community/mathlib/blob/master/src/data/nat/gcd.lean#L31-L34</a></p>",
        "id": 178929238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904092
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 178929322,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904133
    },
    {
        "content": "<p>That gcd is about nat, but <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/gcd_domain.lean#L166-L169\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/gcd_domain.lean#L166-L169\">this one</a> is generic</p>",
        "id": 178929346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904168
    },
    {
        "content": "<p>It seems to assume a commutative ring.</p>",
        "id": 178929364,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904206
    },
    {
        "content": "<p>We could generalize, but it's a matter of whether people care about it</p>",
        "id": 178929377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904231
    },
    {
        "content": "<p>I'm sure this is Kevin's fault for not believing that noncommutative rings exist</p>",
        "id": 178929424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904251
    },
    {
        "content": "<p>Is there a way to generate programs from Lean?</p>",
        "id": 178929435,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904273
    },
    {
        "content": "<p>lean terms <em>are</em> programs</p>",
        "id": 178929442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904283
    },
    {
        "content": "<p>if it doesn't say <code>noncomputable</code> on the definition, it has code and you can execute it</p>",
        "id": 178929453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904303
    },
    {
        "content": "<p>Let me be more specific. Can I generate code in a not-lean, general purpose programming language from lean? Or do I need to write the lean-&gt;lisp function?</p>",
        "id": 178929483,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904351
    },
    {
        "content": "<p>actually, wikipedia seems to agree that GCD domains are commutative, so it's maybe not a crazy assumption</p>",
        "id": 178929554,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904380
    },
    {
        "content": "<p>(actually, lean-&gt;Spad, which is Axiom's language)</p>",
        "id": 178929560,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904392
    },
    {
        "content": "<p>what's wrong with writing a lean-&gt;lisp function?</p>",
        "id": 178929580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904427
    },
    {
        "content": "<p>No lean doesn't support transpilers for every language</p>",
        "id": 178929598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904455
    },
    {
        "content": "<p>lean 4 supports a transpiler to C</p>",
        "id": 178929608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904473
    },
    {
        "content": "<p>A lean-&gt;lisp is perfect. Spad is a Domain-Specific Language on top of lisp specifically for mathematics.</p>",
        "id": 178929668,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904495
    },
    {
        "content": "<p>I'm saying you would have to do it yourself, but the tools to do it exist</p>",
        "id": 178929690,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904526
    },
    {
        "content": "<p>Can you give me a pointer to the transpiler? I might hack that into a lean-lisp (which ought to be somewhat easier, it seems to me, but then I'm a lisper)</p>",
        "id": 178929724,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904560
    },
    {
        "content": "<p>to C?</p>",
        "id": 178929732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904569
    },
    {
        "content": "<p>in lean 4?</p>",
        "id": 178929741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904575
    },
    {
        "content": "<p>I think it's just called a compiler and it's been a big part of the lean 4 project. See the \"counting immutable beans\" paper</p>",
        "id": 178929822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904612
    },
    {
        "content": "<p>I think you would have better success just recursing on the <code>expr</code> type and throwing away type annotations</p>",
        "id": 178929849,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904653
    },
    {
        "content": "<p>I don't want to throw away the type annotations. I'd turn them into CLOS classes, which are also lisp types, so the program could be type-checked on the lisp side.</p>",
        "id": 178929894,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904711
    },
    {
        "content": "<p>The counting paper is this? <a href=\"https://arxiv.org/pdf/1908.05647.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1908.05647.pdf\">https://arxiv.org/pdf/1908.05647.pdf</a></p>",
        "id": 178930000,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904790
    },
    {
        "content": "<p>The reference counting macro in the lean source code (which I read) is a great hack. I am impressed. Since I've written a garbage collector I could decode what was being done. </p>\n<p>Unfortunately I was reading the lean sources to get the logical CIC rules actually used in lean and I failed to reverse-engineer them from the code. Can you point me at a paper that contains the implemented rules?</p>",
        "id": 178930142,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571904929
    },
    {
        "content": "<p>Right now I think the best reference for the CIC rules used in lean is my masters thesis <a href=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\" target=\"_blank\" title=\"https://github.com/digama0/lean-type-theory/releases/tag/v1.0\">https://github.com/digama0/lean-type-theory/releases/tag/v1.0</a></p>",
        "id": 178930228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571904987
    },
    {
        "content": "<p>You won't be able to type check lean on the lisp side. It's too complicated for any simpler type system</p>",
        "id": 178930269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905072
    },
    {
        "content": "<p>Excellent. I need to implement Lean's rules in Axiom so I can use them as part of the proof machinery.</p>",
        "id": 178930273,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571905079
    },
    {
        "content": "<p>you can dynamically check it though</p>",
        "id": 178930329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905109
    },
    {
        "content": "<p>as in, lean programs should not ever call a function with an object of the wrong type</p>",
        "id": 178930343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905137
    },
    {
        "content": "<p>but unless you have a type system that is basically exactly lean's, you won't be able to prove this in advance of getting the object itself</p>",
        "id": 178930371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905172
    },
    {
        "content": "<p>Axiom's type system is well beyond anything directly coded in lisp. Axiom knows the types of everything, everywhere, at all times (dependent types) and computes them in the compiler (or it won't compile). The interpreter computes them but has heuristics because the compile-time types are undecidable.</p>",
        "id": 178930420,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571905205
    },
    {
        "content": "<p>I'm still skeptical that axiom's type system is strong enough for lean</p>",
        "id": 178930453,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905245
    },
    {
        "content": "<p>Well, there we differ. I'm certain Axiom can handle Lean. But, of course, that's my research task.</p>",
        "id": 178930496,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571905304
    },
    {
        "content": "<p>Do you have a reference for axiom's type system?</p>",
        "id": 178930502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905319
    },
    {
        "content": "<p>I'm just guessing</p>",
        "id": 178930547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905328
    },
    {
        "content": "<p>For one thing, if you can handle lean then your axiomatic framework is stronger than ZFC</p>",
        "id": 178930575,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571905377
    },
    {
        "content": "<p>Yeah, lots of papers. See Axiom's wikipedia page. Volume 10.1 Axiom Algebra: Theory has a bunch of papers. Volume 0 has a lot of examples.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)\">https://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)</a></p>",
        "id": 178930931,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571905727
    },
    {
        "content": "<p>Buchberger implemented Axiom's Groebner basis code (later proved in Coq)</p>",
        "id": 178930965,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571905767
    },
    {
        "content": "<p>I thought of trying to translate Coq's Groebner basis proof to Lean but there are a lot of issues to handle (e.g. term ordering) which have nothing to do with the issue. I have a much more modest goal of proving Axiom's 22 GCD algorithms using Lean. But I would like the proofs to \"round trip\" (spad-&gt;lean-&gt;spad).</p>",
        "id": 178931349,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906127
    },
    {
        "content": "<p>James Davenport is one of the original designers of Axiom and he is active in the proof community these dayss.</p>",
        "id": 178931461,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906227
    },
    {
        "content": "<p>I mean just the type system</p>",
        "id": 178931475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571906249
    },
    {
        "content": "<p>Axiom was designed in the late 1970s, prior to a lot of the type notation currently in use. There is no \"set of rules\", although that would make a great PhD thesis for someone who liked true agony.</p>",
        "id": 178931587,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906355
    },
    {
        "content": "<p>An expected result of my research (hmm, where is my cap and gown?) is that the CIC rules are used on the Axiom side while proving programs. That's why I was trying to reverse engineer Lean's current rule set. It really would help to include a few comments in the source code.</p>",
        "id": 178931725,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906476
    },
    {
        "content": "<p>Somehow we need to cross the \"computational mathematics\" bridge between proof tools and computer algebra. Since Axiom has an explicit scaffold of group theory (rather than general rewrite rules like Mathematica) it seems like the best bet to merge these two streams. James Davenport is the only person I've seen who is referenced in both (nearly disjoint) sets of bibliographies.</p>",
        "id": 178931856,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906611
    },
    {
        "content": "<p>If there isn't a clear statement of the axioms, I would be surprised if it was consistent</p>",
        "id": 178931934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571906666
    },
    {
        "content": "<p>It has monoid, groups, rings, fields, etc., all implemented as a hierarchy of typeclasses. I'm decorating the typeclasses with axioms and defintions and decorating the implementations (we call them domains, aka carriers and algorithms) with axioms, definitions, and lemmas. For example, NAT (which Axiom calls NonNegativeIntegers) has the usual decorations.</p>",
        "id": 178932082,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906821
    },
    {
        "content": "<p>So, like lean, when you get \"down to the code\", that is, down to proving or executing, you know a LOT about what you can assume since it is all inherited or explicitly stated.</p>",
        "id": 178932173,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906895
    },
    {
        "content": "<p>Is group theory consistent?</p>",
        "id": 178932241,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571906985
    },
    {
        "content": "<p>From what I can tell from volume 0, the type system is like Java's, it protects the most basic problems but not anything close to functional correctness</p>",
        "id": 178932331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907050
    },
    {
        "content": "<p>In particular, I see nothing that indicates that something with the Ring domain has to satisfy the axioms of a ring</p>",
        "id": 178932368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907083
    },
    {
        "content": "<p>Given that Buchberger's Groebner basis algorithm was proven in Coq and Bruno implemented it in Axiom, I suspect that it is possible to prove things like gcds.</p>",
        "id": 178932400,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907115
    },
    {
        "content": "<p>Re: \"is like Java's\"... hasty generalization. It took me several years to understand Axiom's types. It took me several years to understand CIC. So I'd guess that a 5-minute glance isn't sufficient.</p>",
        "id": 178932607,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907289
    },
    {
        "content": "<p>Then again, I'm rather slow in the uptake :-)</p>",
        "id": 178932631,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907312
    },
    {
        "content": "<p>Does the definition of a semigroup include anything about associativity? Chapter 12.6 suggests no</p>",
        "id": 178932637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907314
    },
    {
        "content": "<p>Axiom has both associative and non-associative domains.  It depends on the set of typeclasses (Axiom calls the categories) you inherit.</p>",
        "id": 178932752,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907406
    },
    {
        "content": "<p>12.7 suggests that this is \"defined by a comment\"</p>",
        "id": 178932756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907413
    },
    {
        "content": "<p>I'm saying that you can implement SemiGroup without being associative, and nothing gives you any trouble</p>",
        "id": 178932778,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907449
    },
    {
        "content": "<p>Axiom uses \"by definition\" inheritance. You have to specify what you want to inherit.  You can construct things like a Lie algebra (non-commutative). </p>\n<p>For some papers that mentions Axiom, see <a href=\"https://swmath.org/software/63\" target=\"_blank\" title=\"https://swmath.org/software/63\">https://swmath.org/software/63</a></p>",
        "id": 178932917,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907579
    },
    {
        "content": "<p>right, so I can say something wrong, like every ring is commutative, in the way that domains and categories are set up, and Axiom does not complain</p>",
        "id": 178933034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907644
    },
    {
        "content": "<p>In what sense would Lean complain, if I say that? (Of course I can't prove it. But that's a different thing, right?)</p>",
        "id": 178933077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571907698
    },
    {
        "content": "<p>that's how lean would complain</p>",
        "id": 178933092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907712
    },
    {
        "content": "<p>when you make assertions in lean, you have a proof obligation</p>",
        "id": 178933157,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907741
    },
    {
        "content": "<p>when you make assertions in axiom, it says \"okay\"</p>",
        "id": 178933165,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907752
    },
    {
        "content": "<p>which means if you want to retrofit proofs, you have a ton of proof obligations to deal with</p>",
        "id": 178933191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907796
    },
    {
        "content": "<p>Your point is that a system like Axiom needs a system like Lean, in order to prove the code correct. The inverse point is that a system like Lean needs a system like Axiom in order to make proves \"effective\".</p>",
        "id": 178933206,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907837
    },
    {
        "content": "<p>My point is that these two computational mathematics domains (proofs and computer algebra) both have 30+ year histories of ignoring each other. I'm trying to cross that divide in both directions.</p>",
        "id": 178933272,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907886
    },
    {
        "content": "<p>I think you would have a much better time trying to get axiom into lean rather than getting lean into axiom</p>",
        "id": 178933307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907929
    },
    {
        "content": "<p>all the concepts in axiom seem to have a mirror in lean, but the converse isn't true</p>",
        "id": 178933374,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571907969
    },
    {
        "content": "<p>I'm not trying to \"get one into another\". I'm trying to make them equivalent.</p>",
        "id": 178933387,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571907984
    },
    {
        "content": "<p>They are clearly not equivalent. They have different goals and are different in almost every technical detail</p>",
        "id": 178933446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908050
    },
    {
        "content": "<p>I think the best place to look for examples that straddle the \"divide\" are tactics like <code>ring</code> that do CAS algorithms in a theorem prover</p>",
        "id": 178933582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908158
    },
    {
        "content": "<p>also Rob's mathematica link, which does bidirectional translation of expressions Lean &lt;-&gt; Mathematica</p>",
        "id": 178933657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908214
    },
    {
        "content": "<p>Computational Mathematics is a subject that covers both proofs and computer algebra. So far, nobody as far as I know has \"crossed the divide\". There are examples, such as Coq's Groebner basis work, but no general convergence.</p>\n<p>I find this unacceptable and, from all I've seen, there is a merger possible. That, of course, is a research statement and is up to me to show.</p>",
        "id": 178933675,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908243
    },
    {
        "content": "<p>what constitutes \"crossing the divide\" for you?</p>",
        "id": 178933703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908272
    },
    {
        "content": "<p>I don't think general convergence is likely, because the aims are different</p>",
        "id": 178933716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908294
    },
    {
        "content": "<p>Spad programs proven using Lean's rules. Lean's use of Axiom as a trusted Oracle in proofs.</p>",
        "id": 178933726,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908317
    },
    {
        "content": "<p>The Mathematica link did that</p>",
        "id": 178933784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908345
    },
    {
        "content": "<p>I understand you don't think convergence is possible. You're not alone. That's why it is a research question.</p>",
        "id": 178933791,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908357
    },
    {
        "content": "<p>You trust Mathematica's programs in a proof step? Mathematica is a general rewrite system and is trivial to make inconsistent.</p>",
        "id": 178933831,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908397
    },
    {
        "content": "<p>It's not that I don't think it's possible, I don't think it makes sense. It's like asking if it's possible for more cars to be amphibious</p>",
        "id": 178933841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908409
    },
    {
        "content": "<p>I don't trust Axiom any more than I trust Mathematica</p>",
        "id": 178933854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908436
    },
    {
        "content": "<p>I don't think using CAS systems as an oracle is a good idea in general</p>",
        "id": 178933908,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908460
    },
    {
        "content": "<p>If you took those spad programs and just transcribe them in lean, you could prove that they are correct and they would still run just fine</p>",
        "id": 178933961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223495\">@Tim Daly</span> You should understand that we don't trust Mathematica at all when we use that link</p>",
        "id": 178933969,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571908552
    },
    {
        "content": "<p>We ask it for an answer, and for hints for the proof. But Lean still builds a formal proof.</p>",
        "id": 178933970,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571908552
    },
    {
        "content": "<p>Rob discusses the possibility of using the result as an axiom, but that's only one of several options</p>",
        "id": 178934051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908604
    },
    {
        "content": "<p>I understand your skepticism. You're not alone. Few people, as you can tell from the bibliographies, understand both domains. So if you ask proof people about proving CAS they bring out your arguments. If you ask the CAS people about Lean they have no idea how to even read the rules in the literature. At a CCNY seminar, a 40 year CAS person, when shown a proof rule asked \"what is that funny fraction?\"</p>",
        "id": 178934063,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908622
    },
    {
        "content": "<p>CAS people don't know or use formal proofs. They treat it like any other programming exercise</p>",
        "id": 178934146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908684
    },
    {
        "content": "<p>I'm all for proving CAS algorithms correct, but you should not try to build that in a world that has no idea what a proof is</p>",
        "id": 178934174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908734
    },
    {
        "content": "<p>I'm constructing the system so the compiler won't compile a program unless it proof-checks.</p>",
        "id": 178934177,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908739
    },
    {
        "content": "<p>in that case <em>you</em> need to have a formal system in mind</p>",
        "id": 178934201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908777
    },
    {
        "content": "<p>\"you should not try to build that in a world that has no idea what a proof is\".... umm, research?</p>",
        "id": 178934207,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908784
    },
    {
        "content": "<p>I have a formal proof system in mind. That's why I'm trying to get a clear statement of Lean's CIC rules. I'd think that would be the most painfully obvious thing to find on page 1 of Lean's website.</p>",
        "id": 178934282,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223495\">@Tim Daly</span> I don't follow. Why is the Mathematica link not a perfect example of what you have in mind. (Sure, it's limited in scope. But it's a start.)</p>",
        "id": 178934285,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571908837
    },
    {
        "content": "<p>When you build a proof system in an environment that wasn't expecting it, there will be a thousand ways for the system to be made inconsistent by some peculiar interaction of features</p>",
        "id": 178934297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908855
    },
    {
        "content": "<p>Even after all these years this is still a problem in HOL Light for example with Obj.magic</p>",
        "id": 178934340,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908900
    },
    {
        "content": "<p>The MMA link is fine. But you can't trust the result. Axiom's result would be proven and provide the proof as part of the response</p>",
        "id": 178934344,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908905
    },
    {
        "content": "<p>Thus Axiom's result is essentially a proven lemma you can use in the proof.</p>",
        "id": 178934408,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571908948
    },
    {
        "content": "<p>I don't see how reimplementing lean in axiom is easier than writing a translator for axiom programs into lean</p>",
        "id": 178934429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908978
    },
    {
        "content": "<p>is spad so complicated?</p>",
        "id": 178934442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571908993
    },
    {
        "content": "<p>I never said I was reimplementing lean in Axiom.</p>",
        "id": 178934448,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909002
    },
    {
        "content": "<blockquote>\n<p>The MMA link is fine. But you can't trust the result. Axiom's result would be proven and provide the proof as part of the response</p>\n</blockquote>\n<p>I definitely can trust the result when Lean says so.</p>",
        "id": 178934454,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571909008
    },
    {
        "content": "<p>If you want to implement the CIC rules in axiom, you are reimplementing lean</p>",
        "id": 178934467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909027
    },
    {
        "content": "<p>You can trust the result if Lean says so.... so if you need a groebner basis result and MMA provides an answer, you then proceed to re-prove the groebner basis algorithm in lean? Because you can't trust the MMA result as a lemma?</p>",
        "id": 178934551,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909102
    },
    {
        "content": "<p>you just need a witness in that case, so the proof is easy</p>",
        "id": 178934594,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909152
    },
    {
        "content": "<p>generating the witness is hard, proving that it works is easy</p>",
        "id": 178934645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909184
    },
    {
        "content": "<p>Can you show that the \"witness\" is a proper basis?</p>",
        "id": 178934652,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909196
    },
    {
        "content": "<p>those are generally good choices for farming out to a CAS</p>",
        "id": 178934658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909207
    },
    {
        "content": "<p>If the proof is not easy, then there was no point asking the CAS</p>",
        "id": 178934691,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909248
    },
    {
        "content": "<p>Axiom has 1100 categories and domains and 10,000+ algorithms. It would be great if Lean could use those as trusted lemmas</p>",
        "id": 178934707,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909276
    },
    {
        "content": "<p>Why? I don't trust them</p>",
        "id": 178934747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909285
    },
    {
        "content": "<p>\"Why? I don't trust them\".... hence, my point.</p>",
        "id": 178934757,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909305
    },
    {
        "content": "<p>is there a reason I should trust them?</p>",
        "id": 178934760,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909315
    },
    {
        "content": "<p>Because they provide Lean proofs with their answers</p>",
        "id": 178934769,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909332
    },
    {
        "content": "<p>that's like saying I should assume false because it makes my proof easier</p>",
        "id": 178934795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909360
    },
    {
        "content": "<p>I want a reason that they are trust<em>worthy</em>. The utility of those algorithms is not in question</p>",
        "id": 178934884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909437
    },
    {
        "content": "<p>Ok. So you don't agree that this research is worth doing as it provides no value. The CAS people don't want proofs because proofs are too hard and test cases show that the programs are correct. The two computational mathematics camps have dual arguments.</p>",
        "id": 178934892,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909451
    },
    {
        "content": "<p>I think you misunderstand me. I think that having a wide variety of CAS algorithms in Lean would be <em>very valuable</em>. But I want to not have to assume false or dubious things as the price of admission</p>",
        "id": 178934946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909516
    },
    {
        "content": "<p>Axiom's motto is \"The 30 Year Horizon\"... I'm looking out 30 years and thinking that these two streams of computational mathematics must eventually merge.</p>",
        "id": 178935011,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909540
    },
    {
        "content": "<p>As I've said, I think the best way to achieve your goals is to write a program to translate axiom algorithms into type correct computable lean terms</p>",
        "id": 178935071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909609
    },
    {
        "content": "<p>I can't rewrite 10k+ algorithms in Lean. Lean doesn't provide a language for programming that I could convince anyone to use. Axiom's Spad language is very close to the mathematics.</p>",
        "id": 178935076,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909619
    },
    {
        "content": "<p>I did something very similar with metamath. I can't rewrite 20k+ theorems from metamath, but I can write a general translator</p>",
        "id": 178935152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909687
    },
    {
        "content": "<p>I know that Axiom's GCD algorithm for NATs is correct. I just have to provide Lean with the proof.</p>",
        "id": 178935165,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909705
    },
    {
        "content": "<p>first you have to provide lean with the algorithm</p>",
        "id": 178935179,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909731
    },
    {
        "content": "<p>Actually, no.</p>",
        "id": 178935194,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909760
    },
    {
        "content": "<p>The algorithm is \"provided\" by the trusted Oracle link, along with the proof, as a lemma.</p>",
        "id": 178935352,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909882
    },
    {
        "content": "<p>There is no way someone will re-implement Bronstein's integration algorithm in lean.</p>",
        "id": 178935425,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571909946
    },
    {
        "content": "<p>Again, write a translator</p>",
        "id": 178935429,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909955
    },
    {
        "content": "<p>lisp is <em>trivially</em> easy to turn into lean terms</p>",
        "id": 178935440,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571909973
    },
    {
        "content": "<p>How can I write self-modifying code in lean?</p>",
        "id": 178935499,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910004
    },
    {
        "content": "<p>Lots of ways, but you have to get more specific</p>",
        "id": 178935531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910029
    },
    {
        "content": "<p>Heck, I'm just trying to find an algorithm in lean that is executable as a working example.</p>",
        "id": 178935573,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910076
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">length</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>       <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">length</span> <span class=\"n\">l</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">length</span> <span class=\"o\">[</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"mi\">3</span><span class=\"o\">]</span>\n<span class=\"c1\">-- 3</span>\n</pre></div>",
        "id": 178935665,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910156
    },
    {
        "content": "<p>there are tons of examples in TPIL</p>",
        "id": 178935673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910167
    },
    {
        "content": "<p>do you have a gcd example?</p>",
        "id": 178935691,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910188
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">#</span><span class=\"kn\">eval</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">gcd</span> <span class=\"mi\">3</span> <span class=\"mi\">6</span>\n<span class=\"c1\">-- 3</span>\n</pre></div>",
        "id": 178935697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910206
    },
    {
        "content": "<p>don't ask me for gcd's of polynomials</p>",
        "id": 178935717,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910230
    },
    {
        "content": "<p>suffice it to say it can be done</p>",
        "id": 178935773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910252
    },
    {
        "content": "<p>\"suffice it to say it can be done\".... and I plan to actually do it. I still have 42 months until the deadline.</p>",
        "id": 178935807,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910295
    },
    {
        "content": "<p>It can be done in far less than 42 months. If you have the algorithm in hand it should take no more than an hour</p>",
        "id": 178935852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910335
    },
    {
        "content": "<p>but if you want <em>all</em> of axiom's algorithms in lean, then you should be writing a translator</p>",
        "id": 178935921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910379
    },
    {
        "content": "<p>I plan to do it as a side-effect of constructing a system where it naturally fits. Nobody cares about a single algorithm. The GCD is only an instance of a more general convergence of proofs and computer algebra.</p>",
        "id": 178935970,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910439
    },
    {
        "content": "<p>Lean has lots of examples of algorithms. It doesn't have that one because we don't have computable polynomials</p>",
        "id": 178936069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910511
    },
    {
        "content": "<p>There are lots of other examples of CAS algorithms of similar or higher complexity, like fourier-motzkin elimination in linarith</p>",
        "id": 178936103,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910552
    },
    {
        "content": "<p>and these are validated algorithms because they run in lean, they have no trusted oracle</p>",
        "id": 178936146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910589
    },
    {
        "content": "<p>Axiom has hundreds of person-years and an estimated 42 million dollars of funding. I don't think Lean is going to see that level of support in the near future so trying to reproduce all of Axiom in Lean is a non-starter.</p>",
        "id": 178936215,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910625
    },
    {
        "content": "<p>WRITE A TRANSLATOR</p>",
        "id": 178936238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910637
    },
    {
        "content": "<p>it's waaaay less work</p>",
        "id": 178936245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910647
    },
    {
        "content": "<p>Methinks you trivialize a hard problem. But I may be wrong.</p>",
        "id": 178936273,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910683
    },
    {
        "content": "<p>it is literally the best decision I made for metamath zero</p>",
        "id": 178936284,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910699
    },
    {
        "content": "<p>I can't write 30000 proofs! but I can write a translator in a few hundred lines and boom, 30000 proofs served right up</p>",
        "id": 178936363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910747
    },
    {
        "content": "<p>and now I have a data set to do testing and benchmarking</p>",
        "id": 178936381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910770
    },
    {
        "content": "<p>Does metamath have polynomials?</p>",
        "id": 178936393,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910790
    },
    {
        "content": "<p>yes</p>",
        "id": 178936397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910794
    },
    {
        "content": "<p>it's not a CAS, so don't ask if it has gcd's of polynomials</p>",
        "id": 178936487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910847
    },
    {
        "content": "<p>so write a CAS :-)</p>",
        "id": 178936530,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571910897
    },
    {
        "content": "<p>My goal was different. My point is, when you have a huge foreign data set you want to work with, you should find a way to translate it or large parts of it rather than dealing with it one bit at a time</p>",
        "id": 178936634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571910972
    },
    {
        "content": "<p>Writing a CAS is a huge amount of work. I can write individual algorithms but never enough. It would be better if I could just import a CAS :)</p>",
        "id": 178936724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571911056
    },
    {
        "content": "<p>The \"translator\" from Spad code to lisp code is probably half a million lines</p>",
        "id": 178936982,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571911227
    },
    {
        "content": "<p>I'd rather work much closer to the mathematics.</p>",
        "id": 178937023,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571911287
    },
    {
        "content": "<p>Anyway, by Daly's Axiom: \"There is no such thing as a simple job\", ...</p>",
        "id": 178937327,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571911545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"223495\">@Tim Daly</span> It might make sense to search for \"metamath zero\" on this chat. Mario ported some really serious results to Lean that way.</p>",
        "id": 178937515,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571911741
    },
    {
        "content": "<p>Were the metamath theorems proven before they were imported?</p>",
        "id": 178937637,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571911832
    },
    {
        "content": "<p>Because if they were known to be true before they were translated then you didn't have to worry that they were false. However, a \"translator\" from untrusted code can't make that assumption.</p>",
        "id": 178937771,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571911943
    },
    {
        "content": "<p>A translator from untrusted code can still produce a term that does... something... in lean</p>",
        "id": 178940396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571914832
    },
    {
        "content": "<p>If I write a program in lean the only thing it checks is that it is type correct</p>",
        "id": 178940413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571914858
    },
    {
        "content": "<p>If I define \"type correct\" so that it is trivial then it is not hard to get lean to get out of the way</p>",
        "id": 178940457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571914887
    },
    {
        "content": "<p>So it's available in lean from the start, and executable too, but you have asserted no properties about it so it's still not much better than you started with. But now it's in lean so you can at least <em>state</em> properties of interest about these algorithms, and in principle prove them</p>",
        "id": 178940556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571914980
    },
    {
        "content": "<p>The better the translation, the more typing you can put into it, so that you have some but not all properties of interest validated at the start</p>",
        "id": 178940608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571915019
    },
    {
        "content": "<blockquote>\n<p>I have a formal proof system in mind. That's why I'm trying to get a clear statement of Lean's CIC rules. I'd think that would be the most painfully obvious thing to find on page 1 of Lean's website.</p>\n</blockquote>\n<p>The first few pages of Mario's thesis go through this.</p>",
        "id": 178944147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571918270
    },
    {
        "content": "<blockquote>\n<p>I can't write 30000 proofs! but I can write a translator in a few hundred lines and boom, 30000 proofs served right up</p>\n</blockquote>\n<p>...and this is why we can prove the prime number theorem in Lean even though no Lean person ever sat down and tried to figure out how to prove the prime number theorem in Lean :D</p>",
        "id": 178944388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1571918430
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Do you have a strategy for providing broader access to these results?</p>",
        "id": 178948594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571921873
    },
    {
        "content": "<p>I guess we don't want to make mathlib depend on these results.</p>",
        "id": 178948660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571921891
    },
    {
        "content": "<p>Is there room for some sort of <code>mathlib²</code> that depends on mathlib and also provides superpower access to results from metamath (and in the future possible other libraries)</p>",
        "id": 178948733,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571921949
    },
    {
        "content": "<p>I guess I could run the translator and push the resulting files as a lean project (separate from mathlib)</p>",
        "id": 178974168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571937067
    },
    {
        "content": "<p>and then users could import both libraries if they want</p>",
        "id": 178974211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571937103
    },
    {
        "content": "<p>Might it even be possible to set up a travis script to do it whenever e.g. <a href=\"http://set.mm\" target=\"_blank\" title=\"http://set.mm\">set.mm</a> changes?</p>",
        "id": 178975473,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1571937807
    },
    {
        "content": "<p>Is that possible? I don't think CI hooks run on anything other than commits to your own repo. I think we tried something like this for keeping core and mathlib in sync</p>",
        "id": 178976030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571938084
    },
    {
        "content": "<p>You can set up travis to run cron jobs. I think mathlib is built with 3.5.0c daily and I set up something similar to keep the community web editor up to date.</p>",
        "id": 178976697,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1571938457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> But this means that sooner or later all mathematicians will move to a <code>mathlib_2</code> project built on top of <code>mathlib</code> and <code>set.mm.lean</code>. Because once a bunch of nice results are available there, we will want to use them. And we won't bother with reproving them in a \"clean\" or \"native\" setting. I'm not sure about all the implications. Part of me thinks that this is a wonderful world, where we can just import stuff from metamath. But maybe it also leads to fragmentation? How do you feel about this yourself?</p>",
        "id": 178982496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571941864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I think that's fine; we should do what we can to make sharing knowledge between theorem provers easy</p>",
        "id": 179010962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571962642
    },
    {
        "content": "<p>If and when that becomes a big thing, we can think about better caching etc. for being able to do this scalably</p>",
        "id": 179011028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571962706
    },
    {
        "content": "<p>Originally, mathlib was designed to be the monolith that it is because of maintenance questions. It is separate from lean repo because different teams work on the two projects. There is no need for mathlib to eat all other projects, only projects that are maintained by members of the mathlib team, because these are the ones that benefit the most from the interaction between mathlib and the project. For separately maintained projects (particularly those with their own team and contribution schedule), keeping them out of mathlib is reasonable.</p>",
        "id": 179011354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1571962999
    },
    {
        "content": "<p>But fragmentation leads to abandonware and bitrot. Somehow all these other projects need to keep up with mathlib and its frequent refactors. By far the easiest way to do this is to make sure they end up as part of mathlib. This is what I'm worried about.</p>",
        "id": 179020460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1571976758
    },
    {
        "content": "<p>A bit of devil's advocate here: a good way to burn out maintainers is with drive-by pull requests :)</p>",
        "id": 179021069,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1571977850
    },
    {
        "content": "<p>my personal opinion on this topic is that giant mono-repositories that contain everything work better in corporate settings where people are paid to care about boring maintenance work</p>",
        "id": 179021197,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1571978050
    },
    {
        "content": "<p>also: if mathlib gets huge, computer science people will riot. Perhaps they want only a subset of the library, but if they want to typecheck from source, they have to do the entire thing. There will be angry GitHub issues</p>",
        "id": 179021205,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1571978099
    },
    {
        "content": "<p>both approaches have their pros and cons. i've seen both ways work in the wild...</p>",
        "id": 179021217,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1571978137
    },
    {
        "content": "<p>A \"riot\" by computer scientists? That's prime XKCD material there....The graphics designs for the protest signs alone would turn into a shed-painting exercise that would never converge.</p>",
        "id": 179024958,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571984401
    },
    {
        "content": "<p>A \"pride of lions\", a \"gaggle of geese\", a \"herd of cattle\".... and now a \"riot of computer scientists\" :-) I am SO going to squeeze this into a talk somewhere.</p>",
        "id": 179025117,
        "sender_full_name": "Tim Daly",
        "timestamp": 1571984619
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I'm reading your MetaMath Zero paper. You mentioned \"proof to the x86 architecture\".</p>\n<p>I worked in security and developed the semantics of the x86 architecture. The input is binary (since we were reverse engineering malware and need to know EXACTLY what the malware does). The output is in several formats. One format is called Conditional-Concurrent assignment (CCA). Basically it rolls a bunch of statements under a logical condition which can be combined with other conditions. If you want to ensure you're getting the right code executed you can compile your program and ask for the assembler output from my program, thus \"round-tripping\" your code.</p>\n<p>The \"Intel Instruction Semantics Generator\" (<a href=\"http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf\" target=\"_blank\" title=\"http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf\">http://daly.axiom-developer.org/TimothyDaly_files/publications/sei/intel/intel.pdf</a>) is a literate program containing both the source code and the documentation, a fair amount of which is the individual intel instruction semantics.<br>\nIt is an SEI/CERT research report I did at CMU.</p>\n<p>The x86 architecture, while widely used is, I can safely say based on my experience, rather a challenge to understand at the logical / semantics layer. It is especially challenging when you automate semantic generation. My advice to you would be to find the smallest possible subset (regardless of efficiency). Perhaps it might make sense to construct mealy / moore state machines for your logical operations and build semantics on verified versions of that.</p>",
        "id": 179109028,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572064735
    },
    {
        "content": "<p>I'm already working down to the byte level, so there is no compiler</p>",
        "id": 179109084,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572064851
    },
    {
        "content": "<p>You have my sympathy.</p>",
        "id": 179109095,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572064879
    },
    {
        "content": "<p>Certainly I do not formalize the entire x86 arch, only the part that matters to me, about 30-40 instructions out of 1800 or so (even intel can't get an accurate count)</p>",
        "id": 179109098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572064909
    },
    {
        "content": "<p>I'm not sure what CCA is; I looked it up and I get references to VHDL hardware logic</p>",
        "id": 179109140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572064944
    },
    {
        "content": "<p>which is a bit lower than I am going. I stop at the ISA level, but below that there is the micro architecture and the arrangement of logic gates, which is usually done in languages like VHDL and Verilog, and it's all closed source in Intel's case</p>",
        "id": 179109156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065026
    },
    {
        "content": "<p>If you are interested in this part of the project you should check out my MM0 + x86 talk at ITP: <a href=\"https://youtu.be/7hAShC6K_vA\" target=\"_blank\" title=\"https://youtu.be/7hAShC6K_vA\">https://youtu.be/7hAShC6K_vA</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"7hAShC6K_vA\" href=\"https://youtu.be/7hAShC6K_vA\" target=\"_blank\" title=\"https://youtu.be/7hAShC6K_vA\"><img src=\"https://i.ytimg.com/vi/7hAShC6K_vA/default.jpg\"></a></div>",
        "id": 179109205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065103
    },
    {
        "content": "<p>you have a 5000 page document? That's even larger than the intel ISA</p>",
        "id": 179109263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065215
    },
    {
        "content": "<p>\"literate\" seems like a stretch</p>",
        "id": 179109268,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065230
    },
    {
        "content": "<p>If you're working in VHDL I did some work at CMU (for a startup idea I failed to startup). I have that code around somewhere but I'm not sure it will be of interest. I used an Altera FPGA. Unfortunately, once I seriously started VHDL coding Altera was bought by Intel. The Xilinx FPGA is a different architecture. The FPGA tool sets are proprietary and I didn't have the funds or the ambition to start all over.</p>",
        "id": 179109269,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065230
    },
    {
        "content": "<p>The document is 60,000 lines of code and about 6000 pages formatted. Nobody expects to print it as it contains executable code.</p>",
        "id": 179109315,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065285
    },
    {
        "content": "<p>Latex thinks the TOC is too large, the numbers overflow</p>",
        "id": 179109324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065330
    },
    {
        "content": "<p>Beleive me, 5000 pages is small in the Intel world. The stack of x86 books makes that look like a pamphlet</p>",
        "id": 179109325,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065337
    },
    {
        "content": "<p>I assume you are trying to communicate, though...?</p>",
        "id": 179109331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065362
    },
    {
        "content": "<p>are you talking to a person or a computer? Seems like trying for both at the same time leads to two poor jobs</p>",
        "id": 179109371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065404
    },
    {
        "content": "<p>It is reasonably well organized by instruction. There are a LOT of instructions, as you've already noticed. At 1 instruction per page you already have several thousand pages.</p>",
        "id": 179109381,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065435
    },
    {
        "content": "<p>holy crap I'm 250 pages in and the TOC keeps going</p>",
        "id": 179109393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065471
    },
    {
        "content": "<p>Literate programming, like Lisp, is an \"Ah Ha! epiphany event\". You don't \"get it\" until you \"get it\" and then you wonder why other people don't \"get it\". Once you \"get it\", you never want to go back.</p>",
        "id": 179109436,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065534
    },
    {
        "content": "<p>The Intel CPU is a complex beast</p>",
        "id": 179109438,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065549
    },
    {
        "content": "<p>I found mistakes in a lot of Intel assemblers.</p>",
        "id": 179109444,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065591
    },
    {
        "content": "<p>You should look at mine then</p>",
        "id": 179109445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572065610
    },
    {
        "content": "<p>Pointer?</p>",
        "id": 179109446,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065621
    },
    {
        "content": "<p>I want to understand things like how you generate lean output.</p>",
        "id": 179109485,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065646
    },
    {
        "content": "<p>I'm also cruising the <a href=\"http://Metamath.org\" target=\"_blank\" title=\"http://Metamath.org\">Metamath.org</a> website, per your recommendation.</p>",
        "id": 179109500,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065754
    },
    {
        "content": "<p>We're not that far apart in what we are trying to do, we are just coming at it from different backgrounds (proof vs computer algebra)</p>",
        "id": 179109611,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572065998
    },
    {
        "content": "<p>x86 semantics is here -&gt; <a href=\"https://github.com/digama0/mm0/blob/master/examples/x86.mm0\" target=\"_blank\" title=\"https://github.com/digama0/mm0/blob/master/examples/x86.mm0\">https://github.com/digama0/mm0/blob/master/examples/x86.mm0</a></p>",
        "id": 179109719,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572066142
    },
    {
        "content": "<p>By the way, I just got a guffaw from your MM0 paper. Back in the day, an Axiom build from scratch used to take 3 weeks on an RS6000.</p>",
        "id": 179109721,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572066144
    },
    {
        "content": "<p>don't worry, we'll get there soon enough</p>",
        "id": 179109731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572066169
    },
    {
        "content": "<p>lean output uses the <code>mm0-hs to-lean</code> subcommand of the haskell MM0 toolchain</p>",
        "id": 179109746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572066232
    },
    {
        "content": "<p>Fortunately for me, Lisp allows runtime \"patching\".</p>",
        "id": 179109747,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572066233
    },
    {
        "content": "<p>I've been doing open source development since 1997 (the slashdot era). An Axiom \"release\" every 2 months for a large code base (&gt;1M lines) costs me about 1 week. So if you build something large and complex, expect that it will come to dominate your time. I can't even read some of the posts here. I'm not sure how one would maintain a large mathematical collection. It will become a major issue.</p>",
        "id": 179109928,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572066585
    },
    {
        "content": "<p>I tried to get stats on the AFP build time; <a href=\"https://arxiv.org/pdf/1905.07244.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1905.07244.pdf\">here</a> it says that it takes 42h of CPU time to build all of the AFP except the <code>very_slow</code> build group... it doesn't say how long these take</p>",
        "id": 179109990,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572066680
    },
    {
        "content": "<p>Build issues (like travis), server issues, merging new code, and worst of all, dealing with the fact that the operating system and compiler changed so your code no longer compiles. One also has to deal with a community that (a) knows more than you about their code and (b) has strong opinions.</p>",
        "id": 179109991,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572066694
    },
    {
        "content": "<p>Worse, since the axioms and definitions have no \"human readable\" form they are quite opaque to the great unwashed in some area (e.g. HoTT). That's where literate programming matters (but I'll let you have the epiphany on your own time :0) )</p>",
        "id": 179110039,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572066811
    },
    {
        "content": "<p>Why can't axioms and definitions have a \"human readable\" form? The mathematics is mostly standard</p>",
        "id": 179110079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572066868
    },
    {
        "content": "<p>You are deep in the religion. It took me 10 courses (some of which you attended) to be able to read pages of greek rules. I've invested about 4 years in the proof areas so far and I still struggle with Coq/Lean/Agda/Idris/Isabelle, not to mention reading ANY paper in the proof literature. As I mentioned before, a computer algebra colleague with 40 years in the computational mathematics business, asked in a seminar \"What is that funny fraction?\" when confronted with a proof rule.</p>\n<p>Believe me, unless you do this every day, a lot of it is completely opaque. I don't know who can possibly maintain it without words. The papers that get published usually only talk about \"the interesting bits\". And if you try to go back to Frege, like I did, you find his notation opaque. </p>\n<p>Axiom, which accepts normal algebra-looking equations, is considered a \"steep learning curve\". Lean is a vertical smooth wall to most people.</p>",
        "id": 179110182,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572067155
    },
    {
        "content": "<p>I took Harper's course on Cubical Type Theory and it was a real stretch for me.</p>",
        "id": 179110323,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572067457
    },
    {
        "content": "<p>Every definition, lemma, and proof should each have a paragraph of natural language and a literature hyperlink.</p>",
        "id": 179111047,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572069056
    },
    {
        "content": "<p>don't read frege, his notation is all over the place</p>",
        "id": 179111228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572069436
    },
    {
        "content": "<p>to be fair, he practically invented the idea of formal notation for logic, but it was a bit like edison's 1000 dead lightbulbs</p>",
        "id": 179111233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572069478
    },
    {
        "content": "<p>I'm looking deeply into Milawa <a href=\"http://www.cse.chalmers.se/~myreen/2015-jar-milawa.pdf\" target=\"_blank\" title=\"http://www.cse.chalmers.se/~myreen/2015-jar-milawa.pdf\">http://www.cse.chalmers.se/~myreen/2015-jar-milawa.pdf</a> for a system \"proven down to the metal\". It is particularly interesting because it takes a layered approach to the problem, aka the trusted kernel idea.</p>",
        "id": 179113831,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572074535
    },
    {
        "content": "<p>The fact that it is lisp-based is also a feature as it is easy to translate logic into lisp notation. I've written machine vision code in C++ so I can read it. But I find that the Lean C++ code is opaque. I could not find how a single logic rule was implemented. (I'm looking at your master's thesis now)</p>",
        "id": 179113897,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572074648
    },
    {
        "content": "<p>A Milawa implementation raises the possibility of using it against itself for checking.</p>",
        "id": 179113920,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572074733
    },
    {
        "content": "<p>Another long-term issue with C++ is.... which C++ \"standard\"? C++ emits a new standard every few years so the C++ you write may not compile in the future. As an example, Axiom compiles to C under the covers. One of the issues is that the C library implementation has changed which caused an amazing amount of maintenance grief. The new \"C++ standard\" will include \"concepts\" which will not compile in earlier versions. I also maintained the open source project Magnus (<a href=\"https://github.com/markuspf/magnus\" target=\"_blank\" title=\"https://github.com/markuspf/magnus\">https://github.com/markuspf/magnus</a>) which is a C++ computer algebra program that does Infinite Group Theory. Keeping that alive in C++ is a nightmare.  (Did you know that you can construct classes IN THE ARGUMENT LIST of a function definition at compile time?</p>",
        "id": 179114260,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572075393
    },
    {
        "content": "<p>as far as I'm aware, C++ has not made anything not compile that used to compile, as this is a very important aspect of the rationale for using C++ in the first place</p>",
        "id": 179114345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572075590
    },
    {
        "content": "<p>If Lean's goal is to import all of mathematics it needs a \"30 year horizon\" view, that is, it needs to be very, very maintainable.</p>",
        "id": 179114349,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572075601
    },
    {
        "content": "<p>Usually, when a compiler update causes your code to break, that means you used undefined behavior</p>",
        "id": 179114393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572075618
    },
    {
        "content": "<p>Oh, how I wish that were true.</p>",
        "id": 179114397,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572075653
    },
    {
        "content": "<p>If a compiler update breaks your code, then you probably relied on UB; but it is very well possible that a <em>standard</em> update breaks your code. Usually they try to not do that too much and have reasonable deprecation windows, but sometime breaking changes happen. For example, C++17 removed <a href=\"https://en.cppreference.com/w/cpp/memory/auto_ptr\" target=\"_blank\" title=\"https://en.cppreference.com/w/cpp/memory/auto_ptr\">std::auto_ptr</a>.</p>",
        "id": 179114576,
        "sender_full_name": "Giovanni Mascellani",
        "timestamp": 1572075972
    },
    {
        "content": "<p>On the other hand, the common lisp code from the 1980s runs unchanged and there is only 1 standard.</p>",
        "id": 179114697,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572076248
    },
    {
        "content": "<p>I've been associated with the Axiom code for nearly 40 years so I understand the issue of \"long term maintenance\". Where does Lean want to be in 40 years? Will it have 100,000 theorems, 50,000 definitions, 1/2 million lemmas, in dozens of areas of mathematics? Who, and how, is that going to be maintained?</p>",
        "id": 179114879,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572076605
    },
    {
        "content": "<p>If <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> wants all of mathematics to be written down in Lean, how is that going to be curated?</p>",
        "id": 179114946,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572076732
    },
    {
        "content": "<p>One very nice thing of MM and MM0 is that they decouple the generation and storage of proofs. You can use whatever language you fancy to create and edit proofs. Then you save them in a (rather) simple format, specified independently of any language or tool, and you are perfectly interoperable with any other proof written for the same system. I don't know much about Lean, but I believe this should be the way to go for whoever wants to store information (not just proofs) in a durable fashion.</p>\n<p>Together with durability, it also gives everybody the power to use their preferred tools and develop new tools using their preferred languages. This is pretty standard practice on the MM mailing list.</p>",
        "id": 179115284,
        "sender_full_name": "Giovanni Mascellani",
        "timestamp": 1572077231
    },
    {
        "content": "<p>Well... \"all of mathematics\" is a big reach. I think at some point <code>mathlib</code> is going to need to start picking some more precise boundaries. I think if you interpret \"all of mathematics\" as \"a strong undergradute/masters education at top maths departments\", it looks a lot more manageable.</p>",
        "id": 179115341,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077367
    },
    {
        "content": "<p>People leave projects for various reasons, such as their funding ran out, or they got a new job so they are not available for answering questions. (Several Axiom authors are dead and my Ouija skills aren't up to asking advanced math questions).</p>",
        "id": 179115342,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572077367
    },
    {
        "content": "<p>We're already a small but appreciable fraction of the way to that threshold, and it's not obvious to me that existing processes (a very public pull request process, with a gradually expanding crew of \"permission to merge\" reviewers) can't get us there.</p>",
        "id": 179115390,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077423
    },
    {
        "content": "<p>We've already seen a bit of a boundary with the external projects that have been done like flypitch</p>",
        "id": 179115394,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077446
    },
    {
        "content": "<p>ultimately I expect it to turn into something like isabelle library vs AFP</p>",
        "id": 179115404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077481
    },
    {
        "content": "<p>And we're already marking some contributions as belonging in the \"archive\" directory, rather than mathlib core.</p>",
        "id": 179115406,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077485
    },
    {
        "content": "<p>And Simon has been working on setting up a build process for \"associated projects\".</p>",
        "id": 179115411,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077503
    },
    {
        "content": "<p>Certainly anything \"research level\", if we ever get there, won't belong in mathlib. (Moving it into mathlib might be like \"someone writing the textbook\".)</p>",
        "id": 179115457,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077542
    },
    {
        "content": "<p>My undergrad mathematics courses covered material known up to about 1800. That wasn't particularly useful for maintaining code written as part of a PhD thesis (e.g. the Risch Integration algorithm, or Cylindrical Algebraic Decomposition, or Groebner bases)</p>",
        "id": 179115458,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572077544
    },
    {
        "content": "<p>most of that is target specific</p>",
        "id": 179115475,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077586
    },
    {
        "content": "<p>if you want risch integration you have a bunch of lemmas to prove that have nothing to do with anything except risch integration</p>",
        "id": 179115486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077615
    },
    {
        "content": "<p>I wasn't attempting to say that a good undergraduate education is all you need to be a useful maintainer of mathlib.</p>",
        "id": 179115487,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077618
    },
    {
        "content": "<p>HoTT is not target specific.</p>",
        "id": 179115489,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572077627
    },
    {
        "content": "<p>HoTT is closer to library level</p>",
        "id": 179115533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077662
    },
    {
        "content": "<p>HoTT is an alternative foundational choice, which mathlib has pretty explicitly disavowed at this point.</p>",
        "id": 179115534,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077666
    },
    {
        "content": "<p>I'm clearly confused about Lean's and Kevin's goals.</p>",
        "id": 179115546,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572077713
    },
    {
        "content": "<p>(It is a lovely subject, but if you're not interested in it as a foundational system, I'd say it's \"research level\"; some undergraduate do learn it --- I've taught some --- but not many.)</p>",
        "id": 179115549,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077731
    },
    {
        "content": "<p>get mathematicians doing formal maths</p>",
        "id": 179115550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077732
    },
    {
        "content": "<p>Make theorem provers actually useful to mathematicians doing research.</p>",
        "id": 179115553,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077749
    },
    {
        "content": "<p>The current mathlib library, realistically, is not going to survive a 30 year horizon. But it is a serious stress test of the design decisions of Lean, and an experiment to see if modern theorem provers can provide an environment that a mathematician can use.</p>",
        "id": 179115600,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077816
    },
    {
        "content": "<p>this is part of why kevin emphasizes definitions over theorems... theorems don't open up new areas to formalize, definitions do</p>",
        "id": 179115602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077819
    },
    {
        "content": "<p>Obviously we're not there yet --- there are a bunch of mathematicians using Lean now, but we've all invested a few years in getting up to speed, and none of us are close to being able to use it \"in our day jobs\".</p>",
        "id": 179115613,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572077850
    },
    {
        "content": "<p>I'm a mathematician (an admittedly poor one) and I'm trying to do research in computer algebra so I'm likely part of your target audience.</p>",
        "id": 179115661,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572077905
    },
    {
        "content": "<p>I just have to figure out how to archive the lean proofs in a more timeless format before the ship goes down</p>",
        "id": 179115663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572077923
    },
    {
        "content": "<p>I don't want the ship to go down. I'm looking to build my next 30 years on it.</p>",
        "id": 179115713,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572078003
    },
    {
        "content": "<p>lean 3 will not last 30 years</p>",
        "id": 179115727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078040
    },
    {
        "content": "<p>the writing is already on the wall, lean 4 exists</p>",
        "id": 179115729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078050
    },
    {
        "content": "<p>Lean 3 is hopefully dead in 2 years.</p>",
        "id": 179115734,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078063
    },
    {
        "content": "<p>Oh, boy! A new standard! Sigh.</p>",
        "id": 179115739,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572078095
    },
    {
        "content": "<p>I think the point to keep in mind is that all the current theorem provers _are really bad_. I like Lean, but because I think it's the best of a bad lot.</p>",
        "id": 179115782,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078129
    },
    {
        "content": "<p>I expect MM to survive the 30 year horizon, but lean is structurally not designed for that</p>",
        "id": 179115785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078136
    },
    {
        "content": "<p>Working on mathlib, and getting mathematicians to use it, is for the sake of helping birth theorem provers that are actually usable.</p>",
        "id": 179115790,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078159
    },
    {
        "content": "<p>There's going to be some wreckage (libraries that bite the dust...) along the way.</p>",
        "id": 179115793,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078173
    },
    {
        "content": "<p>good UI is always associated with short lifespan</p>",
        "id": 179115794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078175
    },
    {
        "content": "<p>because design has fads</p>",
        "id": 179115802,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078194
    },
    {
        "content": "<p>This isn't game programming. This is mathematics.</p>",
        "id": 179115805,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572078206
    },
    {
        "content": "<p>you would be surprised how much that matters to people</p>",
        "id": 179115806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078219
    },
    {
        "content": "<p>I do see part of Mario's point here --- the editing experience in VS Code is pretty awesome, but obviously the VS Code plugin only has a lifespan of &lt;5 years, before everyone moves on to the next best thing.</p>",
        "id": 179115851,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078261
    },
    {
        "content": "<p>look at apple products - they are known for their designs, but they only achieve that with a ridiculous release schedule</p>",
        "id": 179115852,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078295
    },
    {
        "content": "<p>And so some of the extensions we'd like (a term inspector! a graphical rewriter! typeclass resolution parsers!) all have to provide ROI on 5 year timescales.</p>",
        "id": 179115855,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078303
    },
    {
        "content": "<p>not changing means becoming dated and ugly compared to the cool new thing</p>",
        "id": 179115866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078347
    },
    {
        "content": "<p>But I also wonder if Mario means something deeper by \"good UI\" than the actual editor experience.</p>",
        "id": 179115908,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078384
    },
    {
        "content": "<p>In some sense even \"dependent type theory\" is \"good UI\".</p>",
        "id": 179115912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078399
    },
    {
        "content": "<p>It's lovely and expressive and feels like you're talking to the computer the way you actually think about things.</p>",
        "id": 179115924,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078427
    },
    {
        "content": "<p>I think eventually people will come around to my perspective that having a type theory is an editor feature</p>",
        "id": 179115925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078433
    },
    {
        "content": "<p>I once collected over 100 \"computer algebra systems\" on a DVD and gave it out at a conference. All of those projects (and tens of thousands of github/sourceforge/savannah open source projects) died when the original authors left. You're saying that Lean is going to be one of the collection of \"100 best theorem provers that died\".</p>",
        "id": 179115926,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572078442
    },
    {
        "content": "<p>.... until you discover the dependent type theory is ... hard.</p>",
        "id": 179115927,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078445
    },
    {
        "content": "<p>Well --- I was saying that I'll be happy when Lean 3 dies because Lean 4 has arrived and is better.</p>",
        "id": 179115929,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078479
    },
    {
        "content": "<p>I don't think that counts as Lean dying.</p>",
        "id": 179115972,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078500
    },
    {
        "content": "<p>they call it the product lifecycle for a reason</p>",
        "id": 179115974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078506
    },
    {
        "content": "<p>almost no software from 30 years ago is still worth using. The stuff that remains survived by being minimalistic and making that a selling point, like C</p>",
        "id": 179115985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078573
    },
    {
        "content": "<p>a long list of unix command line tools</p>",
        "id": 179115987,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078601
    },
    {
        "content": "<blockquote>\n<p>Well... \"all of mathematics\" is a big reach. I think at some point <code>mathlib</code> is going to need to start picking some more precise boundaries. I think if you interpret \"all of mathematics\" as \"a strong undergradute/masters education at top maths departments\", it looks a lot more manageable.</p>\n</blockquote>\n<p>That's basically the goal of the Xena project, and I am hoping that this is a sufficiently \"small\" goal that it will be both (a) feasible and (b) not impossible to curate. It seems to me to be a very reasonable boundary for mathlib. If you look at <a href=\"https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib\" target=\"_blank\" title=\"https://github.com/leanprover-community/lean-perfectoid-spaces/tree/master/src/for_mathlib\">the <code>for_mathlib</code> directory</a> in the perfectoid project you can see that the stuff that ends up in there is either completely foundational (e.g. lemmas on uniform spaces/with_zero/nnreal) or stuff which people meet in the 4 year MSc course at Imperial (normed spaces, polynomials, primes, submodules etc). Stuff like 3200 LOC on the theory of valuations taking values in some funny linearly ordered monoid, which is at the heart of the definition of an adic space, is not pencilled in to go in there because you have to draw a line somewhere and we certainly don't teach that to the MSc students unless they're doing a specialised project. I agree that this is an interesting long-term question.</p>",
        "id": 179116038,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572078650
    },
    {
        "content": "<p>mathematica is 30 years old, and still going pretty strong</p>",
        "id": 179116039,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078653
    },
    {
        "content": "<p>C++ too... I think the other mode is by growing continuously like a ponzi scheme</p>",
        "id": 179116052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1572078679
    },
    {
        "content": "<p>so far I would guess that ~90% of mathlib is covered in the union of \"good masters degrees\".</p>",
        "id": 179116102,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078741
    },
    {
        "content": "<p>but we're probably only at most 20% of that union. :-)</p>",
        "id": 179116104,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572078778
    },
    {
        "content": "<p>My thinking currently is \"oh look, here are a ton of young mathematicians which I have easy access to, if I go on about Lean all the bloody time then a few of them will get interested and start formalising stuff which they're seeing in lectures, and eventually there will be enough of them to make more of our degree just magically appear in mathlib\". By the way, this week I suggested writing a new 3rd year UG course on doing maths in dependent type theory and the suggestion was met with enthusiasm.</p>",
        "id": 179116212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572079002
    },
    {
        "content": "<p>Axiom was one of \"the big 3\" (Mathematica, Maple, and Axiom). Axiom was sold commercially for a while and then withdrawn and given to me. Maple was sold to a Japanese company. Mathematica still exists but there are problems. The big problem is that companies last, on average, 15 years. A second problem is that, because MMA is the primary company asset it would need to be sold rather than open sourced, as happened with Macsyma from Symbolics when they went under.</p>\n<p>Can you imagine the \"hole\" that will develop in mathematics when Mathematica is no longer available?</p>\n<p>Axiom is trying to build a long term, solid foundation for computational mathematics. While it covers areas of computer algebra it has so far neglected the proof area. The merger of these two streams of computational mathematics, to provide a stable, proven basis is the project goal. </p>\n<p>Product cycles are for games. Mathematics is forever.</p>",
        "id": 179116220,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572079043
    },
    {
        "content": "<p>I know life isn't as easy as this really, but that's the vague plan at this point. Occasionally you run into a Kenny or a Chris, and then all of a sudden you have localisation of rings or quadratic reciprocity appearing in mathlib. And one day the same thing will happen for the basic theory of differentiable functions in one real or complex variable.</p>",
        "id": 179116266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572079086
    },
    {
        "content": "<p>mathematics is not entirely forever, either. you can see the effect of \"product cycles\" in math as well, where old and clumsy ui is deprecated in favor of new and snappy ui and people using the new ui have a hard time working with the old ui. notation changes, the underlying abstractions and intuitions change, and the writing styles of papers change.<br>\nas a result, old papers can be pretty hard to read, and old results are adapted to the new ui.<br>\nitp is still relatively young and thus evolving through these cycles more quickly, especially with good ui being so important to the area. give it some time, let it evolve and maybe we will eventually be able to meet the 30 year horizon when we are sufficiently happy with the ui we've got!</p>",
        "id": 179118460,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1572083263
    },
    {
        "content": "<p>Unfortunately, mathematical software doesn't \"evolve\". People always start from scratch. As I mentioned above, there are hundreds of computer algebra systems, many started with the insight that C++ allows operator overloading so...Hey! We can do polynomials! These computer algebra systems were academic \"hand waving\" and ended up contributing nothing but papers to the field.</p>\n<p>The big systems like Mathematica, Maple, and Axiom had many people contributing in a similar style over many years. Most important is that they had a continuous stream of funding.</p>\n<p>Systems like Sage and Magnus got academic funding for a couple years. When the money ran out they ran into trouble. William Stein left the University of Washington to try to save Sage.</p>\n<p>Coq seems to have a funding stream that has continued over many years. If Lean gets enough places using it for teaching and some research mathematicians using it, then it might survive. But developing it with \"this week's game\" mindset means you can't build on the work.</p>\n<p>So my question becomes \"Is Lean going to be around in 5 years?\" Surely if we want to build a stable base that mathematicians can use both for teaching and research, we want a system that isn't going to devolve into papers.</p>\n<p>Of all the software projects I've done over the last 50 years, only the mathematics software has any sign of being \"forever\". Everything else I've written disappeared.</p>",
        "id": 179120153,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572085946
    },
    {
        "content": "<p>i don't think that we always start from scratch. you can write translators like mario did, port stuff manually like in mathlib in the past or add some sort of backwards compatibility like what has been discussed for lean 4 where lean 3 code could be imported into lean 4.</p>\n<p>sure, there's a compromise - you most certainly cannot expect users to keep up with evolution that is too frequent, and hence you need to listen to your userbase. from what i've gathered over my time here, most people would welcome a switch to lean 4 in order to fix some of the shortcomings of lean 3. i did not get the impression that lean is developed with a \"this week's game\" mindset.</p>\n<p>whether lean will be around in 5 years does not just depend on whether lean is retaining backwards compatibility, it might also depend on exactly the fact that lean is willing to evolve and cater to the needs of its users.</p>",
        "id": 179120785,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1572087275
    },
    {
        "content": "<p>With Lean 4 we are starting from scratch, right?</p>",
        "id": 179120845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087388
    },
    {
        "content": "<p>Whatever fancy things there might be, we're still starting from scratch.</p>",
        "id": 179120848,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087402
    },
    {
        "content": "<p>there was some talk here about being able to import lean 3 code into lean 4, not sure whether that is actually feasible. i'll ask sebastian when he's back from vacation ;)</p>",
        "id": 179120859,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1572087460
    },
    {
        "content": "<p>I have no real idea about when we will be able to start thinking about these question seriously.</p>",
        "id": 179120904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1572087500
    },
    {
        "content": "<p>on an unrelated note, i think it would be better to have discussions like this in #general</p>",
        "id": 179121149,
        "sender_full_name": "Marc Huisinga",
        "timestamp": 1572087854
    },
    {
        "content": "<p>Actually, I fear I sound too negative and should stop. I really like Lean and am looking at ways to use it from Axiom.</p>",
        "id": 179121453,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572088420
    },
    {
        "content": "<p>This paper might be of interest as a \"crossover\" between logic and computer algebra:<br>\nSC2: Satisfiability Checking Meets Symbolic Computation</p>",
        "id": 179124366,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572093612
    },
    {
        "content": "<p>Does Lean support first-class dependent types? The paper (<a href=\"https://arxiv.org/pdf/1102.1323.pdf\" target=\"_blank\" title=\"https://arxiv.org/pdf/1102.1323.pdf\">https://arxiv.org/pdf/1102.1323.pdf</a>) Type Classes for mathematics in type theory talked about essentially this in Coq</p>",
        "id": 179162464,
        "sender_full_name": "Tim Daly",
        "timestamp": 1572167202
    },
    {
        "content": "<p>Yes.</p>",
        "id": 179168399,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1572178134
    }
]
[
    {
        "content": "<p>Do we have the notion of a <em>fundamental system of neighborhoods of 0</em> for topological groups?</p>",
        "id": 135166983,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538652273
    },
    {
        "content": "<p>This would be a basis for the filter <code>nhds 0</code>, right? Or are you asking for more?</p>",
        "id": 135171190,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538656202
    },
    {
        "content": "<p>It probably is. I just don't know enough about filters to be sure...</p>",
        "id": 135171928,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538656500
    },
    {
        "content": "<p>I read some blog post about filters recently. Here are two examples of filters on a topological space X. Choose x in X. Then (1) the set of all subsets of X containing x is a filter (the principal filter). But much more interesting (2) the set of all subsets V of X such that x is in the interior of V -- this is also a filter. This is the filter of neighbourhoods of x and it comes up a lot. For example one can formalise the notion that a map of topological spaces f:X -&gt; Y is continuous at a point x using this neighbourhood filter (more naive attempts at a definition, such as \"pre-image of an open set containing f(x) is open\" are hopelessly poorly behaved and wrong; the filter language is perfect for this). If F is a filter and V is in F then any set containing V is also in F, so you could imagine a filter being generated by a subset and the construction basically being that you throw in any set that contains one of your basis sets; if your basis is well-behaved then this will be a filter. I think this is the notion you want. Any V whose interior contains 0 will contain as a subset some element of your fundamental system.</p>",
        "id": 135173055,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538656933
    },
    {
        "content": "<p>Ok, so I want to write <code>(nhds 0) = \"the smallest filter containing {myset}\"</code>. Is that right?</p>",
        "id": 135173763,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538657192
    },
    {
        "content": "<p>That would mean that <code>{myset}</code> is a fundamental system of neighbourhoods around 0.</p>",
        "id": 135173818,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538657213
    },
    {
        "content": "<p>I think that's right. It probably goes something like this (and you could easily check in Lean!) If B is a bunch of subsets of X (maybe B has to be non-empty), and if the intersection of any two elements of B contains an element of B, then I think that the set F of all subsets of X with the property that they contain an element of B, should be a filter. I'm thinking of B as a fund system of nhds of x and <code>F = nhds x</code>. Hopefully someone will correct me if I've missed something.</p>",
        "id": 135174187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538657340
    },
    {
        "content": "<p>I'm pretty sure that arbitrary intersection of filters is a filter, so one can always look at the filter generated by a random collection of subsets of X, but in the basis case it's simpler because you only have to look at sets containing a basis element, rather than sets containing a finite intersection of basis elements. These were just my thoughts after reading the definition, I don't know some reference where this is all treated succinctly and clearly, although I would imagine that there will be one somewhere.</p>",
        "id": 135174575,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538657469
    },
    {
        "content": "<p>The smallest filter containing <code>s</code> is <code>filter.generate s</code> (<a href=\"https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241\">https://github.com/leanprover/mathlib/blob/master/order/filter.lean#L241</a>)</p>",
        "id": 135174585,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538657473
    },
    {
        "content": "<p>But it would be easier to prove stuff about the smallest filter containing s if s had some nice properties to start with, because then you wouldn't need all the cases in the inductive definition.</p>",
        "id": 135174787,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538657535
    },
    {
        "content": "<p>Note that the order on filter is flipped, i.e. the arbitrary set-intersection of the sets of filters is the supremum on filters.</p>",
        "id": 135174846,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538657553
    },
    {
        "content": "<p>Thanks Johannes for that important reminder! I'm sure there's some logic to it but it always makes me very nervous about filters. There is I think both top and bottom filters, but I am always a bit confused about whether the empty set is allowed to be an element of a filter, and whether the empty collection is a filter. Conventions maybe differ in different places?</p>",
        "id": 135175198,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538657660
    },
    {
        "content": "<p>In particular I never seem to know what is top and bot :-)</p>",
        "id": 135175242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538657675
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102\">https://github.com/leanprover-community/mathlib/blob/completions/analysis/topology/topological_groups.lean#L102</a></p>",
        "id": 135175587,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1538657774
    },
    {
        "content": "<p>the empty set is not a filter, the filter containing the empty set is the bottom filter</p>",
        "id": 135175922,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538657876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Why do you ask <code>pure 0 ≤ Z</code>? Why not equality?</p>",
        "id": 135176397,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658004
    },
    {
        "content": "<p>I've got the very ugly</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">generate</span> <span class=\"o\">{</span><span class=\"n\">U&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">,</span> <span class=\"n\">U&#39;</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}}</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 135176446,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658016
    },
    {
        "content": "<p>Note that if a filter contains the empty set then it contains all sets, and because of this backwards convention this is the one at the bottom</p>",
        "id": 135176459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1538658020
    },
    {
        "content": "<p>I hope that is the same thing as: <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><msup><mi>U</mi><mi>n</mi></msup><mi mathvariant=\"normal\">∣</mi><mi>n</mi><mo>≥</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{ U^n | n \\ge 1 \\}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">{</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.10903em;\">U</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span><span class=\"mord mathrm\">∣</span><span class=\"mord mathit\">n</span><span class=\"mrel\">≥</span><span class=\"mord mathrm\">1</span><span class=\"mclose\">}</span></span></span></span> forms a neighbourhood basis of <code>0</code>.</p>",
        "id": 135176522,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658042
    },
    {
        "content": "<p><code>Z</code> is supposed to be the neighborhood filter around <code>0</code>. <code>Z = pure 0</code> would be wrong, it would result in the discrete topology.</p>",
        "id": 135177578,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538658366
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> there are some rules to work with <code>generate</code>. The best is to use <code>le_antisymm</code>, one side is reduced with <code>sets_iff_generate </code> to the inclusion that all generated elements are neighborhoods. For the other direction it depends on your topology which base element you can select</p>",
        "id": 135178743,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538658714
    },
    {
        "content": "<p>Hmm, I'll have to try and figure out if I can make sense of that.</p>",
        "id": 135179271,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658854
    },
    {
        "content": "<p>I need to prove</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">tfae_i_to_ii</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">U</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span> <span class=\"bp\">∧</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"n\">T</span> <span class=\"bp\">∧</span>\n<span class=\"o\">(</span><span class=\"n\">filter</span><span class=\"bp\">.</span><span class=\"n\">generate</span> <span class=\"o\">{</span><span class=\"n\">U&#39;</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">pnat</span><span class=\"o\">,</span> <span class=\"n\">U&#39;</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"err\">^</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">}}</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">nhds</span> <span class=\"mi\">0</span><span class=\"o\">))</span> <span class=\"bp\">∧</span>\n<span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">∧</span>\n<span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">t</span> <span class=\"bp\">*</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"err\">⊆</span> <span class=\"n\">U</span><span class=\"o\">)</span> <span class=\"bp\">→</span>\n<span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">A₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_subring</span> <span class=\"n\">A₀</span><span class=\"o\">],</span> <span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_ring_of_definition</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">Tsub</span><span class=\"o\">,</span> <span class=\"n\">Tfin</span><span class=\"o\">,</span> <span class=\"n\">hnhds</span><span class=\"o\">,</span> <span class=\"n\">hTU</span><span class=\"o\">,</span> <span class=\"n\">hU2</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 135179296,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658861
    },
    {
        "content": "<p>It looks really scary</p>",
        "id": 135179311,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538658867
    },
    {
        "content": "<p>Uh, the <code>haveI</code> is super ugly. One more reason to not use type classes too often...<br>\nI think I would prefer if you use <code>@is_ring_of_definition ...</code></p>",
        "id": 135180278,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659139
    },
    {
        "content": "<p>Hmm... we should just have bundled subrings (-;</p>",
        "id": 135180692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659247
    },
    {
        "content": "<p>also an option</p>",
        "id": 135180717,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659256
    },
    {
        "content": "<p>what is <code>is_ring_of_definition</code>?</p>",
        "id": 135180743,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659266
    },
    {
        "content": "<p>Also nasty (-;</p>",
        "id": 135180784,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659277
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_ring_of_definition</span> <span class=\"o\">(</span><span class=\"n\">A₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_open</span> <span class=\"n\">A₀</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hJ</span> <span class=\"o\">:</span> <span class=\"n\">is_ideal</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">gen</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A₀</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">finite</span> <span class=\"n\">gen</span> <span class=\"bp\">∧</span> <span class=\"n\">span</span> <span class=\"n\">gen</span> <span class=\"bp\">=</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"bp\">∧</span>\n<span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">topological_subring</span> <span class=\"n\">A₀</span><span class=\"bp\">;</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hJ</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_ideal_adic</span> <span class=\"n\">J</span><span class=\"o\">))</span>\n</pre></div>",
        "id": 135180942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659323
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">is_ideal_adic</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_ideal</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">is_open</span> <span class=\"o\">(</span><span class=\"n\">pow_ideal</span> <span class=\"n\">J</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">is_open</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">pow_ideal</span> <span class=\"n\">J</span> <span class=\"n\">n</span> <span class=\"err\">⊆</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_adic</span> <span class=\"o\">(</span><span class=\"n\">A₀</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">A₀</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A₀</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">hJ</span> <span class=\"o\">:</span> <span class=\"n\">is_ideal</span> <span class=\"n\">J</span><span class=\"o\">],</span>\n<span class=\"o\">(</span><span class=\"k\">by</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">topological_subring</span> <span class=\"n\">A₀</span><span class=\"bp\">;</span> <span class=\"n\">haveI</span> <span class=\"o\">:=</span> <span class=\"n\">hJ</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">is_ideal_adic</span> <span class=\"n\">J</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 135181044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659347
    },
    {
        "content": "<p>But, I'm not looking for help with the maths. I'm just wondering how the assumptions could be formulated in a nicer way.</p>",
        "id": 135181605,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659507
    },
    {
        "content": "<p>Should we put a <code>has_mul</code> on <code>set A</code> if <code>A</code> has <code>has_mul</code>?</p>",
        "id": 135181690,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659536
    },
    {
        "content": "<p>if <code>set A</code> is a monoid, then I could just write <code>U^n</code> and <code>T * U</code>.</p>",
        "id": 135181830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659571
    },
    {
        "content": "<p>First thing: I wouldn't use the existential quantifier in the assumption, have all the things in there directly as assumption</p>",
        "id": 135182127,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659654
    },
    {
        "content": "<p><code>{y : A | ∃ (t ∈ U) (u ∈ U), y = t * u} = (*) &lt;$&gt; U &lt;*&gt; T</code></p>",
        "id": 135182221,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659681
    },
    {
        "content": "<p>Hmm, in fact it is an iff, but I only stated one implication.</p>",
        "id": 135182274,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659688
    },
    {
        "content": "<p><code>(*) &lt;$&gt; T &lt;*&gt; U = (*) &lt;$&gt; U &lt;*&gt; U ∧ (*) &lt;$&gt; U &lt;*&gt; U ⊆ U</code></p>",
        "id": 135182389,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659731
    },
    {
        "content": "<p>Not sure if that improves readability.... what do you think of my <code>monoid (set A)</code> suggestion?</p>",
        "id": 135182531,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659770
    },
    {
        "content": "<p>The <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> are from the applicative functor structor on <code>set</code>. Their function is to lift arbitrary functions to sets.</p>",
        "id": 135182577,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659787
    },
    {
        "content": "<p>I don't think a random mathematician will care about that. When they read Kevin's perfectoid paper, they will want to see code that they roughly understand</p>",
        "id": 135182755,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538659824
    },
    {
        "content": "<p>you can certainly add the <code>monoid (set A)</code> locally. I'm not sure if we want to have this setup generally</p>",
        "id": 135182974,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1538659890
    },
    {
        "content": "<p>Ooh, this is nice. I know the mathematicians here are going to freak, but I really like that the CS version of abstract nonsense has given us a way to easily talk about lifting functions to sets like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>S</mi><mo>+</mo><mi>T</mi></mrow><annotation encoding=\"application/x-tex\">S + T</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.05764em;\">S</span><span class=\"mbin\">+</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span></span></span></span></p>",
        "id": 135193215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538664009
    },
    {
        "content": "<p>What does \"Ooh, this is nice\" mean? As in: just use it, even if it is completely unreadable?</p>",
        "id": 135193942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538664631
    },
    {
        "content": "<p>Basically yes. Treat it like an idiom or set phrase to say this</p>",
        "id": 135194347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538664943
    },
    {
        "content": "<p>When Simon first showed me the <code>f &lt;$&gt; x &lt;*&gt; y</code> idiom for applying functions to monadic values I was mystified, but now I quite like it since it looks so much like regular function application</p>",
        "id": 135194459,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665030
    },
    {
        "content": "<p>(It is equivalent to the monadic block <code>do a &lt;- x, b &lt;- y, return (f a b)</code>)</p>",
        "id": 135194503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665081
    },
    {
        "content": "<p>Until I saw this thread I thought that we would basically have to define a function <code>lift2 f A B</code> for doing this, and it would be even less nice to read</p>",
        "id": 135194647,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665188
    },
    {
        "content": "<p>What is wrong with the <code>monoid</code> instance?</p>",
        "id": 135194792,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1538665281
    },
    {
        "content": "<p>That said, there are also other semi-slick ways of talking about this, like <code>uncurry (+) '' (A × B)</code></p>",
        "id": 135194816,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665301
    },
    {
        "content": "<p>Well, it doesn't generalize as much as this</p>",
        "id": 135194901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665356
    },
    {
        "content": "<p>It may also cause a problem when we have a conflicting meaning for multiplication of sets</p>",
        "id": 135194967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665422
    },
    {
        "content": "<p>I think <code>has_sub</code> has a conflict</p>",
        "id": 135195018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1538665449
    }
]
[
    {
        "content": "<p>I'd like to present my first attempt at a contribution to mathlib. It is the definition of the <a href=\"https://en.wikipedia.org/wiki/Borel_hierarchy#Boldface_Borel_hierarchy\">Borel hierarchy</a> plus some API around it. You can find it (with a bunch of nonsensical garbage in the repo history) <a href=\"https://github.com/sterraf/mylearninglean/blob/main/src/borel_hierarchy.lean\">here</a>.</p>\n<p>The linked theory may serve as a refactor of Gouëzel's formalization of the cardinality bound for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>σ</mi></mrow><annotation encoding=\"application/x-tex\">\\sigma</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">σ</span></span></span></span>-algebras <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_space.cardinal_generate_measurable_le/src\">src#measurable_space.cardinal_generate_measurable_le</a> . I reproved the main theorems in this file using my definitions---from lines 450 onward statements and proofs follow that same file closely.  </p>\n<p>One of the main differences is that I have used unions, suprema, etc., indexed by ordinals (as it is customary in the literature) instead of using representatives. Accordingly, the notation <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>ω</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">\\omega_1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5806em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">ω</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3011em;\"><span style=\"top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is introduced for the <em>ordinal</em> <code>(aleph 1).ord</code> and not for <code>(aleph 1).ord.out.α</code>.</p>\n<p>A brief implementation note: I defined the <em>pair</em> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><msubsup><mi mathvariant=\"normal\">Σ</mi><mi>α</mi><mn>0</mn></msubsup><mo separator=\"true\">,</mo><msubsup><mi mathvariant=\"normal\">Π</mi><mi>α</mi><mn>0</mn></msubsup><mo stretchy=\"false\">⟩</mo></mrow><annotation encoding=\"application/x-tex\">\\langle\\Sigma^0_\\alpha, \\Pi^0_\\alpha\\rangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-2.453em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.0037em;\">α</span></span></span><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mclose\">⟩</span></span></span></span> by recursion on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span></span></span></span>, as suggested by Kevin <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310503644\">here</a>. I couldn't figure out how to use the more elegant inductive definitions suggested by <a href=\"#narrow/stream/217875-Is-there-code-for-X.3F/topic/ordinals.20and.20induction/near/310513474\">Junyan Xu</a> in the same thread.</p>\n<p>I'd like to hear any comments to enhance the code, in order to prepare a PR. Thanks to all for your help in the past weeks, in particular <span class=\"user-mention\" data-user-id=\"464202\">@Felix Weilacher</span> for some discussions about which were the possible directions the formalization of Descriptive Set Theory could go.</p>",
        "id": 315011158,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670635188
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327749\">@Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously (where <code>ff : bool</code> corresponds to your <code>S</code> and <code>tt</code> corresponds to <code>P</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">set_theory.cardinal.continuum</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">bool</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">basic</span> <span class=\"o\">(</span><span class=\"n\">u</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"mi\">0</span> <span class=\"n\">u</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">empty</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"mi\">0</span> <span class=\"bp\">∅</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">univ</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"mi\">0</span> <span class=\"n\">set.univ</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">compl</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">i</span> <span class=\"n\">u</span> <span class=\"n\">ff</span> <span class=\"bp\">→</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">i</span> <span class=\"n\">u</span><span class=\"bp\">ᶜ</span> <span class=\"n\">tt</span>\n<span class=\"bp\">|</span> <span class=\"n\">union</span> <span class=\"o\">{</span><span class=\"n\">i</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">ordinal.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span>\n    <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"n\">n</span> <span class=\"bp\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">tt</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">ff</span>\n</code></pre></div>\n<p>BTW, <code>nonempty_compl_equiv</code> can be proved using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set.image\">docs#equiv.set.image</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/compl_injective\">docs#compl_injective</a>.</p>",
        "id": 315028571,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670651802
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.image\">docs#equiv.image</a> combined with <del> <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.compl\">docs#equiv.compl</a> </del> is a better spelling that's computable (edit: that doesn't seem to work)</p>",
        "id": 315057065,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1670669554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315028571\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"327749\">Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously (where <code>ff : bool</code> corresponds to your <code>S</code> and <code>tt</code> corresponds to <code>P</code>):</p>\n</blockquote>\n<p>Thank you very much, I'll give it a try.</p>",
        "id": 315057529,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670669744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315028571\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"327749\">Pedro Sánchez Terraf</span> Here's how you might define the Sigma and Pi hierarchies inductively and simultaneously <br>\n[...]<br>\nBTW, <code>nonempty_compl_equiv</code> can be proved using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.set.image\">docs#equiv.set.image</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/compl_injective\">docs#compl_injective</a>.</p>\n</blockquote>\n<p>I did the second thing and recovered all the main theorems using this alternative definition. The results are <a href=\"https://github.com/sterraf/mylearninglean/blob/cbef1dac20e3cec8d763ae5868726d0b44d7ec1f/src/borel_hierarchy.lean\">here</a>. Nevertheless, working with this alternative definition was more difficult for me, and the new proofs are much longer, having to use extensionality where there was no need before. Most surely I'm missing some tricks, or guidelines to set up an API to make my life easier.</p>\n<p>For instance, I could not recover my lemma <a href=\"https://github.com/sterraf/mylearninglean/blob/cbef1dac20e3cec8d763ae5868726d0b44d7ec1f/src/borel_hierarchy.lean#L209\">sigma0_one</a> (commented out in the file linked above). One particular problem I have is that working on this goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">z</span> <span class=\"bp\">∈</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"mi\">1</span> <span class=\"n\">ff</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">})),</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">z</span>\n</code></pre></div>\n<p>I can't use<code>cases h</code>. The culprit seems to be that the ordinal <code>1</code> does not appear in the inductive definition. The error reads:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">cases</span> <span class=\"n\">tactic</span> <span class=\"n\">failed</span><span class=\"o\">,</span> <span class=\"n\">unsupported</span> <span class=\"n\">equality</span> <span class=\"n\">between</span> <span class=\"n\">type</span> <span class=\"n\">and</span> <span class=\"n\">constructor</span> <span class=\"n\">indices</span>\n<span class=\"o\">(</span><span class=\"n\">only</span> <span class=\"n\">equalities</span> <span class=\"n\">between</span> <span class=\"n\">constructors</span> <span class=\"n\">and</span><span class=\"bp\">/</span><span class=\"n\">or</span> <span class=\"kd\">variables</span> <span class=\"n\">are</span> <span class=\"n\">supported</span><span class=\"o\">,</span> <span class=\"n\">try</span> <span class=\"n\">cases</span> <span class=\"n\">on</span> <span class=\"n\">the</span> <span class=\"n\">indices</span><span class=\"o\">):</span>\n<span class=\"n\">quot.mk</span> <span class=\"n\">setoid.r</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">punit</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">empty_relation</span> <span class=\"n\">punit</span><span class=\"o\">,</span> <span class=\"n\">wo</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span> <span class=\"bp\">=</span>\n  <span class=\"n\">quot.mk</span> <span class=\"n\">setoid.r</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">pempty</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">empty_relation</span> <span class=\"n\">pempty</span><span class=\"o\">,</span> <span class=\"n\">wo</span> <span class=\"o\">:=</span> <span class=\"n\">_</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>I'm unable to understand the hint of “trying cases on the indices”. I also tried to use the internal lemmas that arise from the inductive definition, like <code>pointclasses.sigma0_pi0_rec.cases_on</code>, which I can correctly check for type but I can not invoke it using <code>apply</code> inside the proof.</p>",
        "id": 315233441,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670778666
    },
    {
        "content": "<p>Ah because the <code>1</code> is an <code>ordinal</code>.<br>\nProbably you could use <code>generalizing</code> somehow to replace it by a variable, together with a hypothesis that it's equal to <code>1</code>, and then use a lemma to eliminate some impossible cases.</p>",
        "id": 315234936,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670779422
    },
    {
        "content": "<p>Looks like another proof growing longer... I'll check it</p>",
        "id": 315235133,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670779550
    },
    {
        "content": "<p>But, <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> , <code>generalizing</code> is part of an <code>induction</code> tactic, isn't it? But here I have the inductive thing in my hyps, not in my target.</p>",
        "id": 315235303,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670779651
    },
    {
        "content": "<p>Oh sorry, I meant <code>generalize</code></p>",
        "id": 315235331,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670779669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315235331\">said</a>:</p>\n<blockquote>\n<p>Oh sorry, I meant <code>generalize</code></p>\n</blockquote>\n<p>Again, it seems that this tactic only operates on the target. It was <code>generalize_hyp</code> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n<p>EDIT: ... that didn't work either since it forgets that the new variable has value <code>1</code>. I think there was a tactic that did exactly what you are suggesting, but I'm not sure. I'll do it by hand.</p>\n<p>EDIT 2:... It was rather circuitous in the end:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">set</span> <span class=\"n\">o</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">)</span> <span class=\"k\">with</span> <span class=\"n\">ho</span><span class=\"o\">,</span>\n<span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">o</span> <span class=\"n\">ff</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n<span class=\"o\">{</span> <span class=\"n\">tauto</span> <span class=\"o\">},</span>\n<span class=\"n\">clear_value</span> <span class=\"n\">o</span><span class=\"o\">,</span> <span class=\"c1\">-- needed!</span>\n</code></pre></div>\n<p>Only then I could use <code>cases</code> . Surely there is a better way <span aria-label=\"cry\" class=\"emoji emoji-1f622\" role=\"img\" title=\"cry\">:cry:</span></p>",
        "id": 315235978,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670779951
    },
    {
        "content": "<p><code>induction h</code> apparently works. Seems <code>cases</code> is trying to too many things at once.</p>",
        "id": 315241578,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670782961
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315241578\">said</a>:</p>\n<blockquote>\n<p><code>induction h</code> apparently works. Seems <code>cases</code> is trying to too many things at once.</p>\n</blockquote>\n<p>I'm <a href=\"https://github.com/sterraf/mylearninglean/blob/72a22e9799aeee19435bba4c14c8a18a7f25744a/src/borel_hierarchy.lean\">done</a>, but I'll try that too. This is unexpected for me, since I thought that tactic was used only when have the inductive object on the target.</p>",
        "id": 315242031,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670783225
    },
    {
        "content": "<p>It's an inductive predicate (inductive family of propositions), so if you do <code>induction</code> on it it will enumerate all possible ways to construct a term of type, i.e. a proof of the proposition, with appropriate inductive hypothesis added to the context (which <code>cases</code> doesn't do).</p>",
        "id": 315243464,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670783944
    },
    {
        "content": "<p>Does it add a hypothesis like <code>0 = 1</code> for the first three cases?</p>",
        "id": 315244118,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670784325
    },
    {
        "content": "<p>No.<br>\nActually, the application of <code>induction</code> succeeds here, but finally I'm stuck again because without the info that the argument was <code>1</code> is lost. Therefore, one of the proof obligations requires me to prove certain closure under complements that is not true (it would if I was proving something general,  but not in this case).</p>",
        "id": 315244510,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670784601
    },
    {
        "content": "<p>To make things clear: What I've been trying is <code>induction h with ...</code>, but now I see there is a different <code>induction h : t</code> which I didn't check before.</p>",
        "id": 315244857,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670784820
    },
    {
        "content": "<p>Yeah I was too optimistic when I said <code>induction</code> works. I can't seem to make it work nicely. <code>ordinal</code> isn't an inductive type so it's not good to do pattern matching on <code>0 : ordinal</code>, but even if I replace the constructors by <code>| empty (i = 0) : sigma0_pi0_rec i tt ∅</code>, <code>induction</code> still doesn't keep the original <code>1</code> but generalizes <code>1</code> to an arbitrary ordinal, which is bad. So the inductive definition apparently doesn't work as nicely as expected, and makes me wonder whether we should just fall back to your original definition by well-founded recursion.</p>",
        "id": 315246498,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670785695
    },
    {
        "content": "<p>Yeah, I've seen some other awful behavior, like an awkward expansion of the definition of <code>0</code>. Some of that can be seen in the last error message I pasted <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315233441\">above</a>, but even in the Infoview at line <a href=\"https://github.com/sterraf/mylearninglean/blob/72a22e9799aeee19435bba4c14c8a18a7f25744a/src/borel_hierarchy.lean#L131\">131 of the file</a>, hypothesis <code>glt</code> <span aria-label=\"puke\" class=\"emoji emoji-1f92e\" role=\"img\" title=\"puke\">:puke:</span></p>",
        "id": 315247048,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786048
    },
    {
        "content": "<p>Maybe worth trying <code>induction'</code> as well?</p>",
        "id": 315247113,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670786110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315246498\">said</a>:</p>\n<blockquote>\n<p>So the inductive definition apparently doesn't work as nicely as expected, and makes me wonder whether we should just fall back to your original definition by well-founded recursion.</p>\n</blockquote>\n<p>Haha none of the options work smoothly for me, but the original was apparently more amenable to the standard tactits (at least the ones I remember of the top of my head). Anyway, I did this at another branch, so the original is still alive and kicking.</p>",
        "id": 315247294,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247113\">said</a>:</p>\n<blockquote>\n<p>Maybe worth trying <code>induction'</code> as well?</p>\n</blockquote>\n<p>Is that Lean4?</p>",
        "id": 315247369,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786280
    },
    {
        "content": "<p>Or something from the last 3 months? Didn't update mathlib3 since then.</p>",
        "id": 315247459,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786336
    },
    {
        "content": "<p>Maybe I can rescue the inductive approach by proving the desired induction principle separately and use that instead of the <code>induction</code> tactic ...</p>",
        "id": 315247599,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670786426
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#induction'\">tactic#induction'</a></p>",
        "id": 315247669,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670786492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247599\">said</a>:</p>\n<blockquote>\n<p>Maybe I can rescue the inductive approach by proving the desired induction principle separately and use that instead of the <code>induction</code> tactic ...</p>\n</blockquote>\n<p>I thought a bit about the shape of such an inductive principle, which is obvious in the case of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_space.generate_measurable\">docs#measurable_space.generate_measurable</a>, but having the ordinal argument confused me.</p>",
        "id": 315247731,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786525
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean</a></p>",
        "id": 315247773,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670786572
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean#L1331\">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean#L1331</a></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span> <span class=\"n\">If</span> <span class=\"n\">the</span> <span class=\"n\">major</span> <span class=\"n\">premise</span> <span class=\"o\">(</span><span class=\"n\">the</span> <span class=\"n\">hypothesis</span> <span class=\"n\">we</span> <span class=\"n\">are</span> <span class=\"n\">performing</span> <span class=\"n\">induction</span> <span class=\"n\">on</span><span class=\"o\">)</span> <span class=\"n\">has</span>\n  <span class=\"n\">complex</span> <span class=\"n\">indices</span><span class=\"o\">,</span> <span class=\"bp\">`</span><span class=\"n\">induction'</span><span class=\"bp\">`</span> <span class=\"bp\">'</span><span class=\"n\">remembers'</span> <span class=\"n\">them.</span> <span class=\"n\">A</span> <span class=\"n\">complex</span> <span class=\"n\">expression</span> <span class=\"n\">is</span> <span class=\"n\">any</span>\n  <span class=\"n\">expression</span> <span class=\"n\">that</span> <span class=\"n\">is</span> <span class=\"n\">not</span> <span class=\"n\">merely</span> <span class=\"n\">a</span> <span class=\"kn\">local</span> <span class=\"n\">hypothesis.</span> <span class=\"n\">A</span> <span class=\"n\">major</span> <span class=\"n\">premise</span>\n  <span class=\"bp\">`</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"n\">p₁</span> <span class=\"bp\">...</span> <span class=\"n\">pₙ</span> <span class=\"n\">j₁</span> <span class=\"bp\">...</span> <span class=\"n\">jₘ</span><span class=\"bp\">`</span><span class=\"o\">,</span> <span class=\"n\">where</span> <span class=\"bp\">`</span><span class=\"n\">I</span><span class=\"bp\">`</span> <span class=\"n\">is</span> <span class=\"n\">an</span> <span class=\"kd\">inductive</span> <span class=\"n\">type</span> <span class=\"k\">with</span> <span class=\"bp\">`</span><span class=\"n\">n</span><span class=\"bp\">`</span>\n  <span class=\"kd\">parameters</span> <span class=\"n\">and</span> <span class=\"bp\">`</span><span class=\"n\">m</span><span class=\"bp\">`</span> <span class=\"n\">indices</span><span class=\"o\">,</span> <span class=\"n\">has</span> <span class=\"n\">a</span> <span class=\"n\">complex</span> <span class=\"n\">index</span> <span class=\"k\">if</span> <span class=\"n\">any</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"bp\">`</span><span class=\"n\">j</span><span class=\"bp\">ᵢ`</span> <span class=\"n\">are</span>\n  <span class=\"n\">complex.</span> <span class=\"n\">In</span> <span class=\"n\">this</span> <span class=\"n\">situation</span><span class=\"o\">,</span> <span class=\"n\">standard</span> <span class=\"bp\">`</span><span class=\"n\">induction</span><span class=\"bp\">`</span> <span class=\"n\">effectively</span> <span class=\"n\">forgets</span> <span class=\"n\">the</span> <span class=\"n\">exact</span>\n  <span class=\"n\">values</span> <span class=\"n\">of</span> <span class=\"n\">the</span> <span class=\"n\">complex</span> <span class=\"n\">indices</span><span class=\"o\">,</span> <span class=\"n\">which</span> <span class=\"n\">often</span> <span class=\"n\">leads</span> <span class=\"n\">to</span> <span class=\"n\">unprovable</span> <span class=\"n\">goals.</span>\n  <span class=\"bp\">`</span><span class=\"n\">induction'</span><span class=\"bp\">`</span> <span class=\"bp\">'</span><span class=\"n\">remembers'</span> <span class=\"n\">them</span> <span class=\"kd\">by</span> <span class=\"n\">adding</span> <span class=\"n\">propositional</span> <span class=\"n\">equalities.</span> <span class=\"n\">As</span> <span class=\"n\">a</span>\n  <span class=\"n\">result</span><span class=\"o\">,</span> <span class=\"n\">you</span> <span class=\"n\">may</span> <span class=\"n\">find</span> <span class=\"n\">equalities</span> <span class=\"n\">named</span> <span class=\"bp\">`</span><span class=\"n\">induction_eq</span><span class=\"bp\">`</span> <span class=\"k\">in</span> <span class=\"n\">your</span> <span class=\"n\">goal</span><span class=\"o\">,</span> <span class=\"n\">and</span> <span class=\"n\">the</span>\n  <span class=\"n\">induction</span> <span class=\"n\">hypotheses</span> <span class=\"n\">may</span> <span class=\"n\">also</span> <span class=\"n\">quantify</span> <span class=\"n\">over</span> <span class=\"n\">additional</span> <span class=\"n\">equalities.</span>\n</code></pre></div>",
        "id": 315247828,
        "sender_full_name": "Reid Barton",
        "timestamp": 1670786624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247773\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/tactic/induction.lean</a></p>\n</blockquote>\n<p>Yeah, I was not importing it. That's why didn't find it.</p>",
        "id": 315248146,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786803
    },
    {
        "content": "<p>Oh I vaguely remembered that <code>induction'</code> exists and tried it but was missing the import. Now I added the import but it still fails: </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">Failed</span> <span class=\"n\">to</span> <span class=\"n\">apply</span> <span class=\"n\">the</span> <span class=\"o\">(</span><span class=\"n\">dependent</span><span class=\"o\">)</span> <span class=\"n\">recursor</span> <span class=\"n\">for</span> <span class=\"n\">pointclasses.sigma0_pi0_rec</span> <span class=\"n\">on</span> <span class=\"n\">h.</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n<span class=\"n\">index</span> <span class=\"o\">:</span> <span class=\"n\">ordinal</span><span class=\"o\">,</span>\n<span class=\"n\">index_1</span> <span class=\"o\">:</span> <span class=\"n\">bool</span><span class=\"o\">,</span>\n<span class=\"n\">index_2</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">,</span>\n<span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">index</span> <span class=\"n\">index_1</span> <span class=\"n\">index_2</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">),</span>\n    <span class=\"n\">index</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"bp\">→</span>\n    <span class=\"n\">index_1</span> <span class=\"bp\">=</span> <span class=\"n\">ff</span> <span class=\"bp\">→</span> <span class=\"n\">index_2</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">})),</span> <span class=\"o\">(</span><span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">↑</span><span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">index_2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 315248155,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670786812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315247669\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://leanprover-community.github.io/mathlib_docs/tactics.html#induction'\">tactic#induction'</a></p>\n</blockquote>\n<p>Btw, this points nowhere in my end. Missing docs? (though I see them in the sources)</p>",
        "id": 315248209,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670786874
    },
    {
        "content": "<p>Why isn't it mentioned in the tactic page ... that's why I wasn't sure it exists</p>",
        "id": 315248359,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670786947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315248155\">said</a>:</p>\n<blockquote>\n<p>Oh I vaguely remembered that <code>induction'</code> exists and tried it but was missing the import. Now I added the import but it still fails: </p>\n</blockquote>\n<p>Same here, though I was not so sure because my <code>h</code> was <code>z ∈ sigma0_pi0_rec 1 ff</code> (equivalent to <code>sigma0_pi0_rec 1 ff z</code> isn't it???)</p>",
        "id": 315248569,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670787046
    },
    {
        "content": "<p>Yeah you have an abuse of defeq here: since <code>sigma0_pi0_rec 1 ff</code> is a predicate you should write <code>sigma0_pi0_rec 1 ff z</code>; if you want to use <code>∈</code> you should define</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">sigma0</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">i</span> <span class=\"n\">ff</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n</code></pre></div>\n<p>instead. But that shouldn't affect the execution of the tactic. You can do a <code>change</code> and it still doesn't work.</p>",
        "id": 315249102,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670787370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315248359\">said</a>:</p>\n<blockquote>\n<p>Why isn't it mentioned in the tactic page ... that's why I wasn't sure it exists</p>\n</blockquote>\n<p>Hmm... that's unfortunate.</p>",
        "id": 315249194,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670787438
    },
    {
        "content": "<p>At least <code>induction'</code> doesn't error out if I replace <code>parameters {α : Type u} (s : set (set α))</code> by <code>variables</code> ... Another reason to avoid <code>parameters</code>? I think it's already banned in mathlib.</p>",
        "id": 315251700,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670789108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315251700\">said</a>:</p>\n<blockquote>\n<p>At least <code>induction'</code> doesn't error out if I replace <code>parameters {α : Type u} (s : set (set α))</code> by <code>variables</code> ... Another reason to avoid <code>parameters</code>? I think it's already banned in mathlib.</p>\n</blockquote>\n<p>Oh I didn't know what was the etiquette about that... Once things were more or less settled, I was going to read the docs concerning PRs.</p>\n<p>But I noticed that they worked a bit erratically... Sometimes you are asked to provide them explicitly in function calls.</p>",
        "id": 315252661,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670789801
    },
    {
        "content": "<p>Yeah <code>induction'</code> nails it. It's so intelligent that it knows <code>0 ≠ 1</code> in ordinals and generates exactly one goal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sigma0_one</span> <span class=\"o\">:</span>\n  <span class=\"n\">sigma0</span> <span class=\"n\">s</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span><span class=\"n\">univ</span><span class=\"o\">}),</span> <span class=\"bp\">⋃</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"o\">{</span> <span class=\"n\">induction'</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">ordinal.lt_one_iff_zero</span> <span class=\"n\">at</span> <span class=\"n\">h_1</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">h_1</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">n</span> <span class=\"bp\">∈</span> <span class=\"n\">pi0</span> <span class=\"n\">s</span> <span class=\"mi\">0</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">pi0_zero</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"bp\">λ</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"n\">n</span><span class=\"o\">⟩</span> <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 315252936,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670790042
    },
    {
        "content": "<p>Right at the last line I'm left with this target <code>(⋃ (n : ℕ), ↑⟨f n, _⟩) = ⋃ (n : ℕ), f n</code>, which is discharged using <code>exact rfl</code>. Is that normal?</p>",
        "id": 315253463,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670790437
    },
    {
        "content": "<p>Yes. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.coe_mk\">docs#subtype.coe_mk</a> holds definitionally.</p>",
        "id": 315253554,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670790505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"387244\">Yaël Dillies</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315253554\">said</a>:</p>\n<blockquote>\n<p>Yes. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/subtype.coe_mk\">docs#subtype.coe_mk</a> holds definitionally.</p>\n</blockquote>\n<p>What I mean is that it seems that <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span>  didn't have that goal. (His proof doesn't close the goal here).</p>",
        "id": 315253699,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670790605
    },
    {
        "content": "<p>Ah sorry, misunderstood your question.</p>",
        "id": 315253829,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1670790669
    },
    {
        "content": "<p>Maybe it's because I didn't use <code>simp</code>? So it's <code>.val</code> here but a coercion <code>↑</code> in your infoview.</p>",
        "id": 315254010,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670790838
    },
    {
        "content": "<p>If I do <code>refine ⟨λ n, ⟨f n, h n⟩, _⟩</code> instead of <code>use</code> I get</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">↥</span><span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">∪</span> <span class=\"o\">{</span><span class=\"bp\">∅</span><span class=\"o\">,</span> <span class=\"n\">univ</span><span class=\"o\">})),</span> <span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"o\">⟨</span><span class=\"n\">f</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩)</span> <span class=\"bp\">=</span> <span class=\"bp\">⋃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"n\">n</span>\n</code></pre></div>\n<p>which <code>use</code> automatically closes. <code>exact rfl</code> can be replaced by <code>refl</code> BTW.</p>",
        "id": 315254174,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670790954
    },
    {
        "content": "<p>It's strange (and bad) that I can't seem to change the name <code>h_1</code> auto-generated by <code>induction'</code> though ...</p>",
        "id": 315254270,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670791001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315254010\">said</a>:</p>\n<blockquote>\n<p>Maybe it's because I didn't use <code>simp</code>? So it's <code>.val</code> here but a coercion <code>↑</code> in your infoview.</p>\n</blockquote>\n<p>I copypasted your code and it doesn't work as is, that's what I mean---but I think it works in your computer. That's the strange thing!<br>\nI already pushed it, you can check it <a href=\"https://github.com/sterraf/mylearninglean/blob/62e7ad4c0de65767636bd2d6b36cf13939ab6581/src/borel_hierarchy.lean#L221\">here</a>.</p>",
        "id": 315254433,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670791111
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224323\">Junyan Xu</span> <a href=\"#narrow/stream/116395-maths/topic/Borel.20hierarchy/near/315254270\">said</a>:</p>\n<blockquote>\n<p>It's strange (and bad) that I can't seem to change the name <code>h_1</code> auto-generated by <code>induction'</code> though ...</p>\n</blockquote>\n<p>You can, the problem is that there are way too many variables: <code>induction' h with _ _ _ _ _ _ _ IH g glt1,</code></p>",
        "id": 315254722,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670791362
    },
    {
        "content": "<p>Nice find! I stopped at <code>h1 h2 h3 h4 h5 h6</code></p>",
        "id": 315254813,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670791436
    },
    {
        "content": "<p>So, what is the final vote on mathlib-appropriate material? <a href=\"https://github.com/sterraf/mylearninglean/blob/main/src/borel_hierarchy.lean\">Well-founded recursion</a> or an <a href=\"https://github.com/sterraf/mylearninglean/blob/1a6b27f9675b0f3561e29ff7971bc24c8aabafbe/src/borel_hierarchy.lean\"><code>inductive</code> definition</a>?</p>\n<p>(I mean, the definitions of <code>sigma0_pi0_rec</code>---both versions of the file need not-so-fine tuning.)</p>",
        "id": 315256174,
        "sender_full_name": "Pedro Sánchez Terraf",
        "timestamp": 1670792580
    },
    {
        "content": "<p>Given that <code>induction'</code> works, I currently prefer <code>inductive</code>.<br>\n<code>induction'</code> still isn't perfect though, it doesn't automatically closes goals with <code>0 ≠ 0</code> assumption here:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">sigma0_pi0_compl</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">:</span> <span class=\"n\">i</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"n\">ff</span> <span class=\"n\">x</span> <span class=\"bp\">↔</span> <span class=\"n\">sigma0_pi0_rec</span> <span class=\"n\">s</span> <span class=\"n\">i</span> <span class=\"n\">tt</span> <span class=\"n\">x</span><span class=\"bp\">ᶜ</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">sigma0_pi0_rec.compl</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">induction'</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n  <span class=\"n\">iterate</span> <span class=\"mi\">3</span> <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"n\">rfl</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">elim</span> <span class=\"o\">},</span> <span class=\"c1\">-- `induction'` doesn't know `0 ≠ 0` is false ...</span>\n  <span class=\"n\">rwa</span> <span class=\"bp\">←</span> <span class=\"n\">compl_inj_iff.1</span> <span class=\"n\">induction_eq_2</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 315257358,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1670793690
    }
]
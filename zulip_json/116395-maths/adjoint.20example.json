[
    {
        "content": "<p>What do I mean here? I think the right answer is \"yes, the preimage function works\".</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">f'</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 17. Show that $f_{!}: P X \\rightarrow P Y$ is a monotone function.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f'</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">f'</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">f'</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">g'</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"n\">_.40</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">set_of</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"n\">_.41</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">frozen_name</span> <span class=\"n\">has_mem.mem</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)))</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">g'</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">f'</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 239499893,
        "sender_full_name": "Iocta",
        "timestamp": 1621460422
    },
    {
        "content": "<p>You don't need <code>hf'</code> because that's true by definition. You don't need the variable <code>f'</code> either and indeed the only thing it can do is cause confusion. Lean already has a definition of f' by the way, it's called <code>f ''</code>. But it's fine to define it again of course.</p>",
        "id": 239501153,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461209
    },
    {
        "content": "<p>Oh I see, you're not using f' in the example. This is very confusing.</p>",
        "id": 239501395,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461365
    },
    {
        "content": "<p>I'm not at lean right now but I genuinely don't know whether your puzzle 19 example will pick up the definition f' or the variable f'</p>",
        "id": 239501522,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461459
    },
    {
        "content": "<p>Looking at your goal it looks like it picked up the variable, which means your goal isn't provable in 19 because the variable f' has nothing to do with your function f</p>",
        "id": 239501629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461516
    },
    {
        "content": "<p>The reason for your error is that lean has no reason to put f in your local context because there is no mention of it in the statement of what you're trying to prove. There is the variable f' but this is unrelated to f. Why not do what you did in the first example and add f and hf' as assumptions?</p>",
        "id": 239502005,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461685
    },
    {
        "content": "<p>You can also delete the definition of f' because you are using it nowhere</p>",
        "id": 239502126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621461742
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">g'</span> <span class=\"n\">f'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"bp\">⋃</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">f'</span> <span class=\"n\">xs</span> <span class=\"bp\">⊆</span> <span class=\"n\">ys</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"n\">_.6</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">set.Union</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">frozen_name</span> <span class=\"n\">has_subset.subset</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f'</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)))</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">f'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">g'</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">f'</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 239502375,
        "sender_full_name": "Iocta",
        "timestamp": 1621461900
    },
    {
        "content": "<p>Now I am using <code>f'</code></p>",
        "id": 239502648,
        "sender_full_name": "Iocta",
        "timestamp": 1621462040
    },
    {
        "content": "<p>I guess some other notation for the setified version of <code>f</code> would be clearer</p>",
        "id": 239502696,
        "sender_full_name": "Iocta",
        "timestamp": 1621462069
    },
    {
        "content": "<p>I'll change that</p>",
        "id": 239502838,
        "sender_full_name": "Iocta",
        "timestamp": 1621462138
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gg</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gg</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"bp\">⋃</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">ff</span> <span class=\"n\">xs</span> <span class=\"bp\">⊆</span> <span class=\"n\">ys</span><span class=\"o\">),</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">ys</span> <span class=\"o\">:</span> <span class=\"mi\">4</span><span class=\"bp\">.</span><span class=\"n\">_.6</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">set.Union</span> <span class=\"o\">(</span><span class=\"k\">fun</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"o\">((</span><span class=\"n\">frozen_name</span> <span class=\"n\">has_subset.subset</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"n\">ys</span><span class=\"o\">)))</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gg</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">gg</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">ff</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 239502934,
        "sender_full_name": "Iocta",
        "timestamp": 1621462200
    },
    {
        "content": "<p>ok changed the notation, not seeing much difference tho</p>",
        "id": 239503385,
        "sender_full_name": "Iocta",
        "timestamp": 1621462449
    },
    {
        "content": "<p><code>use</code> doesn't even work here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gg</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gg</span> <span class=\"n\">ff</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n  <span class=\"n\">use</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">instantiate</span> <span class=\"n\">goal</span> <span class=\"k\">with</span> <span class=\"mi\">6</span><span class=\"bp\">.</span><span class=\"n\">_.6</span>\n<span class=\"n\">state</span><span class=\"o\">:</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span>\n<span class=\"n\">ff</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span>\n<span class=\"bp\">⊢</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gg</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">gg</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"n\">a</span> <span class=\"bp\">⊆</span> <span class=\"n\">ff</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 239504464,
        "sender_full_name": "Iocta",
        "timestamp": 1621463105
    },
    {
        "content": "<p>Your example says \"do all functions called ff have a right adjoint\" not what you claim it says in the comment</p>",
        "id": 239511545,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621467366
    },
    {
        "content": "<p>I think I can <em>state</em> it now, but stuck on a next step.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 17. Show that $f_{!}: P X \\rightarrow P Y$ is a monotone function.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">fs</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">fs</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">fs</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">fs</span>  <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"o\">}</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gs</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">}),</span>\n<span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">ys</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"c1\">--   XY: Type</span>\n<span class=\"c1\">-- f: X → Y</span>\n<span class=\"c1\">-- ys: set Y</span>\n<span class=\"c1\">-- xs: set X</span>\n<span class=\"c1\">-- h: {x : X | f x ∈ ys} ⊆ xs</span>\n<span class=\"c1\">-- ⊢ ys ⊆ fs f xs</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n<span class=\"c1\">--  XY: Type</span>\n<span class=\"c1\">-- f: X → Y</span>\n<span class=\"c1\">-- ys: set Y</span>\n<span class=\"c1\">-- xs: set X</span>\n<span class=\"c1\">-- h: ys ≤ fs f xs</span>\n<span class=\"c1\">-- ⊢ {x : X | f x ∈ ys} ⊆ xs</span>\n <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 239696320,
        "sender_full_name": "Iocta",
        "timestamp": 1621572686
    },
    {
        "content": "<p>This looks promising now -- your <code>fs</code> is taking <code>f</code> as an input so it depends on <code>f</code>. The definition of <code>A \\subseteq B</code> is <code>\\forall x, X in A implies x in B</code> so you can make progress with <code> intro y</code> or <code>intro x</code> (choose an appropriate variable name)</p>",
        "id": 239700193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621576554
    },
    {
        "content": "<p>I'm starting to doubt that either of these conclusions is true. It seems like the first requires f to be onto and the second requires f to be injective. Does that sound right?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 17. Show that $f_{!}: P X \\rightarrow P Y$ is a monotone function.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span>\n<span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hf'</span><span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">fs</span> <span class=\"n\">s</span> <span class=\"bp\">=</span> <span class=\"o\">{</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">y</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">s'</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">s'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">fs</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">fs</span> <span class=\"n\">s'</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hy</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">hx.2</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">fs</span>  <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"o\">}</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gs</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">}),</span>\n<span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">ys</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">],</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- This doesn't seem doable because it would rely on f being onto.</span>\n<span class=\"c1\">-- X Y: Type</span>\n<span class=\"c1\">-- f: X → Y</span>\n<span class=\"c1\">-- ys: set Y</span>\n<span class=\"c1\">-- xs: set X</span>\n<span class=\"c1\">-- h: {x : X | f x ∈ ys} ⊆ xs</span>\n<span class=\"c1\">-- y: Y</span>\n<span class=\"c1\">-- hy: y ∈ ys</span>\n<span class=\"c1\">-- ⊢ y ∈ fs f xs</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">hx'</span><span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span>  <span class=\"o\">{</span><span class=\"n\">x'</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x'</span> <span class=\"bp\">∈</span> <span class=\"n\">fs</span> <span class=\"n\">f</span> <span class=\"n\">xs</span><span class=\"o\">},</span>\n  <span class=\"k\">from</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"k\">have</span> <span class=\"n\">hfx</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"kd\">by</span> <span class=\"n\">apply</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hfs</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">fs</span> <span class=\"n\">f</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">@</span><span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">hfx</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">mem_set_of_eq</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">hfs</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n<span class=\"c1\">-- X Y: Type</span>\n<span class=\"c1\">-- f: X → Y</span>\n<span class=\"c1\">-- ys: set Y</span>\n<span class=\"c1\">-- xs: set X</span>\n<span class=\"c1\">-- h: ys ⊆ fs f xs</span>\n<span class=\"c1\">-- x: X</span>\n<span class=\"c1\">-- hx: x ∈ {x : X | f x ∈ ys}</span>\n<span class=\"c1\">-- hx': x ∈ {x' : X | f x' ∈ fs f xs}</span>\n<span class=\"c1\">-- ⊢ x ∈ xs</span>\n<span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 239705045,
        "sender_full_name": "Iocta",
        "timestamp": 1621580286
    },
    {
        "content": "<p>If you're not sure about the maths then you should work out a paper proof first. I can genuinely never remember which one is a left adjoint and which is a right adjoint so I don't want to speculate on the answer to puzzle 19 :-)</p>",
        "id": 239705351,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621580481
    },
    {
        "content": "<p>Of course, if your proof doesn't work but you have got the adjointness the right way around, this might mean you've chosen the wrong definition of g</p>",
        "id": 239705671,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621580695
    },
    {
        "content": "<p>In this case you might have to find some results of the form \"every function with a right adjoint has property X\"' and show that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mo stretchy=\"false\">!</mo></msub></mrow><annotation encoding=\"application/x-tex\">f_!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mclose mtight\">!</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> does not have property X in order to solve the puzzle completely. I'll be the first to admit that I can't think of any other possibility for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> but of course this isn't a proof that no <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> exists</p>",
        "id": 239706070,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621580920
    },
    {
        "content": "<p>I'm pretty sure f_! and g are adjoints by the way -- can you prove they're adjoints the other way around? The relation isn't symmetric and this is what always gets me</p>",
        "id": 239706224,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621581022
    },
    {
        "content": "<p>I'm still trying to interpret this but Baez has a mnemonic for left/right: </p>\n<blockquote>\n<p>So, while f has no inverse, it has two \"approximate inverses\". The left adjoint comes as close as possible to the (perhaps nonexistent) correct answer while making sure to never choose a number that's too small. The right adjoint comes as close as possible while making sure to never choose a number that's too big.</p>\n<p>The two adjoints represent two opposing philosophies of life: make sure you never ask for too little and make sure you never ask for too much. This is why they're philosophically profound. But the great thing is that they are defined in a completely precise, systematic way that applies to a huge number of situations!</p>\n<p>If you need a mnemonic to remember which is which, remember left adjoints are \"left-wing\" or \"liberal\" or \"generous\", while right adjoints are \"right-wing\" or \"conservative\" or \"cautious\".</p>\n</blockquote>",
        "id": 239706453,
        "sender_full_name": "Iocta",
        "timestamp": 1621581172
    },
    {
        "content": "<p>Switching the arguments worked. I think this is a right adjoint because it's on the right-hand side of the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo></mrow><annotation encoding=\"application/x-tex\">\\le</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span></span></span></span> in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>≤</mo><mi>b</mi><mo>↔</mo><mi>a</mi><mo>≤</mo><mi>u</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">l (a) ≤ b ↔ a ≤ u(b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">↔</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span>\n\n\n\n\n\n<span class=\"kd\">def</span> <span class=\"n\">fs</span>  <span class=\"o\">(</span><span class=\"n\">xs</span><span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">|</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">xs</span> <span class=\"o\">}</span>\n\n\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 19. Does f! always have a right adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a right adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">gs</span>  <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">use</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">}),</span>\n<span class=\"n\">unfold</span> <span class=\"n\">galois_connection</span><span class=\"o\">,</span>\n<span class=\"n\">intros</span> <span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"n\">mem_image_of_mem</span> <span class=\"n\">f</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">fs</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">image</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"o\">},</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">le_eq_subset</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">y</span> <span class=\"n\">hy</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">yim</span><span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">xs</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">image</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">fs</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">exists_prop</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">have</span> <span class=\"n\">fim</span><span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"n\">xs</span> <span class=\"bp\">⊆</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">},</span> <span class=\"kd\">by</span> <span class=\"o\">{</span>\n    <span class=\"n\">intros</span> <span class=\"n\">y'</span> <span class=\"n\">hy'</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">image</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">unfold</span> <span class=\"n\">fs</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">simp</span> <span class=\"bp\">*</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n    <span class=\"n\">cases</span> <span class=\"n\">hy'</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n    <span class=\"n\">use</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">hx.1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span><span class=\"n\">exact</span> <span class=\"n\">hx.2</span><span class=\"o\">,},</span>\n  <span class=\"o\">},</span>\n  <span class=\"k\">have</span><span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">∈</span> <span class=\"n\">f</span> <span class=\"bp\">''</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">|</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">ys</span><span class=\"o\">},</span> <span class=\"k\">from</span> <span class=\"bp\">@</span><span class=\"n\">fim</span> <span class=\"n\">y</span> <span class=\"n\">yim</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">image</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">*</span><span class=\"o\">,</span> <span class=\"n\">and_imp</span><span class=\"o\">,</span> <span class=\"n\">set_of_subset_set_of</span><span class=\"o\">,</span> <span class=\"n\">mem_set_of_eq</span><span class=\"o\">,</span> <span class=\"n\">forall_apply_eq_imp_iff₂</span><span class=\"o\">,</span> <span class=\"n\">exists_imp_distrib</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">this</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">mem_of_eq_of_mem</span> <span class=\"o\">(</span><span class=\"n\">eq.symm</span> <span class=\"n\">hx_right</span><span class=\"o\">)</span> <span class=\"n\">hx_left</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 239712270,
        "sender_full_name": "Iocta",
        "timestamp": 1621584570
    },
    {
        "content": "<p>any obvious places to shrink that code?</p>",
        "id": 239713297,
        "sender_full_name": "Iocta",
        "timestamp": 1621585144
    },
    {
        "content": "<p>My guess is that everything can be shrunk to a couple of lines and even done in term mode</p>",
        "id": 239716336,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621586620
    },
    {
        "content": "<p>You might want to start by looking at <code>simp * at *</code> and finding out what it actually is doing, eg by using <code>squeeze_simp</code>. It might just be doing some trivial rewrite</p>",
        "id": 239716474,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621586681
    },
    {
        "content": "<p>If you are happy to abuse definitional equality then probably most of the <code>unfolds</code> can go. You might find that a lot of rewrites are definitional in which case they can go too. The shorter the code gets, the more readability you sacrifice</p>",
        "id": 239716797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621586850
    },
    {
        "content": "<p>Rewriting <code>{f x | x \\in s}</code> as <code>f '' s</code> and similar should help make the proof shorter</p>",
        "id": 239718601,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621587725
    },
    {
        "content": "<p>Why does it need the lambda? </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">gs</span>  <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span><span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"bp\">⁻¹'</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"c1\">-- ok</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">fs</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">gs</span>  <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"bp\">⁻¹'</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">⟩</span> <span class=\"c1\">--invalid expression</span>\n</code></pre></div>",
        "id": 239809056,
        "sender_full_name": "Iocta",
        "timestamp": 1621629050
    },
    {
        "content": "<p><code>⁻¹'</code> is an infix notation, so it needs an argument on either side</p>",
        "id": 239810728,
        "sender_full_name": "Ruben Van de Velde",
        "timestamp": 1621629952
    },
    {
        "content": "<p>Actually, couldn't we define it as the function it really is?</p>",
        "id": 239811457,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1621630309
    },
    {
        "content": "<p><code>((⁻¹') f)</code> should work</p>",
        "id": 239814007,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621631710
    },
    {
        "content": "<p>If you want to take this further, you can define a filter on a type, define how to push them forward and pull them back along morphisms of types, and show that these concepts also form a Galois connection, and then you can define the function from subsets to filters (the principal filter) and maybe the function \"intersection of all sets in the filter\" from filters to subsets(?) and then perhaps show that there is some sort of Galois insertion between these two ideas (although I've never checked this so I might be wrong).</p>",
        "id": 239878140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621695268
    },
    {
        "content": "<p>Got it cut down</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">gs</span>  <span class=\"o\">:=</span>\n<span class=\"o\">⟨(</span><span class=\"bp\">⁻¹'</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"bp\">λ</span><span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">image_subset_iff</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 239978787,
        "sender_full_name": "Iocta",
        "timestamp": 1621804705
    },
    {
        "content": "<p>At this point you may as well eliminate the existential</p>",
        "id": 239979507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621805562
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"n\">galois_connection</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"bp\">⁻¹'</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">xs</span> <span class=\"n\">ys</span><span class=\"o\">,</span> <span class=\"n\">image_subset_iff</span>\n</code></pre></div>",
        "id": 239979572,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621805605
    },
    {
        "content": "<p>I'd hope library_search can find that we have that exact statement already</p>",
        "id": 239979585,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621805638
    },
    {
        "content": "<p>it finds <code>set.image_preimage</code></p>",
        "id": 239979659,
        "sender_full_name": "Iocta",
        "timestamp": 1621805685
    },
    {
        "content": "<p>dropping the \\exists is like saying \"there's <em>only</em> one\"?</p>",
        "id": 239979709,
        "sender_full_name": "Iocta",
        "timestamp": 1621805760
    },
    {
        "content": "<p>Nope, it's just saying \"I can tell you a specific GS, not just that one exists\"</p>",
        "id": 239979775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1621805810
    },
    {
        "content": "<p>Is this not what I mean?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n<span class=\"kn\">import</span> <span class=\"n\">order.galois_connection</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">order</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">noncomputable theory</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n\n<span class=\"cm\">For any set $X$ let $P X$ be the power set of set, namely the set of all subsets of $X$. It's easy to see that the subset relation $\\subseteq$ makes $P X$ into a poset. Suppose we have any function between sets $ f: X \\rightarrow Y $.</span>\n<span class=\"cm\">This gives a function $ f_{!}: P X \\rightarrow P Y $</span>\n<span class=\"cm\">sending each subset $S \\subseteq X$ to its image under $f : f_{!}(S)=\\{y \\in Y: y=f(x) \\text { for some } x \\in S\\} $.</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">Puzzle 18. Does $f_!$ always have a left adjoint? If so, describe it. If not, give an example where it doesn't, and some conditions under which it does have a left adjoint.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kd\">example</span> <span class=\"o\">:</span> <span class=\"bp\">!∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"bp\">∃</span><span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gs</span> <span class=\"o\">((</span><span class=\"bp\">''</span><span class=\"o\">)</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"kd\">class</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">⊢</span> <span class=\"n\">decidable</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">gs</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Y</span> <span class=\"bp\">→</span> <span class=\"n\">set</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">galois_connection</span> <span class=\"n\">gs</span> <span class=\"o\">(</span><span class=\"n\">image</span> <span class=\"n\">h</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 239999858,
        "sender_full_name": "Iocta",
        "timestamp": 1621827361
    },
    {
        "content": "<p>Remove the <code>!</code>, it is interpreted as boolean negation.</p>",
        "id": 240000266,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1621827843
    },
    {
        "content": "<p>use <code>\\neg</code> for negation</p>",
        "id": 240000307,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1621827857
    }
]
[
    {
        "content": "<p><a href=\"https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean\" target=\"_blank\" title=\"https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean\">https://github.com/kckennylau/category-theory/blob/master/src/adjunction_examples.lean</a></p>",
        "id": 124502143,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522618682
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[reducible] def Set.Prod_Hom (B : Type u) : adjunction examples.Set examples.Set :=\nadjunction.make _ _\n  (examples.Set.product_functor B)\n  (examples.Set.Hom_functor_right B)\n  (λ A C f x, f x.1 x.2)\n  (λ A C f x y, f (x, y))\n  (λ A₁ A₂ C₁ C₂ f g t, rfl)\n  (λ A₁ A₂ C₁ C₂ f g t, rfl)\n  (λ A C f, funext $ λ ⟨t₁, t₂⟩, rfl)\n  (λ A C f, rfl)\n</pre></div>",
        "id": 124520998,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522663344
    },
    {
        "content": "<p>so natural</p>",
        "id": 124520999,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522663356
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[reducible] def Top_Set : adjunction examples.Top examples.Set :=\nadjunction.free_forgetful _\n  examples.Top.discrete\n  examples.Top.forgetful\n  (λ S T f, ⟨f, continuous_top⟩)\n  (λ S T f, f.1)\n  (λ T₁ T₂ S₁ S₂ f g t z, rfl)\n  (λ T₁ T₂ S₁ S₂ f g t, subtype.eq rfl)\n  (λ S T f, subtype.eq rfl)\n  (λ S T f, rfl)\n\n@[reducible] def Set_Top : adjunction examples.Set examples.Top :=\nadjunction.make _ _\n  examples.Top.forgetful\n  examples.Top.indiscrete\n  (λ S T f, f.1)\n  (λ S T f, ⟨f, continuous_bot⟩)\n  (λ T₁ T₂ S₁ S₂ f g t, subtype.eq rfl)\n  (λ T₁ T₂ S₁ S₂ f g t, rfl)\n  (λ S T f, rfl)\n  (λ S T f, subtype.eq rfl)\n</pre></div>",
        "id": 124521485,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522664412
    },
    {
        "content": "<p>that moment when they're adjoint to each other</p>",
        "id": 124521487,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1522664416
    },
    {
        "content": "<p>for a set S, denoting by L(S) the transitive closure of S, we see that for any transitive set T with S ⊆ T, then L(S) ⊆ T</p>",
        "id": 124769998,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523121918
    },
    {
        "content": "<p>I wonder if this is the left adjoint of some forgetful functor</p>",
        "id": 124769999,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523121926
    },
    {
        "content": "<p>well, working in the category of sets with inclusion as morphism, we see that Hom_Trans(L(S),T) = Hom_Set(S,R(T)), where Trans is the category of transitive sets</p>",
        "id": 124770041,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523121983
    },
    {
        "content": "<p>What does this even mean? What is a transitive set?</p>",
        "id": 124771927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523126624
    },
    {
        "content": "<p>A set X is transitive if for every x and y such that x∈y∈X, we have x∈X</p>",
        "id": 124771967,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523126658
    },
    {
        "content": "<p>if the transitive closure is indeed a left adjoint, then we get right-exactness for free</p>",
        "id": 124771978,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523126715
    },
    {
        "content": "<p>Eew. I think I saw that notion in undergraduate set theory nearly 30 years ago, and I'm not sure I've seen it since. Maybe I saw it in the context of ordinals, which is something else I've not seen since.</p>",
        "id": 124772086,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523126997
    },
    {
        "content": "<p>Are you making an assertion here? What is R(T)?</p>",
        "id": 124772191,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127191
    },
    {
        "content": "<p>the forgetful functor that forgets the fact that T is transitive</p>",
        "id": 124772193,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127207
    },
    {
        "content": "<p>Is what you write true?</p>",
        "id": 124772194,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127225
    },
    {
        "content": "<p>I believe so</p>",
        "id": 124772195,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127235
    },
    {
        "content": "<p>If S and T are both transitive, then you're asserting that the transitive maps from S to T are the same as the maps from S to T then?</p>",
        "id": 124772234,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127272
    },
    {
        "content": "<p>yes, since here the morphisms are just inclusions, so there is only one morphism per pair of sets</p>",
        "id": 124772235,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127299
    },
    {
        "content": "<p>What does Hom_Set mean then?</p>",
        "id": 124772241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127325
    },
    {
        "content": "<p>oh, inclusion</p>",
        "id": 124772243,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127333
    },
    {
        "content": "<p>Do you have a question?</p>",
        "id": 124772287,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127442
    },
    {
        "content": "<p>is my belief right</p>",
        "id": 124772288,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127449
    },
    {
        "content": "<p>What does Hom_Trans mean?</p>",
        "id": 124772327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127496
    },
    {
        "content": "<p>subcategory</p>",
        "id": 124772328,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127506
    },
    {
        "content": "<p>I don't know what anything means. It feels like you have made these categories up.</p>",
        "id": 124772329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127525
    },
    {
        "content": "<p>It also seems that you are just as capable of writing down a proof of your assertion as I am. Why not check it in Lean? ;-)</p>",
        "id": 124772331,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127542
    },
    {
        "content": "<p>because to hell with the category of sets in Lean</p>",
        "id": 124772336,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127562
    },
    {
        "content": "<p>What does Hom_Trans mean?</p>",
        "id": 124772338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127565
    },
    {
        "content": "<p>the inclusion in the category of transitive sets</p>",
        "id": 124772339,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127584
    },
    {
        "content": "<p>So at most one map between two sets?</p>",
        "id": 124772340,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127599
    },
    {
        "content": "<p>yes</p>",
        "id": 124772378,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127603
    },
    {
        "content": "<p>\" we see that for any transitive set T with S ⊆ T, then L(S) ⊆ T \". Is that your question?</p>",
        "id": 124772387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127630
    },
    {
        "content": "<p>well that's the UMP of transitive closure</p>",
        "id": 124772388,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127644
    },
    {
        "content": "<p>which should be right</p>",
        "id": 124772389,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127646
    },
    {
        "content": "<p>But what is your question if it is not precisely that statement?</p>",
        "id": 124772398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127669
    },
    {
        "content": "<p>no idea</p>",
        "id": 124772399,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127677
    },
    {
        "content": "<p>We might be done then :-)</p>",
        "id": 124772400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1523127718
    },
    {
        "content": "<p>interesting</p>",
        "id": 124772437,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1523127725
    },
    {
        "content": "<p>Scott I guess I'll keep you updated on what I'm doing by sending pastebin links for now.</p>",
        "id": 133190899,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535836011
    },
    {
        "content": "<p><a href=\"https://pastebin.com/WmdNgPdx\" target=\"_blank\" title=\"https://pastebin.com/WmdNgPdx\">https://pastebin.com/WmdNgPdx</a> is limits and colimits in types (nice and easy) and small and filtered categories (also easy).</p>",
        "id": 133190905,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535836070
    },
    {
        "content": "<p>Next I plan to try to show that small limits commute with filtered colimits</p>",
        "id": 133190955,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535836108
    },
    {
        "content": "<p>Probably I won't finish that in the next few days.</p>",
        "id": 133190963,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535836139
    },
    {
        "content": "<p>Thanks, Reid, that patch has been applied!</p>",
        "id": 133193621,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1535841904
    },
    {
        "content": "<p>I defined the limit functor but the proofs aren't as concise as they should be, especially map_id'.<br>\n<a href=\"https://pastebin.com/QDM9H7TX\" target=\"_blank\" title=\"https://pastebin.com/QDM9H7TX\">https://pastebin.com/QDM9H7TX</a></p>",
        "id": 133219652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535903647
    },
    {
        "content": "<p>Scott -- maybe the simp lemmas could be set up so that map_id' can be proved by obviously?<br>\nmap_comp' is more complicated, since you have to use associativity (backwards)</p>",
        "id": 133219672,
        "sender_full_name": "Reid Barton",
        "timestamp": 1535903738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, in fact I already had this, obscurely hidden in <code>universal/complete/default.lean</code>, with slightly different proofs. I've incorporated some changes from yours, but left my proofs for now. Curiously, <code>obviously</code> does just fine for <code>map_comp'</code>, but fails on <code>map_id'</code> because for some reason <code>simp</code> won't apply <code>limit.lift_π</code>.</p>",
        "id": 133230162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1535926249
    },
    {
        "content": "<p>I guess it was hiding in that directory because I wrote it for the sake of <a href=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean\" target=\"_blank\" title=\"https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean\">https://github.com/semorrison/lean-category-theory/blob/master/src/category_theory/universal/complete/functor_category.lean</a>, a still incomplete proof that C \\lea D has limits if D does.</p>",
        "id": 133230214,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1535926419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Will you change some of the mathlib files to use category theory?</p>",
        "id": 136174097,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540051198
    },
    {
        "content": "<p>what's the plan for category theory?</p>",
        "id": 136174143,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540051207
    },
    {
        "content": "<p>I think at first, not much. Things like <code>has_products CommRing</code> can first live under <code>category_theory/</code>, as we get used to them.</p>",
        "id": 136174176,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051258
    },
    {
        "content": "<p>will they gradually assimilate into the main mathlib library?</p>",
        "id": 136174189,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540051278
    },
    {
        "content": "<p>Eventually such facts should move out to their natural homes, immediately following where the underlying lemmas are actually proved.</p>",
        "id": 136174190,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051279
    },
    {
        "content": "<p>nice</p>",
        "id": 136174193,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1540051286
    },
    {
        "content": "<p>I suspect in the long run a lot of files will want to import <code>category_theory.isomorphism</code>, to avoid having to define their own custom version of <code>equiv</code> for the structure at hand.</p>",
        "id": 136174205,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1540051315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> The new module will be:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">class</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">out_param</span> <span class=\"err\">$</span> <span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">semimodule</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n</pre></div>\n\n\n<p>How will your category theory library deal with this?</p>",
        "id": 136987135,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541152701
    },
    {
        "content": "<p>Mostly users will just want the category of R-modules for some fixed R. After you've fixed the ring this is no more or less scary than bundling any other algebraic typeclass, I think.</p>",
        "id": 136992913,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541156550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I don't see how <code>bundle</code> can solve this</p>",
        "id": 136994837,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541157352
    },
    {
        "content": "<p>Oh, I didn't imply that we should use <code>bundled</code>. It's only intended for the simplest cases.</p>",
        "id": 136994962,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541157393
    },
    {
        "content": "<p>But <code>structure Module (a : Type) [ring a] := (b : Type) (m : module a b)</code>, is presumably fine.</p>",
        "id": 136995172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541157482
    },
    {
        "content": "<p>Maybe you haven't actually said what you're concerned about?</p>",
        "id": 136995228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541157499
    },
    {
        "content": "<p>well you forgot the add_comm_group</p>",
        "id": 136995271,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541157524
    },
    {
        "content": "<p>and actually that's all I'm concerned about</p>",
        "id": 136995293,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541157533
    },
    {
        "content": "<p>So <code>structure Module (a : Type) [ring a] := (b : Type) (g : add_comm_group b) (m : module a b)</code>...?</p>",
        "id": 136995418,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541157595
    },
    {
        "content": "<p>I'm not really sure how all of this works, because last time in my own category repo, I was wrestling with sigma</p>",
        "id": 136995910,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541157766
    },
    {
        "content": "<p>Yeah, I think just building custom structures, and then a few lemmas that peel back out the typeclasses as needed, is easiest.</p>",
        "id": 136996578,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541158042
    },
    {
        "content": "<p>I'll make a few more examples.</p>",
        "id": 136996598,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541158050
    },
    {
        "content": "<p>thanks</p>",
        "id": 137000581,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541159713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> is <code>bundled category</code> a category? If not, what's the proper name?</p>",
        "id": 137066926,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541177210
    },
    {
        "content": "<p>I have a natural transformation <code>a</code> from <code>F</code> to <code>G</code>, and Lean is looking for a natural transformation from <code>G.op</code> to <code>F.op</code>. So I would like to provide <code>a.op</code> but this is not defined yet. What is the natural place to add this definition? In <code>opposites.lean</code> or in <code>natural_transformation.lean</code>?</p>",
        "id": 137078410,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541188479
    },
    {
        "content": "<p>I think it makes sense to keep <code>category</code>/<code>functor</code>/<code>natural_transformation</code> \"at the bottom\" and so put <code>a.op</code> in <code>opposites</code> like <code>F.op</code></p>",
        "id": 137078733,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541188806
    },
    {
        "content": "<p>Ok... fine with me. I could also imagine <code>opposites</code> being pretty \"fundamental\".</p>",
        "id": 137079047,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541189159
    },
    {
        "content": "<p>It would be quite interesting if we know that functors form a category but not that categories form a category...</p>",
        "id": 137079230,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541189375
    },
    {
        "content": "<p>I've searched all the files</p>",
        "id": 137079231,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541189379
    },
    {
        "content": "<p>the problem is that categories form a 2-category</p>",
        "id": 137079297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541189428
    },
    {
        "content": "<p>so \"categories form a category\" is true but mostly useless</p>",
        "id": 137079305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541189445
    },
    {
        "content": "<p>Categories also form a perfectly good category, we just don't have it yet</p>",
        "id": 137079310,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541189452
    },
    {
        "content": "<p>Ok, I'm testing out a heresy:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">cocone</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">cone</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">op</span>\n</pre></div>\n\n\n<p>The first problem I hit is that for <code>c : cocone F</code> the tip of the cocone <code>c.X</code> is now an object of <code>C\\op</code> instead of <code>C</code>. Can this somehow be fixed? I would rather just write <code>f : c.X \\hom X</code> instead of</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"n\">C</span> <span class=\"bp\">_</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"n\">X</span>\n</pre></div>",
        "id": 137079773,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541189969
    },
    {
        "content": "<p>I actually have this problem in ordinary informal math as well: it's hard to talk about both C and C^op at the same time.<br>\nSometimes I write things like <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mover accent=\"true\"><mrow><mi>A</mi></mrow><mo stretchy=\"true\">‾</mo></mover></mrow><annotation encoding=\"application/x-tex\">\\overline{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8833300000000001em;\"></span><span class=\"strut bottom\" style=\"height:0.8833300000000001em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord overline\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8833300000000001em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathit\">A</span></span></span><span style=\"top:-3.80333em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"overline-line\" style=\"border-bottom-width:0.04em;\"></span></span></span></span></span></span></span></span></span> for the object of C^op corresponding to the object <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">A</span></span></span></span> of C, but I'm not really fond of it.</p>",
        "id": 137080246,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541190431
    },
    {
        "content": "<p>\"ordinary informal math\" = category</p>",
        "id": 137080336,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541190523
    },
    {
        "content": "<p>Sure, so we could write <code>X.op</code> for such objects. But this problem is different. With my definition <code>c.X</code> lives in <code>C^op</code> by definition. But I'dd rather have it live in <code>C</code>... And somehow just writing <code>f : (c.X : C) \\hom X</code> doesn't cut it....</p>",
        "id": 137080436,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541190606
    },
    {
        "content": "<p>Hmmm... I have to run. See y'all later.</p>",
        "id": 137080457,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541190636
    },
    {
        "content": "<p>Perhaps we could have <code>unop : C\\op \\to C</code>?</p>",
        "id": 137081858,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541191956
    },
    {
        "content": "<p>or maybe an equivalence of categories <code>C\\op\\op \\cong C</code>?</p>",
        "id": 137082098,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541192178
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">module</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">examples</span><span class=\"bp\">.</span><span class=\"n\">rings</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">opposites</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">Module</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">is_linear_map</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">is_linear_map</span> <span class=\"n\">f</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">examples</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">concrete_category</span> <span class=\"o\">:</span> <span class=\"n\">concrete_category</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">is_linear_map</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"bp\">⟨λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"n\">hf</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">hf</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">hg</span><span class=\"bp\">;</span> <span class=\"n\">constructor</span><span class=\"bp\">;</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[(</span><span class=\"err\">∘</span><span class=\"o\">),</span> <span class=\"bp\">*</span><span class=\"o\">]</span><span class=\"bp\">⟩</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">Mod</span> <span class=\"o\">:=</span> <span class=\"n\">bundled</span> <span class=\"o\">(</span><span class=\"n\">Module</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"kn\">reducible</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">Cat</span> <span class=\"o\">:=</span> <span class=\"n\">bundled</span> <span class=\"n\">category</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">Cat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">D</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">D</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">id</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">comp</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">E</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">C</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">D</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">D</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">E</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">id_comp&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">refl</span><span class=\"o\">,</span>\n  <span class=\"n\">comp_id&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"bp\">;</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Mod</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"err\">ᵒᵖ</span> <span class=\"err\">⥤</span> <span class=\"n\">Cat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">bundled</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">Mod</span> <span class=\"n\">R</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">),</span>\n  <span class=\"n\">map&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"n\">φ</span><span class=\"o\">,</span> <span class=\"n\">concrete_functor</span> <span class=\"o\">(</span><span class=\"k\">begin</span> <span class=\"kn\">end</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">begin</span> <span class=\"kn\">end</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 137083573,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541193752
    },
    {
        "content": "<p>This looks good, but then the real test is whether it's convenient to use objects of <code>Mod R</code> as modules and vice versa, and the same for <code>Cat</code></p>",
        "id": 137084172,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541194498
    },
    {
        "content": "<p>At a minimum you want the instance that gets you the <code>Module</code> back out from <code>x : Mod R</code></p>",
        "id": 137084272,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541194616
    },
    {
        "content": "<p>analogous to <code>instance (x : Ring) : ring x := x.str</code></p>",
        "id": 137084280,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541194630
    },
    {
        "content": "<p>that's just interface</p>",
        "id": 137084285,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541194641
    },
    {
        "content": "<p>anyone can write an interface</p>",
        "id": 137084287,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541194646
    },
    {
        "content": "<p>anyone can define <code>Cat</code>, too</p>",
        "id": 137084348,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541194695
    },
    {
        "content": "<p>Finding a good interface is the important thing</p>",
        "id": 137084357,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541194706
    },
    {
        "content": "<p>Interfaces are hard.</p>",
        "id": 137084372,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541194733
    },
    {
        "content": "<p>I think <code>opposite</code> can have a better interface</p>",
        "id": 137084448,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541194814
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> how should we define an additive category?</p>",
        "id": 137087104,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198162
    },
    {
        "content": "<p>ugh, yeah, defining enriched categories may take a lot of work to do in general. :-(</p>",
        "id": 137087138,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198189
    },
    {
        "content": "<p>If you _just_ want additive categories (which is very reasonable, later we can retrofit them as special cases of enriched categories)</p>",
        "id": 137087180,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198264
    },
    {
        "content": "<p>then I don't think it's too bad</p>",
        "id": 137087225,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198285
    },
    {
        "content": "<p>ok, then how?</p>",
        "id": 137087236,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198321
    },
    {
        "content": "<p>Just have a new typeclass <code>[additive_category C]</code>, with fields <code>hom_abelian : add_comm_group (X \\hom Y)</code> and <code>comp_bilinear : ...</code></p>",
        "id": 137087237,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198330
    },
    {
        "content": "<p>and then some <code>defs</code> that create instances from these fields</p>",
        "id": 137087239,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198342
    },
    {
        "content": "<p>can we instead declare it as a functor from the Hom category to the Ab category</p>",
        "id": 137087261,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198396
    },
    {
        "content": "<p>such that some triangle commutes</p>",
        "id": 137087302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198404
    },
    {
        "content": "<p>I guess Hom isn't a category</p>",
        "id": 137087316,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198432
    },
    {
        "content": "<p>yeah, I'm not sure what you mean</p>",
        "id": 137087321,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198442
    },
    {
        "content": "<p>there must be a way to do this category-theoretically...</p>",
        "id": 137087339,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198467
    },
    {
        "content": "<p>Well... I think often it's better to have the definitions \"explicit\" and then have lemmas saying \"you can interpret this in categorical terms\"</p>",
        "id": 137087358,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198495
    },
    {
        "content": "<p>sure</p>",
        "id": 137087367,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198510
    },
    {
        "content": "<p>In particular, for monoidal categories (or 2-categories), which I really want to get back to,</p>",
        "id": 137087368,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198511
    },
    {
        "content": "<p>it turns out to be a really bad idea to say that a monoidal category is a category equipped with a functor (C x C) \\func C, such that ...</p>",
        "id": 137087421,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198535
    },
    {
        "content": "<p>why isn't Lean ready for a category theory library?</p>",
        "id": 137087436,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541198559
    },
    {
        "content": "<p>and instead you should do everything grossly: a function <code>tensorObjects</code>, a function <code>tensorMorphisms</code>, and then have a lemma saying these form that functor</p>",
        "id": 137087445,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198576
    },
    {
        "content": "<p>This sounds like a really bad idea, but the way lean's notation system and elaborator work, you run into endless misery making the functor the \"primary\" description of the tensor product.</p>",
        "id": 137087481,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198635
    },
    {
        "content": "<p>It's very unfortunate. :-(</p>",
        "id": 137087484,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198639
    },
    {
        "content": "<blockquote>\n<p>why isn't Lean ready for a category theory library?</p>\n</blockquote>\n<p>Speaking to mathematicians, Lean, like every other ITP system, is not ready to do mathematics in. :-)</p>\n<p>Lean is terrible, just less terrible than all the others!</p>",
        "id": 137087555,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541198703
    },
    {
        "content": "<p>I don't know whether this would be easier or harder, but you don't actually need monoidal categories to do enriched categories; you could enrich in a multicategory instead</p>",
        "id": 137088959,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541200632
    },
    {
        "content": "<p>I've found it quite good fun doing abstract maths in Lean. I've not used categories though. But stuff like commutative algebra seems to come out nicely.</p>",
        "id": 137089207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541201037
    },
    {
        "content": "<p>right, until the module thing came along</p>",
        "id": 137089255,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1541201075
    },
    {
        "content": "<p>Lean is often good at abstract stuff. I think maybe abstract usually means it has to be done on paper more formally, because there's less real world intuition.</p>",
        "id": 137089369,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1541201258
    },
    {
        "content": "<blockquote>\n<p>But stuff like commutative algebra seems to come out nicely.</p>\n</blockquote>\n<p>Stockholm syndrome. :-)</p>",
        "id": 137103458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541229371
    },
    {
        "content": "<p>Scott, are you attached to the name <code>category_theory.embedding</code>?<br>\nHow about <code>fully_faithful</code>?</p>",
        "id": 137177771,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541378657
    },
    {
        "content": "<p><code>embedding</code> is ambiguous, I feel. Someone may think it implies \"injective on objects\" for example. The nlab gives a variety of definitions.</p>",
        "id": 137177843,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541378836
    },
    {
        "content": "<p>(Also it collides with the top-level <code>embedding</code> of topological spaces, which is not <code>category_theory</code>'s fault but it did cause some extremely confusing behavior during one of my lean-homotopy-theory mathlib version bumps.)</p>",
        "id": 137177890,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541378920
    },
    {
        "content": "<p>Yes, we should definitely change this.</p>",
        "id": 137179986,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541383203
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Do you have any idea why this would fail?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">,</span>\n<span class=\"err\">𝒳</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">covering_family</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">index</span> <span class=\"bp\">×</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">index</span>\n<span class=\"err\">⊢</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"err\">ᵒᵖ</span> <span class=\"err\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 146815330,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541443967
    },
    {
        "content": "<p>either you're missing the import, or something is weird with universe levels?</p>",
        "id": 146815457,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541444064
    },
    {
        "content": "<p>I have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">presheaf</span> <span class=\"o\">:=</span> <span class=\"n\">X</span><span class=\"err\">ᵒᵖ</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">C</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"o\">(</span><span class=\"n\">presheaf</span> <span class=\"n\">X</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">presheaf</span><span class=\"bp\">;</span> <span class=\"n\">apply_instance</span>\n</pre></div>\n\n\n<p>in the same file.</p>",
        "id": 146815502,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444120
    },
    {
        "content": "<p>Turn on pp.universes?</p>",
        "id": 146815626,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541444224
    },
    {
        "content": "<p>I'll try that. I also see</p>\n<div class=\"codehilite\"><pre><span></span>[class_instances] (0) ?x_0 : category (Xᵒᵖ ⥤ Type v₁) := @functor.category ?x_40 ?x_41 ?x_42 ?x_43\nfailed is_def_eq\n</pre></div>\n\n\n<p>in the trace.</p>",
        "id": 146815660,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444272
    },
    {
        "content": "<p>Ok, that gave me</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">,</span>\n<span class=\"err\">𝒳</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">covering_family</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">U</span><span class=\"o\">,</span>\n<span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">index</span> <span class=\"bp\">×</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">index</span>\n<span class=\"err\">⊢</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"n\">u₁</span> <span class=\"o\">(</span><span class=\"n\">v₁</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">))</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">X</span><span class=\"err\">ᵒᵖ</span> <span class=\"err\">⥤</span> <span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 146815837,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444413
    },
    {
        "content": "<p>Maybe I don't understand universes well enough...</p>",
        "id": 146815842,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444423
    },
    {
        "content": "<p>Should that last <code>v_1</code> be a <code>v_1 + 1</code>?</p>",
        "id": 146815850,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444441
    },
    {
        "content": "<p>I think it should be <code>max u_1 v_1</code>, if I calculated right</p>",
        "id": 146815950,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444549
    },
    {
        "content": "<p>Ah, Scott was kind enough to write out the universe parameters in <code>instance functor.category</code>.</p>",
        "id": 146815980,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444591
    },
    {
        "content": "<p>My guess: perhaps you are doing something where you actually need <code>X</code> to be a small category?</p>",
        "id": 146815996,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444614
    },
    {
        "content": "<p>it's hard to say what to do without knowing where that goal is coming from</p>",
        "id": 146816055,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444656
    },
    {
        "content": "<p>But in <code>yoneda</code> Scott is doing the same thing as I'm doing. Now I'm really confused.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u₁</span> <span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒞</span>\n\n<span class=\"n\">def</span> <span class=\"n\">yoneda</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"o\">((</span><span class=\"n\">C</span><span class=\"err\">ᵒᵖ</span><span class=\"o\">)</span> <span class=\"err\">⥤</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">v₁</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 146816060,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444668
    },
    {
        "content": "<p>Sure you can write down <code>X\\op \\func Type v_1</code>, but it might not have <code>v_1</code>-small hom sets.</p>",
        "id": 146816089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444720
    },
    {
        "content": "<p>Which is what your goal is asking for</p>",
        "id": 146816155,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541444771
    },
    {
        "content": "<p>how big are the homsets of the functor category?</p>",
        "id": 146816217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541444842
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>variables (C : Type u₁) [𝒞 : category.{u₁ v₁} C] (D : Type u₂) [𝒟 : category.{u₂ v₂} D]\ninclude 𝒞 𝒟\n\ninstance functor.category :\n  category.{(max u₁ v₁ u₂ v₂) (max u₁ v₂)} (C ⥤ D) :=\n</pre></div>",
        "id": 146816296,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541444908
    },
    {
        "content": "<p>I wrote the universe levels explicitly in the definition, as documentation for just these moments. :-)</p>",
        "id": 146816308,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541444932
    },
    {
        "content": "<p>Thanks! I'm probably dense, but I'm still confused why Scott could write what he wrote for <code>yoneda</code>, and now I want to apply it and Lean complains...</p>",
        "id": 146816354,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541444990
    },
    {
        "content": "<p>The danger is always the <code>u1</code> appearing the morphism universe level.</p>",
        "id": 146816417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445015
    },
    {
        "content": "<p>Apply what how? What is the actual math?</p>",
        "id": 146816437,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541445029
    },
    {
        "content": "<p>So in Yoneda, we don't care about the universe level of the morphisms in the resulting category.</p>",
        "id": 146816449,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445045
    },
    {
        "content": "<p>But you _do_ care.</p>",
        "id": 146816456,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445054
    },
    {
        "content": "<p>You need a category  <code>category.{(max u₁ (v₁+1)) v₁} (Xᵒᵖ ⥤ Type v₁)</code></p>",
        "id": 146816472,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445070
    },
    {
        "content": "<p>Ooops... I crashed the machine I was logged into...</p>",
        "id": 146816490,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445096
    },
    {
        "content": "<p>I was working on the <code>sheaf</code> branch.</p>",
        "id": 146816497,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445106
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41\">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/sheaf.lean#L41</a></p>",
        "id": 146816561,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445153
    },
    {
        "content": "<p>But with <code>category.{u1 v1} X</code>, you're going to find <code>Xop \\func Type v1</code> only has a category structure with</p>",
        "id": 146816588,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445185
    },
    {
        "content": "<p>objects in universe <code>max u1 (v1+1)</code> (which is fine)</p>",
        "id": 146816603,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445218
    },
    {
        "content": "<p>and morphisms in universe <code>max u1 v1</code></p>",
        "id": 146816619,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445235
    },
    {
        "content": "<p>which breaks your constraint</p>",
        "id": 146816623,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541445240
    },
    {
        "content": "<p>I see. So now I should convince Lean that it should be looking for a more relaxed constraint...</p>",
        "id": 146816683,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445270
    },
    {
        "content": "<p>First need to build mathlib on a new machine. (What is the emoji for compiling?)</p>",
        "id": 146816844,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445410
    },
    {
        "content": "<p>I propose <span class=\"emoji emoji-1f93a\" title=\"fencing\">:fencing:</span> for compiling because of <a href=\"https://www.xkcd.com/303/\" target=\"_blank\" title=\"https://www.xkcd.com/303/\">https://www.xkcd.com/303/</a></p>",
        "id": 146817011,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541445573
    },
    {
        "content": "<p>I guess this is one of the points where one uses universes in a more serious way</p>",
        "id": 146817352,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541445870
    },
    {
        "content": "<p>is this what representable functors are for?</p>",
        "id": 146817488,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1541445982
    },
    {
        "content": "<p>In math one could just pass to a universe in which X is a small category</p>",
        "id": 146817526,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446020
    },
    {
        "content": "<blockquote>\n<p>is this what representable functors are for?</p>\n</blockquote>\n<p>They're used in the Fermat's Last Theorem proof to produce rings out of thin air.</p>",
        "id": 146817571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446063
    },
    {
        "content": "<p>I think your options are</p>\n<ul>\n<li>Assume <code>X</code> is a <code>small_category.{v_1}</code></li>\n<li>Have <code>sieve</code> take values in presheaves valued in <code>Type (max u_1 v_1)</code></li>\n<li>Redesign limits so that you can talk about the limit of a <code>w</code>-sized diagram in a <code>category.{u v}</code> (but I don't think this sounds like a good idea)</li>\n</ul>",
        "id": 146817863,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446309
    },
    {
        "content": "<p>The first two are both versions of the math \"just pick a universe in which X looks small\", and it's a matter of where you want to put that shift of universe</p>",
        "id": 146817945,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446383
    },
    {
        "content": "<p>The fpqc topology has some issues with large limits. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> are you planning on writing something sufficently general to deal with the fpqc topology?</p>",
        "id": 146817951,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446391
    },
    {
        "content": "<p>Yes.</p>",
        "id": 146817961,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541446412
    },
    {
        "content": "<p>I want to do sheaves in the biggest generality possible.</p>",
        "id": 146817974,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541446427
    },
    {
        "content": "<p>Conrad would argue that the fpqc topology \"does not exist\"</p>",
        "id": 146817983,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446439
    },
    {
        "content": "<p>I think I'll go for option 2.</p>",
        "id": 146817984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541446440
    },
    {
        "content": "<p>Are they actual issues or just issues for people who don't believe in universes?</p>",
        "id": 146817988,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446442
    },
    {
        "content": "<p>I don't fully understand the issues</p>",
        "id": 146818048,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446484
    },
    {
        "content": "<p>I think a little bit of both. You need to do resizing at some point. Like we were discussing <code>kappa</code>-small stuff a while ago.</p>",
        "id": 146818056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541446500
    },
    {
        "content": "<p>I think if you express any topology other than the Zariski one naturally in Lean it will have the same issues as the fpqc topology--otherwise you will need to manually replace your category with an essentially equivalent small one</p>",
        "id": 146818087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446531
    },
    {
        "content": "<p>I do understand that the issue with an fpqc cover is that you can't make a set of all fpqc covers</p>",
        "id": 146818088,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446533
    },
    {
        "content": "<p>I'm not sure this is accurate Reid</p>",
        "id": 146818107,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446555
    },
    {
        "content": "<p>With the etale topology there is in some formal sense not a set of etale covers</p>",
        "id": 146818172,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446587
    },
    {
        "content": "<p>but there is a set of etale covers such that every etale cover is isomorphic to a cover in your set</p>",
        "id": 146818174,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446588
    },
    {
        "content": "<p>with fpqc the problem is genuinely worse</p>",
        "id": 146818187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446606
    },
    {
        "content": "<p>because an arbitrary morphism of fields is fpqc</p>",
        "id": 146818188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446606
    },
    {
        "content": "<p>so there is not even a set of isomorphism classes of etale covers of spec(field)</p>",
        "id": 146818203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446621
    },
    {
        "content": "<p>I don't know whether thinking about things in a more universey way makes these two problems become the same</p>",
        "id": 146818256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446672
    },
    {
        "content": "<p>but in ZFC I've always had the impression that they were not the same</p>",
        "id": 146818305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446686
    },
    {
        "content": "<p>Right, that is what I mean--you would not be able to define etale covers as just \"a scheme with an etale map to X\", because that will live in a too large universe--you need to manually replace the category with an equivalent small one with some kind of cardinality argument</p>",
        "id": 146818326,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446707
    },
    {
        "content": "<p>right</p>",
        "id": 146818343,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446718
    },
    {
        "content": "<p>but you can't do that for fpqc</p>",
        "id": 146818352,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446724
    },
    {
        "content": "<p>right</p>",
        "id": 146818363,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446737
    },
    {
        "content": "<p>so there are two kinds of issues which could arise then</p>",
        "id": 146818411,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446768
    },
    {
        "content": "<p>one is if you don't accept the universe axiom, then you can't talk about such large collections like the category of sheaves for the fpqc topology on X at all</p>",
        "id": 146818486,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446806
    },
    {
        "content": "<p>I believe Conrad is strictly ZFC so rejects the fpqc topology</p>",
        "id": 146818510,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541446828
    },
    {
        "content": "<p>but that's not an issue if you do accept universes</p>",
        "id": 146818514,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I pushed my (inconclusive) changes to the sheaf branch. Now my dog insists on a walk (in the rain).</p>",
        "id": 146818575,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541446889
    },
    {
        "content": "<p>but then a second issue which might come up is: you need to take a limit of sets or something, but because the indexing diagram of the limit is large it could take you outside the category you called Set. And that is a real issue even if you believe in universes</p>",
        "id": 146818580,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541446895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks! I'll take a look!</p>",
        "id": 146819009,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541447169
    },
    {
        "content": "<p>Looking through old emails I've exchanged with Conrad on the fpqc matter, he basically says \"fppf is enough for everything, and anyone who wants to work with fpqc -- well, that's their problem, and they can work out the details for themselves\"</p>",
        "id": 146819201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541447350
    },
    {
        "content": "<p>Another possible approach is <a href=\"https://ncatlab.org/nlab/show/small+presheaf\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/small+presheaf\">https://ncatlab.org/nlab/show/small+presheaf</a></p>",
        "id": 146819571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541447644
    },
    {
        "content": "<p>I think you can also think of this as like Ind, but with no restriction on the indexing diagrams you allow</p>",
        "id": 146819792,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541447867
    },
    {
        "content": "<p>However I don't know whether this is useful for applications in algebraic geometry</p>",
        "id": 146819837,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541447889
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/large+site\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/large+site\">https://ncatlab.org/nlab/show/large+site</a> is a not particularly encouraging page</p>",
        "id": 146819848,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541447915
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Hmmzz, I'm not really making any progress...</p>",
        "id": 146820504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541448570
    },
    {
        "content": "<p>I expect you will have other problems, too <span class=\"emoji emoji-1f642\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 146820515,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541448589
    },
    {
        "content": "<p>/me is not designed to think about universe issues...</p>",
        "id": 146820521,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541448597
    },
    {
        "content": "<p>What do you think is the best solution for now? Making <code>X</code> small?</p>",
        "id": 146820597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541448630
    },
    {
        "content": "<p>certainly easiest for the time being</p>",
        "id": 146820648,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541448671
    },
    {
        "content": "<p>and you don't really lose any generality</p>",
        "id": 146820668,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541448697
    },
    {
        "content": "<p>Ok, then I'll leave the headaches for the sheaves refactor that Mario will work on next summer (-;</p>",
        "id": 146820672,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541448702
    },
    {
        "content": "<p>I think your next problem was going to be: you have some coproducts indexed on a <code>Type v_1</code>, but now the morphism size is <code>max u_1 v_1</code></p>",
        "id": 146820747,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541448754
    },
    {
        "content": "<p>so you would need to add some <code>ulift</code> to align them</p>",
        "id": 146820750,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541448764
    },
    {
        "content": "<p>You're completely right.</p>",
        "id": 146821056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541449054
    },
    {
        "content": "<p>So I want my indexing type to be <em>small</em> small</p>",
        "id": 146821111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541449093
    },
    {
        "content": "<p>In which universe should the indexing type of a covering family live?</p>",
        "id": 146821132,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541449133
    },
    {
        "content": "<p><code>max u_1 v_1</code>?</p>",
        "id": 146821143,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541449150
    },
    {
        "content": "<p>I thought you were going to make X small instead</p>",
        "id": 146821152,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541449178
    },
    {
        "content": "<p>so u_1 = v_1</p>",
        "id": 146821157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541449183
    },
    {
        "content": "<p>if not, then I'm not sure</p>",
        "id": 146821163,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541449189
    },
    {
        "content": "<p>Yes, I am going to do that. So then I should just take <code>u_1</code>, right?</p>",
        "id": 146821344,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541449330
    },
    {
        "content": "<p>Whatever the universe level of X is. It seems we tend to call it <code>v</code> in <code>category_theory</code></p>",
        "id": 146821455,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541449463
    },
    {
        "content": "<p>Well, or <code>u</code></p>",
        "id": 146821697,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541449732
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Wouldn't it be useful to have <code>has_pullbacks_of_has_limits</code> be an instance in general?</p>",
        "id": 146823630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541451695
    },
    {
        "content": "<p>I'm afraid of doing that before we know that the pullbacks thus produced are \"nice enough\".</p>",
        "id": 146823698,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541451739
    },
    {
        "content": "<p>Ok, I see.</p>",
        "id": 146823713,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541451765
    },
    {
        "content": "<p>I suspect that you'll only want that instance \"in desperation\", when you don't have access to a construction of pullbacks that is defeq to something easier to work with than the general limit.</p>",
        "id": 146823719,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541451773
    },
    {
        "content": "<p>Hmmm, ok</p>",
        "id": 146823743,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541451803
    },
    {
        "content": "<p>So now I've made two small edits to <code>sheaf</code>.</p>",
        "id": 146823759,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541451827
    },
    {
        "content": "<p>Do you have a minute to look at the errors that remain? I'm very bad at fighting these universe issues.</p>",
        "id": 146823819,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541451855
    },
    {
        "content": "<p>hah, we've been duplicating effort :-)</p>",
        "id": 146824066,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541452137
    },
    {
        "content": "<p>Well, I didn't do much...</p>",
        "id": 146824201,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541452281
    },
    {
        "content": "<p>Do you think the library is ready for this? Or am I making too big a jump?</p>",
        "id": 146824312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541452386
    },
    {
        "content": "<p>We're almost there. :-)</p>",
        "id": 146824367,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541452444
    },
    {
        "content": "<p>And this is exactly the sort of stress testing of limits that we need.</p>",
        "id": 146824419,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541452458
    },
    {
        "content": "<p>I committed a little, but it's still badly broken, and I have to get the kids to school/me to work.</p>",
        "id": 146824431,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541452476
    },
    {
        "content": "<p>Sure, those are more important than silly sheaves (-;</p>",
        "id": 146824449,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541452496
    },
    {
        "content": "<p>See you later</p>",
        "id": 146824459,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541452502
    },
    {
        "content": "<p>I've just been reading SGA4 in the bath</p>",
        "id": 146824782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452784
    },
    {
        "content": "<p>As you do</p>",
        "id": 146824788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452788
    },
    {
        "content": "<p>And very early on when talking about limits and colimits</p>",
        "id": 146824860,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452815
    },
    {
        "content": "<p>They assume that the diagram is u-small</p>",
        "id": 146824888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452840
    },
    {
        "content": "<p>ie isomorphic to an element of the universe u</p>",
        "id": 146824928,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452876
    },
    {
        "content": "<p>Their categories are u-categories</p>",
        "id": 146824964,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452900
    },
    {
        "content": "<p>Ie hom sets are all in u</p>",
        "id": 146824981,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452915
    },
    {
        "content": "<p>But the limits are over u-small diagrams consistently</p>",
        "id": 146825039,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541452939
    },
    {
        "content": "<p>Example theorem : the category of u-abelian groups has u-limits. This <em>means</em> that you take the category  whose objects are abelian groups in some universe, and then take a limit but only over a category which is itself an <em>element</em> of u</p>",
        "id": 146825391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541453280
    },
    {
        "content": "<p>That's essentially our setup too, see <a href=\"https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22\">https://github.com/leanprover-community/mathlib/blob/limits-others-new/category_theory/limits/limits.lean#L21-L22</a></p>",
        "id": 146825626,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541453492
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> In things like <code>coequalizer.desc</code> should the argument <code>w</code> get an auto_param <code>obviously</code>?</p>",
        "id": 146826137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541453984
    },
    {
        "content": "<p>Yes, that seems plausible.</p>",
        "id": 146826530,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541454302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I just pushed some more silly stuff. Didn't make fundamental progress.</p>",
        "id": 146826939,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541454649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I don't think <code>functor.const</code> should be in <code>cones</code>. It is more fundamental. Should this be moved to <code>functor</code> or something?</p>",
        "id": 146850316,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541489857
    },
    {
        "content": "<p>Sounds good.</p>",
        "id": 146851045,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1541491139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> did you ever find a setup for typing the functor arrow in emacs?</p>",
        "id": 147440403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1541869694
    },
    {
        "content": "<p>Nah, haven't looked into it yet. Sorry. Maybe some other emacs user can tell us how to fix this. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> ?</p>",
        "id": 147442348,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541873087
    },
    {
        "content": "<p>The input abbreviations for emacs are defined here: <a href=\"https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407\" target=\"_blank\" title=\"https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407\">https://github.com/leanprover/lean-mode/blob/9d6b8471e2044310b4cd7cd3213b1fc8f78ec499/lean-input.el#L407</a>  It should be straightforward to submit a PR adding the new arrows (you might also want to add Scott's calligraphic symbols).</p>",
        "id": 147442884,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1541874072
    },
    {
        "content": "<p>These are the relevant changes in the vscode extension:<br>\n<code>\\McB</code>, etc. <a href=\"https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12\">https://github.com/leanprover/vscode-lean/commit/46ef6b277f4b90ef440730e3b2f73f9381aa08b0#diff-7c2385f0b8db521fe81e3d20489e5f12</a><br>\n<code>\\bbA</code>, etc. <a href=\"https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12\">https://github.com/leanprover/vscode-lean/commit/0080ed0f7c80b199abf31212a7eb9356d3cbc896#diff-7c2385f0b8db521fe81e3d20489e5f12</a><br>\n<code>\\functor</code> <a href=\"https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12\" target=\"_blank\" title=\"https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12\">https://github.com/leanprover/vscode-lean/commit/d3988d9fae1ab4a7e4785486a08c5eddcd33c575#diff-7c2385f0b8db521fe81e3d20489e5f12</a></p>",
        "id": 147443005,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1541874302
    },
    {
        "content": "<p>In the long term, we might want to have a common source for these abbreviations that is shared by the editor extensions.</p>",
        "id": 147443017,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1541874337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Thanks a lot for the links! Once I find some time, I hope to add a PR.</p>",
        "id": 147443021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541874347
    },
    {
        "content": "<p>Do we know that composition of functors is associative? I can't find it...</p>",
        "id": 147739528,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542287092
    },
    {
        "content": "<p>I don't think so, but it is true by defeq at least</p>",
        "id": 147739654,
        "sender_full_name": "Reid Barton",
        "timestamp": 1542287235
    },
    {
        "content": "<p>I see. So I guess this should be added sooner rather than later.</p>",
        "id": 147739865,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542287486
    },
    {
        "content": "<p>It's in <code>lean-category-theory</code>, under <code>functor_categories/isomorphisms.lean</code>.</p>",
        "id": 147768822,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542311773
    },
    {
        "content": "<p>At least -- it constructs the equality as a natural isomorphism.</p>",
        "id": 147768830,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542311786
    },
    {
        "content": "<p>I thought it would be good to also prove the the unitors and associator for functors satisfy the triangles and pentagon equations, but didn't do that.</p>",
        "id": 147768858,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542311815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, it turned out this was easy to do, so there's a new PR adding unitors and associators for functors, as well as checking the pentagon and triangle. (These will be necessary one day when we want an example of a 2-category!)</p>",
        "id": 147772079,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542314743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  I have a question about yoneda. I find the <code>yoneda.lean</code> file a bit confusing. Is there an easy way to extract that <code>F.obj U</code> is canonically the same as <code>yoneda.obj  ⟹ F</code>, where <code>U : X</code> and <code>F : presheaf X</code>? Or is this something that we have to add to this file?</p>",
        "id": 147797409,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542346559
    },
    {
        "content": "<p>In the adjunctions branch I just sort of ignored most of the contents of <code>yoneda.lean</code> and added an <code>equiv</code> which I could actually understand</p>",
        "id": 147797624,
        "sender_full_name": "Reid Barton",
        "timestamp": 1542346929
    },
    {
        "content": "<p>though I feel this approach isn't ideal either</p>",
        "id": 147797631,
        "sender_full_name": "Reid Barton",
        "timestamp": 1542346963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I don't think this is in your Yoneda file in an equivalent form, is it?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">yoneda_sections</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">yoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span> <span class=\"err\">⟹</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">yoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span> <span class=\"err\">⟹</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"n\">U</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"k\">show</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span> <span class=\"bp\">→</span> <span class=\"n\">yoneda</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">U</span> <span class=\"err\">⟹</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"bp\">_</span> <span class=\"bp\">→</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">V</span><span class=\"o\">,</span> <span class=\"k\">from</span> <span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">i</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n    <span class=\"n\">naturality&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">V₁</span> <span class=\"n\">V₂</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span><span class=\"bp\">;</span> <span class=\"n\">erw</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map_comp</span><span class=\"bp\">;</span> <span class=\"n\">tidy</span> <span class=\"o\">},</span>\n  <span class=\"n\">hom_inv_id&#39;</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">ext</span> <span class=\"n\">α</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">,</span>\n    <span class=\"n\">tidy</span> <span class=\"o\">{</span><span class=\"n\">trace_result</span> <span class=\"o\">:=</span> <span class=\"n\">tt</span><span class=\"o\">},</span>\n    <span class=\"k\">have</span> <span class=\"o\">:=</span> <span class=\"n\">congr</span> <span class=\"o\">(</span><span class=\"n\">α</span><span class=\"bp\">.</span><span class=\"n\">naturality</span> <span class=\"n\">i</span><span class=\"o\">),</span>\n    <span class=\"n\">dsimp</span> <span class=\"n\">at</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"err\">←</span><span class=\"o\">(</span><span class=\"n\">this</span> <span class=\"n\">rfl</span><span class=\"o\">),</span>\n    <span class=\"n\">simp</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_hom_id&#39;</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">tidy</span><span class=\"bp\">;</span> <span class=\"n\">erw</span> <span class=\"n\">F</span><span class=\"bp\">.</span><span class=\"n\">map_id</span><span class=\"bp\">;</span> <span class=\"n\">tidy</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>That <code>hom_inv_id'</code> is particularly nasty. Would <code>tidy</code> + <code>rewrite_search</code> be able to deal with that?</p>",
        "id": 147802724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542355761
    },
    {
        "content": "<p>No, we've already got this. This iso is just a component of the natural isomorphism produced in <code>yoneda_lemma</code>.</p>",
        "id": 147803013,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356207
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>@[simp] lemma yoneda_sections (X : C) (F : Cᵒᵖ ⥤ Type v₁) : (yoneda.obj X ⟹ F) ≅ ulift.{u₁} (F.obj X) :=\nnat_iso.app (yoneda_lemma C) (X, F)\n</pre></div>",
        "id": 147803015,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356215
    },
    {
        "content": "<p>should do it.</p>",
        "id": 147803018,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356219
    },
    {
        "content": "<p>If you're already working in a small category you can remove the <code>ulift</code>.</p>",
        "id": 147803027,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356264
    },
    {
        "content": "<p><code>yoneda_lemma</code> is the natural isomorphism between the two functors starting with <code>(X, F)</code>. You can either embed <code>X</code> into presheafs, via the yoneda embedding, and then take hom, or you can just evaluate <code>F</code> on <code>X</code>.</p>",
        "id": 147803088,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356334
    },
    {
        "content": "<p>And</p>\n<div class=\"codehilite\"><pre><span></span>omit 𝒞\ndef ulift_trivial (V : Type u₁) : ulift.{u₁} V ≅ V := by tidy\n\n@[simp] def yoneda_sections_small {C : Type u₁} [small_category C] (X : C) (F : Cᵒᵖ ⥤ Type u₁) : (yoneda.obj X ⟹ F) ≅ F.obj X :=\nnat_iso.app (yoneda_lemma C) (X, F) ≪≫ ulift_trivial _\n</pre></div>\n\n\n<p>gives you the version you want, for small categories.</p>",
        "id": 147803312,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356735
    },
    {
        "content": "<p>Shall I just push this as a separate PR?</p>",
        "id": 147803314,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356750
    },
    {
        "content": "<p>Sorry, it was an obvious omission in writing <code>yoneda.lean</code>, just writing out the main result in components.</p>",
        "id": 147803361,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542356782
    },
    {
        "content": "<p>This is available at <a href=\"https://github.com/leanprover/mathlib/pull/480\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/pull/480\">https://github.com/leanprover/mathlib/pull/480</a>.</p>",
        "id": 147804444,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542358387
    },
    {
        "content": "<p>It depends on the limits PR, because it's not worth backporting, but you're welcome to merge into the <code>sheaf</code> branch.</p>",
        "id": 147804449,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542358408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Ok cool! I kept on struggling with that product category. But this looks really nice!</p>",
        "id": 147827210,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542385103
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Is <code>iso_of_is_iso</code> missing in the library?</p>",
        "id": 147868545,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542440763
    },
    {
        "content": "<p>Yes, lots of iso stuff is missing, that I've just been discovering now. :-)</p>",
        "id": 147868567,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542440784
    },
    {
        "content": "<p>I've been filling it in the monoidal categories repository, which is where I need it immediately.</p>",
        "id": 147868569,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542440807
    },
    {
        "content": "<p>Is it holding you up? I can make yet another PR to mathlib with some improvements to the <code>iso</code> and <code>is_iso</code> interface.</p>",
        "id": 147868576,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542440838
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">iso_of_is_iso</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_iso</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">≅</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"o\">}</span>\n</pre></div>\n\n\n<p>That's whay I have at the top of my file now.</p>",
        "id": 147868625,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542440955
    },
    {
        "content": "<p>Ok, if that's keeping you afloat for now, I'll finish up a few things before making a \"fixing isos\" PR. It turns out there are at least a dozen other things missing too. :-)</p>",
        "id": 147868668,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542441022
    },
    {
        "content": "<p>As I'm sure Mario has told us many times before, you actually have to use this stuff!</p>",
        "id": 147868676,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1542441072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I just pushed a whole bunch of stuff to the <code>sheaf</code> branch. If you want more data points for how stuff is used...</p>",
        "id": 147869737,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542443354
    },
    {
        "content": "<p>I'm gathering stuff that should move elsewhere at the top of the file. If it fits into PRs that you are preparing, please take it.</p>",
        "id": 147869739,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1542443396
    },
    {
        "content": "<blockquote>\n<p>I do understand that the issue with an fpqc cover is that you can't make a set of all fpqc covers</p>\n</blockquote>\n<p>The issue is that there is not even a set of fpqc covers whose elements refine all possible fpqc covers, whereas for fppf and coarser this is true, even when there's not a set of isomorphism classes of covers. This is a genuine problem, and there is a model of ZF whose category of sets forms a large site with this 'feature' (with covers=surjective functions).</p>",
        "id": 148077160,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1542757332
    },
    {
        "content": "<p>One can of course consider whether a given presheaf is a fpqc sheaf or not, but forget trying to fpcq-sheafify in general. The hypotheses of the general adjoint functor theorem are not satisfied, so one cannot construct the left adjoint to Sh_fpqc(Aff) --&gt; PreSh(Aff).</p>",
        "id": 148077261,
        "sender_full_name": "David Michael Roberts",
        "timestamp": 1542757455
    },
    {
        "content": "<p>I currently have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_left_id</span> <span class=\"o\">:</span> <span class=\"n\">map_left</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">nat_trans</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"bp\">_</span> <span class=\"o\">}</span> <span class=\"o\">},</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">app</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"o\">{</span> <span class=\"n\">left</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right</span> <span class=\"o\">:=</span> <span class=\"mi\">𝟙</span> <span class=\"bp\">_</span> <span class=\"o\">}</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>but that is a worthless simp-lemma because of <code>≅</code>. I think that in fact equality should hold:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_left_id&#39;</span> <span class=\"o\">:</span> <span class=\"n\">map_left</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">nat_trans</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"n\">L</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>But I have no idea how to prove that two terms of a structure are equal. Is it true that they are equal if all their fields are equal? Is this somewhere in mathlib?</p>",
        "id": 148639830,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543327818
    },
    {
        "content": "<p>This is generally what extensionality lemmas do... but you're probably going to have a bad time working with equality of functors</p>",
        "id": 148640013,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543328036
    },
    {
        "content": "<p>what's <code>map_left</code>?</p>",
        "id": 148640081,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543328093
    },
    {
        "content": "<p>Never mind, I figured it out from one of your other messages</p>",
        "id": 148640129,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543328156
    },
    {
        "content": "<p>Not sure it will help, but your question looks like the classic:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">johan</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">aone</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">johan</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">johan</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"bp\">.</span><span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span><span class=\"bp\">.</span><span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">=</span> <span class=\"n\">Y</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n  <span class=\"n\">congr</span> <span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 148640189,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543328206
    },
    {
        "content": "<p>sorry about the silly example, but I wanted a structure including at least one data and one proof field</p>",
        "id": 148640204,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543328250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> Thanks, I should have thought about <code>cases</code>.</p>",
        "id": 148640336,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543328369
    },
    {
        "content": "<p>I think what you have now is the best way</p>",
        "id": 148640349,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543328387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Well, but working with natural isomorphisms is also a massive pain atm.</p>",
        "id": 148640352,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543328390
    },
    {
        "content": "<p>I guarantee it is not as bad as rewriting morphisms across equalities of objects and then trying to reason about the result</p>",
        "id": 148640456,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543328489
    },
    {
        "content": "<p>We should really setup a FAQ somewhere</p>",
        "id": 148640556,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1543328584
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I have no idea if this makes any sense, but I regularly get errors like these:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">colimit</span><span class=\"bp\">.</span><span class=\"n\">pre_map</span> <span class=\"o\">(</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"err\">⋙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">((</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">map_right_id&#39;</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">hom</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"o\">(</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">map_right_id&#39;</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">map_right</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"err\">⟶</span> <span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">id</span> <span class=\"o\">(</span><span class=\"n\">comma</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span>\n        <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"err\">?</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n        <span class=\"n\">v</span>\n        <span class=\"err\">?</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">⟹</span> <span class=\"err\">?</span><span class=\"n\">m_4</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span>\n</pre></div>\n\n\n<p>Would it help to just get rid of the notation <code>⟹</code>, and always speak of natural transformations as homs in the functor category?</p>",
        "id": 148662831,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543348099
    },
    {
        "content": "<p>Or is this a stupid universe issue again? (I just realise there are annoying <code>?</code> in the error...)</p>",
        "id": 148662863,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543348137
    },
    {
        "content": "<p>Ok, never mind. It's a universe issue.</p>",
        "id": 148662980,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543348244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> how do you get that many colours</p>",
        "id": 148664964,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1543350038
    },
    {
        "content": "<p>I had <code>less</code> syntax, instead of <code>lean</code> <span class=\"emoji emoji-1f643\" title=\"upside down\">:upside_down:</span> <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span></p>",
        "id": 148665094,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543350176
    },
    {
        "content": "<blockquote>\n<p>I guarantee it is not as bad as rewriting morphisms across equalities of objects and then trying to reason about the result</p>\n</blockquote>\n<p>Yes. This. Please don't prove equalities between functors, you are just setting yourself up for suffering.</p>",
        "id": 148666324,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543351212
    },
    {
        "content": "<blockquote>\n<p>Would it help to just get rid of the notation <code>⟹</code>, and always speak of natural transformations as homs in the functor category?</p>\n</blockquote>\n<p>I have actually wondered about this too, after a few minor annoyances involving the difference between <code>nat_trans.vcomp</code> and <code>category.comp</code>.</p>",
        "id": 148670683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543355407
    },
    {
        "content": "<p>It's hard to predict which one you will get once you start talking about colimits in categories of presheaves, as Johan has probably also experienced.</p>",
        "id": 148670713,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543355457
    },
    {
        "content": "<p>It might be a rather invasive change though, or even not workable for some reason</p>",
        "id": 148671054,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543355871
    },
    {
        "content": "<p>I've experienced the same pain, but haven't tried removing <code>⟹</code>. It seems a reasonable experiment, however.</p>",
        "id": 148673378,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543357996
    },
    {
        "content": "<p>I don't like the idea of setting myself up for suffering.</p>",
        "id": 148696347,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392722
    },
    {
        "content": "<p>But I'm suffering hard at the moment.</p>",
        "id": 148696378,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392730
    },
    {
        "content": "<p>After all <code>functor.id ⋙ F</code> is not defeq to <code>F</code>, and so we need some natural isomorphisms, and I just get the general feeling that we are walking headfirst into nasty 2-categorical territory.</p>",
        "id": 148696393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392784
    },
    {
        "content": "<p>Because, say what you like, but Lean isn't very good at working with the canonical natural isomorphism between <code>functor.id ⋙ F</code> and <code>F</code>.</p>",
        "id": 148696399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392841
    },
    {
        "content": "<p>I've got the following context:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n<span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">small_category</span> <span class=\"n\">C</span><span class=\"o\">,</span>\n<span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">,</span>\n<span class=\"err\">𝒟</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">has_colimits</span> <span class=\"n\">D</span><span class=\"o\">,</span>\n<span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">C</span>\n<span class=\"err\">⊢</span> <span class=\"n\">colimit</span><span class=\"bp\">.</span><span class=\"n\">pre</span> <span class=\"o\">(</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"err\">⋙</span> <span class=\"n\">F</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">map_right</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">)))</span> <span class=\"bp\">=</span>\n    <span class=\"mi\">𝟙</span> <span class=\"o\">(</span><span class=\"n\">colimit</span> <span class=\"o\">(</span><span class=\"n\">comma</span><span class=\"bp\">.</span><span class=\"n\">fst</span> <span class=\"n\">yoneda</span> <span class=\"o\">(</span><span class=\"n\">functor</span><span class=\"bp\">.</span><span class=\"n\">of_obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"err\">⋙</span> <span class=\"n\">F</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p>This might look a bit daunting, but <code>(comma.map_right yoneda (𝟙 (functor.of_obj X)))</code> is naturally isomorphic to <code>functor.id _</code></p>",
        "id": 148696451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I'm really lost here. The maths is trivial. But Lean is fighting back hard.</p>",
        "id": 148696511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543392976
    },
    {
        "content": "<p>Want to point me to a file and a commit?</p>",
        "id": 148696896,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543393632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <a href=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69\">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/presheaf.lean#L69</a></p>",
        "id": 148697034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543393857
    },
    {
        "content": "<p>Maybe I still don't know how to let the library do the heavy lifting for me...</p>",
        "id": 148697048,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543393889
    },
    {
        "content": "<p>woah, checking out that branch is like stepping into the future. adjunctions, cocompletions, groupoids, oh my.</p>",
        "id": 148697316,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394329
    },
    {
        "content": "<p>Well, most of that is by Reid.</p>",
        "id": 148697393,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543394420
    },
    {
        "content": "<p>Or I should say: all of <em>that</em> is by Reid.</p>",
        "id": 148697415,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543394486
    },
    {
        "content": "<p>Can we not call functors <code>f</code>, when they could perfectly well be <code>F</code>?</p>",
        "id": 148697497,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394634
    },
    {
        "content": "<p>Also, I feel you're slightly overusing variables. Things like <code>map</code> and <code>map'</code> should have the variable <code>F : C \\func D</code> visible right there at the definition.</p>",
        "id": 148697542,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394670
    },
    {
        "content": "<p>variables are great for implicit arguments, or even the primary argument if they are the sole primary argument for 20 definitions in a row...</p>",
        "id": 148697554,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394703
    },
    {
        "content": "<p>Sure. I was using <code>F</code> for presheaves, but I decided that maybe I shouldn't yet do that.</p>",
        "id": 148697568,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543394751
    },
    {
        "content": "<p>Anyway, you shouldn't look too much at the <code>sheaf.lean</code> file. It will need a major rewrite once I have working presheaves.</p>",
        "id": 148697647,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543394822
    },
    {
        "content": "<p>Lots of stuff doesn't compile?</p>",
        "id": 148697740,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394984
    },
    {
        "content": "<p>In the imports of presheaf.lean</p>",
        "id": 148697742,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543394998
    },
    {
        "content": "<p>Hmmm... I thought those were fine... but maybe stuff broke.</p>",
        "id": 148697786,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395027
    },
    {
        "content": "<p>e.g. limits/limits.lean and adjunctions.lean</p>",
        "id": 148697789,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395037
    },
    {
        "content": "<p>adjunctions probably don't compile</p>",
        "id": 148697815,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395072
    },
    {
        "content": "<p>limits should work, but maybe it broke after I merged in Reid's branch</p>",
        "id": 148697822,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395092
    },
    {
        "content": "<p>Ok, I see the thing you probably need, which is naturality in the second argument of colimit.pre</p>",
        "id": 148697824,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395102
    },
    {
        "content": "<p>I can try to provide you that, and you can try to get stuff to compile :-)</p>",
        "id": 148697831,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395119
    },
    {
        "content": "<p>Ok, so I have <code>colimit.pre_map</code></p>",
        "id": 148697896,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395180
    },
    {
        "content": "<p>yes, but that's naturality in the first argument, which isn't what you need</p>",
        "id": 148697904,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395196
    },
    {
        "content": "<p>But I guess we need to upgrade <code>pre</code> into a functor?</p>",
        "id": 148697907,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395198
    },
    {
        "content": "<p>unfortunately I think that might need to wait for 2-categories, I'm not sure. :-)</p>",
        "id": 148697911,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395215
    },
    {
        "content": "<p>Right... but it is where this stuff is sucking us into, not?</p>",
        "id": 148697919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395241
    },
    {
        "content": "<p>I'm actually not sure where I should do this work. The main <code>limits</code> branch is now a bit stranded, as Reid has been pulling stuff out into separate PRs.</p>",
        "id": 148697960,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395250
    },
    {
        "content": "<p>Doing work on the limits branch now may get orphaned, I'm not sure.</p>",
        "id": 148697966,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395262
    },
    {
        "content": "<p>Maybe dump it into <code>sheafy_preamble</code></p>",
        "id": 148697980,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395292
    },
    {
        "content": "<p>I've been using that file to collect all sorts of facts that I need.</p>",
        "id": 148697995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395320
    },
    {
        "content": "<p>Yeah, I'm worried about that getting orphaned too. :-)</p>",
        "id": 148698006,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395361
    },
    {
        "content": "<p>We're playing a bit fast and loose with our branches at the moment.</p>",
        "id": 148698050,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395371
    },
    {
        "content": "<p>Very much.</p>",
        "id": 148698056,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395379
    },
    {
        "content": "<p>So what exactly is the statement that you are trying to prove?</p>",
        "id": 148698093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, I'd really like to straighten out the limits branches a bit. What is the best way to \"rebase\" (possibly by hand) everything remaining on top of <code>limits-2</code>? Is this a bad thing to want to do?</p>",
        "id": 148698100,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395477
    },
    {
        "content": "<p>No idea :-) I hadn't even started.</p>",
        "id": 148698145,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395493
    },
    {
        "content": "<p>Say we have a natural transformation a : E \\natt E'.</p>",
        "id": 148698181,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395573
    },
    {
        "content": "<p>colim.map (a &gt;&gt;&gt; F) gives a map from colim (E &gt;&gt;&gt; F) to colim (E' &gt;&gt;&gt; F)</p>",
        "id": 148698235,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395610
    },
    {
        "content": "<p>presumably the triangle, obtained by mapping both of those to colim F via colim.pre, commutes?</p>",
        "id": 148698250,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395642
    },
    {
        "content": "<p>So then if a is invertible, we have <code>colim.pre F E = colim.map (a^{-1} &gt;&gt;&gt; F) &gt;&gt; colim.pre F E' &gt;&gt; colim.map (a &gt;&gt;&gt; F)</code>.</p>",
        "id": 148698274,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395714
    },
    {
        "content": "<p>and hopefully now if E' is the identity, as in your case, everything quickly simplifies from there</p>",
        "id": 148698318,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395738
    },
    {
        "content": "<p>So <code>pre_map</code> is saying that this triangle commutes.</p>",
        "id": 148698343,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395805
    },
    {
        "content": "<p>No. <code>pre_map</code> is about changing the functor <code>F</code>, not the functor <code>E</code>.</p>",
        "id": 148698410,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395865
    },
    {
        "content": "<p>But if <code>E' = functor.id _</code> it still doesn't simplify, because <code>functor.id _ &gt;&gt;&gt; F</code> is not <code>F</code>. For example <code>colimit.pre F (functor.id _) = \\b1 (colimit F)</code> does not typecheck <span class=\"emoji emoji-2639\" title=\"sad\">:sad:</span></p>",
        "id": 148698416,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395880
    },
    {
        "content": "<p>I've just been looking at the history of the <code>sheaf</code> branch.</p>",
        "id": 148698417,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395882
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I think you are confusing <code>map_pre</code> and <code>pre_map</code>.</p>",
        "id": 148698433,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395910
    },
    {
        "content": "<p>And ... you're up shit creek without a paddle. :-)</p>",
        "id": 148698437,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395927
    },
    {
        "content": "<p><code>pre_map</code> is something I added. It is in <code>sheafy_preamble.lean</code></p>",
        "id": 148698441,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395932
    },
    {
        "content": "<p>Getting <code>sheaf</code> back on top of master after <code>limits-2</code> is merged is going to suck.</p>",
        "id": 148698445,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395945
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I will probably just copy-paste stuff into a new branch...</p>",
        "id": 148698488,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543395975
    },
    {
        "content": "<p>I'm looking at</p>\n<div class=\"codehilite\"><pre><span></span>lemma colimit.pre_map {K : Type v} [small_category K] [has_colimits_of_shape K C] (E : K ⥤ J) :\n  colimit.pre F E ≫ colim.map α = colim.map (whisker_left E α) ≫ colimit.pre G E :=\nby ext; rw [←assoc, colimit.ι_pre, colim.ι_map, ←assoc, colim.ι_map, assoc, colimit.ι_pre]; refl\n</pre></div>\n\n\n<p>in <code>limits-2</code>.</p>",
        "id": 148698489,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543395975
    },
    {
        "content": "<p>I see. But yes, your <code>pre_map</code> is what we need. :-)</p>",
        "id": 148698507,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396029
    },
    {
        "content": "<p>Aaahrg... so the names have changed...</p>",
        "id": 148698523,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396067
    },
    {
        "content": "<p>What is called <code>pre_map</code> in <code>limits-2</code> used to be <code>map_pre</code> on your old limits branch.</p>",
        "id": 148698565,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396089
    },
    {
        "content": "<p>Ok, so in <code>presheaf.lean</code> you can see that I already <code>erw</code>d the <code>pre_map</code>-thingy.</p>",
        "id": 148698572,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396110
    },
    {
        "content": "<p>I see. :-) Reid must have fixed it. :-) As I said, up a creek! :-)</p>",
        "id": 148698574,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396113
    },
    {
        "content": "<p>Well, I can't see that, because nothing compiles. :-)</p>",
        "id": 148698581,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396129
    },
    {
        "content": "<p>So, you need to keep the <code>colim.map</code> in there for the unitor.</p>",
        "id": 148698603,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396174
    },
    {
        "content": "<p>Sorry, I need to run to a seminar...</p>",
        "id": 148698613,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396198
    },
    {
        "content": "<p>And I'm sorry that stuff doens't compile. I still have some sort of interactive VScode when I work on this...</p>",
        "id": 148698663,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396218
    },
    {
        "content": "<p>Maybe I should just wait till limits are merged, and then start from scratch.</p>",
        "id": 148698669,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543396235
    },
    {
        "content": "<p>You just want to know that</p>\n<div class=\"codehilite\"><pre><span></span>colimit.pre F (functor.id _) = colimit.map (left_unitor F)\n</pre></div>\n\n\n<p>(that's not meant to be real code).</p>",
        "id": 148698678,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396250
    },
    {
        "content": "<p>Okay, in any case, keep bugging me about this. I'd both like to help, and like to see the resolution. I think it's going to be fine. :-)</p>",
        "id": 148698746,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543396348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Thanks for all your comments. I'll see if I can make any progress.</p>",
        "id": 148704306,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543403192
    },
    {
        "content": "<p>Oh yeah, I noticed all the <code>limit.</code> lemmas had names of the form <code>limit.foo_bar</code> if the left-hand side looked like <code>limit.foo ... &gt;&gt; limit.bar ...</code>, and so I reversed the components of all the names of the corresponding <code>colimit</code> lemmas because they have the composition on the left-hand side in the other order.</p>",
        "id": 148708825,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543409213
    },
    {
        "content": "<p>Actually I just copied and pasted the limit lemmas to make colimit versions, I ignored whatever was there before (which I think was not a full set of matching lemmas)</p>",
        "id": 148708855,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543409256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I fixed a bunch of compile issues, which we due to <code>functor.const</code> being picked from the wrong namespace (even though <code>category_theory</code> seems to be open). I really hope Lean 4 will kick a lot of these things out of the root namespace, because these conflicts are quite annoying.</p>",
        "id": 148709058,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543409472
    },
    {
        "content": "<p>Yeah I encountered that same <code>functor.const</code> issue too, not sure what caused it to crop up suddenly</p>",
        "id": 148709086,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543409522
    },
    {
        "content": "<p>Does @[priority] affect that kind of resolution?</p>",
        "id": 148709263,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1543409706
    },
    {
        "content": "<p>I can try to produce a rebased version of my <code>adjunctions</code> branch, that shouldn't take too long.</p>",
        "id": 148710423,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543411124
    },
    {
        "content": "<p>It looks like Johan has mostly just been working on one file, so probably easiest to just copy the <code>sheaf</code> branch into a new branch indeed</p>",
        "id": 148712087,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543412926
    },
    {
        "content": "<p>Oh, also the specific shape limit stuff isn't in <code>limits-2</code> yet. I do have a copy that at least builds on top of <code>limits-2</code> though, so I can push that somewhere as a temporary measure for you, Johan</p>",
        "id": 148712367,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543413234
    },
    {
        "content": "<p>Ooh, don't worry too much about this</p>",
        "id": 148712439,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543413290
    },
    {
        "content": "<p>I think it's best to fix it after <code>limits-2</code> is merged.</p>",
        "id": 148712447,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543413302
    },
    {
        "content": "<p>Ah, fair enough. I'll hold off on these things then</p>",
        "id": 148712710,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543413542
    },
    {
        "content": "<p>I'm very confused about <a href=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156\">https://github.com/leanprover-community/mathlib/blob/sheaf/category_theory/commas.lean#L155-L156</a><br>\nI thought I understood <code>rfl</code> by now. But apparently this is not <code>rfl</code>. If someone can explain this mystery, I would be very grateful.</p>",
        "id": 148720854,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543420093
    },
    {
        "content": "<p><code>map_right_id'</code> should be a <code>def</code>.  Theorems don't unfold (except for special circumstances / options).</p>",
        "id": 148721486,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1543420305
    },
    {
        "content": "<p>Aaah, it should certainly be a <code>def</code>. Let me try again.</p>",
        "id": 148721547,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543420339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> Cool! Now it works.</p>",
        "id": 148721603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543420404
    },
    {
        "content": "<p>Computer scientists have such weird ideas about what a theorem is :-)</p>",
        "id": 148727291,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1543425133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I suggest we replace <code>of_obj</code> with <code>of.obj</code> after defining</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">functor</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒞</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"err\">⥤</span> <span class=\"o\">(</span><span class=\"n\">punit</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">const</span> <span class=\"n\">punit</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">of</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">obj_obj</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">obj_map</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"mi\">𝟙</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">map_app</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">of</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"bp\">=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"kn\">end</span> <span class=\"n\">of</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">functor</span>\n</pre></div>\n\n\n<p>Is that ok?</p>",
        "id": 148728262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543425944
    },
    {
        "content": "<p>Yes, that seems sensible</p>",
        "id": 148728479,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543426094
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I fixed a bunch of compile issues, which we due to <code>functor.const</code> being picked from the wrong namespace (even though <code>category_theory</code> seems to be open). I really hope Lean 4 will kick a lot of these things out of the root namespace, because these conflicts are quite annoying.</p>\n</blockquote>\n<p>If someone could track this down, it would be super helpful. I'm not sure what changed here.</p>",
        "id": 148748886,
        "sender_full_name": "Reid Barton",
        "timestamp": 1543444067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Do you think we need something like this? I find it extremely annoying that Lean refuses some of my morphisms because the come from an opposite category. I understand why Lean complains, but getting it to accept the arrow is extremely annoying. This might help...</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n<span class=\"n\">include</span> <span class=\"err\">𝒞</span>\n\n<span class=\"n\">def</span> <span class=\"n\">op</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">_</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">opposite</span> <span class=\"n\">Y</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n<span class=\"n\">def</span> <span class=\"n\">deop</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"err\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"bp\">_</span> <span class=\"err\">𝒞</span> <span class=\"n\">Y</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">f</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">op_deop</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">op</span><span class=\"bp\">.</span><span class=\"n\">deop</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">deop_op</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"err\">ᵒᵖ</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">deop</span><span class=\"bp\">.</span><span class=\"n\">op</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">hom</span>\n</pre></div>",
        "id": 148861225,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543584781
    },
    {
        "content": "<p>This sounds fine to me. I agree dealing with opposites is gross. :-(</p>",
        "id": 148898413,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543621890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> Have you had similar experiences? What is your opinion on my proposed solution?</p>",
        "id": 150778353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543851504
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>, I am experimenting with making <code>op</code> irreducible, and thus _requiring_ the use of <code>op</code> or <code>deop</code> (and corresponding <code>op_obj</code> and <code>deop_obj</code> on objects).</p>",
        "id": 150835179,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543917309
    },
    {
        "content": "<p>It is slightly grosser, but I think we've all discovered that too much can go mysteriously wrong with the current implementation of opposites.</p>",
        "id": 150835194,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543917334
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Aah, that sounds like a good idea!</p>",
        "id": 150835467,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543917640
    },
    {
        "content": "<p>I hadn't thought about making it irreducible. Those boundaries are useful, but I'm not yet aware of how to make the system help us.</p>",
        "id": 150835496,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543917685
    },
    {
        "content": "<p>So yes, I think it is very good if we have to be explicit about <code>op</code>ing and <code>deop</code>ing.</p>",
        "id": 150835503,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543917705
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover/mathlib/issues/510\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/issues/510\">#510</a></p>",
        "id": 150840492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1543923025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> Looks good to me. I do wonder if we can remove the <code>_obj</code> suffix to make things a bit shorter. We could rename the existing <code>op</code> to <code>op_cat</code>.</p>",
        "id": 150841470,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543924396
    },
    {
        "content": "<p>I think this is a good PR, but I regret that a lot of stuff is also becoming somewhat uglier.</p>",
        "id": 150841491,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1543924439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernandez Mir</span> is making me engage with the category theory stuff! Is there a name for this map: <code>(λ f r, f r : (FF.obj x ⟶ FF.obj y) → (FF.obj x → FF.obj y)) </code>? I'm changing a long arrow to a short one. The target of the functor FF is the category <code>CommRing</code>, so I want to take an abstract element of the hom set and actually produce the ring hom. There's a coercion that does it magically, but I actually have a set of abstract homs and want a set of concrete homs and I have to feed <code>set.image</code> something.</p>",
        "id": 151459647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544547227
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Could you provide slightly more context? I typically get away without doing anything.</p>",
        "id": 151461302,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544548703
    },
    {
        "content": "<p>We had a functor <code>FF</code> from a small category <code>J</code> to <code>CommRing</code> and two objects <code>x</code> and <code>y</code> of <code>J</code>, and we wanted the set of maps from <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mi>F</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">FF(x)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathit\">x</span><span class=\"mclose\">)</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>F</mi><mi>F</mi><mo>(</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">FF(y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> coming from <code>J</code>.</p>",
        "id": 151461833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544549198
    },
    {
        "content": "<p>I see, and <code>FF.obj x \\hom FF.obj y</code> is a subtype, but you want a set?</p>",
        "id": 151461946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544549285
    },
    {
        "content": "<p>Is that correct? If so, I think <code>subtype.val</code> would be the function you are looking for.</p>",
        "id": 151461981,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544549330
    },
    {
        "content": "<p>I don't know by heart how <code>CommRing</code> is defined.</p>",
        "id": 151461995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544549351
    },
    {
        "content": "<p>I'm trying to get from <code>category_theory.category.hom R S</code> to <code>R -&gt; S</code></p>",
        "id": 151462204,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544549489
    },
    {
        "content": "<p>I can just evaluate a term of type <code>category_theory.category.hom R S</code> at <code>r</code> and get <code>s : S</code></p>",
        "id": 151462333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544549579
    },
    {
        "content": "<p>but I was wondering what the name of the coercion was, because I needed to refer to the map itself when doing something else.</p>",
        "id": 151462431,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544549643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> On line 90 of <code>category.lean</code> you can find</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"o\">{</span> <span class=\"n\">hom</span>   <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">subtype</span> <span class=\"o\">(</span><span class=\"n\">hom</span> <span class=\"n\">a</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">b</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n</pre></div>\n\n\n<p>(This is in the instance of <code>concrete_category</code> --&gt; <code>category</code>.) So the map you want is called <code>subtype.val</code>.</p>",
        "id": 151465278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544550912
    },
    {
        "content": "<p>I think there is (or should be?) some more high-level name for this, like <code>forget</code></p>",
        "id": 151467554,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544552002
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> That's right. As Reid mentioned, there is a <code>forget</code>ful functor. You will have to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">types</span>\n</pre></div>",
        "id": 151469130,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1544552810
    },
    {
        "content": "<p>Ah that's where it is</p>",
        "id": 151469476,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544552960
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> did you end up using <code>forget</code>? I'm inclined to make its \"C\" argument implicit, would that help or hurt you?</p>",
        "id": 151755507,
        "sender_full_name": "Reid Barton",
        "timestamp": 1544764517
    },
    {
        "content": "<p>I didn't do anything. I was talking about it with Ramon at our last meeting and haven't thought about it since</p>",
        "id": 151758445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544770312
    },
    {
        "content": "<p>I am completely snowed under with teaching and reference writing</p>",
        "id": 151758486,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1544770336
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> sorry I just saw this. I was playing with that code a few days ago and I didn't manage to make it work with forget. What is the \"C\" argument meant to be?</p>",
        "id": 152438280,
        "sender_full_name": "Ramon Fernandez Mir",
        "timestamp": 1545591902
    },
    {
        "content": "<p>In <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean\">https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/category.lean</a>,<br>\nCould anyone tells me why objects are not a field but a parameter to the definition of <code>category</code>? What is the advantage of it? Also, why the definition of a category is a class rather than an ordinary structure?</p>",
        "id": 172717348,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565213008
    },
    {
        "content": "<p>It allows us to say that the \"set\" of all groups have a category structure on it</p>",
        "id": 172717412,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565213051
    },
    {
        "content": "<p>so given two groups <code>G</code> and <code>H</code>, Lean can infer what <code>G \\hom H</code> means</p>",
        "id": 172717451,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565213087
    },
    {
        "content": "<p>structure instances can't be automatically inferred</p>",
        "id": 172717474,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565213103
    },
    {
        "content": "<p>Ok, but what if want to say something like \"let C be a category\" I need to explicitly state its object and become \"let C be a category that has objects as blah\". I find this quite wired.</p>\n<p>I know that this can be solved using <code>Σ obj : Type*, category obj</code> but this is a little bit ad-hoc, does mathlib has a definition for this?</p>",
        "id": 172717820,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565213402
    },
    {
        "content": "<p>Let X be a type that has a category structure C on it</p>",
        "id": 172717942,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565213474
    },
    {
        "content": "<p>This way of defining a category really see a category as an underlining structure of some type. However, many interesting categories focus more on the morphism whereas object carries almost no information e.g. the category of simplexes in which I believe that it has type as <code>category ℕ</code>.</p>",
        "id": 172718443,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565213926
    },
    {
        "content": "<p>This is an interesting example.</p>",
        "id": 172718495,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565213988
    },
    {
        "content": "<p>I don't know what to do with it.</p>",
        "id": 172718560,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1565214020
    },
    {
        "content": "<p>You just do something like <code>def \\Delta := \\nat</code>, and then <code>instance : category \\Delta</code>. This is what type synonyms are for.</p>",
        "id": 172719065,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214567
    },
    {
        "content": "<p>But yes, my initial starts on the category theory library did use bundled categories.</p>",
        "id": 172719072,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214590
    },
    {
        "content": "<p>The payoff, which has not yet been realised in mathlib, of using unbundled categories is that it would allow us to use uniform notation <code>\\iso</code>, <code>\\hom</code>, <code>\\otimes</code> etc across all examples.</p>",
        "id": 172719150,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214645
    },
    {
        "content": "<p>Mostly this hasn't happened because the category theoretic notion of <code>iso</code> between rings, say, would only allow talking about isomorphisms between rings in the same universe.</p>",
        "id": 172719172,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214678
    },
    {
        "content": "<p>This distinction matters, I think for <code>equiv</code> (rather than just using <code>iso</code> in <code>category Type</code>), where it's pretty common to want to shift universes.</p>",
        "id": 172719184,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214711
    },
    {
        "content": "<p>On the other hand it's rare that one deals with isomorphisms of rings in different universes.</p>",
        "id": 172719255,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214752
    },
    {
        "content": "<p>(but it does happen, sure)</p>",
        "id": 172719262,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214758
    },
    {
        "content": "<p>If I were king, I'd use <code>iso</code> instead of <code>mul_equiv</code>, <code>algebra_equiv</code>, <code>homeomorphism</code>, etc. etc., and even use <code>iso</code> in <code>Type</code>, adding an extra <code>pequiv</code> for talking about equivalences that cross universe levels.</p>",
        "id": 172719294,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214813
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"144193\">@Gun Pinyo</span>, there is <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/Cat.lean\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/category_theory/Cat.lean\"><code>src/category_theory/Cat.lean</code></a>, which defines bundled categories in mathlib, although doesn't do very much with them.</p>",
        "id": 172719397,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565214889
    },
    {
        "content": "<blockquote>\n<p>(but it does happen, sure)</p>\n</blockquote>\n<p>Why do you say this? In maths I never leave <code>Type</code>. This universe polymorphism is just something which the CS people want to make us use and this is one point where it adds to the confusion.</p>",
        "id": 172722548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565218176
    },
    {
        "content": "<p>Is Cat a category? If so, you aren't working in Type</p>",
        "id": 172726922,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565222759
    },
    {
        "content": "<p>Maybe that's not the best example, but <code>Type (u+1)</code> makes several appearances in mathlib</p>",
        "id": 172727001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565222840
    },
    {
        "content": "<p>Perhaps you don't think it's important to have ordinals or cardinals or surreals or a model of ZFC</p>",
        "id": 172727066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565222901
    },
    {
        "content": "<p>Probably the only one of those you use regularly are cardinals. Of course there are ways to do cardinals in ZFC as well, but the question is not whether it's possible but whether it is easy to work that way. Jeremy told me today that he believes that FLT can probably be proven in primitive recursive arithmetic (PRA), a weak subsystem of Peano arithmetic, but such a proof would obviously look almost unrecognizable compared to Wiles' proof</p>",
        "id": 172727350,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565223192
    },
    {
        "content": "<blockquote>\n<p>You just do something like <code>def \\Delta := \\nat</code>, and then <code>instance : category \\Delta</code>. This is what type synonyms are for.</p>\n</blockquote>\n<p>Well,  <code>def \\Delta := \\nat</code> is the abuse of notation, what if I want to define the category of cubes then I should do <code>def \\square := \\nat</code> then suddenly we have <code>\\Delta = \\square</code> which shouldn't be true.</p>",
        "id": 172727616,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565223486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  If the advantage of unbundled categories couldn't be used in practice, should we go back and use bundled one (as the main def) as before?</p>",
        "id": 172727984,
        "sender_full_name": "Gun Pinyo",
        "timestamp": 1565224019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"144193\">@Gun Pinyo</span>, I don't think you should think of that as abuse of notation. It is used all over mathlib, and is just part of how typeclasses are used in dependent type theory. After building the API for <code>\\Delta</code> or for <code>\\square</code>, one should then mark <code>\\Delta</code> as <code>[irreducible]</code>, preventing people from seeing the implementation detail that it is definitionally equal to <code>nat</code>.</p>",
        "id": 172730778,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565228100
    },
    {
        "content": "<p>I don't think that the advantages of unbundled categories <em>can't</em> be used in practice, we're just not there yet. :-)</p>",
        "id": 172730792,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565228127
    },
    {
        "content": "<p>The algebraists are currently busy bundling ring homs and similar gadgets, and this actually makes it easier to use the uniform notions provided by the the category theory library.</p>",
        "id": 172730841,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565228184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> </p>\n<blockquote>\n<p>Why do you say this? In maths I never leave <code>Type</code>. </p>\n</blockquote>\n<p>So let's get rid of <code>ring_equiv</code> and friends... :-) If you're happy not being able to change universe levels across a <code>ring_equiv</code>, there's not much advantage over just using the uniform <code>iso</code>.</p>",
        "id": 172730865,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565228262
    },
    {
        "content": "<p>There is the point that in an <code>iso</code> you need to explicitly say that both directions are ring homomorphisms, while the default constructor of <code>ring_equiv</code> only asks that you prove this in one direction, but solving this is just a tiny bit of plumbing. (i.e. we can provide an alternative constructor for isomorphisms of rings, etc)</p>",
        "id": 172730925,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565228341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"144193\">@Gun Pinyo</span> Just for the record, I think that <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> also developped some stuff with cubes. In particular he had a definition of cubical homology, I think. <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> do you still have this code somewhere?</p>",
        "id": 172739125,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1565241639
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">natural_isomorphism</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_limits</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">≅</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">limit</span> <span class=\"n\">F</span> <span class=\"err\">≅</span> <span class=\"n\">limit</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>Is that true? [remark: in my application, F and G are equal but not defeq :-/ ]</p>",
        "id": 184076275,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577062036
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">natural_isomorphism</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">v</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"err\">𝒞</span> <span class=\"o\">:</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_limits</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">small_category</span> <span class=\"n\">J</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">J</span> <span class=\"err\">⥤</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">F</span> <span class=\"err\">≅</span> <span class=\"n\">G</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">limit</span> <span class=\"n\">F</span> <span class=\"err\">≅</span> <span class=\"n\">limit</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">hom</span> <span class=\"o\">:=</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">G</span> <span class=\"bp\">⟨</span><span class=\"n\">limit</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"err\">≫</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"n\">F</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">f</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">obviously</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">lift</span> <span class=\"n\">F</span> <span class=\"bp\">⟨</span><span class=\"n\">limit</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">π</span> <span class=\"n\">G</span> <span class=\"n\">X</span> <span class=\"err\">≫</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"bp\">;</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">limit</span><span class=\"bp\">.</span><span class=\"n\">w</span> <span class=\"n\">G</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">assoc</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"n\">f</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">obviously</span><span class=\"bp\">⟩</span> <span class=\"o\">}</span>\n</pre></div>",
        "id": 184085568,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1577081598
    },
    {
        "content": "<p>surely there's a better proof</p>",
        "id": 184085569,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1577081602
    },
    {
        "content": "<p>I think this stuff is already in mathlib</p>",
        "id": 184094876,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577096052
    },
    {
        "content": "<p>I couldn't find the one I posted but I can quite believe I missed it. Library_search couldn't find it either</p>",
        "id": 184094910,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1577096113
    },
    {
        "content": "<p>It's probably not exactly this, but a slight variant</p>",
        "id": 184094919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1577096129
    }
]
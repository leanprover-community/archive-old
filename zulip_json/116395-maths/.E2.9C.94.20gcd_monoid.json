[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300245\">Filippo A. E. Nuccio</span> has marked this topic as resolved.</p>",
        "id": 303530539,
        "sender_full_name": "Notification Bot",
        "timestamp": 1665527150
    },
    {
        "content": "<p>I think <code>casesI dedicated_lemma</code> is not \"equally annoying\" as <code>haveI := instance_whose_name_was_probably_autogenerated_and_with_not_enough_explicit_arguments</code>.</p>",
        "id": 303535329,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665530162
    },
    {
        "content": "<p>This is what we do for <code>finite -&gt; fintype</code>. See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/nonempty_fintype\">docs#nonempty_fintype</a></p>",
        "id": 303535400,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1665530194
    },
    {
        "content": "<p>I think the following is easy enough?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.fintype.basic</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">nonempty_fintype</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">casesI</span> <span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"bp\">$</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">classical.choice</span> <span class=\"n\">infer_instance</span><span class=\"o\">,</span> <span class=\"n\">refl</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 303536395,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665530884
    },
    {
        "content": "<p>But yes <code>casesI nonempty_fintype α,</code> is indeed shorter, and a lemma probably suffices for our case. I think we just need the lemma <code>[unique_factorization_monoid α] → nonempty (normalized_gcd_monoid α)</code>; once we get the <code>normalized_gcd_monoid α</code>, we would get <code>normalization_monoid α</code> and <code>gcd_monoid α</code> for free. We don't need instances going from <code>nonempty (normalized_gcd_monoid α)</code> to <code>nonempty (gcd_monoid α)</code> etc. and it doesn't seem like we can define a universal <code>nonempty_lift</code> instance that works for all classes.</p>",
        "id": 303537922,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665531893
    },
    {
        "content": "<p>Oh sorry I take that back, it's possible that we already have a <code>normalization_monoid</code> instance but want to put an arbitrary <code>gcd_monoid</code> instance on some type, in which case we don't want an arbitrarily chosen <code>normalized_gcd_monoid</code> instance. And instances from <code>nonempty (normalized_gcd_monoid α)</code> to <code>nonempty (gcd_monoid α)</code> and alike would be necessary if we want theorems with <code>[nonempty (gcd_monoid α)]</code> as an argument to automatically apply to <code>unique_factorization_monoid</code>.</p>",
        "id": 303538310,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665532148
    },
    {
        "content": "<p>So we probably want all of the arrows below to be instances:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>                                       <span class=\"n\">normalized_gcd_monoid</span> <span class=\"bp\">→</span>        <span class=\"n\">gcd_monoid</span>\n                                          <span class=\"bp\">↓</span>                                <span class=\"bp\">↓</span>\n<span class=\"n\">unique_factorization_monoid</span> <span class=\"bp\">→</span> <span class=\"n\">nonempty</span> <span class=\"n\">normalized_gcd_monoid</span> <span class=\"bp\">→</span> <span class=\"n\">nonempty</span> <span class=\"n\">gcd_monoid</span>           <span class=\"bp\">→</span> <span class=\"n\">is_integrally_closed</span>\n                                                             <span class=\"bp\">↘</span> <span class=\"n\">nonempty</span> <span class=\"n\">normalization_monoid</span>\n                                                                           <span class=\"bp\">↑</span>\n                                                                        <span class=\"n\">normalization_monoid</span>\n</code></pre></div>",
        "id": 303539302,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665532911
    },
    {
        "content": "<p>I guess it's impossible to define some meta-instance that generates the following instances automatically; maybe it's doable via automation with a new attribute? Or maybe it should be built into Lean because it won't cause loops?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">nonempty</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">--fails</span>\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">infer_instance</span> <span class=\"c1\">--fails</span>\n</code></pre></div>",
        "id": 303540838,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665533988
    },
    {
        "content": "<p>Forget what I said above: the following simple instance makes the above two examples work, and the linters are actually happy about it (as long as the priority is set to &lt;1000)!</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">nonempty_intro</span> <span class=\"o\">{</span><span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">⟨‹</span><span class=\"n\">α</span><span class=\"o\">›⟩</span>\n</code></pre></div>",
        "id": 303548927,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665540397
    },
    {
        "content": "<p>Still not sure how we should \"lift\" an instance to <code>nonempty</code> though. If an instance has <code>nonempty ...</code> as the conclusion, then every argument could have a <code>nonempty</code> added and it will still be a valid instance. Maybe during an instance search, if the target is <code>nonempty ...</code>, then every subgoal generated should have a <code>nonempty</code> around it? This sounds like it has to be achieved by modifying Lean itself, but could it be achieved via some meta code?</p>",
        "id": 303550173,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1665541669
    }
]
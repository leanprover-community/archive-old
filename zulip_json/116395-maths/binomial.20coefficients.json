[
    {
        "content": "<p>Preparing a lecture on the binomial and multinomial theorem. For pedagogical reasons I will not prove the binomial theorem the way it's proved in Lean (although the students who come to the \"extra material\" session will see the Lean proof). In Lean I guess the binomial coefficient <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\binom{n}{r}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.85em;\"></span><span class=\"strut bottom\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7453919999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> is defined to be <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mfrac><mrow><mi>n</mi><mo>!</mo></mrow><mrow><mi>r</mi><mo>!</mo><mo>(</mo><mi>n</mi><mo>−</mo><mi>r</mi><mo>)</mo><mo>!</mo></mrow></mfrac><mi mathvariant=\"normal\">.</mi></mrow><annotation encoding=\"application/x-tex\">\\frac{n!}{r!(n-r)!}. </annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.8801079999999999em;\"></span><span class=\"strut bottom\" style=\"height:1.400108em;vertical-align:-0.52em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">!</span><span class=\"mopen mtight\">(</span><span class=\"mord mathit mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span><span class=\"mclose mtight\">)</span><span class=\"mclose mtight\">!</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span><span class=\"mclose mtight\">!</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathrm\">.</span></span></span></span> So is there in Lean a proof that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\binom{n}{r}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.85em;\"></span><span class=\"strut bottom\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7453919999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> equals the number of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span>-element subtypes of a a type of size <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">n</span></span></span></span>? [this is my definition of the binomial coefficient in my lectures]</p>",
        "id": 146974762,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541612190
    },
    {
        "content": "<p>Do we know that the powerset of a type of size <code>n</code> has size <code>2 ^ n</code>?</p>",
        "id": 146974999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541612401
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Wouldn't it make sense to define <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">n \\choose r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.85em;\"></span><span class=\"strut bottom\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7453919999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> via Pascal's triangle?</p>",
        "id": 146975085,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541612459
    },
    {
        "content": "<p>it is defined recursively in <code>mathlib</code> (in <code>mathlib/data/nat/choose.lean</code>):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">choose</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span>             <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>       <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"bp\">+</span> <span class=\"n\">choose</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 146975630,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1541612923
    },
    {
        "content": "<p>Sure, that would be another way; then you can prove it's what I said it is by induction on n. Hmm and I guess you could then prove the result about the subsets of size r of a set of size n by induction on n.</p>",
        "id": 146975661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541612946
    },
    {
        "content": "<p>I guess I was just checking that everything I said today was in Lean. I am giving this awful proof of the binomial theorem of the form \"imagine multiplying out (a+b)(a+b)(a+b)...(a+b) n times -- now think about what the general term looks like? You choose r brackets and choose a from them, and choose b from the rest -- done\"</p>",
        "id": 147108963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541612996
    },
    {
        "content": "<p>but actually I think everything is either there or could be there. <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> the sum of the binomial coefficients being <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.664392em;\"></span><span class=\"strut bottom\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathrm\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span></span></span></span></span></span></span> is easy: you can deduce it from the binomial theorem with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">a=b=1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.69444em;\"></span><span class=\"strut bottom\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">a</span><span class=\"mrel\">=</span><span class=\"mord mathit\">b</span><span class=\"mrel\">=</span><span class=\"mord mathrm\">1</span></span></span></span> ;-)</p>",
        "id": 147109092,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541613078
    },
    {
        "content": "<p>Sure. But that's not exactly what I asked <span class=\"emoji emoji-1f609\" title=\"wink\">:wink:</span></p>",
        "id": 147109115,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1541613108
    },
    {
        "content": "<p>I think what you asked for is <a href=\"https://github.com/leanprover/mathlib/blob/89431cf4f01ff0f6b4005f96795a23571258cbf0/data/finset.lean#L1198\" target=\"_blank\" title=\"https://github.com/leanprover/mathlib/blob/89431cf4f01ff0f6b4005f96795a23571258cbf0/data/finset.lean#L1198\">here</a>.</p>",
        "id": 147109165,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1541613135
    },
    {
        "content": "<p>...as long as you can prove that the size of a subset is at most the size of the set (which I am pretty sure is there) and the result about subsets of size r (which should be fine by induction on n).</p>",
        "id": 147242495,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1541613231
    },
    {
        "content": "<blockquote>\n<p>So is there in Lean a proof that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mo fence=\"true\">(</mo><mfrac linethickness=\"0px\"><mrow><mi>n</mi></mrow><mrow><mi>r</mi></mrow></mfrac><mo fence=\"true\">)</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\\binom{n}{r}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.85em;\"></span><span class=\"strut bottom\" style=\"height:1.20001em;vertical-align:-0.35001em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">(</span></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7453919999999999em;\"><span style=\"top:-2.3550000000000004em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\" style=\"margin-right:0.02778em;\">r</span></span></span></span><span style=\"top:-3.144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathit mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size1\">)</span></span></span></span></span></span> equals the number of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">r</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.02778em;\">r</span></span></span></span>-element subtypes of a type of size <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.43056em;\"></span><span class=\"strut bottom\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"base\"><span class=\"mord mathit\">n</span></span></span></span>?</p>\n</blockquote>\n<p>I couldn't find this in mathlib so I've been working off-and-on on this. I finally have a proof, but it seems excessively long and ugly. Well, actually what I have is <a href=\"https://gist.github.com/bryangingechen/3f8e3fa3664bb4b044e9e607725cab1b\" target=\"_blank\" title=\"https://gist.github.com/bryangingechen/3f8e3fa3664bb4b044e9e607725cab1b\">a proof of this</a>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">card_subsets_of_range_eq_choose</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">card</span> <span class=\"o\">((</span><span class=\"n\">powerset</span> <span class=\"o\">(</span><span class=\"n\">range</span> <span class=\"n\">n</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">card</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">choose</span> <span class=\"n\">n</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>(what should be the name?) though what you really want is this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">card_subsets_card_eq_choose</span>  <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">card</span> <span class=\"o\">((</span><span class=\"n\">powerset</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">filter</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">card</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">k</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">choose</span> <span class=\"o\">(</span><span class=\"n\">card</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"n\">k</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p><a href=\"#narrow/stream/113488-general/subject/tutorial/near/135254614\" title=\"#narrow/stream/113488-general/subject/tutorial/near/135254614\">Last time I ran into something like this</a>, <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span> ended up writing a bunch of stuff for me which is now in the tutorials branch. This one's probably much easier but I haven't tried to tackle it yet...</p>\n<p>Anyways, if anyone wants to golf this down to something reasonable or give advice on making it nicer, I'd really appreciate it!</p>",
        "id": 147613115,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542132404
    },
    {
        "content": "<p>I would hope to have a function on <code>list</code> that constructs all k element sublists</p>",
        "id": 147613222,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542132537
    },
    {
        "content": "<p>maybe we have it already?</p>",
        "id": 147613231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542132547
    },
    {
        "content": "<p>Oh that sounds like a good idea.</p>",
        "id": 147613251,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542132577
    },
    {
        "content": "<p>I don't think we have it</p>",
        "id": 147613290,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542132603
    },
    {
        "content": "<p>The nice thing about this is that the proof that this list has length <code>choose n k</code> will be obvious from the construction</p>",
        "id": 147613355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542132638
    },
    {
        "content": "<p>and the rest is just lifting to the quotient</p>",
        "id": 147613375,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542132662
    },
    {
        "content": "<p>right, this is like the approach to finite partitions you suggested before that I still haven't managed to do</p>",
        "id": 147613405,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542132691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123965\">@Bryan Gin-ge Chen</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">sublists_of_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">l</span>      <span class=\"mi\">0</span>     <span class=\"o\">:=</span> <span class=\"o\">[[]]</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">sublists_of_length</span> <span class=\"n\">l</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">++</span>\n  <span class=\"o\">(</span><span class=\"n\">sublists_of_length</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">))</span>\n</pre></div>\n\n\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> The definition of <code>list.sublists</code> in mathlib is totally incomprehensible to me, but is faster than the most natural definition. This approach to <code>sublist_of_length</code> is presumably not the fastest. What's the general policy on fast definitions versus comprehensible definitions?</p>",
        "id": 147615848,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542134708
    },
    {
        "content": "<p>fast is better than comprehensible</p>",
        "id": 147615890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134756
    },
    {
        "content": "<p>you can often prove the comprehensible definition as a lemma though</p>",
        "id": 147615949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134773
    },
    {
        "content": "<p>I think the definition of <code>list.sublists</code> is based on haskell's</p>",
        "id": 147615968,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134791
    },
    {
        "content": "<p>Even if fast means much longer proofs?</p>",
        "id": 147615988,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1542134812
    },
    {
        "content": "<p>yes, although we can also retrofit a faster definition</p>",
        "id": 147616009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134841
    },
    {
        "content": "<p>for me comprehensible is better than fast. For fast we often need a different solution anyway</p>",
        "id": 147616013,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1542134847
    },
    {
        "content": "<p>With Lean4 <span class=\"emoji emoji-1f340\" title=\"four leaf clover\">:four_leaf_clover:</span>  we hopefully can simply redefine constants for fast evaluation</p>",
        "id": 147616086,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1542134885
    },
    {
        "content": "<p>Note that in the case of <code>sublists</code> there is actually a separate version <code>sublists'</code> that is basically the comprehensible one, to which we prove equivalence</p>",
        "id": 147616098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134897
    },
    {
        "content": "<p>Hm, then it would be better to have <code>sublist</code> to be the comprehensible one?!</p>",
        "id": 147616131,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1542134932
    },
    {
        "content": "<p>The idea is that the default one should be VM-fast</p>",
        "id": 147616160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134957
    },
    {
        "content": "<p>because this is in the computational part</p>",
        "id": 147616174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542134971
    },
    {
        "content": "<p>(there is an additional complication, in that <code>sublists</code> and <code>sublists'</code> are not equal but differ by a complicated permutation)</p>",
        "id": 147616280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542135036
    },
    {
        "content": "<p>They actually both have fast VM definitions, but <code>sublists</code> is faster</p>",
        "id": 147616338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542135099
    },
    {
        "content": "<p>and <code>sublists'</code> has nicer equation lemmas</p>",
        "id": 147616348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542135113
    },
    {
        "content": "<p>here's a faster version of the same definition:</p>\n<div class=\"codehilite\"><pre><span></span>def sublists_of_length_aux {α : Type*} : list α → ℕ → (list α → list α) → list (list α) → list (list α)\n| l      0     f r := f [] :: r\n| []     (n+1) f r := r\n| (a::l) (n+1) f r := sublists_of_length_aux l n (f ∘ list.cons a)\n  (sublists_of_length_aux l (n + 1) f r)\n\ndef sublists_of_length {α : Type*} (l : list α) (n : ℕ) : list (list α) :=\nsublists_of_length_aux l n id []\n</pre></div>\n\n\n<p>the idea is to define <code>(sublists_of_length l n).map f ++ r</code> by recursion without stacking recursive calls to <code>map</code> or <code>append</code></p>",
        "id": 147618019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542136482
    },
    {
        "content": "<p>You can prove without too much difficulty that <code>sublists_of_length_aux l n f r = (sublists_of_length l n).map f ++ r</code> and then you can prove your equation lemmas as theorems</p>",
        "id": 147618069,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542136543
    },
    {
        "content": "<p>We used to have this in Lean 2 (but it would be nice to have cleaner proofs).<br>\n<a href=\"https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220\" target=\"_blank\" title=\"https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220\">https://github.com/leanprover/lean2/blob/master/library/theories/combinatorics/choose.lean#L208-L220</a></p>",
        "id": 147712036,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1542244040
    },
    {
        "content": "<blockquote>\n<p>You can prove without too much difficulty that <code>sublists_of_length_aux l n f r = (sublists_of_length l n).map f ++ r</code> and then you can prove your equation lemmas as theorems</p>\n</blockquote>\n<p>Could I get a hint on this step? I'm not sure what to do even to get started:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">sublists_of_length_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">l</span>      <span class=\"mi\">0</span>     <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"bp\">::</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span>     <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sublists_of_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"n\">id</span> <span class=\"o\">[]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)),</span>\n  <span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">l</span> <span class=\"n\">n</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">sublists_of_length</span> <span class=\"n\">l</span> <span class=\"n\">n</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">++</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"n\">l</span> <span class=\"mi\">0</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"c1\">--unfold sublists_of_length_aux,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>I was hoping I could make the first one <code>refl</code>, but it seems I need to do something else first, and I'm having trouble working with the definitions.</p>",
        "id": 147980872,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542648491
    },
    {
        "content": "<p>ah, it looks like lean did a case split on <code>l</code> first, then <code>n</code>, in the definition of <code>sublists_of_length_aux</code>, so that the first equation isn't true by <code>refl</code> but rather by <code>cases l; refl</code></p>",
        "id": 147981987,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542649768
    },
    {
        "content": "<p>you can fix this by swapping the order of the first two arguments to <code>sublists_of_length_aux</code></p>",
        "id": 147981997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542649792
    },
    {
        "content": "<p>Cool, that did the trick.</p>",
        "id": 147982276,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1542650128
    },
    {
        "content": "<p>but actually I think you want to generalize the lemma a bit to prove it:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">sublists_of_length_aux</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">l</span>      <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">[]</span> <span class=\"bp\">::</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span>     <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">r</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">sublists_of_length_aux</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">sublists_of_length</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"n\">id</span> <span class=\"o\">[]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">foo</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)),</span>\n  <span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"bp\">++</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"o\">(</span><span class=\"n\">sublists_of_length_aux</span> <span class=\"n\">n</span> <span class=\"n\">l</span> <span class=\"n\">f</span> <span class=\"n\">r</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">g</span> <span class=\"bp\">++</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span>     <span class=\"n\">l</span>      <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">[]</span>     <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"bp\">::</span><span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">unfold</span> <span class=\"n\">sublists_of_length_aux</span><span class=\"bp\">;</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">foo</span><span class=\"o\">,</span> <span class=\"k\">show</span> <span class=\"o\">((</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"err\">∘</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"err\">∘</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"n\">a</span><span class=\"o\">),</span> <span class=\"k\">by</span> <span class=\"n\">refl</span><span class=\"o\">,</span> <span class=\"n\">foo</span><span class=\"o\">]</span>\n</pre></div>\n\n\n<p>The theorem you want is now a simple corollary</p>",
        "id": 147982611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1542650514
    },
    {
        "content": "<p>I wrote a proof that the cardinality of the collection of k-subsets of an n-element set is <code>choose n k</code>: <a href=\"https://gist.github.com/avigad/d9eef0fed9bb8b8ee4b03daafe604d53\" target=\"_blank\" title=\"https://gist.github.com/avigad/d9eef0fed9bb8b8ee4b03daafe604d53\">https://gist.github.com/avigad/d9eef0fed9bb8b8ee4b03daafe604d53</a></p>\n<p>It seems more complicated than it should be. Can anyone do better?</p>",
        "id": 162776901,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1554678011
    },
    {
        "content": "<p>There's an older thread on this <a href=\"#narrow/stream/116395-maths/topic/binomial.20coefficients\" title=\"#narrow/stream/116395-maths/topic/binomial.20coefficients\">here</a>. I never managed to finish <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> 's suggested proof, unfortunately.</p>",
        "id": 162777139,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1554678453
    },
    {
        "content": "<p>I think that it is worth it to do the list version of this first, as in the other thread. This gives you a useful list function in addition to proving this theorem</p>",
        "id": 162777274,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554678663
    },
    {
        "content": "<p>It will probably be larger in terms of LOC but there won't be any big \"hotspot\" theorem with a huge line count, it breaks into a bunch of 3 line lemmas</p>",
        "id": 162777329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554678723
    },
    {
        "content": "<p>It looks like you will need lots of annoying facts relating finsets and nodup lists, and finsets of finsets vs. lists of lists. You'd have to translate statements about powerset, filter, cardinality, etc. It doesn't sound like fun.</p>\n<p>It is a shame that the textbook proof is so long. All the steps are straightforward, but it is painful to have to spell them out. It's a good test case for automation.</p>",
        "id": 162777760,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1554679472
    },
    {
        "content": "<p>Most of that work is already done</p>",
        "id": 162777850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554679631
    },
    {
        "content": "<p>there are already theorems like that about nodup lists, properties of <code>list.sublists</code> and so on</p>",
        "id": 162777854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554679652
    },
    {
        "content": "<p>why is <code>choose</code> in root namespace?</p>",
        "id": 162777880,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554679682
    },
    {
        "content": "<p>I don't know. Where should it be? The name conflicts with <code>finset.choose</code>.</p>",
        "id": 162778038,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1554679941
    },
    {
        "content": "<p><code>nat.choose</code> of course</p>",
        "id": 162778883,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554681476
    },
    {
        "content": "<p>all the other nat functions are in the <code>nat</code> namespace</p>",
        "id": 162778927,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554681489
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/issues/899\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/issues/899\">#899</a>. As I suspected, the total line count is more, but none of the individual theorems is very long, only about 10 lines at most, and there is more reusability for the list and multiset counterparts</p>",
        "id": 162781773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554686084
    },
    {
        "content": "<p>Nice. But I still think it is a shame that there isn't a more elegant path through <code>finset</code>. Rewriting finite combinatorics in terms of lists isn't the best way to make friends and influence others.</p>",
        "id": 162782206,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1554686788
    },
    {
        "content": "<p>I think that the performance improvement is worth it</p>",
        "id": 162782207,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554686817
    },
    {
        "content": "<p>filtering all subsets is kind of a bad way to generate these lists</p>",
        "id": 162782218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554686835
    },
    {
        "content": "<p>There is certainly a way to do it directly, but then you have to do a lot of reasoning about the sizes of things; here the fact that the size of it is <code>choose</code> is easy because it directly reflects the combinatoric description of how you make a list of all subsets</p>",
        "id": 162782276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554686933
    },
    {
        "content": "<p>Also I prefer to avoid <code>insert</code> and such, because you are always dealing with things not being elements of other things</p>",
        "id": 162782291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554686993
    },
    {
        "content": "<p>I like Mario's proof a lot; it's got that inevitable feel to it. At the same time I appreciate Jeremy's point: mathematicians are going to take some time to get used to <code>list</code> being more important than <code>finset</code>.</p>",
        "id": 162782364,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554687075
    },
    {
        "content": "<p>Mario, I don't buy the claim about \"reflecting the combinatoric description\". Given the recursive definition description of <code>choose</code>, the set-based argument is a one-liner: if a is an arbitrary element of a set s with n + 1 elements, then divide the (k+1)-element subsets of s into the ones that contain a, and the ones that don't. The definition of <code>subsets_len</code> via <code>subsets_len_aux</code> is clever and it makes for a nice formalization, but it distracts from the combinatorial / set-theoretic intuition. You'll never convince combinatoricists to start writing papers that way.</p>",
        "id": 162783246,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1554688643
    },
    {
        "content": "<p>What I mean by \"reflecting the combinatorics\": Consider how you would give the combinatoric bijection. You have a finite set, and you are making a list of all the subsets of length k; you first list all the ones that don't contain some arbitrary element a, then all the ones that do. A little reflection reveals that you don't need any of the structure of finite sets for this, so you may as well do it on lists. Now you want to define a function <code>sublists_len k l</code> such that <code>sublists_len 0 l = [[]]</code>, and <code>sublists_len (k+1) (a::l) = sublists_len (k+1) l ++ map (a::) (sublists_len k l)</code>, because we have split the problem into the size <code>k+1</code> elements in <code>l</code> and the size k elements of <code>l</code> with <code>a</code> appended. This is exactly the definition of <code>sublists_len</code> I give (with a slight optimization so that you don't have to nest maps). As a result, it's trivial to prove a statement about the length being <code>choose n k</code></p>",
        "id": 162783741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554689504
    },
    {
        "content": "<p>The proof is very combinatoric and constructive</p>",
        "id": 162783794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554689552
    },
    {
        "content": "<p>You could actually stop there, but in the interest of getting closer to your version, I also lift the list function to a function on multisets and finsets. There isn't really any added content there, it's just restating facts in the new context. There are some additional observations to be made about how the list function preserves permutations and nodups so that the constructions lift, but that is relatively simple</p>",
        "id": 162783882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554689710
    },
    {
        "content": "<p>The point I want to make is that I'm not proving a theorem, I'm constructing a function</p>",
        "id": 162783934,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554689806
    },
    {
        "content": "<p>It is possible that you are getting hung up on the strange definition <code>sublists_len_aux</code>. If so I would encourage you to ignore it and look only at <code>sublists_len_zero</code>, <code>sublists_len_succ_nil</code>, and <code>sublists_len_succ_cons</code> as the equation lemmas, because that's what they are</p>",
        "id": 162784227,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554690272
    },
    {
        "content": "<p>it's a simple corollary of the orbit-stabilizer theorem... :P</p>",
        "id": 162784609,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1554690947
    },
    {
        "content": "<p>Stepping back a bit, I wonder whether dependent type theory is not really suited to combinatorial arguments like this, although I know sufficiently little about other formalisations of mathematics to know whether any of them would be any better. Something I learnt recently is that simple type theory seems to be not suitable for developing the theory of schemes, and I guess what's going on is that different formalisations of the foundations are better suited to different (possibly overlapping) areas.</p>",
        "id": 162791913,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554703331
    },
    {
        "content": "<p>Finite combinatorics is usually a strong point in DTT. That's why every introductory example has you doing stuff with nat</p>",
        "id": 162791943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554703434
    },
    {
        "content": "<p>Type dependencies don't really come up here</p>",
        "id": 162791996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554703465
    },
    {
        "content": "<p>I think the problem in this example is more along the \"programs / proofs\" axis than the \"DTT / something else\" axis.</p>",
        "id": 162792017,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554703532
    },
    {
        "content": "<p>Mario has written a \"maths as programs\" proof.</p>",
        "id": 162792024,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1554703560
    },
    {
        "content": "<p>Maybe type theory itself isn't suited to combinatorics?</p>",
        "id": 162792145,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554703692
    },
    {
        "content": "<p>Would this all be easier in ZFC?</p>",
        "id": 162792147,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1554703706
    },
    {
        "content": "<p>I can show you <a href=\"http://us2.metamath.org/mpeuni/hashbclem.html\" target=\"_blank\" title=\"http://us2.metamath.org/mpeuni/hashbclem.html\">http://us2.metamath.org/mpeuni/hashbclem.html</a> but I don't think you are in a position to say whether this proof is easier or harder than the lean proof</p>",
        "id": 162792451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554704175
    },
    {
        "content": "<p>It is most similar to Jeremy's proof</p>",
        "id": 162792456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554704205
    },
    {
        "content": "<p>the core of the proof is construction of a bijection from <code>{ x \\sub A | a e. x /\\ #x = n + 1 }</code> to <code>{y \\sub A | #y = n }</code> by showing that <code>x |-&gt; x / {a}</code> and <code>y |-&gt; y u. {a}</code> are inverse</p>",
        "id": 162792537,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554704320
    },
    {
        "content": "<p>Personally, I prefer the \"program\" proof. The style could be mimicked in ZFC with a bunch of new definitions</p>",
        "id": 162792606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1554704423
    }
]
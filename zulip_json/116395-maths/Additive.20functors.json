[
    {
        "content": "<p>I'm working on additive functors.<br>\nHow bad is it if I tag <code>add_map_spec</code> with <code>simp</code> in the following code? (see examples)</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">functor.additive</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_hom'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">functor.additive</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_hom</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">functor.additive.exists_hom'</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">noncomputable</span>\n<span class=\"kd\">def</span> <span class=\"n\">add_map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"n\">classical.some</span> <span class=\"bp\">$</span> <span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_map_spec</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F.add_map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span><span class=\"n\">unfold</span> <span class=\"n\">add_map</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">classical.some_spec</span> <span class=\"o\">(</span><span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">)}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 227295322,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614011503
    },
    {
        "content": "<p>Why not have the <code>F.map 0 = 0</code> and <code>F.map (f + g) = F.map f + F.map g</code> as the API lemmas instead?</p>",
        "id": 227295809,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614011679
    },
    {
        "content": "<p>And, which direction would you want the distribution lemma to simplify in?</p>",
        "id": 227295848,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614011696
    },
    {
        "content": "<p>Sure I can do that, but presumably there are 1000 other lemmas about morphisms of abelian groups which I would like to use eventually.</p>",
        "id": 227295935,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614011728
    },
    {
        "content": "<p>This might be a case where some sort of <code>meta</code> code to transfer over the lemmas could work.</p>",
        "id": 227296089,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614011783
    },
    {
        "content": "<p>This would all be a lot easier if we didn't depricate <code>is_hom</code>/<code>is_add_hom</code>, etc.</p>",
        "id": 227296677,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012024
    },
    {
        "content": "<p>I am confused about this. My current understanding is that the problem with <code>is_add_hom</code> is not that it <em>exists</em>, but that it is a <em>class</em>. I think. If I'm right and if a refactor with these changes would get files like <code>deprecated.group</code> out of <code>deprecated</code> then I might well be motivated to take this on. I totally agree that there are times when <code>is_add_hom</code> is useful, but I also very much believe that for group homomorphisms in Lean 3 you're better off using <code>-&gt;+</code> in general.</p>",
        "id": 227297289,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614012250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> do you have any thoughts about the <code>simp</code> tag in the code above?</p>",
        "id": 227297732,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012434
    },
    {
        "content": "<p>You should be able to define <code>add_map</code> computably I think?</p>",
        "id": 227297836,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614012483
    },
    {
        "content": "<p>I am not really a computer scientist, I don't have much of an understanding of <code>simp</code>. If the linter is happy then why not just try it?</p>",
        "id": 227297877,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614012487
    },
    {
        "content": "<p>Since you only need to unpack the existential inside the proof obligations</p>",
        "id": 227297909,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614012496
    },
    {
        "content": "<p>In practice I guess I would try and stick to <code>add_map</code> as much as possible, so hopefully I'd not need the simp lemma much.</p>",
        "id": 227297958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614012518
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> yeah I can make it computable.</p>",
        "id": 227298072,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012562
    },
    {
        "content": "<p>We have this type of things with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.single\">docs#pi.single</a> too, where we have the regular version, and a separate bundled version <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.single\">docs#add_monoid_hom.single</a>. We copy across the really obvious lemmas like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.single_add\">docs#pi.single_add</a>, but for the more niche ones the user is expected to write \"backwards\" along <a href=\"https://leanprover-community.github.io/mathlib_docs/find/add_monoid_hom.single_apply\">docs#add_monoid_hom.single_apply</a> or similar.</p>",
        "id": 227298221,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614012615
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">functor.additive</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_hom'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">functor.additive</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_hom</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">functor.additive.exists_hom'</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">add_map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">add_map_spec</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F.add_map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">add_map</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 227298292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012644
    },
    {
        "content": "<p>Looks good so far :-)</p>",
        "id": 227298390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614012679
    },
    {
        "content": "<p>Kevin, that was exactly my thought too -- when I know my functor is additive, I will always use <code>add_map</code> instead of <code>map</code>. So why not add that simp lemma :)? Maybe <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> can convince me otherwise.</p>",
        "id": 227298540,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012730
    },
    {
        "content": "<p>I guess you're forced to choose between:</p>\n<ul>\n<li>You want the lemmas about <code>functor.map</code> to apply automatically, and force the user to do a bit of a dance to get the lemmas about <code>add_monoid_hom</code></li>\n<li>You want the lemmas about <code>add_monoid_hom</code> to apply automatically, and force the user to do a bit of a dance to get the lemmas about <code>functor.map</code></li>\n</ul>",
        "id": 227298588,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614012748
    },
    {
        "content": "<p>Hmm.... yeah that's a good point.</p>",
        "id": 227298648,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012778
    },
    {
        "content": "<p>I am a naive mathematician and want both to happen at once :-(</p>",
        "id": 227298752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1614012816
    },
    {
        "content": "<p>Same here :(</p>",
        "id": 227298779,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614012825
    },
    {
        "content": "<p>One argument goes \"bundled homs are ubiquitous, users will recognize when they have a goal that needs them to try and turn <code>map</code> into <code>add_map</code> via manual rewrites, but are less likely to recognize when they need to do the reverse\". But I only make that argument because I'm used to having to do it with things like <code>finsupp.lsingle</code> which would be way too bundled for it to match lots of lemmas about <code>finsupp.single</code> were it not for the fact that <code>simp</code> put it in that form for me</p>",
        "id": 227299075,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614012934
    },
    {
        "content": "<p>This is a contrast the category theory part of the library has from other parts of the library. Which direction is the simplifying one here?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">prod.map_comp_map</span> <span class=\"o\">:</span> <span class=\"n\">prod.map</span> <span class=\"n\">g</span> <span class=\"n\">g'</span> <span class=\"bp\">∘</span> <span class=\"n\">prod.map</span> <span class=\"n\">f</span> <span class=\"n\">f'</span> <span class=\"bp\">=</span> <span class=\"n\">prod.map</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g'</span> <span class=\"bp\">∘</span> <span class=\"n\">f'</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>That is, which one of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.comp_map</span> <span class=\"o\">:</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"bp\">∘</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"bp\">=</span> <span class=\"n\">list.map</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">g</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.map_map</span> <span class=\"o\">:</span> <span class=\"n\">list.map</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">list.map</span> <span class=\"n\">f</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">list.map</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"bp\">∘</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>In <code>list</code>, the choice in <code>map_map</code>. In category theory portions of the library, I've seen that <code>comp_map</code> is the direction preferred.</p>",
        "id": 227299976,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614013221
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> 's comment convinced me against this simp lemma.</p>",
        "id": 227300237,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614013308
    },
    {
        "content": "<p>The thought likely being, anything which would have simplified <code>list.map f l</code> will also simplify <code>list.map (g ∘ f)</code>, and moreover, you'll get possible simplifcations once <code>g ∘ f</code> exists as a term.</p>",
        "id": 227300243,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614013311
    },
    {
        "content": "<p>Maybe a <code>push_comp</code> and a <code>pull_comp</code> tactic?</p>",
        "id": 227300406,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1614013356
    },
    {
        "content": "<p>Can't we have axioms <code>map_add'</code> and <code>map_zero'</code>, and have a bundled version <code>map_hom</code> defined afterwards? I think that you don't need <code>exists_hom</code> then</p>",
        "id": 227300466,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614013380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Does it matter? I'm making a small api anyway...</p>",
        "id": 227300763,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614013486
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>LONG</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">functor.additive</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_hom'</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">functor.additive</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_hom</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">),</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">functor.additive.exists_hom'</span> <span class=\"n\">_</span> <span class=\"n\">_</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_is_hom</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map_zero</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">G.map</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">map_add</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">),</span> <span class=\"n\">G.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">G.map</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">functor.additive</span> <span class=\"n\">G</span> <span class=\"o\">:=</span> <span class=\"n\">functor.additive.mk</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">Y</span><span class=\"o\">,</span>\n<span class=\"o\">⟨⟨</span><span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">G.map</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">map_zero</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">map_add</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">⟩,</span> <span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor.additive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">@[simps]</span>\n<span class=\"kd\">def</span> <span class=\"n\">add_map</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">(</span><span class=\"n\">F.obj</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">F.obj</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">functor.additive.exists_hom</span> <span class=\"n\">F</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span><span class=\"n\">hf</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">],</span>\n  <span class=\"kd\">end</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">add_map_spec</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.add_map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_zero</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_map_spec</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_zero</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_add</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_map_spec</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_add</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_neg</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"n\">add_map_spec</span><span class=\"o\">,</span> <span class=\"n\">add_monoid_hom.map_neg</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">map_sub</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">-</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">-</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_neg_add</span><span class=\"o\">]</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">functor</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>\n</div></div>",
        "id": 227301500,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614013723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> see the <code>of_is_hom</code> in the code above.</p>",
        "id": 227301536,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614013741
    },
    {
        "content": "<p>I don't think it matters too much. But proving <code>map_add'</code> etc might be shorter proofs than <code>exists_hom</code></p>",
        "id": 227301548,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1614013745
    },
    {
        "content": "<p>I think this is probably good enough, no?</p>",
        "id": 227301554,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614013746
    },
    {
        "content": "<p><del>Oh, an annoying thing about your case vs <code>pi.single</code> is that <code>map</code> is not defeq to <code>map_add</code></del></p>",
        "id": 227302424,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014052
    },
    {
        "content": "<p>They're defeq if you apply them :)</p>",
        "id": 227302511,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614014084
    },
    {
        "content": "<p>I'd recommend exploiting the defeq-ness in your proofs then!</p>",
        "id": 227302549,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014096
    },
    {
        "content": "<p>And change to <code>lemma add_map_spec {X Y : C} {f : X ⟶ Y} : ⇑F.add_map = F.map := rfl</code> too</p>",
        "id": 227302698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014151
    },
    {
        "content": "<p>See <code>LONG</code> above</p>",
        "id": 227302828,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614014194
    },
    {
        "content": "<p>Yeah, my comment was in response to that</p>",
        "id": 227303045,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014275
    },
    {
        "content": "<p>What's the issue with <code>add_map_spec</code> then?</p>",
        "id": 227303218,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614014322
    },
    {
        "content": "<p>I'm suggesting the proofs be akin to</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">map_sub</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">-</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.map</span> <span class=\"n\">f</span> <span class=\"bp\">-</span> <span class=\"n\">F.map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"n\">F.add_map.map_sub</span> <span class=\"n\">f</span> <span class=\"n\">g</span>\n</code></pre></div>",
        "id": 227303227,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014326
    },
    {
        "content": "<p>It's not as general as it could be</p>",
        "id": 227303244,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014332
    },
    {
        "content": "<p>Oh I see.</p>",
        "id": 227303257,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614014337
    },
    {
        "content": "<p>Sometimes you might need to replace it even when not applied</p>",
        "id": 227303293,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614014346
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/6367\">#6367</a></p>",
        "id": 227311334,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614017324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> concerning your comment on github. Would this be better in your opinion?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">additive_functor</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">((</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">add_map_eq'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">add_map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"n\">restate_axiom</span> <span class=\"n\">additive_functor.add_map_eq'</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">additive_functor.add_map_eq</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">⥤+</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">additive_functor</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 227324805,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614022726
    },
    {
        "content": "<p>I guess I can play with priorities to get something that sort of works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.preadditive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">D</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">D</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">preadditive</span> <span class=\"n\">D</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">additive_functor</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span> <span class=\"bp\">⥤</span> <span class=\"n\">D</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_map</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">},</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→+</span> <span class=\"o\">((</span><span class=\"n\">obj</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">⟶</span> <span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"n\">Y</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">add_map_eq'</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">},</span> <span class=\"n\">add_map</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">map</span> <span class=\"n\">f</span> <span class=\"bp\">.</span> <span class=\"n\">obviously</span><span class=\"o\">)</span>\n\n<span class=\"n\">restate_axiom</span> <span class=\"n\">additive_functor.add_map_eq'</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">100</span><span class=\"o\">]</span> <span class=\"n\">additive_functor.add_map_eq</span>\n\n<span class=\"kd\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">⥤+</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">26</span> <span class=\"o\">:=</span> <span class=\"n\">additive_functor</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"n\">D</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">⥤+</span> <span class=\"n\">D</span><span class=\"o\">}</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.add_map</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">F.add_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.add_map</span> <span class=\"n\">f</span> <span class=\"bp\">+</span> <span class=\"n\">F.add_map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">Z</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">F.add_map</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">F.add_map</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">F.add_map</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 227325519,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614022978
    },
    {
        "content": "<p>The argument that I thought justified my suggestion is moot for reasons I don't quite understand</p>",
        "id": 227326028,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614023159
    },
    {
        "content": "<p>So I have no opinion on whether that's better or worse</p>",
        "id": 227326103,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614023173
    },
    {
        "content": "<p>But I'd like to understand why your case works when the <code>is_add_monoid_hom</code> case doesn't, in case it informs us about how to fix the <code>is_add_monoid_hom</code> case</p>",
        "id": 227326269,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614023242
    },
    {
        "content": "<p>The answer is, of course, to just redefine groups as one-object groupoids! (joking, of course)</p>",
        "id": 227326982,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614023535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bundled_function</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">bundled_function</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">f.to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_monoid_hom_foo</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bundled_function</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_one</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">is_monoid_hom_foo.map_one</span> <span class=\"n\">is_monoid_hom_foo.map_mul</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bundled_function</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_monoid_hom_foo</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">bundled_function</span> <span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">is_monoid_hom_foo</span> <span class=\"n\">f</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">simp</span>\n</code></pre></div>\n<p>I'm confused.</p>",
        "id": 227329472,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614024536
    },
    {
        "content": "<p>Just to be clear, that works?</p>",
        "id": 227330716,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614025049
    },
    {
        "content": "<p>yes</p>",
        "id": 227330724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614025055
    },
    {
        "content": "<p>That might be a big discovery</p>",
        "id": 227330854,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614025119
    },
    {
        "content": "<p>But I still have no idea why this works but it doesn't for plain functions...</p>",
        "id": 227331197,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614025289
    },
    {
        "content": "<p>For plain functions the simp lemma can't match, because the head of the left-hand-side is a metavariable (any function <code>f</code>). For <code>bundled_function</code> the head is some constant (I guess the coercion?)</p>",
        "id": 227352649,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1614034075
    },
    {
        "content": "<p>Going back up a bit, I'm dubious about using the existential <code>exists_hom'</code>. As Johan says above, why not just have fields <code>map_zero'</code> and <code>map_add'</code>, and construct the bundled <code>F.map_add</code> after the fact?</p>",
        "id": 227352803,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1614034145
    },
    {
        "content": "<p>Perhaps worth a new thread in general about this odd bundling behavior</p>",
        "id": 227353868,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614034718
    },
    {
        "content": "<p>Agreed on the existential not being better than the simpler solution</p>",
        "id": 227353905,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1614034743
    },
    {
        "content": "<p>Okay, I pushed this change to <a href=\"https://github.com/leanprover-community/mathlib/issues/6367\">#6367</a></p>",
        "id": 227356859,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1614036226
    }
]
[
    {
        "content": "<p>The problem of conjugate-linear maps has reared its head again:  for prior (inconclusive) discussion see<br>\n<a href=\"#narrow/stream/116395-maths/topic/Orthogonal.2FUnitary.20Group\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Orthogonal.2FUnitary.20Group</a><br>\n<a href=\"#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class\">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/4770.20smul_comm_class</a><br>\n<a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear.20maps\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Conjugate-linear.20maps</a></p>\n<p>This time the problem is that we have two open PRs constructing orthogonal bases: </p>\n<ul>\n<li>one (<a href=\"https://github.com/leanprover-community/mathlib/issues/5734\">#5734</a>) for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space\">docs#inner_product_space</a>, Euclidean inner products over <code>‚Ñù</code> and Hermitian inner products over <code>‚ÑÇ</code></li>\n<li>one (<a href=\"https://github.com/leanprover-community/mathlib/issues/5814\">#5814</a>) for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bilin_form\">docs#bilin_form</a>, symmetric nondegenerate bilinear forms over an arbitrary domain</li>\n</ul>\n<p>If these both go through, there's going to be a lot of duplicated theory:   the definition and properties of the orthogonal complement, the induced bilinear form on a submodule, as well as the existence of the orthogonal basis.</p>\n<p>It would be really nice to find a flexible joint generalization, if that's possible.  If not, can we try to make the development (and naming conventions) of the theories as parallel as possible, and build glue between them?</p>",
        "id": 223327176,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611112339
    },
    {
        "content": "<p>I think we should try our best to go for the generalization. But I haven't had time to play with this <span aria-label=\"expressionless\" class=\"emoji emoji-1f611\" role=\"img\" title=\"expressionless\">:expressionless:</span></p>",
        "id": 223328356,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611113587
    },
    {
        "content": "<p>I haven't given this much thought, but the tricky part with the joint generalization is that <code>inner_product_space</code> is a typeclass (and should remain one in my opinion) whereas a bilinear form as currently defined is just a regular structure.</p>",
        "id": 223330703,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611116373
    },
    {
        "content": "<p>Also, note that we also have sesquilinear products as a third incarnation of this sort of structure.</p>",
        "id": 223330763,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611116426
    },
    {
        "content": "<p>It might be tempting to have some sort of proto-inner product typeclass to replace bilinear forms and sesquilinear forms and then build the inner product space typeclass on top of that, but I'm not sure that would play well with the fact that inner product spaces are built on top of normed spaces.</p>",
        "id": 223330978,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611116731
    },
    {
        "content": "<p>Maybe having the bilinear/sesquilinear typeclass as a mixin would work.</p>",
        "id": 223331075,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611116821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223330978\">said</a>:</p>\n<blockquote>\n<p>I'm not sure that would play well with the fact that inner product spaces are built on top of normed spaces.</p>\n</blockquote>\n<p>Right, there is the further distinction between linear maps and continuous linear maps.  This latter distinction means, eg, that there need to be two separate constructions of a \"dual\", one for linear maps and one for continuous linear maps.</p>",
        "id": 223331141,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611116890
    },
    {
        "content": "<p>Maybe make the dual a typeclass also?</p>",
        "id": 223331240,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611117032
    },
    {
        "content": "<p>I don't quite follow ... I am not proposing any particular change here, just noting that there is an existing, large-scale parallel development of linear maps and continuous linear maps, culminating in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.dual\">docs#module.dual</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual\">docs#normed_space.dual</a>.</p>\n<p>Or are you proposing a change? :)</p>",
        "id": 223331562,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611117384
    },
    {
        "content": "<p>I agree that the dichotomy between structures and classes puts some restrictions. But I would imagine developing the theory for the generic structure first, and then have 1-liner specializations (maybe automated??) for type classes like <code>inner_product_space</code>.</p>",
        "id": 223331582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611117420
    },
    {
        "content": "<p>That would be nice!</p>",
        "id": 223331611,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611117477
    },
    {
        "content": "<p>Yeah maybe that's the simplest thing to do. Which brings us back to conjugate-linear maps, because we would want to do this for a joint bilinear/sesquilinear form.</p>",
        "id": 223331703,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611117585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223331562\">said</a>:</p>\n<blockquote>\n<p>I don't quite follow ... I am not proposing any particular change here, just noting that there is an existing, large-scale parallel development of linear maps and continuous linear maps, culminating in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.dual\">docs#module.dual</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/normed_space.dual\">docs#normed_space.dual</a>.</p>\n<p>Or are you proposing a change? :)</p>\n</blockquote>\n<p>I was thinking of defining a typeclass <code>dual ùïú E</code> with whatever axioms we would want a reasonable dual to have, with <code>E ‚ÜíL[ùïú] ùïú</code> being an instance for <code>normed_space ùïú E</code>, and this would allow us to generalize the concept. But it does open a whole can of worms regarding the uniqueness of duals, and on second thought it's probably a bad idea.</p>",
        "id": 223331880,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611117770
    },
    {
        "content": "<p>Can we associate a bilinear form with the typeclass, and move as many proofs as possible over to bilinear_form? So add a <code>inner_product_space.bilinear</code> member computed from the existing fields.</p>",
        "id": 223346481,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611133256
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> The problem is that the inner product is not necessarily bilinear.  In the complex case it's sesquilinear.  This is why the lack of conjugate-linear maps is the real issue here.</p>",
        "id": 223378062,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611152540
    },
    {
        "content": "<p>I don't think we should go in the direction of generalizing linear maps to \"linear maps with an automorphism in the target\" everywhere in mathlib: the real concept is that of a linear map, and the issue is that we don't want to rely on the usual vector space structure in the target, but on a twisted one. It would seem more natural to me to introduce a type synonym for the target, in which the vector space structure should be changed. Something like <code>restrict_scalars</code> -- in fact, <code>restrict_scalars</code> is a particular case of this situation: suppose that you have a field morphism <code>u : R -&gt; C</code>, and a <code>C</code> vector space <code>E</code>. Then you can define an <code>R</code>-vector space structure on <code>E</code>, by setting <code>r ‚Ä¢ x := u(r) ‚Ä¢ x</code>. When <code>R</code> is the reals and <code>C</code> is the complexes and <code>u</code> is the inclusion, this is the usual scalar restriction. When both are the complexes and <code>u</code> is complex conjugation, this twists the complex structure. So a \"conjugate-linear map\" on <code>E</code> is just a linear map in the usual sense from <code>E</code> to <code>twist_structure u E</code>.</p>",
        "id": 223480185,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611217392
    },
    {
        "content": "<p>But we try to avoid <code>restrict_scalars</code> in favour of <code>scalar_tower</code>, because type synonyms have their own disadvantages...</p>",
        "id": 223481102,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611218225
    },
    {
        "content": "<p>For example, you can't compose a conjugate-linear endomorphism with itself, because the domain is no longer the same as the target.</p>",
        "id": 223481224,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611218312
    },
    {
        "content": "<p>You can compose them as maps, but not as linear maps, which is good because for general field automorphisms the composition is not a linear map.</p>",
        "id": 223482007,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611218875
    },
    {
        "content": "<p>Sorry, there is something that always works here: a linear map from <code>E</code> to <code>twisted u E</code> gives also a linear map from <code>twisted v E</code> to <code>twisted (u o v) E</code>, or something like that.</p>",
        "id": 223482378,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611219185
    },
    {
        "content": "<p>Right, but those target types quickly become quite messy. That second map is not defeq to a map from <code>E'</code> to <code>twisted _ E'</code>, so you would have to rewrite the target to <code>twisted v (twisted u E)</code> which doesn't look nice.</p>",
        "id": 223482879,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611219551
    },
    {
        "content": "<p>I don't mean to say this is not the way to go. I don't have a better idea. It's just that... you know, I wish life would be easier <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 223482933,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611219594
    },
    {
        "content": "<p>It's definitely defeq to a map from <code>E</code> to <code>E</code>, as <code>twisted u E</code> is defeq to <code>E</code>. As linear maps, I agree they are not defeq, but it's normal since it's a theorem, in a sense.</p>",
        "id": 223483154,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611219723
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> This approach with a type synonym sounds similar to <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span>' experiment a while ago, in one version of <a href=\"https://github.com/leanprover-community/mathlib/issues/4379\">#4379</a>, to write down the \"complex conjugate vector space\" structure (see <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear.20maps\">discussion</a>) and express conjugate-linear maps as linear maps to it.  Here's about the right range of commits:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/4379/files/46f75e1e2e460e9be46e699067656f641d790f80?file-filters%5B%5D=.lean\">https://github.com/leanprover-community/mathlib/pull/4379/files/46f75e1e2e460e9be46e699067656f641d790f80?file-filters%5B%5D=.lean</a></p>\n<p>Is this more or less the method you're suggesting, or are there things you would change?</p>\n<p>One point is that he worked with a map <code>I : R ‚âÉ+* R·µí·µñ</code>, and it sounds like you're suggesting a map <code>I : R ‚âÉ+* R</code>.</p>",
        "id": 223512614,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611238339
    },
    {
        "content": "<p>Yes, it is essentially this idea (thanks for the pointer!) except that in fact I am suggesting a map <code>I : R -&gt;+* C</code> to be able to cover both scalar restriction and structure twisting with a single construction.</p>",
        "id": 223516722,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611240119
    },
    {
        "content": "<p>Can you explain how the Hermitian inner product would look under this construction?  Is it something like, a map from <code>E √ó E</code> to <code>‚ÑÇ ‚äó (twisted ‚ÑÇ)</code>?</p>",
        "id": 223517830,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611240586
    },
    {
        "content": "<p>A bilinear map is in general a linear map on <code>E ‚äó E</code>. A map which is linear in the first variable and antilinear in the second variable is therefore a linear map on <code>E ‚äó (twisted E)</code>. But I don't know if it is worth taking a tensor product viewpoint like that, or saying that it is a map of two variables on <code>E x E</code> which, when you fix a second variable, is a linear map, and when you fix a first variable is linear from <code>E</code> to <code>twisted ‚ÑÇ</code> or, equivalently, is linear from <code>twisted E</code> to <code>‚ÑÇ</code>.</p>",
        "id": 223518957,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611241085
    },
    {
        "content": "<p>Currently <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bilin_form\">docs#bilin_form</a> (which is what's used in <a href=\"https://github.com/leanprover-community/mathlib/issues/5814\">#5814</a>) is a map from <code>M x M</code> to <code>R</code>, that is linear in both arguments.</p>\n<p>You propose that this would be generalized to an object which takes as a parameter a map <code>I : R ‚âÉ+* R</code>, and is a map from <code>M x M</code> to <code>R</code>, that is linear in the first argument and <code>I</code>-twisted linear in the second argument?</p>\n<p>And then <code>inner_product_space</code> gets redefined to be a tuple of <code>normed_space</code>, plus such a twisted form (with <code>I = is_R_or_C.conj</code>), plus a compatibility condition?  And then there's a refactor to move much of the material in <code>inner_product_space</code> to <code>bilin_form</code>?</p>",
        "id": 223522825,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611242533
    },
    {
        "content": "<p>I don't really have the background, but should it be <code>I : R ‚âÉ+* R·µí·µñ</code> to allow for conjugate-linearity in non-commutative rings? Or can we not build bilinear maps of those anyway?</p>",
        "id": 223523188,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611242665
    },
    {
        "content": "<p>I believe this caused Fr√©d√©ric some headaches (see the code I linked <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223512614\">above</a>), but I don't remember exactly, maybe he will comment.</p>",
        "id": 223523493,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611242775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223522825\">said</a>:</p>\n<blockquote>\n<p>You propose that this would be generalized to an object which takes as a parameter a map <code>I : R ‚âÉ+* R</code>, and is a map from <code>M x M</code> to <code>R</code>, that is linear in the first argument and <code>I</code>-twisted linear in the second argument?</p>\n</blockquote>\n<p>This object is precisely <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sesq_form\">docs#sesq_form</a>, isn't it?</p>",
        "id": 223523507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611242779
    },
    {
        "content": "<p>Well, that's for <code>R·µí·µñ</code>.</p>",
        "id": 223523555,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611242801
    },
    {
        "content": "<p>Do we have somewhere that <code>id</code> is a <code>R ‚âÉ+* R·µí·µñ</code> for commutative rings? Maybe that would glue over the awkwardness for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> (edit: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/ring_invo.id\">docs#ring_invo.id</a>)</p>",
        "id": 223525555,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611243561
    },
    {
        "content": "<p>I don't have an opinion for <code>R</code> or <code>R·µí·µñ</code>. I have no meaningful application of sesquilinear forms taking values in a non-commutative ring in mind, but of course it doesn't mean such applications don't exist.</p>",
        "id": 223525628,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611243596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223522825\">said</a>:</p>\n<blockquote>\n<p>And then <code>inner_product_space</code> gets redefined to be a tuple of <code>normed_space</code>, plus such a twisted form (with <code>I = is_R_or_C.conj</code>), plus a compatibility condition?  And then there's a refactor to move much of the material in <code>inner_product_space</code> to <code>bilin_form</code>?</p>\n</blockquote>\n<p>Are you in favour of having this big refactor of <code>inner_product_space</code>?  ... in which case we need to find someone to do it ;)</p>",
        "id": 223526094,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611243775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223523493\">said</a>:</p>\n<blockquote>\n<p>see the code I linked <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223512614\">above</a></p>\n</blockquote>\n<p>I've merged this with master and pushed it to <a href=\"https://github.com/leanprover-community/mathlib/tree/conjugate-module\">branch#conjugate-module</a>, to encourage it not to get completely lost.</p>",
        "id": 223528724,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611244773
    },
    {
        "content": "<p>I would argue against the type synonym approach, after having experimented a bit with it. It's <em>very</em> unpleasant to work with, since you almost never actually want to work in the the \"twisted\" space, so you have to dance around to get back to space you actually want. Just to give an example: suppose I want to define the adjoint of a map <code>E ‚Üí‚Çó[‚ÑÇ] F</code> where <code>E</code> and <code>F</code> are complex vector spaces. The natural thing to do would be to define <code>adj</code> as a bundled conjugate-linear map from <code>E ‚Üí‚Çó[‚ÑÇ] F</code> to <code>F ‚Üí‚Çó[‚ÑÇ] E</code>. With the type synonyms, this just becomes a nightmare. I think generalizing linear maps would work a lot better in practice. If calling it a \"linear map\" is a sacrilege, we can always rename it to <code>semilinear_map</code> :-)</p>",
        "id": 223529128,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611244921
    },
    {
        "content": "<p>Since you have experimented with this, I'll trust your word on it! My concern is that, if one starts to define linear maps for twisted structures, one will also want to define modules for twisted structures, matrices for twisted structures, and in the end redo all the linear algebra library by adding everywhere a twisting factor (and for linear maps one should maybe even have the possibility to add one twisting factor in the source and one in the target) -- otherwise, twisted linear maps will just be gadget that doesn't play well with the rest of the library. And that doesn't seem reasonable.</p>",
        "id": 223533621,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611246542
    },
    {
        "content": "<p>I have been thinking lately about the \"composition problem\" if we go the route of generalizing linear maps to semilinear.  I have an idea and would be interested on comments about whether it's workable.</p>",
        "id": 223536165,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247561
    },
    {
        "content": "<p>Let me first outline the \"naive method\", <span class=\"user-mention\" data-user-id=\"311453\">@Fr√©d√©ric Dupuis</span> this is what we both have in mind, right?  One has modules <code>M</code> over <code>R</code>, <code>M‚ÇÇ</code> over <code>S</code>, and a homomorphism <code>œÉ : R ‚Üí+* S</code>; then composition of two such semilinear maps associated to homomorphisms <code>œÉ : R ‚Üí+* S</code> and <code>œÑ : S ‚Üí+* T</code> gives a semilinear map for the homomorphism <code>œÑ.comp œÉ : R ‚Üí+* T</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">œÉ</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M‚ÇÇ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">S</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">semilinear_map</span>  <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_add'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_smul'</span> <span class=\"o\">:</span> <span class=\"bp\">‚àÄ</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">œÉ</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">‚Ä¢</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">semilinear_map</span> <span class=\"n\">œÉ</span> <span class=\"n\">M</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">‚ü®</span><span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">semilinear_map.to_fun</span><span class=\"o\">‚ü©</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">T</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">œÑ</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M‚ÇÉ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M‚ÇÉ</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semimodule</span> <span class=\"n\">T</span> <span class=\"n\">M‚ÇÉ</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">semilinear_map</span> <span class=\"n\">œÉ</span> <span class=\"n\">M</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">semilinear_map</span> <span class=\"n\">œÑ</span> <span class=\"n\">M‚ÇÇ</span> <span class=\"n\">M‚ÇÉ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilinear_map</span> <span class=\"o\">(</span><span class=\"n\">œÑ.comp</span> <span class=\"n\">œÉ</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">M‚ÇÉ</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">g</span> <span class=\"bp\">‚àò</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">‚ü©</span>\n</code></pre></div>",
        "id": 223536604,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247735
    },
    {
        "content": "<p>The variation I had in mind was to instead make composition take as extra parameters a third homomorphism<code>(Œ∑ : R ‚Üí+* T)</code>, together with <code>[fact (œÑ.comp œÉ = Œ∑)]</code>.</p>",
        "id": 223536684,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247782
    },
    {
        "content": "<p>Then composition gives you a <code>semilinear_map Œ∑ M M‚ÇÉ</code>.</p>",
        "id": 223536823,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247836
    },
    {
        "content": "<p>And we could provide instances for the <code>fact</code>s we expect to use regularly, such as <code>[fact (id.comp id = id)]</code>, which means that the composition of standard-linear maps is just a standard-linear map, rather than an <code>id.comp id</code>-linear map.</p>",
        "id": 223536951,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247910
    },
    {
        "content": "<p>Likewise, instances for <code>[fact (conj.comp id = conj)]</code> and <code>[fact (id.comp conj = conj)]</code>.</p>",
        "id": 223537147,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611247990
    },
    {
        "content": "<p><del>Does that help though? <code>semilinear_map (conj.comp conj) M M‚ÇÉ</code> is still a different type to <code>semilinear_map id M M‚ÇÉ</code></del> ah, that's <code>Œ∑</code></p>",
        "id": 223537400,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611248112
    },
    {
        "content": "<p>What do you mean?  The idea is that one would never have to use <code>semilinear_map (conj.comp conj) M M‚ÇÉ</code>.</p>",
        "id": 223537493,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611248149
    },
    {
        "content": "<p>(another instance one would provide is <code>[fact (conj.comp conj = id)]</code>)</p>",
        "id": 223537587,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611248174
    },
    {
        "content": "<p>To be explicit, you're proposing</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">comp'</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">semilinear_map</span> <span class=\"n\">œÉ</span> <span class=\"n\">M</span> <span class=\"n\">M‚ÇÇ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">semilinear_map</span> <span class=\"n\">œÑ</span> <span class=\"n\">M‚ÇÇ</span> <span class=\"n\">M‚ÇÉ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Œ∑</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">‚Üí+*</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fact</span> <span class=\"o\">(</span><span class=\"n\">œÑ.comp</span> <span class=\"n\">œÉ</span> <span class=\"bp\">=</span> <span class=\"n\">Œ∑</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"n\">semilinear_map</span> <span class=\"n\">Œ∑</span> <span class=\"n\">M</span> <span class=\"n\">M‚ÇÉ</span> <span class=\"o\">:=</span>\n<span class=\"o\">‚ü®</span><span class=\"n\">g</span> <span class=\"bp\">‚àò</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"gr\">sorry</span><span class=\"o\">‚ü©</span>\n</code></pre></div>\n<p>My comment above was me failing to match your code to your prose, and should be ignored</p>",
        "id": 223537704,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611248215
    },
    {
        "content": "<p>Yup.</p>",
        "id": 223537745,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611248230
    },
    {
        "content": "<p>Instead of an argument to comp, there could just be a version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.restrict_scalars\">docs#linear_map.restrict_scalars</a> to rewrite the value of the <code>‚Üí+*</code> instead of the base ring, making it <code>(f.comp g).restrict_œÉ Œ∑</code> or similar</p>",
        "id": 223538047,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611248342
    },
    {
        "content": "<p>The thing is, I think we often want that this kind of rewriting occur <em>by default</em>, eg, we want the default composition of two <code>id</code>-linear maps to be an <code>id</code>-linear map.</p>",
        "id": 223538339,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611248440
    },
    {
        "content": "<p>That's fair - but I think we'd also want a not-by-default version for when the proof needed is too involved to belong in a <code>fact</code>, from which the default could be implemented.</p>",
        "id": 223538672,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611248570
    },
    {
        "content": "<p>For that I was hoping one could use <code>[fact (œÑ.comp œÉ = œÑ.comp œÉ)]</code> :)</p>",
        "id": 223538828,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611248628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223536604\">said</a>:</p>\n<blockquote>\n<p>Let me first outline the \"naive method\", <span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> this is what we both have in mind, right?  One has modules <code>M</code> over <code>R</code>, <code>M‚ÇÇ</code> over <code>S</code>, and a homomorphism <code>œÉ : R ‚Üí+* S</code>; then composition of two such semilinear maps associated to homomorphisms <code>œÉ : R ‚Üí+* S</code> and <code>œÑ : S ‚Üí+* T</code> gives a semilinear map for the homomorphism <code>œÑ.comp œÉ : R ‚Üí+* T</code>.</p>\n</blockquote>\n<p>Yes, that's what I was thinking of, and I like your proposal for composition, it seems like it should work.</p>",
        "id": 223540605,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611249247
    },
    {
        "content": "<p>Another idea -- perhaps one could implement linear maps just as a notational overlay on semilinear maps, i.e. <code>M ‚Üí‚Çó[R] M‚ÇÇ</code> means <code>semilinear_map (ring_hom.id R) M M‚ÇÇ</code></p>",
        "id": 223541202,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611249502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223533621\">said</a>:</p>\n<blockquote>\n<p>Since you have experimented with this, I'll trust your word on it! My concern is that, if one starts to define linear maps for twisted structures, one will also want to define modules for twisted structures, matrices for twisted structures, and in the end redo all the linear algebra library by adding everywhere a twisting factor (and for linear maps one should maybe even have the possibility to add one twisting factor in the source and one in the target) -- otherwise, twisted linear maps will just be gadget that doesn't play well with the rest of the library. And that doesn't seem reasonable.</p>\n</blockquote>\n<p>I'm not sure what you mean by needing modules and matrices for twisted structures -- I think having semilinear maps would solve most of the issues I'm thinking of. Of course this would still be a fairly big refactor and this is the main downside, but judging from the quick tests I did it's not nearly as disruptive as I had initially thought.</p>",
        "id": 223541456,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611249604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223541202\">said</a>:</p>\n<blockquote>\n<p>Another idea -- perhaps one could implement linear maps just as a notational overlay on semilinear maps, i.e. <code>M ‚Üí‚Çó[R] M‚ÇÇ</code> means <code>semilinear_map (ring_hom.id R) M M‚ÇÇ</code></p>\n</blockquote>\n<p>Yes, this seemed to work surprisingly well when I tried it.</p>",
        "id": 223545268,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611251375
    },
    {
        "content": "<p><code>linear_map</code> is almost never used directly in the library, it's nearly always through this notation.</p>",
        "id": 223545384,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611251416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Fr√©d√©ric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545268\">said</a>:</p>\n<blockquote>\n<p>Yes, this seemed to work surprisingly well when I tried it.</p>\n</blockquote>\n<p>Ah, you already tried this! :)</p>",
        "id": 223545447,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611251448
    },
    {
        "content": "<p>Yes, I just tried redefining <code>linear_map</code> as in this proposal and setting up the notation like this. It didn't break much, but of course we would then have to start generalizing theorems to semilinear maps.</p>",
        "id": 223545554,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611251496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223537147\">said</a>:</p>\n<blockquote>\n<p>Likewise, instances for <code>[fact (conj.comp id = conj)]</code> and <code>[fact (id.comp conj = conj)]</code>.</p>\n</blockquote>\n<p>The only downside is that <code>fact</code> shouldn't have global instances. The easy work around is to not use <code>fact</code> but a dedicated <code>fact'</code> (name too be discussed <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>)</p>",
        "id": 223546024,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611251708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546024\">said</a>:</p>\n<blockquote>\n<p>The only downside is that <code>fact</code> shouldn't have global instances.</p>\n</blockquote>\n<p>Oh interesting, can you explain?</p>",
        "id": 223546189,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611251775
    },
    {
        "content": "<p>As I understand it, the typeclass system indexes on the head symbol. So if there are many instances about <code>fact ((foo.comp bar) = quux)</code>, then everytime the <code>p</code>-adic numbers need <code>fact p.prime</code>, TC will also try all those composition facts.</p>",
        "id": 223546353,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611251872
    },
    {
        "content": "<p>So, instances of the form <code>[fact foobar] : [fact xyzzy]</code> are fine, because they keep everything local, and hence when TC searches for <code>fact xyzzy</code> there will only be a small set of <code>facts</code> in scope.<br>\nCurrently there are 5 (or so) global instances. If we start adding a lot to those, TC search might explode.</p>",
        "id": 223546557,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611251971
    },
    {
        "content": "<p>TC experts: correct me if I'm wrong</p>",
        "id": 223546589,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611251983
    },
    {
        "content": "<p>Either way, we could definitely live with a dedicated version of <code>fact</code> for this.</p>",
        "id": 223546798,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611252045
    },
    {
        "content": "<p>Would something like this work?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">is_composition_tuple</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">comp_property</span> <span class=\"o\">:</span> <span class=\"n\">œÑ.comp</span> <span class=\"n\">œÉ</span> <span class=\"bp\">=</span> <span class=\"n\">Œ∑</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">is_composition_tuple</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">comp_property</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp_id</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 223546870,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611252081
    },
    {
        "content": "<p>certainly, except that the name seems a bit long</p>",
        "id": 223546963,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611252122
    },
    {
        "content": "<p>Also, you don't need one for <code>id.comp id</code> because it follows from <code>id.comp f = f</code>... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 223547077,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611252151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223546557\">said</a>:</p>\n<blockquote>\n<p>So, instances of the form <code>[fact foobar] : [fact xyzzy]</code> are fine, because they keep everything local, and hence when TC searches for <code>fact xyzzy</code> there will only be a small set of <code>facts</code> in scope.<br>\nCurrently there are 5 (or so) global instances. If we start adding a lot to those, TC search might explode.</p>\n</blockquote>\n<p>No? Any fact instance will make the global search problem harder. There aren't supposed to be any global instances</p>",
        "id": 223547085,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611252154
    },
    {
        "content": "<p>So we should remove those 5</p>",
        "id": 223547142,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611252176
    },
    {
        "content": "<p>What are they?</p>",
        "id": 223547191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611252191
    },
    {
        "content": "<p>Probably <code>fact (0 &lt; 1)</code> and <code>fact (nat.prime 2)</code> and the likes.</p>",
        "id": 223547248,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611252211
    },
    {
        "content": "<p>Isn't <code>nat.prime</code> a class? Why can't that be an instance?</p>",
        "id": 223547346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611252244
    },
    {
        "content": "<p>No, it's not a class, afaik</p>",
        "id": 223547376,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611252254
    },
    {
        "content": "<p>We could put those facts into a locale, if there are enough of them to make the organization worthwhile</p>",
        "id": 223547789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1611252411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547077\">said</a>:</p>\n<blockquote>\n<p>Also, you don't need one for <code>id.comp id</code> because it follows from <code>id.comp f = f</code>... <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>\n</blockquote>\n<p>I didn't immediately understand, but your point is that we would definitely have the instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_composition_tuple</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">f</span>\n</code></pre></div>\n<p>and so it's unnecessary also to have the instance</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">is_composition_tuple</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Is that right?</p>",
        "id": 223547912,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611252480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223547789\">said</a>:</p>\n<blockquote>\n<p>We could put those facts into a locale, if there are enough of them to make the organization worthwhile</p>\n</blockquote>\n<p>I think we need:</p>\n<ul>\n<li><code>[fact (id.comp œÉ = œÉ)]</code></li>\n<li><code>[fact (œÉ.comp id = œÉ)]</code></li>\n<li><code>[fact (conj.comp conj = id)]</code></li>\n<li><code>[fact (œÑ.comp œÉ = œÑ.comp œÉ)]</code></li>\n</ul>",
        "id": 223548358,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611252665
    },
    {
        "content": "<p>Note that the right-hand side can in general not be deduced from the left-hand side, so there should be some outparam trickery to make this work. If I understand correctly, when setting up the general theory there would be some typeclass assumption like <code>[is_composition_tuple u v w]</code> where <code>u</code>, <code>v</code> and <code>w</code> are some generic automorphisms, and in concrete applications it would pick the right <code>w</code> automatically? This sounds like a pretty idea!</p>",
        "id": 223549939,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611253427
    },
    {
        "content": "<blockquote>\n<p>are some generic automorphisms, </p>\n</blockquote>\n<p>I'm pretty sure we don't have a way of generalizing across types of homomorphisms (linear_map, add_monoid_hom, etc), ignoring the <code>category</code> library that is used in a self-contained way.</p>",
        "id": 223553637,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1611255070
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223553637\">said</a>:</p>\n<blockquote>\n<p>ignoring the <code>category</code> library that is used in a self-contained way.</p>\n</blockquote>\n<p>Yeah, I've always thought that we could save a lot of boilerplate code by using category theory for these kinds of objects.</p>",
        "id": 223555833,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611256055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223553637\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>are some generic automorphisms, </p>\n</blockquote>\n<p>I'm pretty sure we don't have a way of generalizing across types of homomorphisms (linear_map, add_monoid_hom, etc), ignoring the <code>category</code> library that is used in a self-contained way.</p>\n</blockquote>\n<p>Yeah, I meant \"generic\" in the sense of \"not a prescribed one\" (i.e., not just the identity or complex conjugation), but still within the realm of field automorphisms.</p>",
        "id": 223561684,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611258677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223549939\">said</a>:</p>\n<blockquote>\n<p>Note that the right-hand side can in general not be deduced from the left-hand side, so there should be some outparam trickery to make this work. If I understand correctly, when setting up the general theory there would be some typeclass assumption like <code>[is_composition_tuple u v w]</code> where <code>u</code>, <code>v</code> and <code>w</code> are some generic automorphisms, and in concrete applications it would pick the right <code>w</code> automatically? This sounds like a pretty idea!</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> I think maybe you have had a further idea beyond what I said, could you explain?  I was imagining that given a <code>u</code>-linear map <code>f</code> and <code>v</code>-linear map <code>g</code>, one would have to specify the desired <code>w</code> when composing, like <code>f.comp w g</code>.  The composition would require an instance <code>[is_composition_tuple u v w]</code> (i.e., <code>w = v.comp u</code>), and we would write down the \"usual\" instances, so that typeclass inference could find them silently in the concrete applications.</p>\n<p>But you are saying there might be a way to use <code>out_param</code> to find the <code>w</code> automatically, so one could write <code>f.comp g</code>?  That would be better!</p>",
        "id": 223569584,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611262813
    },
    {
        "content": "<p>Yes, that's exactly what out_params do. Otherwise, you would need to write <code>f.comp id g</code> most of the time, and this would get really boring.</p>",
        "id": 223570687,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611263383
    },
    {
        "content": "<p>I was thinking that one would provide <code>[is_composition_tuple u v (v.comp u)]</code>, as a backup for when there is no better way of expressing the composition.  Can you do this but also ensure that the better <code>w</code> is chosen when it's available?</p>",
        "id": 223570881,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611263472
    },
    {
        "content": "<p>Maybe by putting a very low priority on <code>[is_composition_tuple u v (v.comp u)]</code>?</p>",
        "id": 223570904,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611263490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570687\">said</a>:</p>\n<blockquote>\n<p>Otherwise, you would need to write <code>f.comp id g</code> most of the time, and this would get really boring.</p>\n</blockquote>\n<p>We could still have <code>abbreviation</code>s <code>linear_map</code> and <code>linear_map.comp</code> that take care of this, right?</p>",
        "id": 223571007,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611263527
    },
    {
        "content": "<p>If the outparams work, that would be great. But if they don't work, they can be very painful.</p>",
        "id": 223571064,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611263561
    },
    {
        "content": "<p>From Fr√©d√©ric's <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223545268\">experiments</a>, apparently one may not even need an abbreviation <code>linear_map</code>, just notation.</p>",
        "id": 223571165,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611263610
    },
    {
        "content": "<p>But do you think an abbreviation would work better?</p>",
        "id": 223571319,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611263672
    },
    {
        "content": "<p>It would allow for dot-notation, if we need that</p>",
        "id": 223571416,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1611263733
    },
    {
        "content": "<p>For composition, an abbreviation would be a good plan B in case the <code>out_param</code> thing fails.</p>",
        "id": 223571450,
        "sender_full_name": "Fr√©d√©ric Dupuis",
        "timestamp": 1611263751
    },
    {
        "content": "<p>Another question (which Fr√©d√©ric raised before):  will there still be <code>out_param</code> in Lean 4, and will it work the same way?</p>",
        "id": 223571571,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611263804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Conjugate-linear/near/223570881\">said</a>:</p>\n<blockquote>\n<p>I was thinking that one would provide <code>[is_composition_tuple u v (v.comp u)]</code>, as a backup for when there is no better way of expressing the composition.  Can you do this but also ensure that the better <code>w</code> is chosen when it's available?</p>\n</blockquote>\n<p>The problem if you state a theorem that way is that it will only apply when the <code>is_composition_tuple</code> mechanism chooses exactly <code>v.comp u</code>, which is not what you want because you want to apply your theorems in all situations. So I guess we should state theorems with generic assumptions <code>[is_composition_tuple u v w]</code>, so that they apply in all situations.</p>",
        "id": 223573290,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611264689
    },
    {
        "content": "<p>For applications of the theorems, on the other hand, I agree we can have the instance you're mentioning, with a low priority to make sure that the other ones are found first.</p>",
        "id": 223573631,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611264863
    },
    {
        "content": "<p>Yes, great!  For use when <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> does Frobenius-semilinear algebra, whatever that is :)</p>",
        "id": 223573768,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611264937
    },
    {
        "content": "<p>By the way, another point is that sometimes one has to deal with three maps, and thus with associativity (I remember Yury mentioning this).  I'm not sure if the existence of</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">is_composition_tuple</span> <span class=\"o\">(</span><span class=\"n\">v.comp</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"n\">w</span> <span class=\"o\">((</span><span class=\"n\">w.comp</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">u</span><span class=\"o\">)]</span>\n</code></pre></div>\n<p>is enough to solve all problems there.</p>",
        "id": 223574970,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1611265547
    },
    {
        "content": "<p>Given that it will probably take some time before someone finds the courage to do the refactor, it might make sense, for now, to merge separately the two PRs that give the existence of orthonormal basis in the two contexts, to avoid blocking further progress. What do you think?</p>",
        "id": 223619096,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1611308038
    },
    {
        "content": "<p>It seems we stalled on <span class=\"user-mention\" data-user-id=\"243312\">@Jason KY.</span>'s PR <a href=\"https://github.com/leanprover-community/mathlib/issues/5814\">#5814</a>. (It's currently the oldest PR on <a href=\"https://bit.ly/3kaztxO\">#queue</a>!) Shall we merge it?</p>",
        "id": 226601572,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1613524098
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> was experimenting with different approaches</p>",
        "id": 226617463,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1613542125
    },
    {
        "content": "<p>No longer the oldest on the queue now that I made some style changes :) Can we merge this and make changes to it afterwards however? I'm proving some stuff about nondegenerate forms and I would like to use some definitions found in that pr.</p>",
        "id": 226648053,
        "sender_full_name": "Jason KY.",
        "timestamp": 1613564340
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> do you mind taking a look at <a href=\"https://github.com/leanprover-community/mathlib/issues/5814\">#5814</a> again? It looks to me like it's waiting on your OK...</p>",
        "id": 228822713,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1614881663
    },
    {
        "content": "<p>Sorry, I didn't realise!  I'll take a look.</p>",
        "id": 228823918,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1614882088
    }
]
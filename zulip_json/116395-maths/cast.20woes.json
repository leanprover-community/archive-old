[
    {
        "content": "<p>It's quite humiliating, but how do I kill:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 160656265,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552477937
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">:=</span>\n<span class=\"k\">show</span> <span class=\"bp\">_</span> <span class=\"bp\">&lt;</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"err\">←</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span><span class=\"o\">,</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"o\">]</span><span class=\"bp\">;</span> <span class=\"n\">apply</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"bp\">.</span><span class=\"n\">gt_one</span><span class=\"bp\">;</span> <span class=\"n\">assumption</span>\n</pre></div>",
        "id": 160656373,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1552478068
    },
    {
        "content": "<p><code>pp.gt_one</code>?</p>",
        "id": 160656379,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552478078
    },
    {
        "content": "<p>why is <code>[p.prime]</code> an instance though</p>",
        "id": 160656397,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1552478107
    },
    {
        "content": "<p>We really need a <code>cast</code> tactic.</p>",
        "id": 160656399,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552478109
    },
    {
        "content": "<p>and also why does <code>data.nat.prime</code> use ge and gt <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span></p>",
        "id": 160656404,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1552478122
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> Thanks</p>",
        "id": 160656475,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552478173
    },
    {
        "content": "<p>I guess it's a bit more natural to read <code>prime.gt_one</code>? not a strong argument</p>",
        "id": 160656504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552478224
    },
    {
        "content": "<p>you can make them all le and lt if you want</p>",
        "id": 160656525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552478267
    },
    {
        "content": "<p>I would love to be able to prove this via</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">),</span>\n<span class=\"o\">{</span> <span class=\"n\">cast_magic</span> <span class=\"kn\">using</span> <span class=\"n\">this</span> <span class=\"o\">},</span>\n<span class=\"bp\">...</span>\n</pre></div>",
        "id": 160656679,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552478423
    },
    {
        "content": "<p>Did you read my docs on cast?</p>",
        "id": 160658825,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552480630
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md\">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/casts.md</a></p>",
        "id": 160658839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552480668
    },
    {
        "content": "<p>Yes, I read those... but I guess I also forgot them</p>",
        "id": 160658875,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552480682
    },
    {
        "content": "<p>I feel like at least there's an algorithm in there, even if not a tactic</p>",
        "id": 160658888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552480686
    },
    {
        "content": "<p>I wrote them, and I certainly also forgot them.</p>",
        "id": 160658892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552480697
    },
    {
        "content": "<p>That's why I wrote them :-)</p>",
        "id": 160658894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552480704
    },
    {
        "content": "<p>My docs don't seem to help.</p>",
        "id": 160660252,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<p>\"1=1\" can be proved by simp, but for <code>a&lt;b iff a&lt;b</code> it helps a lot if you know the statement of the lemma.</p>",
        "id": 160660253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<p><code>simp</code> uses this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">coe_nat_inj&#39;</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_eq_coe_nat_iff</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>Actually I don't understand this. What does <code>simp</code> to do goals of the form <code>X -&gt; Y</code>? It tries to simplify <code>X</code> and <code>Y</code> and then sees if it has got lucky and the goal has become <code>Z -&gt; Z</code>?</p>",
        "id": 160660254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<p>This works now:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"bp\">→</span> <span class=\"n\">q</span> <span class=\"bp\">=</span> <span class=\"n\">r</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span>\n</pre></div>\n\n\n<p>It didn't used to, apparently. But I am a bit weirded out by this -- I thought that it wasn't <code>simp</code>s job to prove this sort of thing? It's an implication, not an iff or an equality.</p>",
        "id": 160660255,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_lt</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>It wasn't hard for me to construct a proof, but I had to know the general route.</p>",
        "id": 160660256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<p><code>simp</code> uses this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">coe_nat_inj&#39;</span> <span class=\"o\">{</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">↑</span><span class=\"n\">n</span> <span class=\"bp\">↔</span> <span class=\"n\">m</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">coe_nat_eq_coe_nat_iff</span> <span class=\"n\">m</span> <span class=\"n\">n</span>\n</pre></div>\n\n\n<p>Actually I don't understand this. What does <code>simp</code> to do goals of the form <code>X -&gt; Y</code>? It tries to simplify <code>X</code> and <code>Y</code> and then sees if it has got lucky and the goal has become <code>Z -&gt; Z</code>?</p>\n<p>Oh -- ha ha -- </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">theorem</span> <span class=\"n\">imp_self</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">iff_true_intro</span> <span class=\"n\">id</span>\n</pre></div>",
        "id": 160660257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482060
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"mi\">1</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- ⊢ ↑1 &lt; ↑p ↔ 1 &lt; p</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span> <span class=\"c1\">-- gaargh you stupid algorithm</span>\n  <span class=\"c1\">-- ⊢ 1 &lt; ↑p ↔ 1 &lt; p</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- @[simp] theorem nat.cast_lt [linear_ordered_semiring α] {m n : ℕ} :</span>\n<span class=\"c1\">--  (m : α) &lt; n ↔ m &lt; n := ...</span>\n</pre></div>",
        "id": 160660272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482066
    },
    {
        "content": "<p>It's a bit of a challenge to make <code>simp</code> use <code>nat.cast_lt</code> apparently. Can this be fixed somehow? I was seeing if I could construct a proof which did not involve needing to know the name of <code>nat.cast_lt</code> but just relied on the fact that it was a simp lemma.</p>",
        "id": 160661118,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482651
    },
    {
        "content": "<p>I want <code>nat.cast_lt</code> to have greater precedence than \\u 1 = 1.</p>",
        "id": 160661175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482705
    },
    {
        "content": "<p>it's not a question of precedence, it's that 1 is not \\u 1</p>",
        "id": 160661235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482735
    },
    {
        "content": "<p><code>simp</code> cannot solve cast problems, it's just not an appropriate tool</p>",
        "id": 160661266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482766
    },
    {
        "content": "<p>If I change 1 to <code>q</code> it works.</p>",
        "id": 160661271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482770
    },
    {
        "content": "<p>it will sometimes get lucky but that's all it is</p>",
        "id": 160661306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482791
    },
    {
        "content": "<p>I see.</p>",
        "id": 160661347,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482825
    },
    {
        "content": "<p>I don't really understand why <code>simp</code> doesn't solve it.</p>",
        "id": 160661384,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482843
    },
    {
        "content": "<p>It is exactly <code>nat.cast_lt</code>, no?</p>",
        "id": 160661434,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482853
    },
    {
        "content": "<p>what?</p>",
        "id": 160661437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482860
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>  -- ⊢ ↑1 &lt; ↑p ↔ 1 &lt; p\n  simp, -- gaargh you stupid algorithm\n  -- ⊢ 1 &lt; ↑p ↔ 1 &lt; p\n</pre></div>",
        "id": 160661462,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482895
    },
    {
        "content": "<p><code>1 &lt; ↑p ↔ 1 &lt; p</code> is defeq to an application of <code>nat.cast_lt</code>, but the pattern <code>↑?M1 &lt; ↑?M2</code> doesn't match syntactically</p>",
        "id": 160661497,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482929
    },
    {
        "content": "<p>I made it match syntactically, no?</p>",
        "id": 160661511,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482953
    },
    {
        "content": "<p>I got 1 into \\u 1 form</p>",
        "id": 160661568,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482970
    },
    {
        "content": "<p>simp sent it back</p>",
        "id": 160661572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552482975
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 160661578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552482983
    },
    {
        "content": "<p>So is it a question of precedence?</p>",
        "id": 160661616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552483006
    },
    {
        "content": "<p>The problem is that <code>nat.cast_lt</code> is not in a simp normal form, so it rarely triggers</p>",
        "id": 160661636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483018
    },
    {
        "content": "<p><code>simp</code> is not confluent as a result</p>",
        "id": 160661654,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483030
    },
    {
        "content": "<p>The honest approach would just be to have <code>nat.cast_lt</code> not be a simp rule at all, but it works opportunistically sometimes</p>",
        "id": 160661768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483109
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">nat</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">simpa</span> <span class=\"kn\">using</span> <span class=\"n\">this</span><span class=\"o\">,</span>\n  <span class=\"n\">revert</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">suffices</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span> <span class=\"bp\">↔</span> <span class=\"n\">q</span> <span class=\"bp\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">this</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>\n\n\n<p>That works, which is kind of cool, because it meant that I didn't need to know the names of any obscure lemmas.</p>",
        "id": 160661824,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552483162
    },
    {
        "content": "<blockquote>\n<p>names of any obscure lemmas</p>\n</blockquote>\n<p>You mean \"names of anything at all\", right?</p>",
        "id": 160661859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483191
    },
    {
        "content": "<p>These are not difficult names</p>",
        "id": 160661866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483200
    },
    {
        "content": "<p>there is much worse than this in the library</p>",
        "id": 160661923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483212
    },
    {
        "content": "<p>:-)</p>",
        "id": 160661927,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552483216
    },
    {
        "content": "<p>To a beginning maths undergraduate, they're all obscure lemmas :-)</p>",
        "id": 160661941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552483231
    },
    {
        "content": "<p>To me, they're a little obscure because some have <code>cast</code> and some have <code>coe</code></p>",
        "id": 160661976,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552483268
    },
    {
        "content": "<p>This is unfortunate; most of the <code>coe</code> names have to do with coercions from nat to int in core</p>",
        "id": 160662027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1552483318
    },
    {
        "content": "<p>I really don't like these goals.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">p</span><span class=\"bp\">.</span><span class=\"n\">prime</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"bp\">-</span><span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 160662973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552484084
    },
    {
        "content": "<p>I don't think you need that p is prime there</p>",
        "id": 160663305,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552484347
    },
    {
        "content": "<p>;-)</p>",
        "id": 160663318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552484353
    },
    {
        "content": "<p>Did you read my docs about cast?</p>",
        "id": 160663329,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552484367
    },
    {
        "content": "<p>Kevin, I'd rather not prove these things by hand. Even if I can after reading a bunch of docs etc... I'm providing motivation for tactic-writers (-;</p>",
        "id": 160663765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552484691
    },
    {
        "content": "<p>They don't need motivation, they need pity</p>",
        "id": 160667482,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1552486926
    },
    {
        "content": "<p>I haven't fully read this thread (and I can't right now, I need to run in two minutes). But: we have a new intern in Amsterdam, as of last week, who's probably going to think about a cast tactic as his first project. We have some ideas about how to proceed. But if you have thoughts, desiderata, etc, put a list together for us.</p>",
        "id": 160669571,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1552487108
    },
    {
        "content": "<p>Awesome!</p>",
        "id": 160673278,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1552489395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> a general spec would be \"if a mathematician who thinks <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><mo>⊂</mo><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><mo>⊂</mo><mrow><mi mathvariant=\"double-struck\">Q</mi></mrow><mo>⊂</mo><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><mrow><mi mathvariant=\"double-struck\">C</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}\\subset\\mathbb{Z}\\subset\\mathbb{Q}\\subset\\mathbb{R}\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68889em;\"></span><span class=\"strut bottom\" style=\"height:0.85556em;vertical-align:-0.16667em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathbb\">N</span></span><span class=\"mrel\">⊂</span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span><span class=\"mrel\">⊂</span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"mrel\">⊂</span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> can't figure out why something even needs to be proved here, the tactic should prove it. I would be very interested in working with you or others on making a more formal spec, because I do not really understand what goes into the process and yet I feel like I have some understanding of what we mathematicians are missing. Should I just formalise some unit tests?</p>",
        "id": 160678780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552492572
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"c1\">-- ℕ, ℤ, ℚ, ℝ, ℂ</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"n\">bn</span> <span class=\"n\">cn</span> <span class=\"n\">dn</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">az</span> <span class=\"n\">bz</span> <span class=\"n\">cz</span> <span class=\"n\">dz</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">aq</span> <span class=\"n\">bq</span> <span class=\"n\">cq</span> <span class=\"n\">dq</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">ar</span> <span class=\"n\">br</span> <span class=\"n\">cr</span> <span class=\"n\">dr</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ac</span> <span class=\"n\">bc</span> <span class=\"n\">cc</span> <span class=\"n\">dc</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bn</span> <span class=\"bp\">→</span> <span class=\"n\">an</span> <span class=\"bp\">=</span> <span class=\"n\">bn</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">an</span> <span class=\"bp\">=</span> <span class=\"n\">bn</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bn</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">az</span> <span class=\"bp\">=</span> <span class=\"n\">bz</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">az</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bz</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">aq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">br</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">aq</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">br</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bz</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bz</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bq</span> <span class=\"bp\">↔</span> <span class=\"o\">((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">bq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bn</span> <span class=\"bp\">↔</span> <span class=\"n\">an</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bn</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bz</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bz</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bq</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bq</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">-- zero and one cause special problems</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"n\">bq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bq</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"n\">aq</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">aq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">bn</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"bp\">+</span> <span class=\"n\">bn</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">bq</span> <span class=\"bp\">=</span> <span class=\"o\">((</span><span class=\"n\">an</span> <span class=\"bp\">+</span> <span class=\"n\">bq</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">bn</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">bn</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">))</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(((((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">bq</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"n\">cq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"n\">dn</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">bq</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">cq</span> <span class=\"err\">^</span> <span class=\"n\">dn</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bq</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">cr</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"err\">^</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"n\">dz</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">an</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bq</span> <span class=\"bp\">∧</span> <span class=\"o\">((</span><span class=\"n\">cr</span> <span class=\"err\">^</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℂ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">dz</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>\n\n\n<p>There are some example goals. Some, but not all, can be solved with <code>simp</code>. One or two might be even solvable with <code>rfl</code>.  I got a bit silly with the last one in the sense that I introduced \\and -- this just shows my inexperience with this sort of thing.  I don't know what is reasonable. What is reasonable? If you give me a subset of these things, I can tell you how I would prove them following the tricks I've picked up. Problems such as this were constantly showing up last summer when I was working with a team of undergraduates solving undergraduate level mathematics problems -- you might think some of the examples are artificial but when students have a question about natural numbers and they start subtracting and dividing, they do drift into Z and Q, and I would sometimes see \\u \\u as a consequence.</p>",
        "id": 160699722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552495796
    },
    {
        "content": "<p>I don't even know if \\iff is asking more than one might naturally expect a tactic to deliver. Rob I would be very happy to work with you on developing a spec, but of course I can tell you nothing about tactic design. Even a tactic which only proves one-way implications and equalities would be useful, but I have seen with my own eyes that mathematicians sometimes want one-way implications and sometimes two-way ones.</p>",
        "id": 160700808,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1552495945
    },
    {
        "content": "<p>Thanks, Kevin. This is a good start. The <code>\\u \\u</code> examples are definitely not trivial, I come across those often enough too.</p>",
        "id": 160761499,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1552553380
    },
    {
        "content": "<p>We'll come back and talk about a formal spec once Paul-Nicolas has made some more progress, but these examples help a lot for the moment.</p>",
        "id": 160761559,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1552553419
    },
    {
        "content": "<p>One more data point about casts and stupid arithmetic goal. This afternoon I want students to prove that if <code>f : ℝ → ℝ</code> sequentially tends to <code>y₀</code> at <code>x₀</code> then it tends to <code>y₀</code> en <code>x₀</code>. I almost gave on this idea, although this is the perfect illustration for the current chapter (negation of quantified statements). I ended writing in the assignment Lean file:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">axiom</span> <span class=\"n\">limite_inv_succ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">ε</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"bp\">≥</span> <span class=\"n\">N</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"n\">ε</span>\n\n<span class=\"kn\">axiom</span> <span class=\"n\">inv_succ_pos</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">,</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span>\n</pre></div>\n\n\n<p>because I couldn't see a way to prove them without devoting a whole lecture to casts and coes.</p>",
        "id": 161748819,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1553596574
    },
    {
        "content": "<p>I've been doing some basic undergraduate exercises.  I think that this one is a good test case for the cast infrastructure:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\"> We are asked to pass judgement on the following &quot;definition&quot; :</span>\n\n<span class=\"cm\">  k : ℝ → ℤ sends x ∈ ℝ to the closest integer.</span>\n\n<span class=\"cm\"> We define precisely what it means for n to be the closest</span>\n<span class=\"cm\"> integer to x : we should have | x - m | &gt; | x - n | for any</span>\n<span class=\"cm\"> integer m ≠ n.  We then show that if m ∈ ℤ, there is no</span>\n<span class=\"cm\"> closest integer to m + 1/2.  From this we deduce that there</span>\n<span class=\"cm\"> is no function k with the expected properties.</span>\n\n<span class=\"cm\"> This is much harder work than you might think.  A lot of the</span>\n<span class=\"cm\"> problem is caused by the cast maps ℤ → ℚ → ℝ</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">abs</span> <span class=\"o\">(</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"n\">abs</span> <span class=\"o\">(</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\"> Even basic identities like 1/2 - 1 = -1/2 cannot easily be</span>\n<span class=\"cm\"> proved directly in ℝ, because there are no general algorithms</span>\n<span class=\"cm\"> for exact calculation in ℝ.  We need to work in ℚ and then</span>\n<span class=\"cm\"> apply the cast map.</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"n\">def</span> <span class=\"n\">half_Q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span>\n<span class=\"n\">def</span> <span class=\"n\">neg_half_Q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span> <span class=\"n\">half_Q</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">half_R</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">half_Q</span>\n<span class=\"n\">noncomputable</span> <span class=\"n\">def</span> <span class=\"n\">neg_half_R</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">neg_half_Q</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\"> Here is a small identity that could in principle be proved</span>\n<span class=\"cm\"> by a long string of applications of the commutative ring axioms.</span>\n<span class=\"cm\"> The &quot;ring&quot; tactic automates the process of finding this string.</span>\n\n<span class=\"cm\"> For reasons that I do not fully understand, the ring tactic</span>\n<span class=\"cm\"> seems to work more reliably if we do it in a separate lemma</span>\n<span class=\"cm\"> so that the terms are just free variables.  We can then</span>\n<span class=\"cm\"> substitute values for this variables as an extra step.  In</span>\n<span class=\"cm\"> particular, we will substitute h = 1/2, and then give a</span>\n<span class=\"cm\"> separate argument that the final term 2 * h - 1 is zero.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">misc_identity</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">h</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">by</span> <span class=\"n\">ring</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\"> We now prove that there is no closest integer to m + 1/2.</span>\n<span class=\"cm\"> The obvious approach would be to focus attention on the</span>\n<span class=\"cm\"> candidates n = m and n = m + 1, but it turns out that that</span>\n<span class=\"cm\"> creates more work than necessary.  It is more efficient to</span>\n<span class=\"cm\"> prove that for all n, the integer k = 2 m + 1 - n is different</span>\n<span class=\"cm\"> from n and lies at the same distance from m + 1/2, so</span>\n<span class=\"cm\"> n does not have the required property.</span>\n<span class=\"cm\">-/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">no_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">is_closest_integer</span> <span class=\"n\">n</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">half_R</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">intro</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">x_Q</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">half_Q</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">x_R</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">half_R</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"n\">by_cases</span> <span class=\"n\">e0</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"o\">{</span><span class=\"c1\">-- In this block we consider the possibility that k = n, and</span>\n  <span class=\"c1\">-- show that it is impossible.</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e0</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">e1</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n   <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">ring</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">e0</span><span class=\"o\">]</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"k\">by</span> <span class=\"n\">ring</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">e2</span> <span class=\"o\">:=</span> <span class=\"k\">calc</span>\n   <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod</span> <span class=\"mi\">1</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">rfl</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"n\">congr_arg</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod</span> <span class=\"n\">x</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"n\">e1</span>\n   <span class=\"bp\">...</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mul_mod_right</span> <span class=\"mi\">2</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">),</span>\n  <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">≠</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"n\">e2</span><span class=\"o\">,</span>\n <span class=\"o\">},{</span>\n  <span class=\"k\">let</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"n\">k</span> <span class=\"n\">e0</span><span class=\"o\">),</span>\n  <span class=\"k\">let</span> <span class=\"n\">u_R</span> <span class=\"o\">:=</span> <span class=\"n\">x_R</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"n\">v_R</span> <span class=\"o\">:=</span> <span class=\"n\">x_R</span> <span class=\"bp\">-</span> <span class=\"n\">k</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">v_R</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"n\">u_R</span> <span class=\"bp\">+</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">half_R</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n   <span class=\"n\">dsimp</span><span class=\"o\">[</span><span class=\"n\">u_R</span><span class=\"o\">,</span><span class=\"n\">v_R</span><span class=\"o\">,</span><span class=\"n\">x_R</span><span class=\"o\">,</span><span class=\"n\">k</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_mul</span><span class=\"o\">,</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_bit0</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span><span class=\"o\">,</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_neg</span><span class=\"o\">],</span>\n   <span class=\"n\">exact</span> <span class=\"n\">misc_identity</span> <span class=\"o\">(</span><span class=\"err\">↑</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">↑</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">half_R</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h3</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">half_Q</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">dec_trivial</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h4</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">half_R</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"o\">(((</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">half_Q</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℚ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n   <span class=\"n\">dsimp</span><span class=\"o\">[</span><span class=\"n\">half_R</span><span class=\"o\">],</span>\n   <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_add</span><span class=\"o\">,</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_mul</span><span class=\"o\">,</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_bit0</span><span class=\"o\">,</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_neg</span><span class=\"o\">,</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_one</span><span class=\"o\">],</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h5</span> <span class=\"o\">:</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">half_R</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h4</span><span class=\"o\">,</span><span class=\"n\">h3</span><span class=\"o\">,</span><span class=\"n\">rat</span><span class=\"bp\">.</span><span class=\"n\">cast_zero</span><span class=\"o\">],</span>\n  <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h5</span><span class=\"o\">,</span><span class=\"n\">add_zero</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"k\">have</span> <span class=\"n\">h6</span> <span class=\"o\">:</span> <span class=\"n\">abs</span> <span class=\"n\">v_R</span> <span class=\"bp\">=</span> <span class=\"n\">abs</span> <span class=\"n\">u_R</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">rw</span><span class=\"o\">[</span><span class=\"n\">h2</span><span class=\"o\">,</span><span class=\"n\">abs_neg</span><span class=\"o\">],</span>\n  <span class=\"n\">exact</span> <span class=\"n\">h1</span> <span class=\"n\">h6</span><span class=\"o\">,</span>\n <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">k_does_not_exist</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">is_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">k_spec</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"n\">half_R</span><span class=\"o\">,</span>\n <span class=\"n\">exact</span> <span class=\"n\">no_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">k_spec</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 161749221,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1553596937
    },
    {
        "content": "<p>Instead of <code>1/(n+1)</code>, you can use <code>((1:R)/2)^n</code> (and the fact that this sequence tends to <code>0</code>, which should already be there). No need to cast with this one.</p>",
        "id": 161749440,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1553597163
    },
    {
        "content": "<blockquote>\n<p>Even basic identities like 1/2 - 1 = -1/2 cannot easily be<br>\n proved directly in ℝ, because there are no general algorithms<br>\n for exact calculation in ℝ.  We need to work in ℚ and then<br>\n apply the cast map.</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">:</span> <span class=\"o\">(</span> <span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"mi\">1</span> <span class=\"bp\">/</span> <span class=\"mi\">2</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">norm_num</span>\n</pre></div>\n\n\n<p>?</p>",
        "id": 161754183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553601783
    },
    {
        "content": "<blockquote>\n<p>For reasons that I do not fully understand, the ring tactic<br>\n seems to work more reliably if we do it in a separate lemma<br>\n so that the terms are just free variables.  We can then<br>\n substitute values for this variables as an extra step.  In<br>\n particular, we will substitute h = 1/2, and then give a<br>\n separate argument that the final term 2 * h - 1 is zero.</p>\n</blockquote>\n<p><code>ring</code> can sometimes be a bit ropey when division is involved. One could probably beef it up by putting in a \"clear denominators\" step.</p>",
        "id": 161754483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553602060
    },
    {
        "content": "<p>Oh, it's the casts as well. <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> here's something to add to the list of cast test cases:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">example</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"err\">???</span>\n</pre></div>\n\n\n<p>It can be solved by <code>simp;ring</code></p>",
        "id": 161760958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553606834
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130308\">@Neil Strickland</span> here's my take on the result.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">norm_num</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">def</span> <span class=\"n\">is_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n <span class=\"bp\">∀</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">≠</span> <span class=\"n\">n</span> <span class=\"bp\">→</span> <span class=\"n\">abs</span> <span class=\"o\">(</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">m</span> <span class=\"o\">)</span> <span class=\"bp\">&gt;</span> <span class=\"n\">abs</span> <span class=\"o\">(</span> <span class=\"n\">x</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"o\">)</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">no_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n <span class=\"bp\">¬</span> <span class=\"o\">(</span><span class=\"n\">is_closest_integer</span> <span class=\"n\">n</span> <span class=\"o\">((</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">intro</span> <span class=\"n\">h0</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">x_R</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">k</span> <span class=\"o\">:=</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"n\">by_cases</span> <span class=\"n\">e0</span> <span class=\"o\">:</span> <span class=\"n\">k</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n <span class=\"o\">{</span><span class=\"c1\">-- In this block we consider the possibility that k = n, and</span>\n  <span class=\"c1\">-- show that it is impossible.</span>\n  <span class=\"n\">exfalso</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"n\">at</span> <span class=\"n\">e0</span><span class=\"o\">,</span> <span class=\"c1\">-- I prefer this to dsimp</span>\n  <span class=\"c1\">-- every operation I make here is &quot;natural&quot; hence will be in mathlib somewhere</span>\n  <span class=\"c1\">-- and I find it using ctrl-space and name guesswork</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">sub_eq_iff_eq_add</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">two_mul</span><span class=\"o\">,</span> <span class=\"n\">eq_comm</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">sub_eq_iff_eq_add&#39;</span><span class=\"o\">,</span> <span class=\"err\">←</span><span class=\"n\">mul_sub</span><span class=\"o\">]</span> <span class=\"n\">at</span> <span class=\"n\">e0</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- e0 : 2 * (n - m) = 1</span>\n  <span class=\"k\">have</span> <span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">-</span> <span class=\"n\">m</span><span class=\"o\">))</span> <span class=\"err\">%</span> <span class=\"mi\">2</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mul_mod_right</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">e0</span><span class=\"o\">,</span> <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">mod_eq_of_lt</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"mi\">2</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">dec_trivial</span><span class=\"o\">)]</span> <span class=\"n\">at</span> <span class=\"n\">e2</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- e2 : 1 = 0</span>\n  <span class=\"n\">cases</span> <span class=\"n\">e2</span><span class=\"o\">,</span> <span class=\"c1\">-- just showing off here</span>\n <span class=\"o\">},{</span>\n  <span class=\"k\">let</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">ne_of_gt</span> <span class=\"o\">(</span><span class=\"n\">h0</span> <span class=\"n\">k</span> <span class=\"n\">e0</span><span class=\"o\">),</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h1</span><span class=\"o\">,</span>\n  <span class=\"n\">convert</span> <span class=\"n\">abs_neg</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- get rid of k</span>\n  <span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"o\">((</span><span class=\"mi\">2</span> <span class=\"bp\">*</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span> <span class=\"bp\">-</span> <span class=\"n\">n</span><span class=\"o\">),</span>\n  <span class=\"c1\">-- simp does the casts, although it&#39;s a sin to apply it when not closing a goal</span>\n  <span class=\"c1\">-- instead of simp one should say:</span>\n<span class=\"c1\">--  suffices : -(1 : ℝ) + (2⁻¹ + (↑n + (↑m + -(2 * ↑m)))) = -2⁻¹ + (↑n + -↑m),</span>\n<span class=\"c1\">--    simpa,</span>\n  <span class=\"n\">simp</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- now ring finishes the job</span>\n  <span class=\"n\">ring</span>\n <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">k_does_not_exist</span> <span class=\"o\">:</span> <span class=\"bp\">¬</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℤ</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">is_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n <span class=\"n\">rintro</span> <span class=\"bp\">⟨</span><span class=\"n\">k</span><span class=\"o\">,</span><span class=\"n\">k_spec</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n <span class=\"k\">let</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span><span class=\"o\">)</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"bp\">/</span><span class=\"mi\">2</span><span class=\"o\">,</span>\n <span class=\"n\">exact</span> <span class=\"n\">no_closest_integer</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"mi\">0</span> <span class=\"o\">(</span><span class=\"n\">k_spec</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 161761561,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553607271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  Thanks, that's better than my version.  I will see what I can learn from it.</p>",
        "id": 161783291,
        "sender_full_name": "Neil Strickland",
        "timestamp": 1553620588
    },
    {
        "content": "<p>I know you might have pedagogical obstructions to writing your code, so I didn't know how much of my version you'd like. No doubt you can get some super-mangled version of the proof that 2(m-n)=1 is false which is unreadable.</p>",
        "id": 161783445,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1553620689
    },
    {
        "content": "<p>Here is the first version of the cast tactic I've been working one and that <span class=\"user-mention\" data-user-id=\"110596\">@Rob Lewis</span> mentioned a few weeks ago<br>\n<a href=\"https://github.com/lean-forward/coe_tactic\" target=\"_blank\" title=\"https://github.com/lean-forward/coe_tactic\">https://github.com/lean-forward/coe_tactic</a></p>\n<p>Basically it's a simplify tactic with the appropriate set of lemmas, plus a little heuristic to infer casts in some cases.</p>",
        "id": 162927051,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1554827901
    },
    {
        "content": "<p>for instance, the expression <code> (an : ℚ) + (bz : ℚ) </code> will first be rewritten as <code> ((an : ℤ) : ℚ) + (bz : ℚ) </code> by the heuristic, and then as <code> ((an : ℤ) + bz) : ℚ) </code> by the appropriate simp lemma</p>",
        "id": 162927341,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1554828132
    },
    {
        "content": "<p>Exciting news!</p>",
        "id": 162927347,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1554828138
    },
    {
        "content": "<p>If anyone feels inspired, I'm also trying to change the names of the different tactics.<br>\nMainly I want to replace coe with cast, as it seems more appropriate.<br>\nBut there's also the problem of the simpa equivalent of norm_coe, which right now is named norm_coe_a<br>\nSo I'm taking any ideas to name these tactics as clearly <br>\nas possible</p>",
        "id": 163200281,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1555082753
    },
    {
        "content": "<p>Hello everyone,<br>\nI've worked a lot on trying to improve the code and make it as clear and usable as possible.</p>\n<p>There are now 5 tactics:<br>\n- norm_cast<br>\n- rw_mod_cast, that applies a list of rw rules and normalizes between them<br>\n- apply_mod_cast, that normalizes the goal and a given expression, and then applies the expression<br>\n- exact_mod_cast, that is similar to apply_mod_cast but for exact<br>\n- assumption_mod_cast, that normalizes the goal and all the expressions from the context, then uses assumption</p>\n<p>I've also copied padics files from mathlib and tried to improve the proofs using these tactics.</p>\n<p>I'm waiting for any feedback about what should be changed or added to the tactics,<br>\nand whether they could be added to mathlib</p>",
        "id": 164449657,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1556542919
    },
    {
        "content": "<p>Thank you very much for this work! I'm not fighting those kinds of problems those days, but I'll try to find some time to come back to projects I used to work on but gave up because of those issues. Do you know whether your work could be adapted to other coercions and casts? In the perfectoid project we also have many coercion fights, but with more complicated types that nat or int.</p>",
        "id": 164450180,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556543212
    },
    {
        "content": "<p>Here was an example we ran into -- if K was a field and K-hat was its completion (with respect to some topology blah blah blah), also a field in cases of interest, then we had an injective map from K to K-hat (a coercion, in fact), so we had a proof that if x was non-zero then coe(x) was also non-zero. Now say x is non-zero. The constructor<code> units.mk0</code> can be used to make a unit out of x, which a mathematician would also call x. The fact that the unit x got coerced into the unit (coe x) was not <code>rfl</code> because we needed to apply <code>units.ext</code>. Mathematicians find these sorts of goals very frustrating because we don't want to waste our time proving x=x, and when rfl doesn't work it's frustrating. <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> do you know what -- I think we needed some unit predicate instead of explicitly carrying around the useless inverse which we never used (because it's uniquely determined by x).</p>",
        "id": 164450692,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556543537
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> <br>\nThe only thing to do to make it work on other types of casts should be (theoretically) to add new lemmas to the set of norm_cast lemmas.<br>\nBut in practiced I've only used it on nat/int/rat/reals and padics, so I definitely have to try using it on more complex examples.</p>",
        "id": 164450784,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1556543630
    },
    {
        "content": "<p>I think the main problems my students had were all with these use examples (nat/int/rat/real) -- it will be interesting to see how much better you have made their lives!</p>",
        "id": 164450872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556543700
    },
    {
        "content": "<p>I think what really need now is documentation of your work. We have the test file, which is much better than nothing, but we also need some documentation <em>text</em>, explaining what the tactics are doing, roughly how they are doing it, what we can hope for, what is out of scope, how to add new lemmas, etc. I know it's no fun at all. But a <em>lot</em> of software development (especially in free software) turn out to be useless for lack of documentation</p>",
        "id": 164450998,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556543836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  I didn't understand every detail of the example by lack of mathematical background, but the units.ext should be rewritten as an equivalence to be used in the current version of my code. apart from this it should work.</p>",
        "id": 164451116,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1556543958
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210574\">@Patrick Massot</span> I recently added comments to the norm_cast file, but I will try to rewrite a more detailed documentation page if that's necessary</p>",
        "id": 164451248,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1556544049
    },
    {
        "content": "<p>Your comments in <code>norm_cast</code> seem helpful for people who want to improve the tactics, not for users</p>",
        "id": 164451468,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556544192
    },
    {
        "content": "<p>And the user facing tactis (the interactive ones) don't even have docstrings</p>",
        "id": 164451508,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1556544235
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span>  I didn't understand every detail of the example by lack of mathematical background, but the units.ext should be rewritten as an equivalence to be used in the current version of my code. apart from this it should work.</p>\n</blockquote>\n<p>I think <code>units.ext_iff</code> is the iff version</p>",
        "id": 164462354,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556552205
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> well if you send me a particular proof that is actually a lot of boiler plate code to move casts around, I will try to make it clearer with my tactics</p>",
        "id": 164462904,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1556552668
    },
    {
        "content": "<p>I cannot do this right now but I will certainly remember your suggestion!</p>",
        "id": 164463116,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1556552865
    },
    {
        "content": "<p>I made a pull request on the mathlib repository : <a href=\"https://github.com/leanprover-community/mathlib/pull/988\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/988\">https://github.com/leanprover-community/mathlib/pull/988</a>,<br>\ntherefore the coe_tactic repo is no longer up to date.</p>",
        "id": 164986687,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1557153428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"213273\">@Paul-Nicolas Madelaine</span> Thanks a lot for writing these tactics! I look forward to using them <span aria-label=\"octopus\" class=\"emoji emoji-1f419\" role=\"img\" title=\"octopus\">:octopus:</span></p>",
        "id": 164991692,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557156818
    },
    {
        "content": "<p>One comment... for some reason <code>mod_cast</code> sounds too much like you are doing something with modular arithmetic... would it make sense to call the tactics <code>norm_cast</code> after <code>norm_num</code>?<br>\nOk... maybe that actually sounds like you are taking norms... I don't know. I should probably just get used to it <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 164991899,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557156944
    },
    {
        "content": "<p>One of the tactics is already called <code>norm_cast</code>. The others were hard to name. We're open to suggestions!</p>",
        "id": 164992078,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1557157075
    },
    {
        "content": "<p>Wait, what does the <code>mod</code> in <code>mod_cast</code> stand for? I thought it stood for \"modify\". But should I read <code>rw_mod_cast</code> as \"<code>rw</code> modulo casts\"? If so, then I think it's actually a good name.</p>",
        "id": 164993023,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557157792
    },
    {
        "content": "<p>Maybe I was just being sleepy (-;</p>",
        "id": 164993071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557157803
    },
    {
        "content": "<p>Yes, we have rewrite/apply/exact/assumption modulo casts.</p>",
        "id": 164993170,
        "sender_full_name": "Rob Lewis",
        "timestamp": 1557157902
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"213273\">@Paul-Nicolas Madelaine</span> Does it make sense to also make <code>convert_mod_cast</code>? Or does <code>exact_mod_cast</code> handle this?</p>",
        "id": 165655564,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557863349
    },
    {
        "content": "<p>(I haven't tested yet, waiting for the tactics to land in the nightly cache...)</p>",
        "id": 165655596,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557863373
    },
    {
        "content": "<p>What is the status of Scott's efforts to bring us more compiled stuff? Does he have that branch ready for you somewhere?</p>",
        "id": 165655709,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557863423
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/pull/1000/files#diff-dbd7f4184984f905b3e1ed514ca280ccR65\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/1000/files#diff-dbd7f4184984f905b3e1ed514ca280ccR65\">https://github.com/leanprover-community/mathlib/pull/1000/files#diff-dbd7f4184984f905b3e1ed514ca280ccR65</a></p>",
        "id": 165655823,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1557863490
    },
    {
        "content": "<p>that's a python museum!</p>",
        "id": 165655964,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557863554
    },
    {
        "content": "<p>This syntax is has been replaced by a now obsolete syntax!</p>",
        "id": 165655998,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557863574
    },
    {
        "content": "<p>anyway, <a href=\"https://tqft.net/lean/mathlib/\" target=\"_blank\" title=\"https://tqft.net/lean/mathlib/\">https://tqft.net/lean/mathlib/</a> doesn't look very helpful</p>",
        "id": 165656043,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557863594
    },
    {
        "content": "<p>It's getting there...</p>",
        "id": 165657259,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557864378
    },
    {
        "content": "<p>I modified the script, attempting to make it more robust against build failures, and accidentally deleted everything</p>",
        "id": 165657297,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557864412
    },
    {
        "content": "<p>it's rebuilding as we speak</p>",
        "id": 165657306,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557864417
    },
    {
        "content": "<p>It's a lot of building. :-)</p>",
        "id": 165657315,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1557864422
    },
    {
        "content": "<p>Thanks! Your efforts are very much appreciated</p>",
        "id": 165657354,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1557864456
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> the exact_mod_cast tactic is really just a normalization then a call to the <code>exact</code> tactic, so <code>convert_mod_cast</code> would make sense, and it could also normalize the new goals</p>",
        "id": 165695930,
        "sender_full_name": "Paul-Nicolas Madelaine",
        "timestamp": 1557909110
    }
]
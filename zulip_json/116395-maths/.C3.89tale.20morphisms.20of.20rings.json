[
    {
        "content": "<p>Is anyone working on étale ring moprhisms? It seems like a very reachable definition and I would like to give a try if nobody is doing it.</p>",
        "id": 219027888,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607294881
    },
    {
        "content": "<p>Which definition are you thinking of using?</p>",
        "id": 219028870,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607296085
    },
    {
        "content": "<p>étale ring morphisms would be a great thing to have. A lofty goal would be to define the etale site on the category of schemes.</p>",
        "id": 219029171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607296554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> do we have fibered products of schemes yet?</p>",
        "id": 219029292,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607296744
    },
    {
        "content": "<p>no but <span class=\"user-mention\" data-user-id=\"246273\">@Bhavik Mehta</span> told me that you didn't need products to define a site the way he set it up :-)</p>",
        "id": 219029302,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607296774
    },
    {
        "content": "<p>I never worked through the construction in Hartshorne carefully, products of schemes would be a cool project</p>",
        "id": 219029353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607296806
    },
    {
        "content": "<p>Oh... How does it work without pullbacks? The def of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.pretopology\">docs#category_theory.pretopology</a> requires pullbacks. Is there some other trick?</p>",
        "id": 219029442,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607296945
    },
    {
        "content": "<p>I just started think about it, so I don't know which definition is the best to chose... this is for sure the first problem. I don't find morphism of finite presentation in mathlib, so it is maybe reasonable to start defining them (they are interesting in any case) and  then definite the module of differentials?</p>",
        "id": 219029510,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607297045
    },
    {
        "content": "<p>Presumably defining formally etale morphisms shouldn't be too bad.</p>",
        "id": 219029535,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607297116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219029442\">said</a>:</p>\n<blockquote>\n<p>Oh... How does it work without pullbacks? The def of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.pretopology\">docs#category_theory.pretopology</a> requires pullbacks. Is there some other trick?</p>\n</blockquote>\n<p>You can define a grothendieck topology without pullbacks, which is enough to give a site (strictly speaking you can define a pretopology without pullbacks as well but the only ref I could find was in the elephant and it didn't seem to be that helpful so I didn't bother)</p>",
        "id": 219029543,
        "sender_full_name": "Bhavik Mehta",
        "timestamp": 1607297137
    },
    {
        "content": "<p>So you could go with formally etale + locally finite pres</p>",
        "id": 219029544,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607297138
    },
    {
        "content": "<p>I always find it interesting that in EGA Grothendieck defines smooth via the differential approach, and then later on when he has realised the formally smooth + LFP approach he doesn't just prove that smooth = formally smooth + LFP, he actually explicitly _redefines_ smooth to mean this. He changes the definition, even though mathematically nothing is happening.</p>",
        "id": 219029758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607297435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> you're right, that's probably the quicker way of stating the definition (also, for rings it is enough to work with morphisms of finite presentation). I am not sure it is the most useful thought...</p>",
        "id": 219029938,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607297699
    },
    {
        "content": "<p>Formally etale makes sense intuitively (at least for me).</p>",
        "id": 219031209,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607299469
    },
    {
        "content": "<p>I guess a more useful description would be something which is locally isomorphic to one of those standard etale maps. But with this I imagine you would run into the issue of \"canonical isomorphisms\" which was a big issue for localization (as <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> can tell you all about)</p>",
        "id": 219031459,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607299899
    },
    {
        "content": "<p>Sure, formally étale is quite clear intuitively!  I am not sure it is well suited to develop for example étale cohomology,but maybe this is just because I learnt it using \"flat and unramified\" in Milne.</p>",
        "id": 219031592,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607300144
    },
    {
        "content": "<p>And actually I guess it's not much of a problem to write down the definition of unramified...</p>",
        "id": 219031634,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607300166
    },
    {
        "content": "<p>Yeah I learned the flat+unramified definition first</p>",
        "id": 219031640,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607300196
    },
    {
        "content": "<p>Are flat morphisms in mathlib? I don't find them!</p>",
        "id": 219031694,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607300304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> has a branch IIRC</p>",
        "id": 219031697,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607300321
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/flat-module\">https://github.com/leanprover-community/mathlib/tree/flat-module</a> I think</p>",
        "id": 219031720,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607300397
    },
    {
        "content": "<p>If you're choosing between equivalent definitions then you could try to prove they are equivalent... though I have no idea what's involved in this case.</p>",
        "id": 219031786,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607300508
    },
    {
        "content": "<p>But eventually, it would have to happen no matter what.</p>",
        "id": 219031787,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607300514
    },
    {
        "content": "<p>usually for a Prop it doesn't matter too much which one you pick as the definition in the end, though it's mildly preferable to choose one which doesn't involve quantifications over types if possible</p>",
        "id": 219031901,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607300708
    },
    {
        "content": "<p>Flat +unramified can be written without quantifying over types. For flatness one would use the characterization using ideals, as opposed to the \"exact functor\" definition</p>",
        "id": 219032129,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607301068
    },
    {
        "content": "<p>Is there some universal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>→</mo><mi>B</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">B \\to B/I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">I</span></span></span></span> (or universal small family) that you can write down (in the context of <a href=\"https://ncatlab.org/nlab/show/formally+%C3%A9tale+morphism+of+schemes#ExplicitlyInComponents\">https://ncatlab.org/nlab/show/formally+%C3%A9tale+morphism+of+schemes#ExplicitlyInComponents</a>)?</p>",
        "id": 219032222,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607301192
    },
    {
        "content": "<p>where it's not clear to me exactly what \"universal\" should mean beyond \"if it works for this one then it works for anything\"</p>",
        "id": 219032307,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607301307
    },
    {
        "content": "<p>I guess you can get by with quotients of the strict henselizations of the local rings? Not 100% sure. But that's complicated to write down anyway</p>",
        "id": 219032327,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607301345
    },
    {
        "content": "<p>I have no idea...</p>",
        "id": 219032448,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607301489
    },
    {
        "content": "<p>I guess the answer might be whatever you use to prove that it implies flat and unramified</p>",
        "id": 219032522,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607301615
    },
    {
        "content": "<p>In any case, Reid makes a very good point about avoiding quantification over types in the definition we choose</p>",
        "id": 219032527,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607301629
    },
    {
        "content": "<p>But I have the impression that it really doesn't make too much sense to get to a super quick but practically useless definition, and probably it makes sense to follow the \"standard path\". For example it's clear that flat morphisms are a fundamental notion that we need if we want to have a reasonable commutative algebra library</p>",
        "id": 219032528,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607301632
    },
    {
        "content": "<p>right, so by default proving two definitions are equivalent is a good goal</p>",
        "id": 219032541,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607301672
    },
    {
        "content": "<p>In any case I will start with finite presentation, that should be easy and it is needed with any definition</p>",
        "id": 219032903,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607302236
    },
    {
        "content": "<p>Note that <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> has most of the stuff on differentials done already</p>",
        "id": 219044840,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607320921
    },
    {
        "content": "<p>but I think it depends on some of the tensor PRs that are still open, I dunno</p>",
        "id": 219044883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607320934
    },
    {
        "content": "<p>haven't had time to think about this recently</p>",
        "id": 219044884,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607320942
    },
    {
        "content": "<p>Does someone see a good approach to define finitely presented algebras? I see that for finite algebras quotients are avoided, but I don't see how we can avoid them for finitely presented (except using very abstract characterization as compact objects)</p>",
        "id": 219343676,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607524509
    },
    {
        "content": "<p>Can't you say something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">\\</span><span class=\"n\">exists</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">B</span><span class=\"o\">),</span> <span class=\"bp\">\\</span><span class=\"n\">exists</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">\\</span><span class=\"k\">in</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"n\">A</span> <span class=\"bp\">\\</span><span class=\"n\">to_a</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">),</span>\n<span class=\"n\">surjective</span> <span class=\"n\">f</span> <span class=\"bp\">\\</span><span class=\"n\">and</span> <span class=\"n\">ideal.is_fg</span> <span class=\"n\">ker</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219344600,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607524881
    },
    {
        "content": "<p><span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span> is very much pseudo-lean</p>",
        "id": 219344630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607524894
    },
    {
        "content": "<p>Taking a <code>finset B</code> might run into some awkwardness around the 0 algebra</p>",
        "id": 219344815,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607524958
    },
    {
        "content": "<p>You could also just use <code>fin n</code> for some <code>n</code></p>",
        "id": 219344841,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607524966
    },
    {
        "content": "<p>Otherwise I think it looks good</p>",
        "id": 219344891,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607524991
    },
    {
        "content": "<p>wait... what's wrong with the finset?</p>",
        "id": 219344997,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607525035
    },
    {
        "content": "<p>Yes, that works.  I was wondering this because for finitely generated there is nothing like this, and maybe there was a reason I was missing. Do we know that polynomial in several variables have the universal property of the free algebra?</p>",
        "id": 219345093,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607525059
    },
    {
        "content": "<p>well you might want to know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>R</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes R \\to B \\otimes R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is still finitely presented, but something funny might happen if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">R = 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>",
        "id": 219345300,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607525144
    },
    {
        "content": "<p>aha, I see</p>",
        "id": 219345375,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607525165
    },
    {
        "content": "<p>yes, so starting with <code>\\exists n, ...</code> is indeed better</p>",
        "id": 219345407,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607525179
    },
    {
        "content": "<p>Of course it can be dealt with somehow, but this awkwardness might recur</p>",
        "id": 219345409,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607525180
    },
    {
        "content": "<p>I was envisioning writing a <code>is_finite_type</code>, a class that tells you an algebra is of finite type, with some small API that gives a surjective map from some mv_polynomial ring, as well as a <code>is_finitely_generated</code> Prop on ideals, which you can apply to the kernel of the surjective map. I feel like both <code>is_finite_type</code> and <code>is_finitely_generated</code> would be useful independently anyway</p>",
        "id": 219347530,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526033
    },
    {
        "content": "<p>Oh... we already have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.finite_type\">docs#algebra.finite_type</a> :)</p>",
        "id": 219347768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526136
    },
    {
        "content": "<p>There is alreay <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebra.finite_type\">docs#algebra.finite_type</a>. What it is missing is that the definition is equivalent to quotient of some mv_polynomial ring</p>",
        "id": 219347774,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607526140
    },
    {
        "content": "<p>This is quick using  <code>mv_polynomial.eval₂_hom</code>, but I guess it is worth to mention somewhere that mv_poly have the universal property of free algebras</p>",
        "id": 219347928,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607526218
    },
    {
        "content": "<p>It must be somewhere reachable from <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/CommRing/adjunctions.lean#L29\">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/CommRing/adjunctions.lean#L29</a></p>",
        "id": 219348059,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526263
    },
    {
        "content": "<p>Is this universal property not there?</p>",
        "id": 219348065,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526266
    },
    {
        "content": "<p>I only find <code>free_comm_ring_equiv_mv_polynomial_int</code> that is this statement for <code>ℤ</code>-algebras</p>",
        "id": 219348071,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607526269
    },
    {
        "content": "<p>oh</p>",
        "id": 219348083,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526274
    },
    {
        "content": "<p>that's possible I guess</p>",
        "id": 219348089,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526277
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Algebra/basic.lean#L78\">https://github.com/leanprover-community/mathlib/blob/master/src/algebra/category/Algebra/basic.lean#L78</a> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 219348157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526309
    },
    {
        "content": "<p>ah but it's not the polynomial algebra!</p>",
        "id": 219348183,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526321
    },
    {
        "content": "<p>oh especially because these are noncommutative algebras... ignore me</p>",
        "id": 219348232,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526346
    },
    {
        "content": "<p>But what's wrong with this? <br>\n<a href=\"https://github.com/leanprover-community/mathlib/blob/d12a7319934516253eb85a7f90cc47fc20621cdb/src/algebra/category/CommRing/adjunctions.lean#L47\">https://github.com/leanprover-community/mathlib/blob/d12a7319934516253eb85a7f90cc47fc20621cdb/src/algebra/category/CommRing/adjunctions.lean#L47</a></p>",
        "id": 219348316,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526372
    },
    {
        "content": "<p>Oh, just that it's mv_polynomial over Z?</p>",
        "id": 219348342,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526389
    },
    {
        "content": "<p>Yes; I didn't actually look at the proof though</p>",
        "id": 219348388,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526410
    },
    {
        "content": "<p>But the adjunction must use some lemma from mv_polynomials right?</p>",
        "id": 219348424,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526430
    },
    {
        "content": "<p>Or if we have the restriction of scalars / base-change adjunction somewhere, you can just compose them :)</p>",
        "id": 219348507,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526481
    },
    {
        "content": "<p>I can't really imagine the proof uses R=Z in an essential way, can it?</p>",
        "id": 219348628,
        "sender_full_name": "Reid Barton",
        "timestamp": 1607526529
    },
    {
        "content": "<p>I'm quite sure we don't have that</p>",
        "id": 219348631,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607526530
    },
    {
        "content": "<p>We have very little on base-change</p>",
        "id": 219348644,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1607526542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219348628\">said</a>:</p>\n<blockquote>\n<p>I can't really imagine the proof uses R=Z in an essential way, can it?</p>\n</blockquote>\n<p>Yeah that's what I'm thinking too...</p>",
        "id": 219348667,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526554
    },
    {
        "content": "<p>Hmmmm... maybe not, it uses this <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.eval₂_cast_comp\">docs#mv_polynomial.eval₂_cast_comp</a></p>",
        "id": 219348957,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526686
    },
    {
        "content": "<p>Now I realize that I never actually tried working with mv_polynomials :-/</p>",
        "id": 219349356,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526858
    },
    {
        "content": "<p>I have the impression that <code>CommRing.free</code> is defined using mv_poly, but <code>Algebra.free</code> is defined using <code>free_algebra</code> that uses <code>free_algebra.rel</code> and I am lost. In any case there is no proof of the existence of the free algebra, right? So this is needed in any case</p>",
        "id": 219349374,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607526863
    },
    {
        "content": "<p>Yeah, the <code>Algebra.free</code> is the noncommutative free algebra</p>",
        "id": 219349449,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526905
    },
    {
        "content": "<p>But you can still use this to prove something is finitely-generated, btw.</p>",
        "id": 219349484,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607526922
    },
    {
        "content": "<p>Ah, non commutative is scary</p>",
        "id": 219349533,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607526944
    },
    {
        "content": "<p>But the kernel of the surjective map will be in the noncommutative ring, and mathlib still doesn't have anything about ideals in noncommutative rings.</p>",
        "id": 219349699,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607527009
    },
    {
        "content": "<p>Maybe it is better to prove that finitely generated is the same as quotient of mv_poly ring</p>",
        "id": 219349887,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607527088
    },
    {
        "content": "<p>Yeah. I assume there is some induction principle in mathlib for maps from mv_polynomial rings to commutative rings?</p>",
        "id": 219350012,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607527144
    },
    {
        "content": "<p><code>mv_polynomial.eval₂_hom</code> gives the homomorphism,  surjectivity shouldn't be hard</p>",
        "id": 219350053,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607527160
    },
    {
        "content": "<p><code>mv_polynomial.aeval</code> is even better: its image is a subalgebra, so it is surjective</p>",
        "id": 219350284,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607527256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/.C3.89tale.20morphisms.20of.20rings/near/219345300\">said</a>:</p>\n<blockquote>\n<p>well you might want to know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>R</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes R \\to B \\otimes R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is still finitely presented, but something funny might happen if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">R = 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>\n</blockquote>\n<p>Concerning this:  looking at the definition of <code>algebra.finite_type</code> we see that this is </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">algebra.finite_type</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">⊤</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">fg</span>\n</code></pre></div>\n<p>And <code>fg</code> is defined as follows</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">fg</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">R</span> <span class=\"bp\">↑</span><span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">S</span>\n</code></pre></div>\n<p>Finally, <code>algebra.adjoin</code> is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">adjoin</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">subalgebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">algebra_map_mem'</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">subsemiring.subset_closure</span> <span class=\"bp\">$</span> <span class=\"n\">or.inl</span> <span class=\"o\">⟨</span><span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n  <span class=\"bp\">..</span> <span class=\"n\">subsemiring.closure</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">∪</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>In particular there is  <code>set.range (algebra_map R A) ∪ s)</code> and the <code>0</code>-algebra is not even considered...</p>",
        "id": 219355061,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607529121
    },
    {
        "content": "<p>Ah, but of course <code>set.range (algebra_map R A)</code> is <code>0</code> for the trivial ring. Sorry</p>",
        "id": 219355397,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607529258
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Here's another approach, just in case you find it helpful:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>LONG</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.free_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.ring_quot</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">free_comm_algebra</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">rel</span> <span class=\"o\">:</span> <span class=\"n\">free_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">free_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">mk</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">free_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">*</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">free_comm_algebra</span>\n\n<span class=\"kd\">@[derive ring]</span>\n<span class=\"kd\">def</span> <span class=\"n\">free_comm_algebra</span> <span class=\"o\">:=</span> <span class=\"n\">ring_quot</span> <span class=\"o\">(</span><span class=\"n\">free_comm_algebra.rel</span> <span class=\"n\">A</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">free_comm_algebra</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">free_comm_algebra</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">comm_ring</span> <span class=\"o\">(</span><span class=\"n\">free_comm_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">ring_quot.mk_ring_hom_surjective</span> <span class=\"n\">_</span> <span class=\"n\">a</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">rcases</span> <span class=\"n\">ring_quot.mk_ring_hom_surjective</span> <span class=\"n\">_</span> <span class=\"n\">b</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">b</span><span class=\"o\">,</span><span class=\"n\">rfl</span><span class=\"o\">⟩,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"bp\">←</span><span class=\"n\">ring_hom.map_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">ring_quot.mk_ring_hom_rel</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">rel.mk</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"o\">(</span><span class=\"n\">infer_instance</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">free_comm_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">by</span> <span class=\"n\">apply_instance</span>\n<span class=\"c1\">--ring_hom.to_algebra $ (ring_quot.mk_ring_hom _).comp (algebra_map A (free_algebra A S))</span>\n\n<span class=\"kd\">@[simp]</span>\n<span class=\"kd\">def</span> <span class=\"n\">lift_aux</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">free_comm_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n  <span class=\"n\">ring_quot.lift</span> <span class=\"bp\">$</span>\n<span class=\"o\">{</span> <span class=\"n\">val</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">free_algebra.lift</span> <span class=\"n\">A</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span><span class=\"o\">,</span>\n  <span class=\"n\">property</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"n\">induction</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"n\">w</span><span class=\"o\">,</span>\n    <span class=\"n\">simp_rw</span> <span class=\"n\">ring_hom.map_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- something must be missing in the ring_quot api</span>\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">ring_quot.mk_ring_hom</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">lift</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">free_comm_algebra</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">commutes'</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n    <span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">lift_aux</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_quot.mk_ring_hom</span> <span class=\"o\">(</span><span class=\"n\">free_comm_algebra.rel</span> <span class=\"n\">A</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">algebra_map</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">erw</span> <span class=\"n\">ring_quot.lift_mk_ring_hom_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">((</span><span class=\"n\">free_algebra.lift</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">commutes</span> <span class=\"n\">r</span><span class=\"o\">,</span>\n  <span class=\"kd\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">lift_aux</span> <span class=\"n\">A</span> <span class=\"n\">S</span> <span class=\"n\">f</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">free_comm_algebra</span>\n</code></pre></div>\n</div></div>",
        "id": 219361035,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607531367
    },
    {
        "content": "<p>Of course, one should prove a couple more lemmas about this <code>free_comm_algebra.lift</code> function, but you get the idea...</p>",
        "id": 219361164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1607531410
    },
    {
        "content": "<p>Is this the correct way of stating that <code>A</code> is of finite type over <code>R</code> if and only if it is a quotient of a mv_poly ring?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">finite_type</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial</span> <span class=\"n\">ι</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">surjective</span> <span class=\"n\">f</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>In particular, I don't know if <code>[fintype ι]</code> should be written in some other way.</p>",
        "id": 219589381,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1607683878
    },
    {
        "content": "<p>This looks fine, but note that because <code>[fintype iota]</code> comes after the colon you'll have to use one of the <code>I</code> tactics in your proof, e.g. <code>resetI</code>.</p>",
        "id": 219595765,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1607687463
    },
    {
        "content": "<p>I am trying to prove that  <code>R</code> is finitely presented as <code>R</code>-algebra, so in practice that <code>R</code> is isomorphic to polynomials in no variables. My definition is</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">algebra.finitely_presented</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">surjective</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.ker</span> <span class=\"o\">(</span><span class=\"n\">alg_hom.to_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span>\n</code></pre></div>\n<p>I want to use <code>∅ : finset A</code> and then <code>mv_polynomial.pempty_ring_equiv</code> (or a variant for algebras, that's not the problem) that says <code>mv_polynomial pempty R ≃+* R</code>. I am a little confused by <code>pempty</code>: how do I transform <code>{x // x ∈ ∅}</code> to <code>pempty</code>? This should be obvious, but maybe I am missing something.</p>\n<p>I can write a MWE if the question is not clear.</p>",
        "id": 219996086,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608046803
    },
    {
        "content": "<p>You can't just transform <code>{x // x \\in \\empty}</code> into <code>pempty</code> since they'rre different types.</p>",
        "id": 219996228,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608046864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> can you also comment on why you chose this defn instead of the version with <code>fin n</code>?</p>",
        "id": 219996315,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608046906
    },
    {
        "content": "<p>there will be no theorems about <code>mv_polynomial {x // x ∈ s}</code></p>",
        "id": 219996412,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608046935
    },
    {
        "content": "<p>What you can do is construct a bijection between them and (presumably) use something from mathlib which gives an isomorphism between <code>mv_polynomial X R</code> and <code>mv_polynomial Y R</code> assuming an equivalence between <code>X</code> and <code>Y</code>.</p>",
        "id": 219996462,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608046958
    },
    {
        "content": "<p>My idea was to prove that the two are equivalent. Is <code>fin 0</code> the same as <code>pempty</code>?</p>",
        "id": 219996516,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608046984
    },
    {
        "content": "<p>no :-)</p>",
        "id": 219996550,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608046994
    },
    {
        "content": "<p>It depends what you mean by <code>the same</code> :)</p>",
        "id": 219996572,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1608047005
    },
    {
        "content": "<p>I mean yes sure they're \"the same\", but they're not definitionally equal</p>",
        "id": 219996583,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047011
    },
    {
        "content": "<p>but you're far more  likely to find an isomorphism between R and <code>mv_polynomial R (fin 0)</code> and R in mathlib than you are to find one between <code>mv_polynomial s</code> and <code>R</code> if <code>s</code> is an empty finset</p>",
        "id": 219996767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047073
    },
    {
        "content": "<p>I mean, there already is a theorem that says that a mv poly ring in no variables is the same as the ring, this is <code>mv_polynomial.pempty_ring_equiv</code>, it seems natural to use it</p>",
        "id": 219996776,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047076
    },
    {
        "content": "<p>Probably there is also a theorem saying that if X and Y are in bijection then R[X] and R[Y] are ring isomorphic.</p>",
        "id": 219996863,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> Doesn't it make sense to first build some more constructors for <code>finitely_presented</code>?</p>",
        "id": 219996964,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047158
    },
    {
        "content": "<p>So that you can choose between <code>finset</code>, <code>fin n</code> or <code>fintype</code>.</p>",
        "id": 219997066,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047180
    },
    {
        "content": "<p>The variables are a type, not a <code>finset</code>, this is what is probably confusing me</p>",
        "id": 219997110,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047199
    },
    {
        "content": "<p>Once you have those, you can just use <code>pempty</code> and be done directly.</p>",
        "id": 219997113,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047200
    },
    {
        "content": "<p>Probably there is a coercion from <code>finset X</code> to <code>Type</code> -- that's what the little up-arrows are if you are seeing any of them</p>",
        "id": 219997192,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  what do you mean by constructors? I was following what is done for <code>finite_type</code>, and the first result is that <code>R</code> is of finite type over itself</p>",
        "id": 219997458,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047312
    },
    {
        "content": "<p>I think the definition of <code>finite_type</code> should quantify over <code>fin n</code> instead of finsets</p>",
        "id": 219997517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608047334
    },
    {
        "content": "<p>A constructor is a way of constructing a finitely-presented algebra.</p>",
        "id": 219997548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047347
    },
    {
        "content": "<p>and then you should prove the version you wrote as a lemma</p>",
        "id": 219997610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608047371
    },
    {
        "content": "<p>So for example you might want to prove that if X is a fintype and I is a finitely-generated ideal of R[X] then R[X]/I is finitely-presented. Or as Mario says you might want to completely rethink the definition. Definitions are the hardest part for mathematicians.</p>",
        "id": 219997780,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608047418
    },
    {
        "content": "<p><code>finite_type</code> is defined in terms of a <code>finset</code> of generators, without mv polynomials, but I proved that it is equivalent to the definition with mv poly (all the versions, with <code>finset</code>, <code>fintype</code> and <code>fin n</code>), so that's OK</p>",
        "id": 219997939,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047481
    },
    {
        "content": "<p>It's \"maths-OK\"</p>",
        "id": 219997978,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047501
    },
    {
        "content": "<p>yes, of course :)</p>",
        "id": 219998004,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047509
    },
    {
        "content": "<p>But I admit that I didn't flesh out that API completely.</p>",
        "id": 219998018,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047513
    },
    {
        "content": "<p>what do those lemmas look like exactly?</p>",
        "id": 219998092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1608047523
    },
    {
        "content": "<p>You say all of those are equivalent, but mathlib doesn't know this yet</p>",
        "id": 219998101,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047526
    },
    {
        "content": "<p>So, I'm suggest that for <code>fin_pres</code> the first thing you should do is prove that your definition (whichever you choose) is equivalent to all those variants.</p>",
        "id": 219998198,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047558
    },
    {
        "content": "<p>Because that will allow users to choose whether they want to index their polynomials by some subset of <code>A</code>, or by <code>fin n</code>, or by a fintype like <code>pempty</code>.</p>",
        "id": 219998283,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047594
    },
    {
        "content": "<p>And it will also allow you to destruct using</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">fin_pres.exists_surjection_mv_poly_fin</span>\n<span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">I</span><span class=\"o\">,</span><span class=\"n\">_inst_I</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">fin_pres.exists_surjection_mv_poly_fintype</span>\n<span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">H</span><span class=\"bp\">&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">fin_pres.exists_surjection_mv_poly_finset</span>\n</code></pre></div>",
        "id": 219998565,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608047697
    },
    {
        "content": "<p>This was absolutely in my todo list, I just thought to start with the ring itself, but I see that it more convenient to start with things like mv poly are finitely presented, equiv preserves finite presentation and then deduce that the ring is finitely presented</p>",
        "id": 219998600,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047713
    },
    {
        "content": "<p>By the way to <code>finite_type</code> the equivalences are all there (I merged them this weekend) <code>algebra.finite_type.iff_quotient_mv_polynomial</code>, <code>algebra.finite_type.iff_quotient_mv_polynomial'</code> and <code>algebra.finite_type.iff_quotient_mv_polynomial''</code></p>",
        "id": 219998846,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608047799
    },
    {
        "content": "<p>I just realized that the definition with <code>finset</code> is quite meaningless since it forces the variables to have as type the big ring. The definition with <code>fin n</code> is <em>much</em> better!</p>",
        "id": 220006388,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608050486
    },
    {
        "content": "<p>In proving that finite presentation is preserved by algebra iso I got a deterministic timeout that I don't undestand, as in the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">data.mv_polynomial</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.noetherian</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">function</span> <span class=\"o\">(</span><span class=\"n\">surjective</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">B</span><span class=\"o\">]</span>\n\n<span class=\"kd\">@[class]</span>\n<span class=\"kd\">def</span> <span class=\"n\">finitely_presented</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">surjective</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.ker</span> <span class=\"o\">(</span><span class=\"n\">alg_hom.to_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"n\">hfp</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">tactic.unfreeze_local_instances</span><span class=\"o\">,</span> <span class=\"c1\">--without it  it says failed to revert 'hfp', it is a frozen local instance</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">hfp</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">alg_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">alg_equiv.to_alg_hom</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>Can someone help? Is it related to \"failed to revert 'hfp', it is a frozen local instance \" (that I don't understand either)? Thank you!</p>",
        "id": 220228054,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608201761
    },
    {
        "content": "<p>Your frozen local instance issue is that <code>finitely_presented</code> is a class. This is I think unrelated to your timeout, which is <code>use</code> misbehaving. At times like this I revert to <code>existsi g</code>, which is a more primitive tactic which works fine here.</p>",
        "id": 220228284,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608201962
    },
    {
        "content": "<p>If you're making the definition of <code>finitely_presented</code> yourself then you probably want to make an API for it which enables you to get <code>n, f, hf</code> out of it without going through all this stuff at the beginning of a proof of something else.</p>",
        "id": 220228443,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202078
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[class]</span>\n<span class=\"kd\">def</span> <span class=\"n\">finitely_presented</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n<span class=\"n\">surjective</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.ker</span> <span class=\"o\">(</span><span class=\"n\">alg_hom.to_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">finitely_presented_spec</span> <span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">mv_polynomial</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">A</span><span class=\"o\">),</span>\n  <span class=\"n\">surjective</span> <span class=\"n\">f</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.ker</span> <span class=\"o\">(</span><span class=\"n\">alg_hom.to_ring_hom</span> <span class=\"n\">f</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">fg</span> <span class=\"o\">:=</span>\n<span class=\"n\">h</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finitely_presented_spec</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">],</span>\n  <span class=\"k\">have</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">alg_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">alg_equiv.to_alg_hom</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">existsi</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220228654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202200
    },
    {
        "content": "<p><code>have g</code> is \"evil\", because <code>have</code> forgets the definition</p>",
        "id": 220228777,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608202275
    },
    {
        "content": "<p>it's only for Props, so you should use <code>let g</code> here</p>",
        "id": 220228790,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608202287
    },
    {
        "content": "<p>Right! That's the explanation for the <code>use</code> failure, which is unrelated to the frozen local instance issue.</p>",
        "id": 220228827,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202321
    },
    {
        "content": "<p>PS <code>⟨⟩</code> is right-associative so you can just write <code>⟨n, f, hf⟩</code></p>",
        "id": 220228962,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202411
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> regarding the frozen instance: for performance reasons Lean keeps a cache of all the instances that it knows. But if you do <code>rcases</code> on <code>hfp</code>, then you destroy something that is in the cache. You have to explicitly tell Lean that you are ok with this, by unfreezing the cache.</p>",
        "id": 220229054,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608202458
    },
    {
        "content": "<p>My suggestion avoids this problem completely by leaving it on the cache.</p>",
        "id": 220229102,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202500
    },
    {
        "content": "<p>Using Kevin's \"trick\" you don't need to do the unfreezing (because you don't destruct <code>hfp</code> any longer), which saves you a line at the beginning of your proofs</p>",
        "id": 220229103,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608202501
    },
    {
        "content": "<p>Also, leaving the cache in tact probably is good for performance as well</p>",
        "id": 220229137,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1608202523
    },
    {
        "content": "<p>and in competitive lean, saving a line is highly regarded :-)</p>",
        "id": 220229146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202528
    },
    {
        "content": "<p>One last thing -- rather than <code>let</code> I would use <code>set</code> because it enables you to name your instance -- that is, if you want to use <code>g</code> later. If you don't need it later then I wouldn't define it at all. Every definition comes with a cost.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finitely_presented_spec</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"n\">alg_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">alg_equiv.to_alg_hom</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"k\">with</span> <span class=\"n\">hg</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"c1\">-- hg remembers the definition of g</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">test</span> <span class=\"o\">[</span><span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">≃ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">finitely_presented</span> <span class=\"n\">R</span> <span class=\"n\">B</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"o\">⟨</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finitely_presented_spec</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">,</span>\n  <span class=\"n\">use</span> <span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">alg_hom.comp</span> <span class=\"o\">(</span><span class=\"n\">alg_equiv.to_alg_hom</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"c1\">-- no g in your local context at all, which is great if you don't need it again</span>\n  <span class=\"n\">sorry</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 220229344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1608202653
    },
    {
        "content": "<p>Thank you! The <code>have g</code> was there just to check that <code>g</code> had the correct type, I had removed it anyway.</p>",
        "id": 220229501,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608202770
    },
    {
        "content": "<p>I'd recommend not making <code>finitely_presented</code> a class</p>",
        "id": 220243825,
        "sender_full_name": "Reid Barton",
        "timestamp": 1608212359
    },
    {
        "content": "<p>On the other hand, I'd probably make it a <code>structure</code> (still <code>Prop</code>-valued though)</p>",
        "id": 220244412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1608212687
    },
    {
        "content": "<p>I just made a PR (to get some  feedback basically, in practice there is not much more than the definition). If you want to comment it is <a href=\"https://github.com/leanprover-community/mathlib/issues/5407\">#5407</a></p>",
        "id": 220245837,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1608213514
    }
]
[
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c\">/-</span><span class=\"cm\">- `S` is a subgroup: a set containing 1 and closed under multiplication, addition and and additive inverse. -/</span>\n<span class=\"n\">class</span> <span class=\"n\">is_subring</span>  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"c1\">-- would like `extends is_add_subgroup`, but that class doesn&#39;t exist</span>\n<span class=\"o\">(</span><span class=\"n\">one_mem</span>       <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">mul_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">add_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">inv_mem</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span>   <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"bp\">-</span><span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ring</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">is_subring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">ring</span> <span class=\"n\">S</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 127699034,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528354481
    },
    {
        "content": "<p>I think the route of defining <code>is_add_subgroup</code> will pay off in the end. Is this again one of those things where <code>[to_additive]</code> should help? The last time I tried that, it didn't work.</p>",
        "id": 127699067,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528354546
    },
    {
        "content": "<p>Ok, the easy way out: I'll extend <code>is_submonoid</code>. Even though it feels \"unmathematical\" to me.</p>",
        "id": 127699721,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528355321
    },
    {
        "content": "<p>A minimalist definition of subgroup is : non-empty and closed under lam x y,xy^{-1}. Is there any point using this minimalist definition? You could do the same with add_mem and inv_mem here. Does this save time or obfuscate? Or both?</p>",
        "id": 127703755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528360329
    },
    {
        "content": "<p>I think it would be best if we could extend both <code>is_submonoid</code> and <code>is_add_subgroup</code>.</p>",
        "id": 127706197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528363340
    },
    {
        "content": "<p>Regarding minimalist definitions (<code>x * y^{-1}</code>), I think it is best if the official definition is the bog standard definition, with no clever tricks or surprises. It's fine to then provide an alternative constructor which allows you to take advantage of shortcuts like this if you want them.</p>",
        "id": 127711064,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528367964
    },
    {
        "content": "<p>Until the constructions become seriously dire, I think it's best to optimise definitions to be usable (after you've constructed instances), rather than easy to satisfy.</p>",
        "id": 127711149,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528368022
    },
    {
        "content": "<p>(Of course actually redundant things should be lemmas.)</p>",
        "id": 127711160,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1528368035
    },
    {
        "content": "<p><a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring/src/for_mathlib\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring/src/for_mathlib\">https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring/src/for_mathlib</a></p>",
        "id": 127723434,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528384930
    },
    {
        "content": "<p>Here is a small start on subrings</p>",
        "id": 127723435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528384939
    },
    {
        "content": "<p>Update: <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/subring/src/for_mathlib/subring.lean\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/blob/subring/src/for_mathlib/subring.lean\">https://github.com/jcommelin/lean-perfectoid-spaces/blob/subring/src/for_mathlib/subring.lean</a></p>",
        "id": 127758357,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440423
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> what do you think is the best strategy for integral elements?</p>",
        "id": 127758368,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440439
    },
    {
        "content": "<p>Were univariate polynomials already there? Somewhere? Did Chris or Nicholas do this?</p>",
        "id": 127758422,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440525
    },
    {
        "content": "<p>I think lots of people did univariate polynomials</p>",
        "id": 127758494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440660
    },
    {
        "content": "<p>but I don't know if anyone submitted a PR</p>",
        "id": 127758500,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440666
    },
    {
        "content": "<p>I think Kenny proved a universal property</p>",
        "id": 127758507,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> Did any of you PR a definition of a polynomial in 1 variable into mathlib?</p>",
        "id": 127758520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440721
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Note that for the definition of a perfectoid space it might be the case that one only has to formalise the definition, i.e. \"I am a root of a monic poly with coefficients in the smaller ring\"</p>",
        "id": 127758567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440791
    },
    {
        "content": "<p>Yes, that is what I am currently trying to do</p>",
        "id": 127758569,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440811
    },
    {
        "content": "<p>To prove integral closure is a ring will involve some Noetherian arguments</p>",
        "id": 127758571,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440816
    },
    {
        "content": "<p>but I am not sure this result is needed</p>",
        "id": 127758572,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440822
    },
    {
        "content": "<p>We need \"I am a subring of R^o\"</p>",
        "id": 127758573,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440832
    },
    {
        "content": "<p>but I am not sure we need \"...and by the way R^o is a ring\"</p>",
        "id": 127758574,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528440840
    },
    {
        "content": "<p>Right, we never take the closure (-; We only have stuff that already is a subring, and then prove it is closed</p>",
        "id": 127758614,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440849
    },
    {
        "content": "<p>Oooh, what you are saying is different from what I was saying...</p>",
        "id": 127758621,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528440888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span>  There are no univariate polynomials in mathlib or in a PR. I want to move the polynomials from Mason-Stother proof in July / August.</p>",
        "id": 127762328,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1528448339
    },
    {
        "content": "<p>I will do that once I've done my project.</p>",
        "id": 127766040,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1528455576
    },
    {
        "content": "<p>What is the best way to define the n-th power of an ideal?</p>",
        "id": 127766743,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528456910
    },
    {
        "content": "<p>Current proposal:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">span</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">|</span> <span class=\"bp\">∃</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">multiset</span> <span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"bp\">∧</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">val</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 127767182,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528457699
    },
    {
        "content": "<p>I think Kenny did product of ideals so you could just define them recursively</p>",
        "id": 127772173,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528464757
    },
    {
        "content": "<p>Are Kenny's ideals a subtype parameterised by the ring? I guess they form a monoid? Then you could just write <code>I ^ n</code>?</p>",
        "id": 127772572,
        "sender_full_name": "Johannes Hölzl",
        "timestamp": 1528465207
    },
    {
        "content": "<p>But <code>I</code> has type <code>set R</code>. And there is some instance hanging around telling you that it is an ideal. So now Lean wants <code>have_pow (set R) nat</code>.</p>",
        "id": 127772627,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528465295
    },
    {
        "content": "<p>And that doesn't make sense.</p>",
        "id": 127772630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528465301
    },
    {
        "content": "<p>But maybe I'm missing something.</p>",
        "id": 127772637,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528465315
    },
    {
        "content": "<p>It doesn't make sense to a mathematician -- that's what you're missing.</p>",
        "id": 127773371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466286
    },
    {
        "content": "<p>I think the idea in CS is that you just define I*J for I and J sets to be the ideal generated by the ij</p>",
        "id": 127773379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466312
    },
    {
        "content": "<p>why not?</p>",
        "id": 127773380,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466317
    },
    {
        "content": "<p>it's the same math/CS thing</p>",
        "id": 127773388,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466325
    },
    {
        "content": "<p>it's just like dividing by zero</p>",
        "id": 127773391,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466332
    },
    {
        "content": "<p>Is that even a CS thing?</p>",
        "id": 127773393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466335
    },
    {
        "content": "<p>yes</p>",
        "id": 127773396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466338
    },
    {
        "content": "<p>nobody divides by zero except CS people</p>",
        "id": 127773400,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466344
    },
    {
        "content": "<p>oh</p>",
        "id": 127773404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466348
    },
    {
        "content": "<p>maybe applied mathematicians do</p>",
        "id": 127773405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466351
    },
    {
        "content": "<p>no not even them</p>",
        "id": 127773407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466353
    },
    {
        "content": "<p>where's the division by zero</p>",
        "id": 127773408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466353
    },
    {
        "content": "<p>they only do 0 / 0</p>",
        "id": 127773409,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466355
    },
    {
        "content": "<p>the \"division by zero\" is when you multiply two sets that are not ideals together</p>",
        "id": 127773413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466369
    },
    {
        "content": "<p>when nobody in their right mind would do this</p>",
        "id": 127773414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466374
    },
    {
        "content": "<p>presumably this is exactly what is meant by I^n</p>",
        "id": 127773415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466375
    },
    {
        "content": "<p>Exactly</p>",
        "id": 127773416,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466382
    },
    {
        "content": "<p>The notion A*B for A,B sets is well defined even if they are not ideals</p>",
        "id": 127773470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466413
    },
    {
        "content": "<p>It's just a different way of thinking about things. I know exactly why Johan is confused.</p>",
        "id": 127773472,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466414
    },
    {
        "content": "<p>Yes, well-defined and kind-of pointless</p>",
        "id": 127773485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466428
    },
    {
        "content": "<p>but if you want to restrict to ideals, it makes no difference</p>",
        "id": 127773486,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466430
    },
    {
        "content": "<p>so we don't think of it</p>",
        "id": 127773487,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466432
    },
    {
        "content": "<p>exactly</p>",
        "id": 127773488,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466433
    },
    {
        "content": "<p>and then whenever you apply it, you are probably carrying around a proof that things are ideals</p>",
        "id": 127773491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466445
    },
    {
        "content": "<p>not at all pointless, the notation is not limited to ring theory</p>",
        "id": 127773495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466451
    },
    {
        "content": "<p>This is just another instance of this canonical disconnect</p>",
        "id": 127773497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466455
    },
    {
        "content": "<p>we only define things where we need them</p>",
        "id": 127773503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466462
    },
    {
        "content": "<p>you over-define and sift later</p>",
        "id": 127773513,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466470
    },
    {
        "content": "<p>it's just cultural</p>",
        "id": 127773516,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1528466476
    },
    {
        "content": "<p>I'm certain I've seen A - B and A + B and other things as well with weirder sets than ideals</p>",
        "id": 127773523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466500
    },
    {
        "content": "<p>i.e. \"prove C + C = [0, 2] where C is the cantor set\"</p>",
        "id": 127773576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466524
    },
    {
        "content": "<p>0/0 is also well-defined. It is 57.</p>",
        "id": 127773599,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528466576
    },
    {
        "content": "<p>but I'm not even stressing this domain of definition, define it on ideals if you want</p>",
        "id": 127773615,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466586
    },
    {
        "content": "<p>you can still define I^n that way</p>",
        "id": 127773623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466610
    },
    {
        "content": "<p>And <code>A * B</code> for <code>A B : set R</code> has two definitions that make sense. (1) <code>{ a*b | a \\in A, b \\in B}</code> or (2) <del><code>span { a*b | a \\in A, b \\in B}</code></del> sorry, I meant <code>span { a*b | a \\in span A, b \\in span B}</code></p>",
        "id": 127773630,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528466641
    },
    {
        "content": "<p>since I^(n+1) = I^n * I and I^0 = B and these are both ideals</p>",
        "id": 127773673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466649
    },
    {
        "content": "<p>in ring theory you obviously need the second definition</p>",
        "id": 127773680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466661
    },
    {
        "content": "<p>I would say that (1) is more natural. But for ideals you want (2)</p>",
        "id": 127773685,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528466666
    },
    {
        "content": "<p>A question: using the set definition, is <code>span (I*I*I) = span (span (I*I) * I)</code>?</p>",
        "id": 127773722,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466742
    },
    {
        "content": "<p>yes</p>",
        "id": 127773729,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528466758
    },
    {
        "content": "<p>Anyway, Kevin, here is <a href=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring\" target=\"_blank\" title=\"https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring\">https://github.com/jcommelin/lean-perfectoid-spaces/tree/subring</a> with <code>is_integrally_closed</code> up to some sorrys in mason-stother.</p>",
        "id": 127773771,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528466765
    },
    {
        "content": "<p>A subset B is trivial, to see that B subset A, suffices to show that <code>span(I*I)*I subset I*I*I</code>, and then it follows from distributivity</p>",
        "id": 127773788,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1528466805
    },
    {
        "content": "<p>Here's another CS-ism: instead of dealing with ideals, generalize to all sets by implicitly taking the span when you need to</p>",
        "id": 127773808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466831
    },
    {
        "content": "<p>Ok, so we put a semiring structure on <code>set R</code>...</p>",
        "id": 127773872,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528466904
    },
    {
        "content": "<p>One problem with doing this generally is that <code>-A</code> is taken in sets</p>",
        "id": 127773903,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528466956
    },
    {
        "content": "<p>Hmm, there is no semiring structure actually. Because <code>neg A</code> is <code>span (-A)</code>, and so <code>neg neg A \\ne A</code>.</p>",
        "id": 127773973,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467042
    },
    {
        "content": "<p>Unless <code>A</code> is an ideal... but that is a very crazy assumption. (-;</p>",
        "id": 127773984,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467069
    },
    {
        "content": "<p>I think the nice thing to do is to define a class <code>ideals R</code>, just as with <code>opens X</code>.</p>",
        "id": 127774029,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467123
    },
    {
        "content": "<p>And then put the nice structure on <code>ideals R</code>.</p>",
        "id": 127774043,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467137
    },
    {
        "content": "<p>actually if you only want a semiring you don't need neg</p>",
        "id": 127774051,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467166
    },
    {
        "content": "<p>I don't think you have to worry about any cancellation</p>",
        "id": 127774056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467181
    },
    {
        "content": "<p>but the distributive law fails I think</p>",
        "id": 127774067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467191
    },
    {
        "content": "<p>Aah, you are right of course</p>",
        "id": 127774069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467192
    },
    {
        "content": "<p><code>{1, 2}*({1} + {1}) = {2, 4}</code>, <code>{1, 2}*{1} + {1,2}*{1} = {2,3,4}</code></p>",
        "id": 127774147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467254
    },
    {
        "content": "<p>No, your counterexample fails. Both sides are <code>R</code>.</p>",
        "id": 127774188,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467337
    },
    {
        "content": "<p>And in fact, I think you get a semiring.</p>",
        "id": 127774235,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467365
    },
    {
        "content": "<p>The output of <code>+</code> and <code>*</code> is always an ideal.</p>",
        "id": 127774259,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467385
    },
    {
        "content": "<p><code>A + B</code> is defined as <code>span (span A +' span B)</code>, where <code>+'</code> is the stupid element-wise addition.</p>",
        "id": 127774283,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467455
    },
    {
        "content": "<p>Analogously for <code>*</code>.</p>",
        "id": 127774288,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467473
    },
    {
        "content": "<p>(I agree that my initial definition was wrong. But I had not learnt your CS-ism back then. So I didn't put in enough <code>span</code>s.)</p>",
        "id": 127774346,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467530
    },
    {
        "content": "<p>I think <code>span (A +' B)</code> should suffice?</p>",
        "id": 127774416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467663
    },
    {
        "content": "<p>My observation is that elementwise addition is non-distributive (although it is associative and commutative if the underlying op is)</p>",
        "id": 127774476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528467738
    },
    {
        "content": "<p>Right, but you want that multiplication and addition of ideals is distributive.</p>",
        "id": 127774499,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467809
    },
    {
        "content": "<p>That is a fact that will someday be in mathlib, I hope.</p>",
        "id": 127774504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467821
    },
    {
        "content": "<p>So we tweak our definition, and throw in some extra <code>span</code>s.</p>",
        "id": 127774514,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528467839
    },
    {
        "content": "<p>You don't need the extra spans though, the span in the upgraded addition is sufficient to fix the issues</p>",
        "id": 127774669,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528468019
    },
    {
        "content": "<p><code>span (A *' span (B +' C)) = span (span (A *' B) +' span (A *' C))</code></p>",
        "id": 127774696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1528468068
    },
    {
        "content": "<p>Take <code>A = R</code>, <code>B = {1}</code> and <code>C = {-1}</code>. Then LHS = 0 while RHS = R.</p>",
        "id": 127774957,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528468383
    },
    {
        "content": "<p>The main point here is that you should be writing <code>(I : ideal R)</code>, not <code>(I : set R) (h : is_ideal I)</code> or whatever.</p>",
        "id": 127780905,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528475663
    },
    {
        "content": "<p>So why do we still write <code>(R : Type) [ring R]</code>? Shouldn't we write <code>R : Ring</code> and <code>G : Group</code> or something like that?</p>",
        "id": 127781504,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528476582
    },
    {
        "content": "<p>Or does the difference have to do with whether your class is a <code>Prop</code>?</p>",
        "id": 127781586,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528476668
    },
    {
        "content": "<p>So all the <code>is_open</code>s, <code>is_ideal</code>s and <code>is_subring</code>s get gathered into classes <code>opens</code>, <code>ideals</code>, and <code>subrings</code>. But things like rings and groups shouldn't...</p>",
        "id": 127781612,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528476719
    },
    {
        "content": "<p>I think in many cases you should also be writing <code>R : Ring</code> etc. Particularly in settings where the only thing you know about <code>R</code> is that it is a ring.</p>",
        "id": 127781677,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528476782
    },
    {
        "content": "<p><code>R : Ring</code> might be less convenient when dealing with specific objects. For examples, the real numbers are a ring but they are also a topological space, etc.</p>",
        "id": 127781694,
        "sender_full_name": "Reid Barton",
        "timestamp": 1528476822
    },
    {
        "content": "<p>Right</p>",
        "id": 127781772,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528476916
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> I think Mario said something along the lines that type inference and coercions don't work together.</p>",
        "id": 127781873,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528477039
    },
    {
        "content": "<p>So, suppose you have the following statement <code>instance {R : Type} [ring R] (S: subrings R) : ring S</code>. If you then want to prove <code>instance {R : Type} [comm_ring R] (S: subrings R) : comm_ring S</code> I think you run in to trouble, because now Lean needs to turn <code>S</code> into a <code>Type</code> and also infer that it is a <code>ring</code>.</p>",
        "id": 127781959,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528477198
    },
    {
        "content": "<p>And I couldn't just easily prove stuff.</p>",
        "id": 127782008,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528477211
    },
    {
        "content": "<p>(I don't have Lean here atm... so I can't reproduce the exact problem I ran into.</p>",
        "id": 127782026,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1528477228
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">coe_bot</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"err\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℤ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe_set_range</span>\n</code></pre></div>\n\n\n<p>Here, ⊥ is defined to be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_bot</span> <span class=\"o\">(</span><span class=\"n\">subring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">set_range</span><span class=\"bp\">⟩</span>\n</code></pre></div>\n\n\n<p>The proof of the above lemma gives the error : </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe_set_range</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">ℤ</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">→+*</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n<span class=\"n\">Additional</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">c</span><span class=\"o\">:</span><span class=\"err\">\\</span><span class=\"n\">Users</span><span class=\"err\">\\</span><span class=\"n\">ashvn</span><span class=\"err\">\\</span><span class=\"n\">my_project</span><span class=\"err\">\\</span><span class=\"n\">DVR</span><span class=\"err\">\\</span><span class=\"n\">src</span><span class=\"err\">\\</span><span class=\"n\">bundled_subrings_working</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span> <span class=\"kn\">context</span><span class=\"o\">:</span> <span class=\"n\">switched</span> <span class=\"n\">to</span> <span class=\"n\">simple</span> <span class=\"n\">application</span> <span class=\"n\">elaboration</span> <span class=\"n\">procedure</span> <span class=\"n\">because</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">use</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">to</span> <span class=\"n\">elaborate</span> <span class=\"n\">it</span><span class=\"o\">,</span> <span class=\"n\">error</span> <span class=\"n\">message</span>\n  <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n    <span class=\"o\">(</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe_set_range</span>\n  <span class=\"n\">term</span>\n    <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span>\n  <span class=\"n\">has</span> <span class=\"n\">type</span>\n    <span class=\"bp\">ℤ</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n    <span class=\"err\">?</span><span class=\"n\">m_1</span> <span class=\"bp\">→+*</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span>\n</code></pre></div>\n\n\n<p>The lemma coe_set_range says:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">coe_set_range</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">set_range</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">f</span> <span class=\"o\">:=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">image_univ</span>\n</code></pre></div>\n\n\n<p>I don't see why there is a type mismatch error occurs, since both \\Z and R are rings. I also don't understand the long error.</p>",
        "id": 205655108,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596241753
    },
    {
        "content": "<p>Try turning on <code>set_option pp.all true</code>?</p>",
        "id": 205655270,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596242025
    },
    {
        "content": "<p>Gives the error: </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">coe_set_range</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_4</span> <span class=\"err\">?</span><span class=\"n\">m_5</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">R</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span> <span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"n\">l_1</span>\n<span class=\"n\">Additional</span> <span class=\"n\">information</span><span class=\"o\">:</span>\n<span class=\"n\">c</span><span class=\"o\">:</span><span class=\"err\">\\</span><span class=\"n\">Users</span><span class=\"err\">\\</span><span class=\"n\">ashvn</span><span class=\"err\">\\</span><span class=\"n\">my_project</span><span class=\"err\">\\</span><span class=\"n\">DVR</span><span class=\"err\">\\</span><span class=\"n\">src</span><span class=\"err\">\\</span><span class=\"n\">bundled_subrings_working</span><span class=\"bp\">.</span><span class=\"n\">lean</span><span class=\"o\">:</span> <span class=\"kn\">context</span><span class=\"o\">:</span> <span class=\"n\">switched</span> <span class=\"n\">to</span> <span class=\"n\">simple</span> <span class=\"n\">application</span> <span class=\"n\">elaboration</span> <span class=\"n\">procedure</span> <span class=\"n\">because</span> <span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">use</span> <span class=\"n\">expected</span> <span class=\"n\">type</span> <span class=\"n\">to</span> <span class=\"n\">elaborate</span> <span class=\"n\">it</span><span class=\"o\">,</span> <span class=\"n\">error</span> <span class=\"n\">message</span>\n  <span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n    <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">coe_set_range</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_4</span> <span class=\"err\">?</span><span class=\"n\">m_5</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span>\n  <span class=\"n\">term</span>\n    <span class=\"bp\">@</span><span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span>\n  <span class=\"n\">has</span> <span class=\"n\">type</span>\n    <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"mi\">0</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">int</span> <span class=\"n\">R</span> <span class=\"n\">int</span><span class=\"bp\">.</span><span class=\"n\">semiring</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span>\n  <span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n    <span class=\"bp\">@</span><span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span> <span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_2</span> <span class=\"err\">?</span><span class=\"n\">m_4</span><span class=\"o\">)</span>\n      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">ring</span><span class=\"bp\">.</span><span class=\"n\">to_semiring</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"err\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"err\">?</span><span class=\"n\">m_3</span> <span class=\"err\">?</span><span class=\"n\">m_5</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"n\">l_1</span>\n</code></pre></div>\n\n\n<p>It seems to me that the problem is that we have int.semiring instead of int.to_semiring?</p>",
        "id": 205655692,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596242657
    },
    {
        "content": "<p>Is <code>coe_set_range</code> in mathlib?</p>",
        "id": 205656042,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596243123
    },
    {
        "content": "<p>It looks like a universe issue</p>",
        "id": 205656049,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596243127
    },
    {
        "content": "<p><code>@ring_hom.{0 u}</code> versus <code>@ring_hom.{?l_1 ?l_1}</code></p>",
        "id": 205656054,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596243137
    },
    {
        "content": "<p>Actually, this is just a copy of </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">coe_bot</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"err\">⊥</span> <span class=\"o\">:</span> <span class=\"n\">subsemiring</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">cast_ring_hom</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">coe_srange</span>\n</code></pre></div>\n\n\n<p>for subrings, so this works for \\N, but not for \\Z (as a subring)</p>",
        "id": 205656055,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596243146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/subrings/near/205656042\">said</a>:</p>\n<blockquote>\n<p>Is <code>coe_set_range</code> in mathlib?</p>\n</blockquote>\n<p>No, the lemma I want to use is defined in the file.</p>",
        "id": 205656543,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596243890
    },
    {
        "content": "<p>I would assume the <code>variables</code> are set up in a way that causes this universe issue.</p>",
        "id": 205657076,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596244710
    },
    {
        "content": "<p>Changing </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n</code></pre></div>\n\n\n<p>solved it, thank you!</p>",
        "id": 205657250,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596245025
    },
    {
        "content": "<p>I have a ring R, and a list <code>L : list(list R))</code> . I want to define a list <code>M : list(list R))</code> such that </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"bp\">-</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">L</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span>\n</code></pre></div>\n\n\n<p>I think this definition should do it : </p>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"k\">let</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">has_neg</span> <span class=\"o\">))</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>however, this gives an error</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">has_neg</span><span class=\"o\">)</span> <span class=\"n\">L</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">L</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"err\">?</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>Any help is appreciated, thank you!</p>",
        "id": 205923961,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596556028
    },
    {
        "content": "<p>Is it because <code>has_neg</code> should be <code>has_neg.neg</code>?</p>",
        "id": 205924450,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596556302
    },
    {
        "content": "<p>Also, I don't think this would work, since the product of <code>[-1,-2]</code> is not the negative of the product of <code>[1,2]</code>.</p>",
        "id": 205924533,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596556336
    },
    {
        "content": "<p>But it's possible I'm misunderstanding what you're trying to do here...</p>",
        "id": 205924623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596556388
    },
    {
        "content": "<p>This is a difficult question, since list.prod evaluates the empty list to 1.</p>",
        "id": 205927514,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596557843
    },
    {
        "content": "<p>How you you define this for, say, the following list of lists: <code>[[],[]]</code>?</p>",
        "id": 205927721,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596557938
    },
    {
        "content": "<p><code>(list.map list.prod L).sum</code> when evaluated at <code>[[1,2],[3,4]]</code> is ([2,12]).sum which is 14. If you negate everything you still get 14.</p>",
        "id": 205928954,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596558636
    },
    {
        "content": "<p>Yeah, so it seems you want to only negate the head of each list, but then the empty lists cause issues.</p>",
        "id": 205929017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596558674
    },
    {
        "content": "<p>I think you want to define a function like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n\n<span class=\"n\">def</span> <span class=\"n\">helper</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n<span class=\"bp\">|</span> <span class=\"o\">[]</span> <span class=\"o\">:=</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">]</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">as</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">-</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">as</span>\n</code></pre></div>\n\n\n<p>and map using that.</p>",
        "id": 205929247,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596558819
    },
    {
        "content": "<p>I defined </p>\n<div class=\"codehilite\"><pre><span></span><code>  <span class=\"k\">let</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span><span class=\"n\">list</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"n\">b</span><span class=\"o\">))</span> <span class=\"n\">L</span><span class=\"o\">,</span>\n</code></pre></div>\n\n\n<p>and it seems to work. I believe it is equivalent to the definition you gave?<br>\nThank you!</p>",
        "id": 205965897,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596578242
    },
    {
        "content": "<p>It's a bit different, but it also works.</p>",
        "id": 205965929,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1596578277
    },
    {
        "content": "<p>That should certainly work. What are you doing though?</p>",
        "id": 205965973,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578285
    },
    {
        "content": "<p>I was trying to prove this (got from the <code>subsemiring</code> file) : </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">lemma</span> <span class=\"n\">mem_closure_iff_exists_list</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"n\">s</span> <span class=\"bp\">↔</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>After struggling with the negation case for a while, I found this in the <code>is_subring</code> file :</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">theorem</span> <span class=\"n\">exists_list_of_mem_closure</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hx</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">closure</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"n\">L</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">list</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">t</span> <span class=\"err\">∈</span> <span class=\"n\">L</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">y</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"bp\">∨</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">-</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"n\">R</span><span class=\"o\">))</span> <span class=\"bp\">∧</span> <span class=\"o\">(</span><span class=\"n\">L</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">prod</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">sum</span> <span class=\"bp\">=</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n\n\n<p>The proof is similar, so I am currently working the proof around.</p>",
        "id": 205966298,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596578478
    },
    {
        "content": "<p>Then your suggestion looks perfect!</p>",
        "id": 205966448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578546
    },
    {
        "content": "<p>Because -1 is in your ring</p>",
        "id": 205966471,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578567
    },
    {
        "content": "<p>The lemma as it stands without allowing -1 is false</p>",
        "id": 205966525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578617
    },
    {
        "content": "<p>Yeah I'm confused</p>",
        "id": 205966545,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596578633
    },
    {
        "content": "<p>Yes exactly, I realised that only after trying the negation case for very long</p>",
        "id": 205966619,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596578653
    },
    {
        "content": "<p>Since <code>exists_list_of_mem_closure</code> already exists, what are you trying to prove? A corresponding statement for semirings? i.e. what is <code>R</code>?</p>",
        "id": 205966746,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596578743
    },
    {
        "content": "<p>oh <code>mem_closure_iff_exists_list</code> also already exists, so now I'm doubly confused</p>",
        "id": 205966909,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596578823
    },
    {
        "content": "<p>You're trying to prove <code>mem_closure_iff_exists_list</code> even though mathlib already has a proof?</p>",
        "id": 205966935,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596578843
    },
    {
        "content": "<p>We're bundling subrings. It existed for <code>is_subring</code>.</p>",
        "id": 205967143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596578984
    },
    {
        "content": "<p>I am trying to adapt <code>exists_list_of_mem_closure</code> for bundled subrings, the definition of closure is somewhat different, and the existing proof breaks, because it uses something from <code>deprecated.subgroups</code>.</p>",
        "id": 205967371,
        "sender_full_name": "Ashvni Narayanan",
        "timestamp": 1596579127
    },
    {
        "content": "<p>I see</p>",
        "id": 205967563,
        "sender_full_name": "Reid Barton",
        "timestamp": 1596579251
    }
]
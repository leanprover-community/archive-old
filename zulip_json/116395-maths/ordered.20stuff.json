[
    {
        "content": "<p>Dear All,</p>\n<p>every once in a while, someone comes along saying that there is something funny about <code>ordered_[something]</code> (typically <code>ordered_semiring</code>).</p>\n<p>Given the large quantity of typeclasses for types with one or two operations, with/without zero, with/without one, (non-)commutative, non-unital, cancel, left/right cancel, and so on, I have a proposal.</p>\n<p>Do <em>not</em> define <code>ordered_[everything]</code> with the variant <code>linearly_ordered_</code>.  Instead, assume the \"ring-type\" class and the \"order-type\" class separately and introduce one or two typeclasses for types that have <code>mul</code> and <code>le</code> (possibly slightly more) to bind the two.</p>\n<p>Here is a more concrete proposal.</p>\n<p>The main extra axioms are monotonicity of add/mul on the left/right.  There is also a \"contrapositive\" version of monotonicity (that is equivalent to monotonicity for linear orderings):</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span>\n</code></pre></div>\n<p>that I would probably add to the classes below for good measure.</p>\n<p>Thus, I suggest to introduce</p>\n<ul>\n<li>a <code>mul_left_mono</code> , <code>a ≤ b → c * a ≤ c * b</code>, and contrapositive,</li>\n<li>a <code>mul_right_mono</code>, <code>a ≤ b → a * c ≤ b * c</code>, and contrapositive,</li>\n<li>a <code>mul_mono</code> (extending left and right),</li>\n<li>the <code>to_additive</code> of those, and</li>\n<li><code>zero_le_one</code>.</li>\n</ul>\n<p>Besides giving more flexibility with mixing in the classes, this also allows removing a large number of typeclasses.</p>\n<p>What are people's opinion on this?  Does it seem worthwile?  Reasonable?  Are there some unseen issues that I might be missing?</p>",
        "id": 235566045,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619032690
    },
    {
        "content": "<p>IIUC, this is the ordered flavour of the issue that we have to choose between either having an exponential number of type classes or having exponential term sizes.</p>",
        "id": 235571913,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619035177
    },
    {
        "content": "<p>I am reminded of this recent-ish thread: <a href=\"#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231441524\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/.60.5Bcomm_ring.20R.5D.60.20vs.20.60.5Bring.20R.5D.20.5Bcomm.20R.5D.60/near/231441524</a></p>",
        "id": 235572305,
        "sender_full_name": "Oliver Nash",
        "timestamp": 1619035319
    },
    {
        "content": "<p>I also think the current method has a problem: we have many <code>ordered_[algebraic_thing]</code>, and we don't nearly have all combinations.<br>\nOn an old branch <a href=\"https://github.com/leanprover-community/mathlib/tree/canonically_ordered_sub\">branch#canonically_ordered_sub</a> I tried to add a <code>sub</code> field to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/canonically_ordered_add_monoid\">docs#canonically_ordered_add_monoid</a> (since <em>many</em> canonically ordered types have a <code>sub</code> defined for that type specifically, and I wanted to unify these definitions). However, to do it properly, I would have to greatly increase the number of  <code>ordered_[algebraic_thing]</code> classes, so it kind-of stalled.</p>\n<p>I think making the <code>ordered_[algebraic_thing]</code> classes mixins is a good idea, that will hugely decrease the number of classes we need. However, I don't think we should split up the classes like you propose: we still keep the <code>[ordered_(semi)ring \\a]</code> class. However, this time it takes arguments <code>[semiring \\a] [partial_order \\a]</code>. And then we can change these arguments, but we don't need change the mixin:</p>\n<ul>\n<li><code>[semiring \\a] [partial_order \\a] [ordered_ring \\a]</code></li>\n<li><code>[ring \\a] [partial_order \\a] [ordered_ring \\a]</code></li>\n<li><code>[semiring \\a] [linear_order \\a] [ordered_ring \\a]</code></li>\n<li><code>[ring \\a] [linear_order \\a] [ordered_ring \\a]</code><br>\n(currently the linearly ordered structures are also assumed to be <code>nontrivial</code>. If that is important, I guess we have to add that as a separate argument as well.)<br>\nThis is very similar to how we do <a href=\"https://leanprover-community.github.io/mathlib_docs/find/topological_group\">docs#topological_group</a>.</li>\n</ul>",
        "id": 235595710,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1619046361
    },
    {
        "content": "<p>Oliver, thanks for your comment: I had not thought about the lengthening of proof terms!</p>",
        "id": 235612656,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619060006
    },
    {
        "content": "<p>Floris, thanks a lot for your input!</p>\n<p>I will try to make a concrete model following your proposal, although I may not have much time today.</p>\n<p>Let me try to summarize your idea.  We should have separate typeclasses for <code>left/right_ordered_(semi)rings</code>, <code>left/right_ordered_(comm_)monoid(_with...)</code>,  (+ additive version), each of which takes </p>\n<ul>\n<li>a left/right/both input,</li>\n<li>a ring/monoid/add_monoid typeclass, and</li>\n<li><del>a preorder/partial order/linear order input</del><br>\nand returns a typeclass that adds monotonicity on the correct side of the corresponding algebraic structure?</li>\n</ul>\n<p>Roughly, we should have<br>\n<code>(3 for left, right, both) * (3 for monoid, add_monoid, semiring) = 9</code><br>\ntypeclasses, right?  E.g.</p>\n<ul>\n<li><code>ordered_left_add_monoid </code> with input something with <code>has_add</code> and <code>has_le</code>, =&gt; addition on the left is monotone, or</li>\n<li><code>ordered_semiring </code> with input something with <code>has_add</code>, <code>has_mul</code> and <code>has_le</code> =&gt; addition and multiplication are monotone on the left and on the right.</li>\n</ul>\n<p>Let me know if this is not what you had in mind!</p>",
        "id": 235613439,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619060752
    },
    {
        "content": "<p>In your bulleted list you've included preorder/partial order/linear order as a varying parameter. Hopefully this should just be handled by mixing, not dependency.</p>",
        "id": 235613595,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619060889
    },
    {
        "content": "<p>Scott, you are right: I did not intend the kind of order to play a role, other than <code>has_le</code> is present!  I will remove it!</p>",
        "id": 235613779,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619061060
    },
    {
        "content": "<p>More concretely, the typeclasses will simply add two axioms for each operation <code>+</code> or <code>*</code> specified: monotonicity of left/right/both addition/multiplication and the cancellative/contrapositive version (which is unnecessary but would be assumed in case the order is linear).</p>",
        "id": 235613957,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619061252
    },
    {
        "content": "<p>Here is a first attempt at setting up this proposal:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.ring</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ordered_proposal</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_left_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_right_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_right</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">ordered_left_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_right_mul</span> <span class=\"n\">α</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_left_add</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_right_add</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_right</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_add</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">ordered_left_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_right_add</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">ordered_left_mul</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">ordered_right_mul</span>\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">to_additive</span><span class=\"o\">]</span> <span class=\"n\">ordered_mul</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_left_semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">ordered_left_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_left_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_le_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_right_semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"kd\">extends</span> <span class=\"n\">ordered_right_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_right_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_zero</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">zero_le_one</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">≤</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">ordered_left_semiring</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">ordered_right_semiring</span> <span class=\"n\">α</span>\n<span class=\"c1\">-- this name already exists for a typeclass that often raised questions.</span>\n<span class=\"c1\">-- The typeclass proposed here is not equivalent to the current `ordered_semiring`.</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">ordered_proposal</span>\n</code></pre></div>",
        "id": 235617711,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619065266
    },
    {
        "content": "<p>Any comments are really welcome!</p>",
        "id": 235617719,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619065276
    },
    {
        "content": "<p>I am thinking that I might make the add/mul be an input of a typeclass <code>ordered_left</code> and then there is no need for the <code>to_additive</code> version...</p>",
        "id": 235619261,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619066958
    },
    {
        "content": "<p>Hmm, that last suggestion sounds a bit un-mathlib-y, and will possibly make using <code>to_additive</code> more of a struggle. I would just embrace <code>to_additive</code>. :-)</p>",
        "id": 235622345,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619069687
    },
    {
        "content": "<p>Ok, I am not trying to push the explicit add/mul issue further, but another unification that would have arisen, is that you could dispense with left/right, since you could feed it <code>(+)</code>, for the left add version, or <code>function.swap (*)</code>, for the right mul version.</p>",
        "id": 235622586,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619069926
    },
    {
        "content": "<p>Anyway, my initial suggestion would be to simply add these typeclasses in a first PR and do nothing else.</p>\n<p>I would relegate the removal of the existing typeclasses, replacing them with the ones above to a later PR.</p>\n<p>The only issue that I see at the moment with this plan is that the new <code>ordered_semiring</code> would clash with the old one.  Would calling the new one <code>ordered_add_mul</code> be a better name?</p>",
        "id": 235622803,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619070129
    },
    {
        "content": "<p>I don't think we would want to add these new typeclasses unless we knew they were actually going to work, so I'm not sure it makes sense to do this in separate PRs.</p>",
        "id": 235627876,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1619074323
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/116395-maths/topic/ordered.20stuff/near/235617711\">said</a>:</p>\n<blockquote>\n<p>Here is a first attempt at setting up this proposal:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.ring</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">ordered_proposal</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">ordered_left_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>There is a problem with this definition that you are embedding a multiplication in this class. So, if you require <code>[ring α] [linear_order α] [ordered_left_mul α]</code> then you have two unrelated multiplications, which is not what you want. The idea of mixins is rather that they should not contain data, and take the data as typeclass assumptions. I am a little bit wary of </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ordered_left_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>because it means that any mention of this class would have a lot of parameters. Maybe one could indeed define these classes to state theorems in the most general version, but for the practical hierarchy I think I'd go directly for things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">left_ordered_semiring</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">add</span> <span class=\"n\">the</span> <span class=\"n\">right</span> <span class=\"kd\">axiom</span> <span class=\"n\">you</span> <span class=\"n\">want</span> <span class=\"n\">to</span> <span class=\"n\">put</span> <span class=\"n\">here</span>\n</code></pre></div>\n<p>and then record an instance from this to your general class <code>ordered_left_mul</code>.</p>",
        "id": 235635931,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619078460
    },
    {
        "content": "<p>Sébastien, thank you very much for your comments: I did run exactly into the issue that you mention!</p>",
        "id": 235679004,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619098902
    },
    {
        "content": "<p>I have been playing a bit with this and the code below seems like it would work to do the mix <em>and</em> interact well with <code>to_additive</code>.  Do people have any opinion on whether it seems like a good solution?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic.ring</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">my_mix</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">direct</span>  <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">inverse</span> <span class=\"o\">:</span>  <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">},</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">c</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">my_mix</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">[</span><span class=\"n\">my_mix</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">ab</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">mul_le_mul_right</span> <span class=\"o\">[</span><span class=\"n\">my_mix</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"o\">:=</span>\n<span class=\"n\">direct</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">ab</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">[</span><span class=\"n\">my_mix</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">inverse</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">ab</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lt_of_mul_lt_mul_right</span> <span class=\"o\">[</span><span class=\"n\">my_mix</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">ab</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"o\">:=</span>\n<span class=\"n\">inverse</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"n\">c</span> <span class=\"n\">ab</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">my_mix</span>\n</code></pre></div>",
        "id": 235679179,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619098962
    },
    {
        "content": "<p>Dear All,</p>\n<p>here is a current proposal to counterbalance the <code>ordered_algebraic_gadget</code> hierarchy in such a way that the hypotheses on</p>\n<ul>\n<li>the order (<code>preorder</code>, <code>partial_order</code>, <code>linear_order</code>),</li>\n<li>the algebraic operations (<code>mul</code>, <code>add</code>),</li>\n<li>the appropriate left/right monotonicity</li>\n</ul>\n<p>can be split.  I am planning to make a PR with these changes, but I welcome any comment!  Below is a sample of what is going on: the actual code posted below is quite short, but it also contains a lot of doc-strings and comments to help with readability.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.ring.basic</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">variants</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"n\">N</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"o\">}</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"sd\">/-- `covariant` is useful to formulate succintly statements about the interactions between an</span>\n<span class=\"sd\">action of a Type on another one and a relation on the acted-upon Type.</span>\n\n<span class=\"sd\">See the `covariant_class` doc-string for its meaning. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">covariant</span>     <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">},</span> <span class=\"n\">r</span> <span class=\"n\">n₁</span> <span class=\"n\">n₂</span> <span class=\"bp\">→</span> <span class=\"n\">r</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/-- `contravariant` is useful to formulate succintly statements about the interactions between an</span>\n<span class=\"sd\">action of a Type on another one and a relation on the acted-upon Type.</span>\n\n<span class=\"sd\">See the `contravariant_class` doc-string for its meaning. -/</span>\n<span class=\"kd\">def</span> <span class=\"n\">contravariant</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">},</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">n₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">m</span> <span class=\"n\">n₂</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"n\">n₁</span> <span class=\"n\">n₂</span>\n\n<span class=\"sd\">/--  Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the</span>\n<span class=\"sd\">`covariant_class` says that \"the action `μ` preserves the relation `r`.</span>\n\n<span class=\"sd\">More precisely, the `covariant_class` is a class taking two Types `M N`, together with an \"action\"</span>\n<span class=\"sd\">`μ : M → N → N` and a relation `r : N → N`.  Its unique field `covc` is the assertion that</span>\n<span class=\"sd\">for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair</span>\n<span class=\"sd\">`(n₁, n₂)`, then, the relation `r` also holds for the pair `(μ m n₁, μ m n₂)`,</span>\n<span class=\"sd\">obtained from `(n₁, n₂)` by \"acting upon it by `m`\".</span>\n\n<span class=\"sd\">If `m : M` and `h : r n₁ n₂`, then `covariant_class.covc m h : r (μ m n₁) (μ m n₂)`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">covariant_class</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">covc</span> <span class=\"o\">:</span>  <span class=\"n\">covariant</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">μ</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"sd\">/--  Given an action `μ` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the</span>\n<span class=\"sd\">`contravariant_class` says that \"if the result of the action `μ` on a pair satisfies the</span>\n<span class=\"sd\">relation `r`, then the initial pair satisfied the relation `r`.</span>\n\n<span class=\"sd\">More precisely, the `contravariant_class` is a class taking two Types `M N`, together with an</span>\n<span class=\"sd\">\"action\" `μ : M → N → N` and a relation `r : N → N`.  Its unique field `covtc` is the assertion that</span>\n<span class=\"sd\">for all `m ∈ M` and all elements `n₁, n₂ ∈ N`, if the relation `r` holds for the pair</span>\n<span class=\"sd\">`(μ m n₁, μ m n₂)` obtained from `(n₁, n₂)` by \"acting upon it by `m`\"\", then, the relation `r`</span>\n<span class=\"sd\">also holds for the pair `(n₁, n₂)`.</span>\n\n<span class=\"sd\">If `m : M` and `h : r (μ m n₁) (μ m n₂)`, then `covariant_class.covc m h : r n₁ n₂`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">class</span> <span class=\"n\">contravariant_class</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">covtc</span> <span class=\"o\">:</span> <span class=\"n\">contravariant</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">sample_application</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">linear_order</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">covariant_class</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"n\">contravariant_class</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">z</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">hlt</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">covariant_class.covc</span> <span class=\"n\">x</span> <span class=\"n\">hle</span> <span class=\"o\">:</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span> <span class=\"bp\">≤</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"k\">#check</span> <span class=\"o\">(</span><span class=\"n\">contravariant_class.covtc</span> <span class=\"n\">x</span> <span class=\"n\">hlt</span> <span class=\"o\">:</span> <span class=\"n\">y</span> <span class=\"bp\">&lt;</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- sample definition</span>\n<span class=\"sd\">/--  Addition on the left is monotone.  The two fields are defeq to</span>\n<span class=\"sd\">* `add_le_add_left       :  ∀ (a) {b c}, b ≤ c → a + b ≤ a + c`,</span>\n<span class=\"sd\">* `lt_of_add_lt_add_left :  ∀ (a) {b c}, a + b ≤ a + c → b &lt; c`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[ancestor has_add has_le has_lt]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_left_mono</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span>       <span class=\"o\">:</span>  <span class=\"n\">covariant</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:</span>  <span class=\"n\">contravariant</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">))</span>\n\n<span class=\"sd\">/--  Multiplication on the left is monotone.  The two fields are defeq to</span>\n<span class=\"sd\">* `mul_le_mul_left       :  ∀ (a) {b c}, b ≤ c → a * b ≤ a * c`,</span>\n<span class=\"sd\">* `lt_of_mul_lt_mul_left :  ∀ (a) {b c}, a * b ≤ a * c → b &lt; c`.</span>\n<span class=\"sd\">-/</span>\n<span class=\"kd\">@[ancestor has_mul has_le has_lt, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">mul_left_mono</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span>  <span class=\"o\">(</span><span class=\"n\">covariant</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)))</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span>  <span class=\"n\">contravariant</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">))</span>\n\n<span class=\"c1\">-- sample instance</span>\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">instance</span> <span class=\"n\">mul_left_mono.to_covariant_class</span> <span class=\"o\">[</span><span class=\"n\">mul_left_mono</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">covariant_class</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">covc</span> <span class=\"o\">:=</span> <span class=\"n\">mul_left_mono.mul_le_mul_left</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- together with these, I also plan to incorporate instances from \"well-known\" typeclasses,</span>\n<span class=\"c1\">-- such as `ordered_comm_monoid` to this hierarchy</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">sample_application</span>\n</code></pre></div>",
        "id": 236147763,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619431227
    },
    {
        "content": "<p>I should have said, <em>many</em> of the lemmas in <code>algebra/ordered_monoid</code> can be proven by assuming at most two of the <code>covariant</code> <code>contravariant</code> classes + an algebraic class, such as <code>has_mul</code> or <code>mul_one_class</code> + an order class, such as <code>preorder</code> or <code>partial_order</code>.</p>",
        "id": 236148475,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619431588
    },
    {
        "content": "<p>For what it's worth you could also write <code>covariant</code> as <code>∀ m, (r ⇒ r) (μ m) (μ m)</code>, which is defeq and comes with a tiny bit of API.</p>",
        "id": 236148738,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619431744
    },
    {
        "content": "<p>Thanks Eric: I do not even know how to type the arrow symbol, but I can take a look!</p>",
        "id": 236148781,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619431784
    },
    {
        "content": "<p>It's <a href=\"https://leanprover-community.github.io/mathlib_docs/find/relator.lift_fun\">docs#relator.lift_fun</a> and <code>\\r=</code></p>",
        "id": 236148823,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619431804
    },
    {
        "content": "<p><code>class mul_left_mono (M : Type*) extends has_mul M, has_le M, has_lt M :=</code> is not going to work though</p>",
        "id": 236149250,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619432066
    },
    {
        "content": "<p>If you extend <code>has_mul</code> and <code>has_le</code>, then you can't use your class at the same time as <code>ring</code> or <code>partial_order</code> (doing so would pull in two different versions of those operators), which is a massive dealbreaker.</p>",
        "id": 236149286,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619432085
    },
    {
        "content": "<p><code>class mul_left_mono (M : Type*) [has_mul M] [has_le M] [has_lt M] :=</code> would be safe in that regard</p>",
        "id": 236149313,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619432103
    },
    {
        "content": "<p>Ok, I have been mostly using assumptions such as <code>[preorder α] [mul_one_class α] [covariant_class α α has_mul.mul has_le.le]</code>.  To be honest, I do not really feel the need to introduce the classes <code>mul_left_mono</code>.  I do seem to care about having instances from the \"known\" classes to the correctly decorated <code>co(ntra)variant</code> class and then prove lemmas assuming <code>co(ntra)variant_class</code>.</p>\n<p>This seems in line with what you are saying, right?  I may simply ditch the <code>add/mul_left/righ_mono</code> typeclasses altogether.</p>",
        "id": 236149793,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619432397
    },
    {
        "content": "<p>The direction you're exploring for this ordered stuff looks a lot like the direction explored for basic algebra structure with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_commutative\">docs#is_commutative</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/is_left_id\">docs#is_left_id</a> etc. Since the latter exploration seems to have been abandoned, it would be good to understand why before attempting to follow in its footsteps</p>",
        "id": 236151698,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619433429
    },
    {
        "content": "<p>Well, at the moment, the change is really minimal and you can split the left/right assumptions, which alone seems worthwhile.</p>",
        "id": 236152120,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619433713
    },
    {
        "content": "<p>If anyone knows of pitfalls or issues with the <code>is_commutative/is_left_id</code> approach mentioned by Eric, please, let me know!</p>",
        "id": 236152222,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619433748
    },
    {
        "content": "<p>It looks to me like something which was introduced in core Lean and they figured they'd see if it turned out to be useful, and for some reason it didn't catch on -- perhaps because we were so fixated on old structures that we didn't need it?</p>",
        "id": 236153478,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1619434520
    },
    {
        "content": "<p>Ok, I am going to try it, since I do believe that the left/right distinction is important, the actual change is tiny, and the lemmas are much more general now.</p>",
        "id": 236153686,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619434654
    },
    {
        "content": "<p>The <code>@[algebra]</code> classes were part of a plan for an algebraic normalizer in lean core that was derailed by lean 4</p>",
        "id": 236158150,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619437063
    },
    {
        "content": "<p>they are basically unfinished code</p>",
        "id": 236158168,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619437075
    },
    {
        "content": "<p>see <a href=\"https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1\">https://github.com/leanprover/lean/wiki/Refactoring-structures#encoding-the-algebraic-hierarchy-1</a></p>",
        "id": 236158377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619437175
    },
    {
        "content": "<p>Importantly, note the section on \"The unbundled approach doesn't work with the simplifier as is.\" That is still true with today's <code>simp</code></p>",
        "id": 236158516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619437226
    },
    {
        "content": "<p>there was a critical second step in the plan that would have made these classes work well, and that part never happened, so now we just have some unbundled typeclasses, which are useful for exactly what they look like but aren't really usable as a replacement for the algebraic hierarchy</p>",
        "id": 236158650,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1619437317
    },
    {
        "content": "<p>I added a brief summary in a docstring in <a href=\"https://github.com/leanprover-community/lean/pull/568\">https://github.com/leanprover-community/lean/pull/568</a> - feel free to edit it <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>.</p>",
        "id": 236163080,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619439484
    },
    {
        "content": "<p>Thanks for the insight!</p>",
        "id": 236163104,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619439489
    },
    {
        "content": "<p>Ok, thank you!</p>",
        "id": 236165920,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619440839
    },
    {
        "content": "<p>As I am viewing it at the moment, I would keep the usual names (the <code>ordered_...</code>) as the \"reference classes\".  However, I would like the theorems to be proven with the <code>co(ntra)variant</code> assumptions, since those are much more flexible.  Since \"all\" the <code>co(tra)variant</code> variants are instances for <code>ordered_comm_monoid</code> and behave well with <code>to_additive</code>, they should automatically work for the rest of the hierarchy.</p>",
        "id": 236166278,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619440959
    },
    {
        "content": "<p>I am experimenting and it seems to work with very few problems.</p>",
        "id": 236166299,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619440972
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7371\">#7371</a></p>\n<p>It is still experimental, but I also want to see how this hierarchy interacts with the other files!</p>",
        "id": 236194361,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619450579
    },
    {
        "content": "<p>I filled in the various extra <code>_</code> needed in some files and CI is now in the final Lint/Run Test sprint.</p>\n<p>If anyone has any comments on this PR (<a href=\"https://github.com/leanprover-community/mathlib/issues/7371\">#7371</a>), I would be very very happy to hear them!</p>",
        "id": 236296116,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619509486
    },
    {
        "content": "<p>(Note that it <em>looks</em> massive, but most of the difference is that I moved a substantial chunk of a file into another one.)</p>",
        "id": 236296217,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619509556
    },
    {
        "content": "<p>To help guide with the review:</p>\n<ul>\n<li>the \"old\" file <code>algebra/ordered_monoid</code> lost a lot of content that was moved to the new file <code>algebra/ordered_monoid_lemmas</code>,</li>\n<li>new stuff in the old file <code>ordered_monoid</code> includes instances to the new typeclasses <code>covariant</code> and <code>contravariant</code>,</li>\n<li>genuinely new stuff in the new file <code>ordered_monoid_lemmas</code> is basically the first 100 lines; after that, it is \"old\" lemmas with weaker assumptions (and essentially identical proofs),</li>\n<li>the remaining 10 changed files are simply fixes, almost always caused by different numbers of implicit arguments when <code>@</code> was used in a lemma.</li>\n</ul>\n<p>Disclaimer: no lemmas were removed in the making of this PR.</p>",
        "id": 236298859,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619511219
    },
    {
        "content": "<p>I think I like a lot the idea of switching to mixins instead of infinitely many typeclasses with all possible algebraic structures and all possible order structures. I have a question on the design of the PR, though. You formulate assumptions such as <code>[contravariant_class α α (*) (&lt;)]</code> or <code>[covariant_class α α (*) (≤)]</code> and so on. I think it is a very good idea to have a common instance when it makes it possible to factor out proofs, but here I don't really see what it buys compared to having a few classes like <code>mul_le_mul</code> or friends. </p>\n<p>It is likely that instance search would be a little bit faster with the more specialized classes that with the generic <code>contravariant_class</code> and <code>covariant_class</code> mechanism, because with the generic classes Lean would try all instances of the class even when they clearly don't make sense (for instance, it would try the instances for addition even if you're asking for something on multiplication). That shouldn't be a performance bottleneck, though, so if you see an advantage to the generic classes then I'm happy to go for it!</p>",
        "id": 236330403,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619527988
    },
    {
        "content": "<p>I do not know about performance, so I will leave that side of the question.  I have tried making a typeclass such as what is below</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">ordered_left_mul</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span>       <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>but I could not \"stack this on top\" of a <code>[semiring α] [partial_order α]</code>, since the multiplication and order assumed in <code>ordered_left_mul</code> are \"new\".</p>",
        "id": 236330984,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528213
    },
    {
        "content": "<p>With the new instances that take the operation and the order as inputs, you can use the \"same\" operation and order that you are familiar.</p>\n<p>Once I got to this stage, I went for creating only two new classes and merged everything in.  I have a dream that, together with the <code>to_additive</code> attribute, there might also be a <code>to_right</code> attribute that would change <code>left</code> to <code>right</code> and <code>mul/add</code> to <code>function.swap mul/add</code> and would just do the quadruplication for you for free!</p>",
        "id": 236331370,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528363
    },
    {
        "content": "<p>I do think that these typeclasses <code>covariant_class</code> and <code>contravariant_class</code> could be useful in different contexts as well.  For instance, Kevin mentioned that a specialization of one of them is something called <code>con/add_con</code>.</p>",
        "id": 236331893,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528570
    },
    {
        "content": "<p>Also, while they look intimidating, they simply say that you can test a property of pairs before or after acting on each element of the pair by some \"operation\".  This is a relatively common concept in maths.</p>",
        "id": 236332009,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/116395-maths/topic/ordered.20stuff/near/236330984\">said</a>:</p>\n<blockquote>\n<p>but I could not \"stack this on top\" of a <code>[semiring α] [partial_order α]</code>, since the multiplication and order assumed in <code>ordered_left_mul</code> are \"new\".</p>\n</blockquote>\n<p>What do you mean by this? Do you mean  <code>example [semiring α] [partial_order α] [ordered_left_mul α] : ... := ...</code> does not work (it should)? Or do you mean that something else you tried that you haven't pasted here didn't work?</p>",
        "id": 236332686,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619528900
    },
    {
        "content": "<p>In any case, there are the axioms that seem useful</p>\n<ul>\n<li><code>mul_le_mul</code> + left/right + add/mul</li>\n<li><code>mul_lt_mul</code> + left/right + add/mul</li>\n<li><code>le_of_mul_le_mul</code> + left/right + add/mul</li>\n<li><code>lt_of_mul_le_mul</code> + left/right + add/mul</li>\n</ul>",
        "id": 236332704,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528908
    },
    {
        "content": "<p>Eric, let me try to see what did not work: I was typing based on something that I remembered, not something that I had just tried.</p>",
        "id": 236332843,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619528968
    },
    {
        "content": "<p>I cannot reproduce it now.  It might have been that I was trying to use the version with the explicit <code>(*)</code>.  Indeed, this does not work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">my_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">new</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n<span class=\"c1\">-- invalid object declaration, environment already has an object named 'new.to_my_class'</span>\n</code></pre></div>\n<p>I understand the issue, but you are right: if you give <em>different</em> names to the fields, for add, mul, left, right, le, lt, direct and inverse, you should be ok!</p>",
        "id": 236337643,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619530602
    },
    {
        "content": "<p>Ok, this might be a list of all the typeclasses that I have come across:</p>\n<ul>\n<li><code>mul_le_mul_left</code></li>\n<li><code>mul_le_mul_right</code></li>\n<li><code>add_le_add_left</code></li>\n<li><code>add_le_add_right</code></li>\n<li><code>le_of_mul_le_mul_left</code></li>\n<li><code>le_of_mul_le_mul_right</code></li>\n<li><code>le_of_add_le_add_left</code></li>\n<li><code>le_of_add_le_add_right</code></li>\n<li><code>mul_lt_mul_left</code></li>\n<li><code>mul_lt_mul_right</code></li>\n<li><code>add_lt_add_left</code></li>\n<li><code>add_lt_add_right</code></li>\n<li><code>lt_of_mul_lt_mul_left</code></li>\n<li><code>lt_of_mul_lt_mul_right</code></li>\n<li><code>lt_of_add_lt_add_left</code></li>\n<li><code>lt_of_add_lt_add_right</code></li>\n</ul>\n<p>I was hoping that by reducing them to two and making them take inputs, would have made automation easier.  If you think that having them displayed out individually is a better option, I can certainly do this.</p>\n<p>This might simply involve changing the first two files, since all the files external to <code>ordered_monoid</code> and <code>ordered_monoid_lemmas</code> have no explicit <code>co(ntra)variant_class</code> assumption.</p>",
        "id": 236338967,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619531063
    },
    {
        "content": "<p>As of now, most of these appear \"paired\": <code>mul_le_mul_left</code>comes together with <code>lt_of_mul_lt_mul_left</code> and there is no \"real\" <code>left/right</code>distinction, since they are only applied to commutative monoids/rings.</p>",
        "id": 236339539,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619531284
    },
    {
        "content": "<p>Yes, I meant using those instead of the <code>covariant_class / contravariant_class</code> instances. I think it shouldn't make any difference for the statements (you would only need to state the multiplicative ones as <code>to_additive</code> should take care of the additive versions).</p>",
        "id": 236339804,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619531384
    },
    {
        "content": "<p>While I like the idea of exploring alternatives to <code>to_additive</code> (that is, passing <code>(*)</code> and <code>(+)</code> explicitly), I think doing it at the same time as splitting apart the order classes is perhaps too many changes at once; your list already becomes half the length with <code>to_additive</code></p>",
        "id": 236339925,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619531419
    },
    {
        "content": "<p>Ok, but the classes need to be defined individually, right? <code>to_additive</code> only kicks in at the level of lemmas/defs, not classes?  Or at least I thought so.</p>",
        "id": 236340052,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619531470
    },
    {
        "content": "<p>Yes, that's true I think</p>",
        "id": 236340889,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619531779
    },
    {
        "content": "<p>Note also that, as of now, <code>to_additive</code> is already doubling all the lemmas, so the change is really only at the \"setting up level\" and in the first couple of lemmas that refer explicitly with the axiom by its <code>class.field_name</code>.  So really, this is a very minor change to the current PR.</p>\n<p><code>to_right</code>: I agree that it does not belong to this PR and I would need to learn a lot of programming to figure out how to do it!</p>",
        "id": 236341170,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619531889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321459\">Damiano Testa</span> <a href=\"#narrow/stream/116395-maths/topic/ordered.20stuff/near/236337643\">said</a>:</p>\n<blockquote>\n<p>Indeed, this does not work:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">my_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">new</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">)</span>\n<span class=\"c1\">-- invalid object declaration, environment already has an object named 'new.to_my_class'</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>A version of that which does work is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">my_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">cond</span> <span class=\"o\">:</span> <span class=\"n\">true</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">new</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">preorder</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">my_class_le</span> <span class=\"o\">:</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">my_class_lt</span> <span class=\"o\">:</span> <span class=\"n\">my_class</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">&lt;</span><span class=\"o\">))</span>\n\n<span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"kd\">instance</span><span class=\"o\">,</span> <span class=\"n\">priority</span> <span class=\"mi\">100</span><span class=\"o\">]</span> <span class=\"n\">new.my_class_le</span> <span class=\"n\">new.my_class_lt</span>\n</code></pre></div>",
        "id": 236342519,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619532365
    },
    {
        "content": "<p>Eric, I like your suggestion!</p>\n<p>This is the fully expanded list of classes:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[ancestor has_add has_le]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_le_add_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_le, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">mul_le_mul_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_le]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_le_add_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_le, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">mul_le_mul_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_lt]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_lt_add_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_lt, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">mul_lt_mul_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_lt]</span>\n<span class=\"kd\">class</span> <span class=\"n\">add_lt_add_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_lt, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">mul_lt_mul_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_le]</span>\n<span class=\"kd\">class</span> <span class=\"n\">le_of_add_le_add_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_le, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">le_of_mul_le_mul_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_mul_le_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_le]</span>\n<span class=\"kd\">class</span> <span class=\"n\">le_of_add_le_add_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_add_le_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_le, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">le_of_mul_le_mul_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_mul_le_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_lt]</span>\n<span class=\"kd\">class</span> <span class=\"n\">lt_of_add_lt_add_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_lt, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">lt_of_mul_lt_mul_left_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_add has_lt]</span>\n<span class=\"kd\">class</span> <span class=\"n\">lt_of_add_lt_add_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[ancestor has_mul has_lt, to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">lt_of_mul_lt_mul_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236343912,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619532873
    },
    {
        "content": "<p>Personally, from the point of view of conciseness, I prefer to have only two new ones.  If, however, you think that having all of them is better, than I can change the PR.</p>",
        "id": 236344020,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619532905
    },
    {
        "content": "<p>I don't think extending <code>has_mul</code> and <code>has_le</code> or friends is a good idea: the point of mixins is precisely to let the user prescribe how he likes the algebraic structure (through a <code>ring</code>, a <code>comm_ring</code>, a <code>monoid</code> or a whatever instance), and the order structure (through a <code>partial_order</code>, a <code>linear_order</code>, a <code>conditionally_complete_lattice</code> or whatever instance) and then add your mixin to say how the two interact. If you bake the multiplication and the order into your classes like <code>lt_of_mul_lt_mul_right_class</code>, you can't do this and you're back to square 1, no?</p>",
        "id": 236344820,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619533173
    },
    {
        "content": "<p>Instead, taking them as typeclass assumptions as you did in your previous attemps looks like a perfect solution.</p>",
        "id": 236345096,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619533252
    },
    {
        "content": "<p>I might be misunderstanding something, but I need to have <code>*</code> and <code>&lt;</code> for the field to make sense, no?  How can I state </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>for a Type that does not already have a multiplication and an order?</p>",
        "id": 236345185,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533277
    },
    {
        "content": "<p>(I may be missing something very basic, since I have fallen into many traps while preparing the PR, so feel free to state the completely obvious, or assume that I have missed something trivial!)</p>",
        "id": 236345413,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533368
    },
    {
        "content": "<p>Just like you did in one of your previous messages:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">mul_le_mul_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">b</span>\n</code></pre></div>",
        "id": 236345638,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619533456
    },
    {
        "content": "<p>I think the confusion was which of <code>[ ... ]</code> or <code>extends</code> \"creates\" a new multiplication or just uses the existing one</p>",
        "id": 236345756,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619533489
    },
    {
        "content": "<p>Ah, the issue is <code>extends</code>!  I did not realize that this was different then putting square brackets.. sorry.</p>",
        "id": 236345768,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533492
    },
    {
        "content": "<p>And the answer is <code>[ ... ]</code> says, fetch me what already exists. <code>extends</code> means, create new things of what I'm extending, with this other thing on top additionally</p>",
        "id": 236345889,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619533527
    },
    {
        "content": "<p>Sébastien and Yakov, thank you for bringing my attention to this: I knew that things worked or did not work sometimes, but I had not realized what the source of the problem was!</p>",
        "id": 236345953,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533550
    },
    {
        "content": "<p>I had the opposite mental image: I thought <code>extend</code> referred to \"extend the properties of what you had by adding these axioms\", whereas the other, I would have thought \"create a new class\"!</p>",
        "id": 236346180,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533607
    },
    {
        "content": "<p>So, here is an updated version:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_add_le_add_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_mul_le_mul_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_add_le_add_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_le_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_mul_le_mul_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_le_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_add_lt_add_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_mul_lt_mul_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_add_lt_add_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_mul_lt_mul_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_le_of_add_le_add_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_add_le_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_le_of_mul_le_mul_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_mul_le_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_le_of_add_le_add_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_add_le_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_le_of_mul_le_mul_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_of_mul_le_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_lt_of_add_lt_add_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_lt_of_mul_lt_mul_left</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">has_lt_of_add_lt_add_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n\n<span class=\"kd\">@[to_additive]</span>\n<span class=\"kd\">class</span> <span class=\"n\">has_lt_of_mul_lt_mul_right</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_mul_lt_mul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">*</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236346531,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619533719
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/attributes.html#ancestor\">attr#ancestor</a> is for <code>extends</code>, so those attributes are wrong there and should just be removed.</p>",
        "id": 236346924,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619533842
    },
    {
        "content": "<p>In a lemma, saying <code>[group G]</code> postulates all the axioms of groups on the <code>G : Type</code>, and makes the available in the proving of the lemma. But in a definition (<code>class</code> is just a definition made available to the typeclass search), <code>[group G]</code> says, to use this definition, one must prove first that I have a group structure known on G. Of course, once seen in that way, then <code>lemma</code> is just like a definition: \"to use this lemma to prove things, you must first prove that the relevant type has a group structure.\"</p>",
        "id": 236347095,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1619533900
    },
    {
        "content": "<p>Eric, I updated the definitions, removing the <code>ancestors</code>.  Anything else?</p>",
        "id": 236348199,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534237
    },
    {
        "content": "<p>They look reasonable, but I do wonder if they have too much granularity; for instance, are there any situations where you'd want to use any of those on something which isn't a preorder?</p>",
        "id": 236348424,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619534323
    },
    {
        "content": "<p>A good test would be \"how many lemmas can I create from just this typeclass\"</p>",
        "id": 236348507,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619534354
    },
    {
        "content": "<p>I have not tried hard, but in the initial file, almost all lemmas used a combination of two of the typeclasses above and assumed <code>preorder</code>.</p>",
        "id": 236348751,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534429
    },
    {
        "content": "<p>I'd also be tempted to use the name <code>has_foo</code> instead of <code>foo_class</code>, but that might be worth a wider poll</p>",
        "id": 236349026,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619534528
    },
    {
        "content": "<p>I agree with you, though, I think that <code>preorder</code> is almost always assumed.  However, isn't the point of view that you should make definitions apply as generally as possible?  What if someone else later needs a version of this that is not necessarily transitive?</p>",
        "id": 236349110,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534557
    },
    {
        "content": "<p>I agree that putting just <code>has_le</code> or <code>has_lt</code> is enough here.</p>",
        "id": 236349403,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619534648
    },
    {
        "content": "<p>I agree also that <code>has_foo</code> is better than <code>foo_class</code>.</p>",
        "id": 236349464,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619534669
    },
    {
        "content": "<p>Btw, this was the reasoning that led me to replace them with arbitrary relations and create the <code>covariant</code> and <code>contravariant</code> typeclasses...</p>",
        "id": 236349511,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534689
    },
    {
        "content": "<p>Once you take this onboard, you only need two classes and apply them to the correct operation and relation.</p>",
        "id": 236349618,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534735
    },
    {
        "content": "<p>Anyway, I will change the names to <code>has_...</code></p>",
        "id": 236349672,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534756
    },
    {
        "content": "<p>There is a gotcha that with your definitions they are of type <code>Type</code>, while you want <code>Prop</code>, so you should specify it explicitly. As in</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">lt_of_add_lt_add_right_class</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_lt</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">lt_of_add_lt_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">},</span> <span class=\"n\">b</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span> <span class=\"bp\">+</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">&lt;</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 236349677,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1619534758
    },
    {
        "content": "<p>I guess we do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_comm_class\">docs#smul_comm_class</a> as prior art for the <code>_class</code> suffix</p>",
        "id": 236349839,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619534812
    },
    {
        "content": "<p>Perhaps that should be renamed to <code>has_smul_comm</code> at some point</p>",
        "id": 236349937,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619534850
    },
    {
        "content": "<p>Changed the names in the code above.</p>",
        "id": 236350073,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619534895
    },
    {
        "content": "<p>... and also <code>(α : Type*)</code> (rather than <code>(α : Type)</code>) as well as <code>: Prop</code>, although I do not understand the reason for this!</p>",
        "id": 236350596,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619535087
    },
    {
        "content": "<p>Anyway, while my \"minimalistic\" side would have preferred to introduce only 2 new typeclasses instead of 16, if it is the opinion of two moderators that 16 is better than 2, then I will go ahead and revise the PR!</p>",
        "id": 236351923,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619535537
    },
    {
        "content": "<p>(also, my initial driving concept was that I would have wanted to decrease the global number of classes, getting rid of the <code>ordered_[...]</code> ones, in favour of using the two new ones.  This also made me less open to adding even more typeclasses!)</p>",
        "id": 236352581,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619535664
    },
    {
        "content": "<p>What's the most of these typeclasses that any existing lemma needs , that you've found so far?</p>",
        "id": 236353985,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619535905
    },
    {
        "content": "<p>I think 3 of these new ones, plus an order and a binary operation</p>",
        "id": 236354602,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619536048
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"k\">#check</span> <span class=\"bp\">@</span><span class=\"n\">mul_lt_mul_of_le_of_lt</span>\n<span class=\"n\">mul_lt_mul_of_le_of_lt</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">d</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_1</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_2</span> <span class=\"o\">:</span> <span class=\"n\">cancel_monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_3</span> <span class=\"o\">:</span> <span class=\"n\">covariant_class</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">has_mul.mul</span> <span class=\"n\">has_le.le</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_4</span> <span class=\"o\">:</span> <span class=\"n\">contravariant_class</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"n\">has_mul.mul</span> <span class=\"n\">has_lt.lt</span><span class=\"o\">]</span>\n<span class=\"o\">[</span><span class=\"n\">_inst_5</span> <span class=\"o\">:</span> <span class=\"n\">covariant_class</span> <span class=\"n\">α</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">function.swap</span> <span class=\"n\">has_mul.mul</span><span class=\"o\">)</span> <span class=\"n\">has_le.le</span><span class=\"o\">],</span>\n\n<span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">d</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">c</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">*</span> <span class=\"n\">d</span>\n</code></pre></div>",
        "id": 236354725,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619536081
    },
    {
        "content": "<p>I have not played with rings, though, only monoids.  So it might be 6, when you want to mix orders on addition and multiplication in the same statement.</p>",
        "id": 236355201,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619536192
    },
    {
        "content": "<p>I have collected all these latest comments in the new PR <a href=\"https://github.com/leanprover-community/mathlib/issues/7369\">#7369</a>.  I went for a PR that only introduces the new typeclasses and will get to using them for the actual lemmas in a later PR.  Of course, comments are always more than welcome!</p>",
        "id": 236505937,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619616342
    },
    {
        "content": "<p>I assume you meant <a href=\"https://github.com/leanprover-community/mathlib/issues/7396\">#7396</a>?</p>",
        "id": 236508687,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1619617400
    },
    {
        "content": "<p>Yes, Eric, thank you for the correction!</p>",
        "id": 236511824,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1619618560
    }
]
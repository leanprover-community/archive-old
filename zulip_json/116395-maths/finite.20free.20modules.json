[
    {
        "content": "<p>For LTE we need some stuff about finite free abelian groups. Since the int_smul refactor, we can completely transparently treat those as finite free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\Z</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>-modules. Ergo: we want a theory of finite free modules. It seems best from a Lean perspective to split this into finitely generated modules (we already have those) and free modules.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>We can then have an instance saying that modules (i.e., vector spaces) over a field are always free.</p>\n<p>I also suggest replacing <code>[finite_dimensional K V]</code> everywhere by <code>[module.finite K V]</code></p>\n<p>I would also like to generalize <code>finrank</code> from fields to rings. It could assume <code>module.finite</code> and <code>module.free</code> as assumptions, but we might as well just definite it to be <code>0</code> on nonsense input.</p>",
        "id": 238587346,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620888058
    },
    {
        "content": "<p>Feedback on this proposal is very welcome</p>",
        "id": 238587356,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620888072
    },
    {
        "content": "<p>(cc: <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>)</p>",
        "id": 238588263,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620888979
    },
    {
        "content": "<p>One caveat about <code>finrank</code> -- people sometimes talk about the rank of a projective module. Over an integral domain (say), a projective module has a well-defined rank, equal to the dimension of the vector space you get by tensoring up to the field of fractions, and this rank is well-behaved (e.g. under short exact sequences of projective modules. direct sums etc). For example the fractional ideals of a Dedekind domain are just (up to isomorphism) the projective rank 1 modules.</p>",
        "id": 238590484,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1620890916
    },
    {
        "content": "<p>I wonder if we could call this one <code>projective_rank</code>?</p>",
        "id": 238591092,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1620891373
    },
    {
        "content": "<p>A typeclass of free modules sounds like a good idea!</p>\n<p>My main suggestion would be to have the index type and basis be directly accessible as (noncomputable?) definitions. In the bundled-basis refactor, I found that making the index type and basis a \"real\" definition, rather than an <code>exists</code> which you have to destructure, gets rid of some annoyances. So you can turn</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"bp\">\\&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">module.free_finite.exists_basis_fintype</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"n\">hι</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">whatever</span> <span class=\"n\">b</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">whatever</span> <span class=\"o\">(</span><span class=\"n\">module.free_finite.basis_fintype</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and have the <code>fintype</code> instance be automatically inferred.</p>",
        "id": 238606954,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1620903537
    },
    {
        "content": "<p>I guess we can even have <code>module.free.basis_type R M</code>, and infer a <code>fintype</code> instance for it in the presence of <code>module.finite R M</code>.</p>",
        "id": 238607185,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620903664
    },
    {
        "content": "<p>So we can decouple <code>free</code> and <code>finite</code></p>",
        "id": 238607211,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1620903679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> there was a small discussion here</p>",
        "id": 239092867,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621259697
    },
    {
        "content": "<p>So the idea is to have something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n<span class=\"kd\">def</span> <span class=\"n\">basis_type</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">:=</span> <span class=\"n\">classical.some</span> <span class=\"n\">hf.exists_basis</span>\n</code></pre></div>\n<p>Or something different?</p>",
        "id": 239096218,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621260861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130384\">@Riccardo Brasca</span> lgtm, and then <code>instance : fintype (free.basis_type R M)</code> under the assumption <code>[module.finite R M]</code></p>",
        "id": 239096908,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621261105
    },
    {
        "content": "<p>etc</p>",
        "id": 239096915,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621261107
    },
    {
        "content": "<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>",
        "id": 239099672,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262008
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/238606954\">said</a>:</p>\n<blockquote>\n<p>A typeclass of free modules sounds like a good idea!</p>\n<p>My main suggestion would be to have the index type and basis be directly accessible as (noncomputable?) definitions. In the bundled-basis refactor, I found that making the index type and basis a \"real\" definition, rather than an <code>exists</code> which you have to destructure, gets rid of some annoyances. So you can turn</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">begin</span>\n  <span class=\"n\">obtain</span> <span class=\"bp\">\\&lt;</span><span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">hι</span><span class=\"bp\">\\&gt;</span> <span class=\"o\">:=</span> <span class=\"n\">module.free_finite.exists_basis_fintype</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"n\">letI</span> <span class=\"o\">:</span> <span class=\"n\">fintype</span> <span class=\"n\">ι</span> <span class=\"o\">:=</span> <span class=\"n\">hι</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">whatever</span> <span class=\"n\">b</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>into</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">whatever</span> <span class=\"o\">(</span><span class=\"n\">module.free_finite.basis_fintype</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and have the <code>fintype</code> instance be automatically inferred.</p>\n</blockquote>\n<p>I was following Anne's suggestion, but maybe I misunderstood it.</p>",
        "id": 239100357,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621262223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239099672\">said</a>:</p>\n<blockquote>\n<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>\n</blockquote>\n<p>While I'm all in favour of punishing non-constructivists, think about the poor people who refactor something to do with bases and suffer the pain of having to fix up other people's usages of the axiom of choice :P</p>",
        "id": 239100449,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621262250
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span> <a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239100449\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239099672\">said</a>:</p>\n<blockquote>\n<p>Why even have <code>basis_type</code>? I feel like the user should be made painfully aware whenever they choose a basis</p>\n</blockquote>\n<p>While I'm all in favour of punishing non-constructivists, think about the poor people who refactor something to do with bases and suffer the pain of having to fix up other people's usages of the axiom of choice :P</p>\n</blockquote>\n<p>Fair enough <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 239100516,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262273
    },
    {
        "content": "<p>Although I wouldn't mind having <code>module.free</code> contain data (in the form of a <code>trunc (Σ ι, basis ι R M)</code> I guess?)</p>",
        "id": 239100860,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621262383
    },
    {
        "content": "<p>Yea, I was just about to suggest that!</p>",
        "id": 239101011,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262424
    },
    {
        "content": "<p>This makes it easier to obtain the type and basis at the same time</p>",
        "id": 239101057,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262440
    },
    {
        "content": "<p>Although why <code>trunc</code> over <code>nonempty</code>?</p>",
        "id": 239101257,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262511
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>looks reasonable to me</p>",
        "id": 239101331,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262525
    },
    {
        "content": "<p><code>trunc</code> is basically <code>nonempty</code> but you can still do limited computations with it (e.g. <code>#print axioms trunc.lift</code> contains no axioms)</p>",
        "id": 239101798,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621262666
    },
    {
        "content": "<p>Sure, I agree, but that's another universe variable one has to keep track of...</p>",
        "id": 239102419,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262865
    },
    {
        "content": "<p>I don't know, I guess one should also decide what the universe level of <code>I</code> should be!</p>",
        "id": 239102498,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621262887
    },
    {
        "content": "<p>bleurgh if <code>module.free</code> contains data then you're looking at diamonds later on. This is punishing non-constructivists, which I am not at all in favour of!</p>",
        "id": 239104263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621263508
    },
    {
        "content": "<p>Hmm, or maybe this is Ok if it's not a class?</p>",
        "id": 239104379,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621263558
    },
    {
        "content": "<p>It should be a class!</p>",
        "id": 239105488,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621263933
    },
    {
        "content": "<p>well then I am definitely against trunc. I vote for Prop. I was in the middle of writing a blog post about trunc and bases but then marking hit :-(</p>",
        "id": 239105613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621263969
    },
    {
        "content": "<p>What about universes? I guess this works?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u1</span> <span class=\"n\">u2</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"n\">u1</span> <span class=\"n\">u2</span><span class=\"o\">)),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 239105985,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621264093
    },
    {
        "content": "<p>I like  <code>nonempty (Σ (I : Type (max u1 u2)), basis I R M)</code> (and I don't understand <code>trunc</code>...)</p>",
        "id": 239108506,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621264831
    },
    {
        "content": "<p>The <code>I</code> should live in the same universe as <code>M</code>, I think</p>",
        "id": 239108796,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621264922
    },
    {
        "content": "<p>Because in principle a basis should be able to be a <code>subtype</code> of <code>M</code>.</p>",
        "id": 239108883,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621264942
    },
    {
        "content": "<p>Are you really against <code>def basis_type := (nonempty.some hf.exists_basis).1</code>? I get that choosing a base is evil, but here we are just naming it... mathematically this seems ok</p>",
        "id": 239108966,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621264970
    },
    {
        "content": "<p>I would be fine with that def'n</p>",
        "id": 239109079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621265009
    },
    {
        "content": "<p>I think either <code>max u1 u2</code> or just <code>u2</code> is fine. We need the existence of a basis as a subtype as part of the API anyway</p>",
        "id": 239109663,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621265216
    },
    {
        "content": "<p>I mean we should just have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u1</span> <span class=\"n\">u2</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u2</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">basis_to_subtype</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 239110078,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621265371
    },
    {
        "content": "<p>This is exactly <code>basis.reindex_range</code> <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 239111081,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621265711
    },
    {
        "content": "<p>I just asked library search and it didn't work, but good to know that we have it!</p>",
        "id": 239111659,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621265925
    },
    {
        "content": "<p>Probably because you need <code>nontrivial R</code></p>",
        "id": 239112357,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266180
    },
    {
        "content": "<p>So in this case i think using <code>u2</code> as the universe of <code>I</code> would be better, since it would be easier to construct an instance of <code>free</code> given a basis using this <code>reindex_range</code></p>",
        "id": 239112367,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266182
    },
    {
        "content": "<p>Ah</p>",
        "id": 239112454,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266208
    },
    {
        "content": "<p>Why is that needed for <code>reindex_range</code>?</p>",
        "id": 239112595,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266252
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.reindex_range\">docs#basis.reindex_range</a></p>",
        "id": 239112646,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266269
    },
    {
        "content": "<p>It comes from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.injective\">docs#basis.injective</a></p>",
        "id": 239112814,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266335
    },
    {
        "content": "<p>But that's also true over the trivial ring, isn't it?</p>",
        "id": 239112927,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266365
    },
    {
        "content": "<p>I am thinking about what is a basis over the trivial ring</p>",
        "id": 239112981,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266383
    },
    {
        "content": "<p>Oh I guess anything is a basis over the trivial ring</p>",
        "id": 239113115,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266431
    },
    {
        "content": "<p>Now I am thinking about what is a <em>module</em> over the trivial ring...</p>",
        "id": 239113427,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266526
    },
    {
        "content": "<p>The trivial module</p>",
        "id": 239113443,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266535
    },
    {
        "content": "<p>And I think there is only the ring itself</p>",
        "id": 239113450,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266537
    },
    {
        "content": "<p>Since 1 equals 0 in the ring</p>",
        "id": 239113470,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266545
    },
    {
        "content": "<p>Yeah but think about what linear independence says... If a linear combination is zero then the scalars in the linear combination are all zero, but that's always true <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 239113664,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266613
    },
    {
        "content": "<p>And clearly any collection spans the trivial module</p>",
        "id": 239113724,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266630
    },
    {
        "content": "<p>I guess if one adds the condition that the elements of a basis must be nonzero, then a basis over the trivial ring would have to be empty, and everything works</p>",
        "id": 239113842,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1621266676
    },
    {
        "content": "<p>Ahahah, linear independence is really different</p>",
        "id": 239113898,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621266700
    },
    {
        "content": "<p>OK, I am going to add this</p>",
        "id": 239115137,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621267127
    },
    {
        "content": "<p>The correct way of saying that <code>M</code> is trivial is <code>subsingleton M</code>?</p>",
        "id": 239115269,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621267177
    },
    {
        "content": "<p>Ah, there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.subsingleton\">docs#module.subsingleton</a> good to know</p>",
        "id": 239115606,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621267274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/finite.20free.20modules/near/239104263\">said</a>:</p>\n<blockquote>\n<p>bleurgh if <code>module.free</code> contains data then you're looking at diamonds later on. This is punishing non-constructivists, which I am not at all in favour of!</p>\n</blockquote>\n<p><code>trunc _</code> is a subsingleton so the diamond issue is only as bad as it is for <code>decidable_eq</code>. (I will not take a position as to whether <code>decidable_eq</code> unduly punishes non-constructivists <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span>)</p>",
        "id": 239116529,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621267579
    },
    {
        "content": "<p>The reason Jason XY and I spent hours and hours writing <code>finsum</code> was precisely because of <code>decidable_eq</code> diamonds with finsets.</p>",
        "id": 239121718,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621269623
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/7642\">#7642</a> to get rid of <code>nontrivial R</code>.</p>",
        "id": 239140617,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1621277298
    },
    {
        "content": "<p>I'm in favour of <code>basis_type</code>. If we want to make non-constructivists suffer just the right amount we could call it <code>choose_basis</code> or <code>some_basis</code>.</p>",
        "id": 239172281,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292299
    },
    {
        "content": "<p>How about exposing that it is a subset of the carrier set?</p>",
        "id": 239172332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292336
    },
    {
        "content": "<p>instead of just being an arbitrary type (in an arbitrary universe!)</p>",
        "id": 239172391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292377
    },
    {
        "content": "<p>IIRC that's how the vector basis theorem is stated anyway</p>",
        "id": 239172471,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292410
    },
    {
        "content": "<p>That is:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 239172581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292474
    },
    {
        "content": "<p>I wrote exactly that on a branch yesterday. :-)</p>",
        "id": 239172615,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292508
    },
    {
        "content": "<p>While we're on the topic of finite modules, why does <code>finite_dimensional</code> even exist? We should just be using <code>module.finite</code> throughout.</p>",
        "id": 239172728,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292548
    },
    {
        "content": "<p>what's the difference?</p>",
        "id": 239172745,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292569
    },
    {
        "content": "<p><code>module.finite</code> just says finitely generated. <code>finite_dimensional</code> is just a synonym for <code>is_noetherian</code> over a field.</p>",
        "id": 239172867,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292642
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/finite_dimensional.iff_fg/src\">src#finite_dimensional.iff_fg</a> says these are equivalent</p>",
        "id": 239172932,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292676
    },
    {
        "content": "<p>So I think it's just duplication at this point.</p>",
        "id": 239173114,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621292802
    },
    {
        "content": "<p>IIRC the point of being able to say that a vector space was finite dimensional is because that is what is being taught to first year mathematics undergraduates all over the world. I am a little unhappy that vector space disappeared and now this. Is there no way we can keep these things as abbreviations somehow? We're just making lean less accessible to mathematics undergraduates this way, although I wholly understand the reasons for it. I would just love there to be a way which we can switch on a way of saying finite dimensional vector space so we don't have to start telling them that they need to be proving theorems about ranks of Noetherian modules</p>",
        "id": 239205183,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621320005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> would it be ok for you if <code>vector_space</code> were notation for <code>module</code>?</p>",
        "id": 239205386,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621320140
    },
    {
        "content": "<p>Of course that means that every module over every semiring is suddenly a <code>vector_space</code>...</p>",
        "id": 239205409,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621320161
    },
    {
        "content": "<p>Maybe I am saying something silly, since I do not really know what <code>open_locale</code> does, but could the name <code>vector_space</code> be a synonym of <code>module</code> only if <code>open_locale vectors</code> is present?</p>",
        "id": 239206133,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1621320702
    },
    {
        "content": "<p>Certainly.</p>",
        "id": 239206427,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621320910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> <code>open_locale</code> is just a way to execute a little bit of prerecorded code, typically of the form <code>local notation blabla</code></p>",
        "id": 239206460,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621320941
    },
    {
        "content": "<p>Yes, I don't want everyone to be forced to eat vector spaces over rings!</p>",
        "id": 239206713,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1621321146
    },
    {
        "content": "<p>There is a bit of an implementation issue to get rid of <code>finite_dimensional</code> in favour of <code>module.free</code>.</p>",
        "id": 239221109,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621328834
    },
    {
        "content": "<p>The problem is just that both <code>is_noetherian</code> and <code>module.free</code> are typeclasses, and in the presence of <code>[field R]</code> (or even <code>[division_ring R]</code>) they are equivalent. So the situation is highly prone to cycles...</p>",
        "id": 239221236,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621328893
    },
    {
        "content": "<p>But both are useful independently.</p>",
        "id": 239221318,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621328933
    },
    {
        "content": "<p>(I assume it would be <code>module.free</code> and <code>module.finite</code> together being equivalent to <code>noetherian</code>, since <code>free</code> can also imply infinite-dimensional, no?)</p>",
        "id": 239221760,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621329174
    },
    {
        "content": "<p>It would be cool if we introduced <code>[[double_brackets]]</code> syntax for \"add this instance parameter and all the (missing) instance parameters it depends on\", e.g. so that <code>{R M : Type*} [[module R M]]</code> stands for <code>{R M : Type*} [semiring R] [add_comm_monoid M] [module R M]</code>.</p>\n<p>Then we could do the following: define <code>is_noetherian (R M : Type*) [[module R M]] [module.finite R M] := _</code> and use <code>[[is_noetherian R M]]</code> as parameters. The Noetherian -&gt; finite implication (which should always hold, unless I misinterpret the meaning of <code>module.finite</code>) is provided syntactically and we can safely add the finite -&gt; Noetherian implication as an instance assuming <code>field</code>/<code>division_ring</code>.</p>",
        "id": 239222755,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621329701
    },
    {
        "content": "<p>Why would that not create loops?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"bp\">-</span> <span class=\"n\">I</span> <span class=\"n\">need</span> <span class=\"bp\">`</span><span class=\"n\">module.finite</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"bp\">`</span>\n<span class=\"bp\">-</span> <span class=\"n\">Let's</span> <span class=\"n\">look</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">module.noetherian</span><span class=\"bp\">`</span>\n<span class=\"bp\">-</span> <span class=\"n\">Ooh</span><span class=\"o\">,</span> <span class=\"n\">we</span> <span class=\"n\">are</span> <span class=\"n\">over</span> <span class=\"n\">a</span> <span class=\"n\">field</span><span class=\"o\">,</span> <span class=\"n\">might</span> <span class=\"n\">as</span> <span class=\"n\">well</span> <span class=\"n\">look</span> <span class=\"n\">for</span> <span class=\"bp\">`</span><span class=\"n\">module.finite</span><span class=\"bp\">`</span>\n<span class=\"bp\">-</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 239223000,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621329839
    },
    {
        "content": "<p>I tried a while ago to hack up double brackets, but as I recall I had issues where adding more parameters made the elaborator angry because the De Bruijn numbering changed.</p>",
        "id": 239223060,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621329859
    },
    {
        "content": "<p>Ooh, angry elaborators are scary!</p>",
        "id": 239223188,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621329940
    },
    {
        "content": "<p>Here's a quick example:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span><span class=\"bp\">.</span> <span class=\"c1\">-- E.g. `ring`</span>\n<span class=\"kd\">class</span> <span class=\"n\">bar</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kd\">extends</span> <span class=\"n\">foo</span> <span class=\"n\">R.</span> <span class=\"c1\">-- E.g. `division_ring`</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">rel</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">R</span><span class=\"o\">]</span><span class=\"bp\">.</span> <span class=\"c1\">-- E.g. `module.finite`</span>\n<span class=\"kd\">class</span> <span class=\"n\">rel2</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">rel</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span><span class=\"bp\">.</span> <span class=\"c1\">-- E.g. `is_noetherian`</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">uses_rel2</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">foo</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">rel</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">rel2</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">rel_to_rel2</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">bar</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">rel</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">rel2</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">bar</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">rel</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">uses_rel2</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n</code></pre></div>",
        "id": 239223929,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621330314
    },
    {
        "content": "<p>Instance trace:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[class_instances]  class-instance resolution trace\n[class_instances] (0) ?x_0 : @rel2 R M (@bar.to_foo R _inst_1) _inst_2 := @rel_to_rel2 ?x_1 ?x_2 ?x_3 ?x_4\n[class_instances] cached instance for bar R\n_inst_1\n[class_instances] caching instance for @rel2 R M (@bar.to_foo R _inst_1) _inst_2\n@rel_to_rel2 R M _inst_1 _inst_2\n</code></pre></div>",
        "id": 239224020,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621330342
    },
    {
        "content": "<p>This also works when there are no instance parameters to the declaration itself:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">bar</span> <span class=\"n\">ℕ</span> <span class=\"o\">:=</span> <span class=\"o\">{}</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">rel</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span> <span class=\"o\">:=</span> <span class=\"o\">⟨⟩</span>\n\n<span class=\"kd\">set_option</span> <span class=\"n\">trace.class_instances</span> <span class=\"n\">true</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">:=</span> <span class=\"n\">uses_rel2</span> <span class=\"n\">ℕ</span> <span class=\"n\">ℤ</span>\n</code></pre></div>",
        "id": 239224452,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1621330526
    },
    {
        "content": "<p>ooh, I see, <code>noetherian</code> assumes <code>finite</code>. So there is no instance going from <code>noeth</code> to <code>finite</code>.</p>",
        "id": 239224695,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621330632
    },
    {
        "content": "<p>But with all those mixins, I agree that the need for <code>[[]]</code> becomes higher and higher</p>",
        "id": 239224744,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1621330658
    },
    {
        "content": "<p>My preference would <em>not</em> be to replace <code>finite_dimensional</code> with <code>is_noetherian</code>, but rather to replace <code>finite_dimensional</code> with <code>module.finite</code>. Hopefully this is much more manageable for undergraduates. (Further, I agree it would be good to add <code>abbreviations</code> back in for <code>vector_space := module</code> and <code>finite_dimensional := module.finite</code> if this can be done cleanly.)</p>\n<p>This would require a good mechanism to promote <code>module.finite</code> to <code>is_noetherian</code> whenever we're working over a field (even a division ring), and this is what I'm unhappy about at the moment. We can't have a global instance, as it causes typeclass search loops. Perhaps a local instance is okay, or just manually invoking it, if it turns out it isn't needed too many times.</p>",
        "id": 239517266,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1621471254
    },
    {
        "content": "<p>After a small break to work on LTE I am coming back to free modules (not necessarily finite). What do you think of the following?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 240295308,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622019515
    },
    {
        "content": "<p>There was some discussion about <code>trunc</code>, but even if I understand it better now (thank's Kevin!) I still don't if it is worth to use it</p>",
        "id": 240295352,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622019555
    },
    {
        "content": "<p><code>nonempty</code> is fine for now, it would be nice to use <code>trunc</code> instead but that probably causes enough issues for you that it's not worth it.</p>",
        "id": 240295782,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622019813
    },
    {
        "content": "<p><code>trunc</code> just has diamond risks which <code>nonempty</code> hasn't got</p>",
        "id": 240296854,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622020441
    },
    {
        "content": "<p>As a mathematician if someone said to me \"you know it's free, now do you need the axiom of choice to get a basis\" I would reply \"of course\". But that's only my mental model of what freeness means</p>",
        "id": 240296958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622020499
    },
    {
        "content": "<p>And we want a lemma saying that this is equivalent to having a base in the same universe as the module, right?</p>",
        "id": 240297350,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622020739
    },
    {
        "content": "<p>Hmm, actually now that I look at it again, I'm worried that the <code>Type*</code> will cause extra universe parameters to pop up. One moment while I do some testing...</p>",
        "id": 240297508,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622020845
    },
    {
        "content": "<p>Yes, <code>I : Type*</code> gives unexpected errors:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">module.free</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">choose_basis_index</span> <span class=\"o\">[</span><span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span> <span class=\"o\">:=</span> <span class=\"n\">module.free.exists_basis.some.1</span>\n<span class=\"c1\">-- Error: Don't know how to synthesize placeholder : Type ?</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">choose_basis</span> <span class=\"o\">[</span><span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">module.free.exists_basis.some.2</span>\n<span class=\"c1\">-- Error: Type mismatch, has type _ : Type (max ?l_1 ?l_2 ?l_3) expected _ : Type (max ?l_1 u_1 u_2)</span>\n</code></pre></div>",
        "id": 240297930,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622021160
    },
    {
        "content": "<p>Fixed:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">module.free</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">choose_basis_index</span> <span class=\"o\">[</span><span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">module.free.exists_basis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.1</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">choose_basis</span> <span class=\"o\">[</span><span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">module.free.exists_basis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.2</span>\n</code></pre></div>",
        "id": 240298083,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622021251
    },
    {
        "content": "<p>My idea was to prove first of all that the two defs are equivalent, using <code>basis.reindex_range</code></p>",
        "id": 240298317,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622021402
    },
    {
        "content": "<p>But if we will never use the general one we can just go with the latter</p>",
        "id": 240298371,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622021419
    },
    {
        "content": "<p>Sure, that sounds like a good idea. The issue with the <code>Type*</code> formulation is that Lean can't figure out which universe <code>I</code> is supposed to belong to.</p>",
        "id": 240298438,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622021487
    },
    {
        "content": "<p>So you get infinitely many copies of <code>module.free R M</code>, one for each universe level. (And, while I don't think you can construct an explicit counterexample in mathlib's, in certain models of type theory there might not be a basis for <code>M : Type 2</code> and <code>I : Type 1</code>, while there is one for <code>M : Type 2</code> and <code>I : Type 2</code>. In other words, you might not be able to prove the equivalence of <code>module.free.{1 2 2}</code> and <code>module.free.{2 2 2}</code>.)</p>",
        "id": 240298901,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622021756
    },
    {
        "content": "<p>I can't even work out how to write the explicit universe version, despite it not being what we want anyway.</p>",
        "id": 240298968,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622021783
    },
    {
        "content": "<p>Ah, got it:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">class</span> <span class=\"o\">{</span><span class=\"n\">w</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"n\">module.free</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">module.free</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">choose_basis_index</span> <span class=\"o\">[</span><span class=\"n\">module.free.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">module.free.exists_basis</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">some.1</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">choose_basis</span> <span class=\"o\">[</span><span class=\"n\">module.free.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"n\">module.free.exists_basis.some.2</span>\n</code></pre></div>",
        "id": 240299158,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622021899
    },
    {
        "content": "<p>The elaborator needed a hand</p>",
        "id": 240299164,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622021904
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">uI</span> <span class=\"n\">uR</span> <span class=\"n\">uM</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uR</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uM</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uI</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">module.free</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">choose_basis_index</span> <span class=\"o\">[</span><span class=\"n\">module.free.</span><span class=\"o\">{</span><span class=\"n\">uI</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">uI</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">module.free.exists_basis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.1</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">choose_basis</span> <span class=\"o\">[</span><span class=\"n\">module.free.</span><span class=\"o\">{</span><span class=\"n\">uI</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">basis.</span><span class=\"o\">{</span><span class=\"n\">uI</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index.</span><span class=\"o\">{</span><span class=\"n\">uI</span><span class=\"o\">}</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">module.free.exists_basis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.2</span>\n</code></pre></div>",
        "id": 240299197,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622021942
    },
    {
        "content": "<p>Indeed I am not able to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">module.free_def</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p><code>v</code> here is the universe of <code>M</code></p>",
        "id": 240299219,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622021953
    },
    {
        "content": "<p>The first implication is easy, but not the other</p>",
        "id": 240299245,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622021978
    },
    {
        "content": "<p>Exactly, if <code>I</code>'s universe in on the left hand side is lower than <code>v</code>, there are models where that implication does not hold.</p>",
        "id": 240299478,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622022117
    },
    {
        "content": "<p>Hm, I don't really  understand all the problems here, but it seems to me that requiring the base to be in the same universe as the module is the easiest thing to do</p>",
        "id": 240301147,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622023139
    },
    {
        "content": "<p>Yes, I would make the universes of <code>I</code> the same as that of <code>M</code>.</p>",
        "id": 240301398,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622023286
    },
    {
        "content": "<p>What Johan said. Riccardo, here is a way of thinking about universes. We have the <code>Prop</code> universe, where every type has 0 or 1 terms! Now there is not a \"finite\" universe of finite types, but you could pretend that there was, because <code>fintype</code> satisfies most of the axioms which universes have to satisfy. And then there is <code>Type</code> which is a proper mathematical universe, big enough to have things in like the real numbers and more generally the sort of things we need to do mathematics (and for those people who don't use category theory in their work, this universe is big enough for everything they do). Now clearly if you have a free module in Type you don't want to start looking for a basis in Fintype because it might not be finitely generated. Similarly there might well be free modules in Type 2 which don't have a basis in Type -- mathematically you might say that any \"module\" which is not actually a set (e.g. the real \"vector space\" with a basis equal to all ordinals or whatever your favourite class which is not a set is) can't have a basis which is a set.</p>\n<p>It's almost never right to put extra universe variables in definitions, i.e. a new universe variable which appears in the term of a definition but not the type of the definition. </p>\n<p>The one thing to be careful of with <code>set</code> is that it is not quite the right notion for the zero ring. I don't know how much of an issue this is. The zero module has got a basis of size 37, namely the ordered 37-tuple (0,0,0,...,0). This basis cannot be expressed with the <code>set</code> trick. However, because you are only defining a <code>Prop</code> this should not be an issue, and the zero ring has to be treated separately in much of the theory of bases anyway.</p>",
        "id": 240305411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622025839
    },
    {
        "content": "<p>One thing that I noticed when looking at the <code>module.finite</code> stuff is that if you do want free universes, you usually don't care about having them in an <code>iff</code>. That is, you usually want something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">from_some_universe</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span>\n<span class=\"n\">to_set</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>What's convenient when going in one direction is very different to what's convenient going in the other direction</p>",
        "id": 240309000,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622028187
    },
    {
        "content": "<p>This seems reasonable to me</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.basis</span>\n\n<span class=\"kd\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">module.free</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"o\">[]</span> <span class=\"o\">:</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">module.free_def</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">basis.reindex_range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">nonempty_sigma.2</span> <span class=\"n\">h</span><span class=\"o\">⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">module.free_iff_set</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">S</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">basis.reindex_range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">⟩⟩,</span>\n    <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">hS</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">nonempty_sigma.2</span> <span class=\"o\">⟨</span><span class=\"n\">S</span><span class=\"o\">,</span> <span class=\"n\">hS</span><span class=\"o\">⟩⟩⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">of_basis</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">module.free_def</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">b.reindex_range</span><span class=\"o\">⟩⟩</span>\n</code></pre></div>",
        "id": 240310768,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622029278
    },
    {
        "content": "<p>So in practice to prove that something is free it is enough to have a basis (regardless of the universe), and if something is free we have the index type in the same universe of the module, or the index set if we prefer</p>",
        "id": 240310911,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622029368
    },
    {
        "content": "<p>This might also be a nice way to write it, using doc#small to promise that the <code>w</code> used is one that <code>M</code> fits into, even if its not the same universe as <code>v</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic.small</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">module.free_def</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">),</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">basis.reindex_range</span> <span class=\"n\">h.exists_basis.some.2</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reindex</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">_</span><span class=\"o\">)⟩⟩,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">nonempty_sigma.2</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b.reindex_range</span><span class=\"o\">⟩⟩⟩</span>\n</code></pre></div>",
        "id": 240312196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622030222
    },
    {
        "content": "<p>Nice!</p>",
        "id": 240312672,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622030490
    },
    {
        "content": "<p>But even with that definition, your <code>of_basis</code> is still needed, I think</p>",
        "id": 240312954,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622030635
    },
    {
        "content": "<p>It's at least a nice piece of glue code for the common case where there is an explicit basis.</p>",
        "id": 240313324,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622030778
    },
    {
        "content": "<p>Sure, that is more general. If you have a basis, indexed by a type in any universe, then the module is free</p>",
        "id": 240313345,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622030789
    },
    {
        "content": "<p>But the converse is indeed false</p>",
        "id": 240313369,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622030798
    },
    {
        "content": "<p>is the the case that the existence of a basis indexed by <code>I : type w</code>implies <code>M : type v</code> is <code>w</code>-small?</p>",
        "id": 240313693,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622030973
    },
    {
        "content": "<p>That is, can this sorry be filled?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">module.free_def</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∃</span> <span class=\"o\">[</span><span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"n\">M</span><span class=\"o\">],</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">),</span> <span class=\"n\">nonempty</span> <span class=\"o\">(</span><span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span> <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kd\">by</span> <span class=\"n\">casesI</span> <span class=\"n\">h</span> <span class=\"k\">with</span> <span class=\"n\">_</span> <span class=\"n\">h</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"k\">let</span> <span class=\"n\">b</span> <span class=\"o\">:=</span> <span class=\"n\">h.exists_basis.some.2</span> <span class=\"k\">in</span> <span class=\"o\">⟨</span><span class=\"n\">shrink</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">b</span><span class=\"o\">),</span>\n    <span class=\"o\">⟨(</span><span class=\"n\">basis.reindex_range</span> <span class=\"n\">b</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reindex</span> <span class=\"o\">(</span><span class=\"n\">equiv_shrink</span> <span class=\"n\">_</span><span class=\"o\">)⟩⟩),</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"o\">⟨</span><span class=\"gr\">sorry</span><span class=\"o\">,</span> <span class=\"o\">⟨(</span><span class=\"n\">nonempty_sigma.2</span> <span class=\"n\">h</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"o\">⟨</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">b</span><span class=\"o\">⟩,</span> <span class=\"o\">⟨</span><span class=\"n\">set.range</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">b.reindex_range</span><span class=\"o\">⟩⟩⟩⟩</span>\n</code></pre></div>",
        "id": 240313775,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622031007
    },
    {
        "content": "<p>We have that <code>M</code> is in bijection with <code>I →₀ R</code>, which is in universe <code>max w u</code></p>",
        "id": 240314097,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622031178
    },
    {
        "content": "<p>So it should be possible to show <code>M</code> is <code>max w u</code>-small</p>",
        "id": 240314142,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622031206
    },
    {
        "content": "<p>(I don't know the API around <a href=\"https://leanprover-community.github.io/mathlib_docs/find/small\">docs#small</a> well though.)</p>",
        "id": 240314159,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622031223
    },
    {
        "content": "<p>No, me neither, nor is it probably worth spending too much time worrying about it</p>",
        "id": 240314185,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622031241
    },
    {
        "content": "<p>Untested, but should work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">small_of_basis</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">w</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">I</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">small.</span><span class=\"o\">{</span><span class=\"n\">max</span> <span class=\"n\">w</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"n\">small.mk'</span> <span class=\"n\">b.repr.to_equiv</span>\n</code></pre></div>",
        "id": 240314463,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622031365
    },
    {
        "content": "<p>Then the question becomes \"can I replace <code>[small.{w} M]</code> with <code>[small.{max w u} M]</code> in the above lemma, or does that make the other direction false?\". It certainly makes my proof not work any more</p>",
        "id": 240314566,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622031438
    },
    {
        "content": "<p>Hmm, can't think of any easy counterexamples (e.g. if <code>u</code> is big and <code>w</code> is small, then <code>M := I →₀ R</code> shows <code>I</code> can live in a smaller universe than <code>M</code>, but the converse is still OK), though I wouldn't be surprised if <code>max w u</code> is too big for the implication to hold.</p>",
        "id": 240314989,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622031669
    },
    {
        "content": "<p>If <code>R</code> is the zero ring (in any universe) then it doesn't matter which universe <code>I</code> lives in, <code>I →₀ R</code> can be descended to <code>Type</code> (and even to <code>Prop</code>).</p>",
        "id": 240316150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622032223
    },
    {
        "content": "<p>Another way of putting it : if <code>R : Prop</code> then <code>I →₀ R : Prop</code>, which makes me wonder whether <code>imax</code> is relevant.</p>",
        "id": 240320427,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622034213
    },
    {
        "content": "<p>I've opened the WIP PR <a href=\"https://github.com/leanprover-community/mathlib/issues/7722\">#7722</a>. If you have some comments and/or request for any features don't hesitate to write there!</p>",
        "id": 240331251,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622038612
    },
    {
        "content": "<p>The linter complains about</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">choose_basis_index</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">exists_basis</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">some.1</span>\n</code></pre></div>\n<p>saying </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\"> The `has_inhabited_instance` linter reports: -/</span>\n<span class=\"c\">/-</span><span class=\"cm\"> TYPES ARE MISSING INHABITED INSTANCES: -/</span>\n<span class=\"k\">#print</span> <span class=\"n\">module.free.choose_basis_index</span> <span class=\"c\">/-</span><span class=\"cm\"> inhabited instance missing -/</span>\n</code></pre></div>\n<p>Is it telling me something I I should care about or can I just disable it? The basis index can be empty (for the trivial module).</p>",
        "id": 240379537,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622058026
    },
    {
        "content": "<p>Did you prove that e.g. a subsingleton module has an empty basis, or that R has a basis of size 1? You can just use such an example to satisfy the linter</p>",
        "id": 240384322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622059952
    },
    {
        "content": "<p>In case you want to disable it: put <code>@[nolint has_inhabited_instance]</code> above it.</p>",
        "id": 240384719,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1622060157
    },
    {
        "content": "<p>I mean,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>is false in general.  I can prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"n\">foo</span> <span class=\"o\">[</span><span class=\"n\">nontrivial</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">inhabited</span> <span class=\"o\">(</span><span class=\"n\">choose_basis_index</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>that make the linter happy, so my question is whether I should provide this instance or disable the linter.</p>",
        "id": 240392156,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622063414
    },
    {
        "content": "<p>Right, but <code>instance foo : inhabited (choose_basis_index int int)</code> is true and this will also make the linter happy.</p>",
        "id": 240392566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622063643
    },
    {
        "content": "<p>I have never understood the point of this linter</p>",
        "id": 240392755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622063700
    },
    {
        "content": "<p>I am also confused. I thought it was telling me \"this type can be empty, are you sure do you want to work with it?\". So I am surprised that telling him that sometimes it's not empty makes it happy</p>",
        "id": 240392983,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622063772
    },
    {
        "content": "<p>I think it just needs a proof that it's not globally empty, for some reason. Quite what happens when you define the empty type I don't know.</p>",
        "id": 240393024,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622063803
    },
    {
        "content": "<p>Ah, you mean empty as Pi type or whatever</p>",
        "id": 240393116,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622063868
    },
    {
        "content": "<p>right</p>",
        "id": 240393126,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1622063882
    },
    {
        "content": "<p>I think the goal is mainly to prevent you declaring a structure whose proof fields result in a contradiction. It doesn't protect against your fields only being compatible in a degenerate case</p>",
        "id": 240393403,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622064027
    },
    {
        "content": "<p>My understanding is that the intention of the linter is to nudge contributors to provide some basic instances of new types whenever possible. If adding an inhabited instance with an extra typeclass assumption is possible and potentially useful / instructive for future mathlib users, great! However, I don't think it's a big deal if you choose to disable it with the <code>nolint</code> attribute.</p>",
        "id": 240393440,
        "sender_full_name": "Bryan Gin-ge Chen",
        "timestamp": 1622064053
    },
    {
        "content": "<p>I understand it for classes, I provided <code>module.free</code> and of course I want to have some instance of it (I already have). It is complaining about the type that indexes the basis of a free module. I think I will just disable it, I feel a little uncomfortable in calling \"default\" a random element in a random module over a random ring</p>",
        "id": 240394306,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622064553
    },
    {
        "content": "<p>Adding the instance <code>[module.free]</code> for polynomial rings I noticed that we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.basis_monomials\">docs#mv_polynomial.basis_monomials</a> but there is no version for <code>polynomial R</code>, so I wanted to provide it. Because of the structure of the import, it seems to me a little complicated to do it directly, so I thought to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/mv_polynomial.punit_alg_equiv\">docs#mv_polynomial.punit_alg_equiv</a> (polynomials are mv_polynomial indexed by <code>punit</code>). So far so good, so I tried to prove this</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.mv_polynomial.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">polynomial.basis_monomials</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">ℕ</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"n\">basis.map</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial.punit_alg_equiv</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_linear_equiv</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">basis.reindex</span> <span class=\"n\">_</span> <span class=\"o\">((</span><span class=\"n\">equiv.punit_arrow_equiv</span> <span class=\"n\">ℕ</span><span class=\"o\">)),</span>\n<span class=\"c1\">--  refine basis.reindex _ finsupp.equiv_fun_on_fintype,</span>\n<span class=\"c1\">--  exact mv_polynomial.basis_monomials punit R,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>But I get the error</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"bp\">?</span><span class=\"n\">m_1.reindex</span> <span class=\"o\">(</span><span class=\"n\">equiv.punit_arrow_equiv</span> <span class=\"n\">ℕ</span><span class=\"o\">)</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">equiv.punit_arrow_equiv</span> <span class=\"n\">ℕ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"n\">equiv.</span><span class=\"o\">{(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">l_1</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">punit.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">l_1</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Sort</span> <span class=\"o\">(</span><span class=\"n\">max</span> <span class=\"bp\">?</span><span class=\"n\">l_1</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">equiv.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">l_1</span><span class=\"bp\">+</span><span class=\"mi\">1</span> <span class=\"mi\">1</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">punit.</span><span class=\"o\">{</span><span class=\"bp\">?</span><span class=\"n\">l_2</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">nat</span><span class=\"o\">)</span> <span class=\"n\">nat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"bp\">?</span><span class=\"n\">l_1</span>\n</code></pre></div>\n<p>I think that the problem is that  <code>equiv.punit_arrow_equiv ℕ : Sort (max ? 1)</code>, but <code>basis.reindex</code> wants a <code>Type</code>. Is there a simple way to avoid this ? Thank's!</p>",
        "id": 240444071,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622110339
    },
    {
        "content": "<p>I believe the issue is that Lean can't figure out that <code>max ? 1</code> is always at least <code>1</code> until the <code>?</code> becomes a \"real\" universe variable. It works if you do the definition in opposite order:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.mv_polynomial.basic</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">polynomial.basis_monomials</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">ℕ</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">refine</span> <span class=\"o\">((</span><span class=\"n\">mv_polynomial.basis_monomials</span> <span class=\"n\">punit</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reindex</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">finsupp.equiv_fun_on_fintype.trans</span> <span class=\"o\">((</span><span class=\"n\">equiv.punit_arrow_equiv</span> <span class=\"n\">ℕ</span><span class=\"o\">))},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">mv_polynomial.punit_alg_equiv</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_linear_equiv</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 240445389,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622111148
    },
    {
        "content": "<p>Although I would avoid using a tactic block for data:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">noncomputable</span> <span class=\"kd\">def</span> <span class=\"n\">polynomial.basis_monomials</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">ℕ</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">((</span><span class=\"n\">mv_polynomial.basis_monomials</span> <span class=\"n\">punit</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">reindex</span>\n  <span class=\"o\">(</span><span class=\"n\">finsupp.equiv_fun_on_fintype.trans</span> <span class=\"o\">(</span><span class=\"n\">equiv.punit_arrow_equiv</span> <span class=\"n\">ℕ</span><span class=\"o\">)))</span><span class=\"bp\">.</span><span class=\"n\">map</span>\n  <span class=\"o\">(</span><span class=\"n\">mv_polynomial.punit_alg_equiv</span> <span class=\"n\">R</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">to_linear_equiv</span>\n</code></pre></div>",
        "id": 240445544,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622111223
    },
    {
        "content": "<p>A more general solution is to turn the <code>Type*</code> parameters in <code>linear_algebra.basis</code> into <code>Sort*</code>. I expect that nothing, or very little, will break if we do so.</p>",
        "id": 240445754,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622111358
    },
    {
        "content": "<p>Your proof works, thank's! I am seeing what happens using <code>Sort*</code></p>",
        "id": 240445909,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622111420
    },
    {
        "content": "<p>Do we have something like the direct sum of free modules is free? I mean, using basis...</p>",
        "id": 240606537,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622209858
    },
    {
        "content": "<p>On the direct sum of copies of <code>M</code> you can go via <code>finsupp</code>: <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp_lequiv_direct_sum\">docs#finsupp_lequiv_direct_sum</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.basis\">docs#finsupp.basis</a></p>",
        "id": 240607118,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622210106
    },
    {
        "content": "<p>I can't find anything for the direct sum of different modules or <code>dfinsupp</code>, though it shouldn't be hard to define it directly using <code>basis.of_repr</code>.</p>",
        "id": 240607367,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622210231
    },
    {
        "content": "<p>Thank's !</p>",
        "id": 240608155,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622210583
    },
    {
        "content": "<p>Something like this in <code>linear_algebra/dfinsupp.lean</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">basis</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">basis</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">basis.of_repr</span> <span class=\"o\">((</span><span class=\"n\">map_range.linear_equiv</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">trans</span>\n  <span class=\"gr\">sorry</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 240608966,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622210951
    },
    {
        "content": "<p>Where the <code>sorry</code> is <code>(Π₀ (i : ι), η i →₀ R) ≃ₗ[R] (Σ (i : ι), η i) →₀ R</code> (which doesn't seem to exist yet, but should be true...)</p>",
        "id": 240609034,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622210984
    },
    {
        "content": "<p>I will take care of this later today or tomorrow (watching Kevin's talk right now)</p>",
        "id": 240609323,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622211102
    },
    {
        "content": "<p>What's that equivalence called for the non-finsupp version? Is it <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.Pi_curry\">docs#equiv.Pi_curry</a>?</p>",
        "id": 240611240,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622211943
    },
    {
        "content": "<p>Sorry for the late reply, I've been a little bit sick in the last few days.</p>\n<p>I am trying to prove <code>(Π₀ (i : ι), η i →₀ R) ≃ₗ[R] (Σ (i : ι), η i) →₀ R</code>, but I am having troubles even in stating it. Indeed, Lean seems unable to find the instance <code>module R (Π₀ (i : ι), η i →₀ R)</code>. I think that the problem is that in general, to have an instance <code>module R (Π₀ (i : ι), β i)</code> we want an instance <code>[Π (i : ι), module R (β i)]</code>. In this case <code>β i = η i →₀ R</code> and of course Lean is able to find <code>[module R (η i →₀ R)]</code> for a fixed <code>i : ι</code>, but I guess is not able to produce <code>[Π  (i : ι), module R (η i →₀ R)]</code>.</p>\n<p>Any help is appreciated :)</p>",
        "id": 240925716,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622545753
    },
    {
        "content": "<p>First of all, I hope you feel better soon!</p>",
        "id": 240926943,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622546546
    },
    {
        "content": "<p>Thank's, it's nothing serious!</p>",
        "id": 240927157,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622546693
    },
    {
        "content": "<p>I think I had the same problem with finding <code>Π i, module R (M i)</code> instances before, let me see if I can find it somewhere...</p>",
        "id": 240927195,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622546719
    },
    {
        "content": "<p>I've usually had to restate <code>dfinsupp.module</code> locally with my precise assumptions</p>",
        "id": 240927343,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622546809
    },
    {
        "content": "<p>Typically it's something like you have <code>add_comm_group (M i)</code> but the definition mathlib has wants only <code>add_comm_monoid  (M i)</code>, and typeclass search gets confused by all the binders</p>",
        "id": 240927395,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1622546844
    },
    {
        "content": "<p>Found the thread: <a href=\"#narrow/stream/113488-general/topic/Inference.20faiing.2C.20but.20not.20inside.20a.20.CE.BB\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Inference.20faiing.2C.20but.20not.20inside.20a.20.CE.BB</a></p>",
        "id": 240927437,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622546871
    },
    {
        "content": "<p>The issue is that the elaborator doesn't figure out that <code>finsupp.has_zero _</code> can be unified with <code>finsupp.add_zero_class.to_has_zero _</code>.. Here's a hack that seems to work:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.finsupp</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mul_zero_class.to_has_zero</span> <span class=\"n\">finsupp.has_zero</span> <span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">finsupp.add_monoid</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Σ</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n  <span class=\"n\">_</span>\n</code></pre></div>",
        "id": 240928594,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622547664
    },
    {
        "content": "<p>(I went through the <code>pp.all</code> output of the failing instance and the definition of <code>dfinsupp.add_comm_monoid</code> and disabled all instances that appeared in the failing instances but not in the definition.)</p>",
        "id": 240928726,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1622547744
    },
    {
        "content": "<p>Ah thank you! I was trying to understand what was going on, but it seems a little more advanced for me</p>",
        "id": 240929021,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622547923
    },
    {
        "content": "<p>So I am trying to prove</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra.dfinsupp</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">η</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n\n<span class=\"kd\">noncomputable theory</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"kd\">instance</span><span class=\"o\">]</span> <span class=\"n\">mul_zero_class.to_has_zero</span> <span class=\"n\">finsupp.has_zero</span>\n  <span class=\"n\">finsupp.add_zero_class</span> <span class=\"n\">finsupp.add_monoid</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">sigma_finsupp_lequiv_dfinsupp</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">Σ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">η</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"bp\">≃ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"bp\">Π₀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">η</span> <span class=\"n\">i</span> <span class=\"bp\">→₀</span> <span class=\"n\">N</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">dfinsupp.mk</span> <span class=\"o\">(</span><span class=\"n\">finsupp.split_support</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">finsupp.split</span> <span class=\"n\">f</span> <span class=\"n\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">map_add'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">map_smul'</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>\n<p>But <code>map_add'</code> seems quite painful: I can do it (I think) by several <code>by_cases</code>, looking at <code>f.split_support</code>, <code>g.split_support</code> and <code>(f + g).split_support</code>. Do someone see a better way of doing this?</p>",
        "id": 241138243,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622635149
    },
    {
        "content": "<p>Hmm, I will open a new topic with this problem, it is not directly related to free modules.</p>",
        "id": 241143111,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1622638063
    },
    {
        "content": "<p>Is the following</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">finprod</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">add_comm_monoid</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n<span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">),</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">:</span> <span class=\"n\">module.free</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>the correct way of saying that a finite product of free modules is free? Or should I use some <code>finset</code> directly?</p>",
        "id": 242738227,
        "sender_full_name": "Riccardo Brasca",
        "timestamp": 1623766298
    },
    {
        "content": "<p>That matches the phrasing in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi.basis\">docs#pi.basis</a>, so sounds good to me.</p>",
        "id": 242738667,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1623766459
    },
    {
        "content": "<p>Yes , and you could even make it an <code>instance</code>. I would call it <code>free.pi</code> (the <code>fintype</code> assumption is implicit in the name)</p>",
        "id": 242738669,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1623766459
    },
    {
        "content": "<p><code>pi.module.free</code> might be better</p>",
        "id": 242753602,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623771824
    },
    {
        "content": "<p>To match <code>pi.module</code></p>",
        "id": 242753641,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623771842
    },
    {
        "content": "<p>Lean doesn't generate good names for typeclasses containing a dot as far as I know</p>",
        "id": 242753717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1623771861
    }
]
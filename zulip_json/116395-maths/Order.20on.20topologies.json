[
    {
        "content": "<p>I already asked this question in the middle of another thread and got no answer, let me try again:</p>\n<p>Is the order relation on topological_space and uniform_space open for debate? Currently we have incompatibility with the order on filters, as seen in <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148</a> and <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472</a>, generating things like <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542</a> and generating a push-forward which is right-adjoint to pull-back<br>\n As far as I can see, real world never write <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_1 \\leq t_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.63597em;\"></span><span class=\"strut bottom\" style=\"height:0.7859700000000001em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">≤</span><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> for topologies <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_1</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.61508em;\"></span><span class=\"strut bottom\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">t_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.61508em;\"></span><span class=\"strut bottom\" style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span> but write sentences randomly using either the \"finer than\" or \"coarser than\" relation.</p>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span></p>",
        "id": 167570928,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559909726
    },
    {
        "content": "<p>I would agree to switch the order. I don't have strong opinion either way, but coherence over the different concepts is a valuable goal.</p>",
        "id": 167571503,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1559910187
    },
    {
        "content": "<p>That's because the order on filters is silly, not the order on topologies.</p>",
        "id": 167571553,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1559910243
    },
    {
        "content": "<p>If you believe the reasonable-looking statement<br>\n(*) The identity map <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>(</mo><mi>X</mi><mo separator=\"true\">,</mo><msub><mi>T</mi><mn>1</mn></msub><mo>)</mo><mo>→</mo><mo>(</mo><mi>X</mi><mo separator=\"true\">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">(X, T_1) \\to (X, T_2)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.75em;\"></span><span class=\"strut bottom\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"base\"><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mrel\">→</span><span class=\"mopen\">(</span><span class=\"mord mathit\" style=\"margin-right:0.07847em;\">X</span><span class=\"mpunct\">,</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> is continuous iff <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">T_1 \\le T_2</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"base\"><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span><span class=\"mrel\">≤</span><span class=\"mord\"><span class=\"mord mathit\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathrm mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"></span></span></span></span></span></span></span></span><br>\nthen you should use Patrick's order, with the discrete topology at the bottom and the indiscrete topology at the top.</p>",
        "id": 167573035,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559911537
    },
    {
        "content": "<p>However in algebraic geometry there is an \"op\" inserted between the morphisms of schemes and the morphisms of their structure sheaves, so perhaps one should not believe (*), I'm not sure.</p>",
        "id": 167573114,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559911572
    },
    {
        "content": "<p>I wouldn't be against reversing the order of topologies, though it looks like a fair amount of work</p>",
        "id": 167573815,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559912169
    },
    {
        "content": "<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358\">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>",
        "id": 167574022,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559912353
    },
    {
        "content": "<p>What about</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">to_topological_space_mono</span> <span class=\"o\">{</span><span class=\"n\">u₁</span> <span class=\"n\">u₂</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">u₁</span> <span class=\"bp\">≤</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">_</span> <span class=\"n\">u₁</span> <span class=\"bp\">≤</span> <span class=\"bp\">@</span><span class=\"n\">uniform_space</span><span class=\"bp\">.</span><span class=\"n\">to_topological_space</span> <span class=\"bp\">_</span> <span class=\"n\">u₂</span> <span class=\"o\">:=</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">uniform_continuous_iff</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">uα</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">uβ</span> <span class=\"o\">:</span> <span class=\"n\">uniform_space</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">uniform_continuous</span> <span class=\"n\">f</span> <span class=\"bp\">↔</span> <span class=\"n\">uβ</span><span class=\"bp\">.</span><span class=\"n\">comap</span> <span class=\"n\">f</span> <span class=\"bp\">≤</span> <span class=\"n\">uα</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 167574220,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559912503
    },
    {
        "content": "<p>The first lemma means you can't change the order on topologies without changing the order on uniform structures.</p>",
        "id": 167574389,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559912602
    },
    {
        "content": "<p>Or wait, were you going to reverse the order on <code>uniform_space</code> too?</p>",
        "id": 167574395,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559912607
    },
    {
        "content": "<p>Okay, I missed that <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 167574408,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559912617
    },
    {
        "content": "<p>Yes, see the first message</p>",
        "id": 167574413,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559912622
    },
    {
        "content": "<p>The second lemma means the order on uniform spaces currently doesn't play nicely with the order on filters</p>",
        "id": 167574521,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559912651
    },
    {
        "content": "<blockquote>\n<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358\">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>\n</blockquote>\n<p>I guess this is only one argument. I like push-forward to be the left adjoint because this is what happens for functions acting on subsets. But of course sheaves are the other way around.</p>",
        "id": 167575692,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559913642
    },
    {
        "content": "<p>This is sort of like saying \"wouldn't it be great if all -1's were +1's?\". It's not so clear that there's a perfect answer here. I guess I mean that it is clear that there is not a perfect answer here.</p>",
        "id": 167576054,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559913923
    },
    {
        "content": "<p>We don't want a perfect answer here. We want something consistent across filters, topology and uniform structures</p>",
        "id": 167576133,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559913969
    },
    {
        "content": "<p>Currently it is not consistent in mathlib</p>",
        "id": 167576146,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559913986
    },
    {
        "content": "<p>And if we add the constraint that <code>principal</code> is monotone then we get that the correct order is the one we currently have on filters (unless we want to reverse the orderings on subsets...)</p>",
        "id": 167576199,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559914042
    },
    {
        "content": "<p>Is it <em>possible</em> for everything to be consistent? Or are you just focussed on some small subset of inconsistent things, and if you change to make it consistent that then some other small subset will be inconsistent?</p>",
        "id": 167576204,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1559914048
    },
    {
        "content": "<p>What would be a bigger set here?</p>",
        "id": 167576231,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559914076
    },
    {
        "content": "<p><code>filter.sets</code> isn't monotone.</p>",
        "id": 167576336,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1559914141
    },
    {
        "content": "<p>Who cares? The goal of the theory is to hide this function as much as possible</p>",
        "id": 167577532,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559915158
    },
    {
        "content": "<p>We can't make everything consistent, but it doesn't mean that every possible convention is equally good</p>",
        "id": 167582788,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559918593
    },
    {
        "content": "<p>What should we do then?</p>",
        "id": 167584317,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1559919654
    },
    {
        "content": "<p>I'm happy with the change you suggested--as long as I don't have to be the one to implement it</p>",
        "id": 167584618,
        "sender_full_name": "Reid Barton",
        "timestamp": 1559919868
    },
    {
        "content": "<p>I just discovered a flaw in this plan: <a href=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111\">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111</a></p>",
        "id": 167787562,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560194134
    },
    {
        "content": "<p>I'm afraid the Galois insertion involving the topology generated by a collection of subset is the motivation behind the weird order on topologies</p>",
        "id": 167787639,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560194179
    },
    {
        "content": "<p>I suppose you could use <code>order_dual</code> and <code>copy</code>, if you really want...</p>",
        "id": 167788092,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560194528
    },
    {
        "content": "<p>Maybe we should do antitone Galois connections as well</p>",
        "id": 167788118,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560194556
    },
    {
        "content": "<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>",
        "id": 167788147,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560194585
    },
    {
        "content": "<blockquote>\n<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>\n</blockquote>\n<p>it's OK, we can just define the order on subgroups to be <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi><mo>≤</mo><mi>K</mi><mspace width=\"0.277778em\"></mspace><mo>⟺</mo><mspace width=\"0.277778em\"></mspace><mi>K</mi><mo>⊆</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H\\leq K\\iff K\\subseteq H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"strut\" style=\"height:0.68333em;\"></span><span class=\"strut bottom\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"base\"><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span><span class=\"mrel\">≤</span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span><span class=\"mrel\"><span class=\"mspace thickspace\"></span><span class=\"mrel\">⟺</span></span><span class=\"mord mathit\"><span class=\"mspace thickspace\"></span><span class=\"mord mathit\" style=\"margin-right:0.07153em;\">K</span></span><span class=\"mrel\">⊆</span><span class=\"mord mathit\" style=\"margin-right:0.08125em;\">H</span></span></span></span></p>",
        "id": 167788612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560194910
    },
    {
        "content": "<p>Probably that's what the order is in mathlib anyway :P</p>",
        "id": 167788647,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560194945
    },
    {
        "content": "<p>But don't do it on the subfields as well ;-)</p>",
        "id": 167789433,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560195542
    },
    {
        "content": "<p>I tried using <code>order_dual</code> to change the partial order on topologies but still have a Galois insertion, so that I can list the complete lattice instance from <code>set (set a)</code>.  But then of course the <code>has_top</code> instance is still the wrong one. Is this the issue the <code>copy</code> is meant to solve? I don't understand at all this copy thing in <code>order.fiilter.basic</code>. The beginning of the story looks like:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">set</span> <span class=\"n\">filter</span> <span class=\"n\">lattice</span> <span class=\"n\">classical</span>\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">prop_decidable</span>\n\n<span class=\"n\">universes</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"n\">w</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">topological_space</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The least topology containing a collection of basic sets. -/</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">generate_open</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">basic</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span><span class=\"err\">∈</span><span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">generate_open</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">univ</span>   <span class=\"o\">:</span> <span class=\"n\">generate_open</span> <span class=\"n\">univ</span>\n<span class=\"bp\">|</span> <span class=\"n\">inter</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">s</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">generate_open</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">generate_open</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">generate_open</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">∩</span> <span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"n\">sUnion</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">∀</span><span class=\"n\">s</span><span class=\"err\">∈</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">generate_open</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">generate_open</span> <span class=\"o\">(</span><span class=\"err\">⋃₀</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- The smallest topological space containing the collection `g` of basic sets -/</span>\n<span class=\"n\">def</span> <span class=\"n\">generate_from</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_open</span>        <span class=\"o\">:=</span> <span class=\"n\">generate_open</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_univ</span>   <span class=\"o\">:=</span> <span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_inter</span>  <span class=\"o\">:=</span> <span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">inter</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">sUnion</span>  <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">topological_space</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">lattice</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">partial_order</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">le</span>          <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">t</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"bp\">≤</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">t</span> <span class=\"n\">s</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">topological_space_eq</span> <span class=\"err\">$</span> <span class=\"n\">le_antisymm</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">le_refl</span>     <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">le_refl</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span>    <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span><span class=\"o\">,</span> <span class=\"n\">le_trans</span> <span class=\"n\">h₂</span> <span class=\"n\">h₁</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">le_generate_from_iff_subset_is_open</span> <span class=\"o\">{</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span> <span class=\"o\">{</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">t</span> <span class=\"bp\">≤</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"n\">g</span> <span class=\"bp\">↔</span> <span class=\"n\">g</span> <span class=\"err\">⊆</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">intro</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">ht</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">ht</span> <span class=\"bp\">_</span> <span class=\"err\">$</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">hg</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">hs</span><span class=\"bp\">.</span><span class=\"n\">rec_on</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">v</span> <span class=\"n\">hv</span><span class=\"o\">,</span> <span class=\"n\">hg</span> <span class=\"n\">hv</span><span class=\"o\">)</span>\n    <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open_univ</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">u</span> <span class=\"n\">v</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open_inter</span> <span class=\"n\">u</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"k\">assume</span> <span class=\"n\">k</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open_sUnion</span> <span class=\"n\">k</span><span class=\"o\">))</span>\n\n<span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">mk_of_closure</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">))</span>\n  <span class=\"o\">(</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">is_open</span>        <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">u</span><span class=\"o\">,</span> <span class=\"n\">u</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_univ</span>   <span class=\"o\">:=</span> <span class=\"n\">hs</span> <span class=\"bp\">▸</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">univ</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_inter</span>  <span class=\"o\">:=</span> <span class=\"n\">hs</span> <span class=\"bp\">▸</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">inter</span><span class=\"o\">,</span>\n  <span class=\"n\">is_open_sUnion</span> <span class=\"o\">:=</span> <span class=\"n\">hs</span> <span class=\"bp\">▸</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">sUnion</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">mk_of_closure_sets</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)}</span>\n  <span class=\"o\">{</span><span class=\"n\">hs</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">u</span> <span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">=</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">mk_of_closure</span> <span class=\"n\">s</span> <span class=\"n\">hs</span> <span class=\"bp\">=</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"n\">s</span> <span class=\"o\">:=</span>\n<span class=\"n\">topological_space_eq</span> <span class=\"n\">hs</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n\n<span class=\"n\">def</span> <span class=\"n\">gi_generate_from</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">@</span><span class=\"n\">galois_insertion</span> <span class=\"bp\">_</span> <span class=\"o\">(</span><span class=\"n\">order_dual</span> <span class=\"err\">$</span> <span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span>\n    <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_from</span> <span class=\"o\">(</span><span class=\"bp\">λ</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">|</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">is_open</span> <span class=\"n\">s</span><span class=\"o\">}):=</span>\n<span class=\"o\">{</span> <span class=\"n\">gc</span>        <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">t</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"n\">le_generate_from_iff_subset_is_open</span><span class=\"o\">,</span>\n  <span class=\"n\">le_l_u</span>    <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">t</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">topological_space</span><span class=\"bp\">.</span><span class=\"n\">generate_open</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">choice</span>    <span class=\"o\">:=</span> <span class=\"bp\">λ</span><span class=\"n\">g</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">mk_of_closure</span> <span class=\"n\">g</span>\n    <span class=\"o\">(</span><span class=\"n\">subset</span><span class=\"bp\">.</span><span class=\"n\">antisymm</span> <span class=\"n\">hg</span> <span class=\"err\">$</span>  <span class=\"n\">le_generate_from_iff_subset_is_open</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"err\">$</span> <span class=\"n\">le_refl</span> <span class=\"bp\">_</span><span class=\"o\">),</span>\n  <span class=\"n\">choice_eq</span> <span class=\"o\">:=</span> <span class=\"k\">assume</span> <span class=\"n\">s</span> <span class=\"n\">hs</span><span class=\"o\">,</span> <span class=\"n\">mk_of_closure_sets</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">complete_lattice</span> <span class=\"o\">(</span><span class=\"n\">topological_space</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">gi_generate_from</span> <span class=\"n\">α</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">lift_complete_lattice</span>\n</pre></div>\n\n\n<p>This is accepted by Lean, but then I still have the discrete topology at top. I'm sorry this conversation is very sparse, but I'm at a conference, with very little Lean time.</p>",
        "id": 168055681,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560439683
    },
    {
        "content": "<p>Maybe the definition of the lattice structure on <code>opens X</code> helps? It uses Galois insertions, dual, and copy.</p>",
        "id": 168055999,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560439875
    },
    {
        "content": "<p>Did you write that?</p>",
        "id": 168056422,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560440108
    },
    {
        "content": "<p>Do you understand what's going on?</p>",
        "id": 168056428,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560440115
    },
    {
        "content": "<p>I don't understand why it seems to involve additional proofs in <code>copy</code> on top of the Galois insertion. How can there be any mathematical content?</p>",
        "id": 168056546,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560440201
    },
    {
        "content": "<p>I only want to reverse the order</p>",
        "id": 168056555,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560440214
    },
    {
        "content": "<p>I think the galois insertion should be between <code>(topological_space α)</code> and <code>(order_dual $ set α)</code>, not <code>(order_dual $ topological_space α)</code> and <code>(set α)</code></p>",
        "id": 168057911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1560441096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I wrote it with help of Johannes. I think <code>copy</code> allows you to redefine the data parts of the structure, for better defeqs. But then you get proof obligations that the data is provably equal to what you get out of the duality. (That's what my memory tells me.) Maybe <span class=\"user-mention\" data-user-id=\"110294\">@Johannes Hölzl</span> can enlighten us.</p>",
        "id": 168067490,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1560447696
    },
    {
        "content": "<blockquote>\n<p>I think the galois insertion should be between <code>(topological_space α)</code> and <code>(order_dual $ set α)</code>, not <code>(order_dual $ topological_space α)</code> and <code>(set α)</code></p>\n</blockquote>\n<p>Isn't this ruining the <code>le_l_u</code> axiom of Galois insertions?</p>",
        "id": 168078138,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454507
    },
    {
        "content": "<p>This is really weird, it looks like, starting from a Galois insertion, if you switch order on both sides you don't get a Galois insertion in the other direction</p>",
        "id": 168078313,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454643
    },
    {
        "content": "<p>I must have messed up something</p>",
        "id": 168078321,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454650
    },
    {
        "content": "<blockquote>\n<p>This is really weird, it looks like, starting from a Galois insertion, if you switch order on both sides you don't get a Galois insertion in the other direction</p>\n</blockquote>\n<p>I haven't been following today's discussion but this is indeed not the case</p>",
        "id": 168078582,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560454811
    },
    {
        "content": "<p>You get a Galois coinsertion (if that's a real word) instead</p>",
        "id": 168078610,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560454836
    },
    {
        "content": "<p>Yes, it looks like a coinsertion</p>",
        "id": 168078659,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454872
    },
    {
        "content": "<p>You get <code>u l = id</code> instead of <code>l u = id</code></p>",
        "id": 168078689,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454907
    },
    {
        "content": "<p>But it should be enough to lift complete lattice instances</p>",
        "id": 168078749,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454937
    },
    {
        "content": "<p>Yes</p>",
        "id": 168078755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560454945
    },
    {
        "content": "<p>This is all so silly. I simply want to reverse my partial order which is already known to be a complete lattice.</p>",
        "id": 168078772,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560454971
    },
    {
        "content": "<p>You could use the fact that the dual is a Galois nnection.</p>",
        "id": 168078786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1560454983
    },
    {
        "content": "<p>Maybe I should keep the current Galois insertion as a local instance and then use <code>order_dual.complete_lattice</code> or something</p>",
        "id": 168078812,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560455018
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>import topology.basic\n\nopen set filter lattice\nuniverses u v w\n\nnamespace topological_space\nvariables {α : Type u}\n\n/-- The least topology containing a collection of basic sets. -/\ninductive generate_open (g : set (set α)) : set α → Prop\n| basic  : ∀s∈g, generate_open s\n| univ   : generate_open univ\n| inter  : ∀s t, generate_open s → generate_open t → generate_open (s ∩ t)\n| sUnion : ∀k, (∀s∈k, generate_open s) → generate_open (⋃₀ k)\n\n/-- The smallest topological space containing the collection `g` of basic sets -/\ndef generate_from (g : set (set α)) : topological_space α :=\n{ is_open        := generate_open g,\n  is_open_univ   := generate_open.univ g,\n  is_open_inter  := generate_open.inter,\n  is_open_sUnion := generate_open.sUnion  }\n\nsection lattice\n\ndef old_order : partial_order (topological_space α) :=\n{ le          := λt s, t.is_open ≤ s.is_open,\n  le_antisymm := assume t s h₁ h₂, topological_space_eq $ le_antisymm h₁ h₂,\n  le_refl     := assume t, le_refl t.is_open,\n  le_trans    := assume a b c h₁ h₂, @le_trans _ _ a.is_open b.is_open c.is_open h₁ h₂ }\n\nlocal attribute [instance] old_order\n\nlemma generate_from_le_iff_subset_is_open {g : set (set α)} {t : topological_space α} :\n  topological_space.generate_from g ≤ t ↔ g ⊆ {s | t.is_open s} :=\niff.intro\n  (assume ht s hs, ht _ $ topological_space.generate_open.basic s hs)\n  (assume hg s hs, hs.rec_on (assume v hv, hg hv)\n    t.is_open_univ (assume u v _ _, t.is_open_inter u v) (assume k _, t.is_open_sUnion k))\n\nprotected def mk_of_closure (s : set (set α))\n  (hs : {u | (topological_space.generate_from s).is_open u} = s) : topological_space α :=\n{ is_open        := λu, u ∈ s,\n  is_open_univ   := hs ▸ topological_space.generate_open.univ _,\n  is_open_inter  := hs ▸ topological_space.generate_open.inter,\n  is_open_sUnion := hs ▸ topological_space.generate_open.sUnion }\n\nlemma mk_of_closure_sets {s : set (set α)}\n  {hs : {u | (topological_space.generate_from s).is_open u} = s} :\n  topological_space.mk_of_closure s hs = topological_space.generate_from s :=\ntopological_space_eq hs.symm\n\ndef gi_generate_from (α : Type*) :\n  galois_insertion topological_space.generate_from (λt:topological_space α, {s | t.is_open s}) :=\n{ gc        := assume g t, generate_from_le_iff_subset_is_open,\n  le_l_u    := assume ts s hs, topological_space.generate_open.basic s hs,\n  choice    := λg hg, topological_space.mk_of_closure g\n    (subset.antisymm hg $ generate_from_le_iff_subset_is_open.1 $ le_refl _),\n  choice_eq := assume s hs, mk_of_closure_sets }\n\nlemma generate_from_mono {α} {g₁ g₂ : set (set α)} (h : g₁ ⊆ g₂) :\n  topological_space.generate_from g₁ ≤ topological_space.generate_from g₂ :=\n(gi_generate_from _).gc.monotone_l h\n\ndef old_complete_lattice {α : Type u} : complete_lattice (topological_space α) :=\n(gi_generate_from α).lift_complete_lattice\nend lattice\n\n\ninstance : partial_order (topological_space α) :=\n{ le          := λ t s, s.is_open ≤ t.is_open,\n  le_antisymm := assume t s h₁ h₂, topological_space_eq $ le_antisymm h₂ h₁,\n  le_refl     := assume t, le_refl t.is_open,\n  le_trans    := assume a b c h₁ h₂, le_trans h₂ h₁ }\n\ninstance : complete_lattice (topological_space α) :=\n@order_dual.lattice.complete_lattice _ old_complete_lattice\nend topological_space\n\n\nclass discrete_topology (α : Type*) [t : topological_space α] : Prop :=\n(eq_top : t = ⊥)\n\n@[simp] lemma is_open_discrete {α : Type*} [topological_space α] [discrete_topology α] (s : set α) :\n  is_open s :=\n(discrete_topology.eq_top α).symm ▸ trivial\n</pre></div>",
        "id": 168079905,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560455798
    },
    {
        "content": "<p>Patrick did you crash zulip</p>",
        "id": 168080086,
        "sender_full_name": "Reid Barton",
        "timestamp": 1560456071
    },
    {
        "content": "<blockquote>\n<p>Patrick did you crash zulip</p>\n</blockquote>\n<p>Indeed Zulip crashed while I was editing my message. And then talks resumed, and discussions, and dinner and wasn't able to return to here before bed. Anyway, I wanted to say that the code above seems to work.</p>",
        "id": 168134728,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560518911
    },
    {
        "content": "<p>Done in <a href=\"https://github.com/leanprover-community/mathlib/pull/1138\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/1138\">https://github.com/leanprover-community/mathlib/pull/1138</a></p>",
        "id": 168380292,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1560846913
    }
]
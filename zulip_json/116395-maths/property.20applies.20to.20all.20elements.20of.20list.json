[
    {
        "content": "<p>Is there another, convenient way one might specify this given what exists in mathlib?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">allp</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n<span class=\"bp\">|</span> <span class=\"n\">nil</span> <span class=\"o\">{}</span> <span class=\"o\">:</span> <span class=\"n\">allp</span> <span class=\"o\">[]</span>\n<span class=\"bp\">|</span> <span class=\"n\">cons</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">→</span> <span class=\"n\">allp</span> <span class=\"n\">l</span> <span class=\"bp\">→</span> <span class=\"n\">allp</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Or, alternatively:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">allp</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">foldr</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"n\">true</span>\n</pre></div>",
        "id": 125884050,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525075801
    },
    {
        "content": "<p>The standard way to write <code>allp</code> is <code>\\forall x \\in l, p x</code></p>",
        "id": 125884097,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525075861
    },
    {
        "content": "<p>I see. That uses the recursive of <code>list.mem</code> to accomplish the recursion of <code>allp</code>.</p>\n<p>Are there existing equivalent theorems to these?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">allp_singleton</span> <span class=\"o\">(</span><span class=\"n\">pa</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">]</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">allp_append</span> <span class=\"o\">:</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"n\">l₁</span> <span class=\"bp\">→</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"n\">l₂</span> <span class=\"bp\">→</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">l₁</span> <span class=\"bp\">++</span> <span class=\"n\">l₂</span><span class=\"o\">)</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">allp_nil</span> <span class=\"o\">:</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"o\">[]</span> <span class=\"bp\">↔</span> <span class=\"n\">true</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">allp_cons</span> <span class=\"o\">:</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">allp</span> <span class=\"n\">p</span> <span class=\"n\">l</span>\n</pre></div>",
        "id": 125884291,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525076333
    },
    {
        "content": "<p>In the core library?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">ball_nil</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"bp\">@</span><span class=\"n\">nil</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">ball_cons</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">::</span> <span class=\"n\">l</span><span class=\"o\">),</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"err\">∈</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 125884299,
        "sender_full_name": "Sean Leather",
        "timestamp": 1525076398
    },
    {
        "content": "<p>There are <code>forall_mem_nil</code> and <code>forall_mem_cons</code>, but the append theorem is not there. You can probably get the singleton theorem by simp</p>",
        "id": 125884401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525076565
    }
]
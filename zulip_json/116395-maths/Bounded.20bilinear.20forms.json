[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms/near/261908431\">said</a>:</p>\n<blockquote>\n<p>I've looked at the linear algebra part of it and I feel like even that is in need of a quite significant cleanup: I think it is possible to unify <code>bilinear_map</code>, <code>bilin_form</code> and <code>sesq_form</code> into a single <code>semibilin_map</code> which has the former three as special cases. The definition could be essentially what is the definition of <code>bilin_form</code> but way more general (yesterday I generalized it to a bilinear map, but not with the ring homomorphism yet). the way that <code>bilin_form</code> is written makes it easy to extend it to a bounded bilinear form, I don't see how to do the same thing with the current definition of the bilinear map.</p>\n</blockquote>\n<p>Is there any reason to use these over things like <code>E →ₗ[R] F →ₗ[R] G</code>?</p>",
        "id": 261924572,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637241058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz</span> I agree, that whole part of the library needs a clean-up.  I think we all know this, and have been put off because it's a big task!  Here are some of the design considerations that have occured to me ... what do you think?  (Tagging <span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> also):</p>\n<ol>\n<li>\n<p>(you mentioned this one) do we try to unite <code>R</code>-bilinear maps <code>M → N → P</code> with <code>R</code>-bilinear forms <code>M → M → R</code>?</p>\n</li>\n<li>\n<p>do we try to make the theory parallel with <code>R</code>-multilinear maps <code>Π(i : ι), M₁ i → M₂</code>?  (note: it is common in mathlib to have parallel developments of the 2-input and arbitrary-input version of something, like <code>pi</code> vs <code>prod</code>, <code>sup</code> vs <code>Sup</code>, etc; sometimes there is an effor to make these two developments exactly parallel, sometimes it's looser).</p>\n</li>\n<li>\n<p>how do we deal with semilinearity, and in particular with the interaction between semilinearity and noncommutativity?  Note that currently <code>sesq_form</code> is effectively for a <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_ring\">docs#star_ring</a> <code>R</code>, requiring the map be <code>R</code>-linear in one argument and <code>I : R ≃+* Rᵒᵖ</code>-semilinear in the other argument, so a full generalization would need to deal with multiple possible scalar rings (<code>R</code>, <code>Rᵒᵖ</code>at least, but why not more?). Or we could just give up on the attempt to deal with noncommutativity here.</p>\n</li>\n<li>\n<p>(maybe to be deferred to a future refactor) how does this interact with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space\">docs#inner_product_space</a>?  I think eventually it would be nice to have something like the integration library, where you can work with a particular measure if you specify it, or with some silent default measure if not -- so here there might in some cases be a silent default bilinear form, and sometimes an explicitly-specified one.</p>\n</li>\n</ol>",
        "id": 261947072,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251180
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"113489\" href=\"/#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms\">#new members &gt; Bounded bilinear forms</a> by <span class=\"user-mention silent\" data-user-id=\"238446\">Anne Baanen</span></p>",
        "id": 261947665,
        "sender_full_name": "Notification Bot",
        "timestamp": 1637251358
    },
    {
        "content": "<p>I was also thinking about this because just yesterday I opened a PR (<a href=\"https://github.com/leanprover-community/mathlib/issues/10373\">#10373</a>) to allow semilinear versions of maps of type <code>E →ₗ[R] F →ₗ[R] G</code>, i.e. <code>E →ₛₗ[σ] F →ₛₗ[ρ] G</code>, with <code>[module R₁ E]</code>, <code>[module R₂ F]</code> and <code>[module R₃ G]</code>, and <code>σ : R₁ →+* R₃</code>, <code>ρ : R₂ →+* R₃</code>. As far as I can tell, this should cover pretty much all cases of interest, so I was wondering if we should just use that systematically and deprecate <code>bilin_form</code> and <code>sesq_form</code>.</p>",
        "id": 261948208,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637251551
    },
    {
        "content": "<p>Interesting ... yes, it does seem to cover all cases of interest.  It makes the parallel with multilinear maps <code>Π(i : ι), M₁ i → M₂</code> less direct, though.  (Note that eventually we want semimultilinear maps, too, or at least I do!  How do we do those?)</p>",
        "id": 261948653,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261948653\">said</a>:</p>\n<blockquote>\n<p>Interesting ... yes, it does seem to cover all cases of interest.  It makes the parallel with multilinear maps <code>Π(i : ι), M₁ i → M₂</code> less direct, though.  (Note that eventually we want semimultilinear maps, too, or at least I do!  How do we do those?)</p>\n</blockquote>\n<p>We could semilinearize multilinear maps by replacing <code>R</code> with an indexed family of ring homs that all go to the same output ring.</p>",
        "id": 261948888,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637251788
    },
    {
        "content": "<p>But that doesn't work if (say) the output ring is sometimes <code>R</code>, sometimes <code>Rᵒᵖ</code></p>",
        "id": 261948996,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251822
    },
    {
        "content": "<p>(For me, it would be a commutative ring, where this doesn't matter.)</p>",
        "id": 261949064,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251849
    },
    {
        "content": "<p>Maybe we need an indexed family of ring homs, all of whose output rings have actions on <code>M₂</code></p>",
        "id": 261949150,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251895
    },
    {
        "content": "<p>with some compatibility condition like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/smul_comm_class\">docs#smul_comm_class</a> on these actions</p>",
        "id": 261949221,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637251920
    },
    {
        "content": "<p>What do you mean \"sometimes\"? The output space has to be a module over some ring -- which one is it?</p>",
        "id": 261949355,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637251959
    },
    {
        "content": "<p>Ah I see. Yes that could work.</p>",
        "id": 261949404,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637251984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261949355\">said</a>:</p>\n<blockquote>\n<p>What do you mean \"sometimes\"? The output space has to be a module over some ring -- which one is it?</p>\n</blockquote>\n<p>Look at the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sesq_form\">docs#sesq_form</a>, which is a map <code>M → M → R</code>, where the <code>R</code> is considered as being both an <code>R</code>-module and an <code>Rᵒᵖ</code>-module, so that a sesquilinear form is <code>R</code>-linear in the first argument and <code>(I : R ≃+* Rᵒᵖ)</code>-sesquilinear in the second argument.</p>",
        "id": 261949674,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637252085
    },
    {
        "content": "<p>Ah I see. Yeah we would need some sort of compatibility condition on the actions on the output space.</p>",
        "id": 261950725,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637252520
    },
    {
        "content": "<p>Maybe even just having two unrelated module instances would suffice.</p>",
        "id": 261951094,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637252644
    },
    {
        "content": "<p>Yes ... with the assumption of compatibility added in where actually required.</p>",
        "id": 261951411,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637252765
    },
    {
        "content": "<p>Here's something that seems as general as I can make it, and which would admit an exact parallel for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multilinear_map\">docs#multilinear_map</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₁</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₂</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bilinear_map</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">bilin</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_smul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">σ₁</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_smul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">σ₂</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n</code></pre></div>",
        "id": 261951506,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637252808
    },
    {
        "content": "<p>(with <code>[smul_comm_class S₁ S₂ N]</code> added presumably for certain theorems)</p>",
        "id": 261951535,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637252824
    },
    {
        "content": "<p>Do we actually need a structure for this? I was hoping to be able to get away with just <code>E →ₛₗ[σ] F →ₛₗ[ρ] G</code>, and I guess now with <code>σ : R₁ →+* R₃</code> and <code>ρ : R₂ →+* S₃</code>, where <code>R₃</code> and <code>S₃</code> both have actions on <code>G</code>.</p>",
        "id": 261952552,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637253245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261924572\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/113489-new-members/topic/Bounded.20bilinear.20forms/near/261908431\">said</a>:</p>\n<blockquote>\n<p>I've looked at the linear algebra part of it and I feel like even that is in need of a quite significant cleanup: I think it is possible to unify <code>bilinear_map</code>, <code>bilin_form</code> and <code>sesq_form</code> into a single <code>semibilin_map</code> which has the former three as special cases. The definition could be essentially what is the definition of <code>bilin_form</code> but way more general (yesterday I generalized it to a bilinear map, but not with the ring homomorphism yet). the way that <code>bilin_form</code> is written makes it easy to extend it to a bounded bilinear form, I don't see how to do the same thing with the current definition of the bilinear map.</p>\n</blockquote>\n<p>Is there any reason to use these over things like <code>E →ₗ[R] F →ₗ[R] G</code>?</p>\n</blockquote>\n<p>The way this is done in <code>bilinear_map</code> is not really satisfying in my opinion since it treats the first and second variable differently and there is still the need for boilerplate code in that module. Another question is whether we need even more boilerplate once we want to bundle <code>E →ₗ[R] F →ₗ[R] G</code> with other properties such as <code>is_bounded</code>.</p>",
        "id": 261952793,
        "sender_full_name": "Moritz",
        "timestamp": 1637253356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261951506\">said</a>:</p>\n<blockquote>\n<p>Here's something that seems as general as I can make it, and which would admit an exact parallel for <a href=\"https://leanprover-community.github.io/mathlib_docs/find/multilinear_map\">docs#multilinear_map</a>:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₁</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₂</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bilinear_map</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span> <span class=\"bp\">→</span> <span class=\"n\">M₂</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_add_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">bilin</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_smul_left</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">σ₁</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_add_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">bilin_smul_right</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M₂</span><span class=\"o\">),</span> <span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">σ₂</span> <span class=\"n\">a</span> <span class=\"bp\">•</span> <span class=\"o\">(</span><span class=\"n\">bilin</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">))</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>This looks almost exactly what I came up with modulo the σ₁ and σ₂. Almost everything from <code>bilin_form</code> translates without any major changes to that definition.</p>",
        "id": 261953178,
        "sender_full_name": "Moritz",
        "timestamp": 1637253522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261952793\">said</a>:</p>\n<blockquote>\n<p>The way this is done in <code>bilinear_map</code> is not really satisfying in my opinion since it treats the first and second variable differently and there is still the need for boilerplate code in that module. Another question is whether we need even more boilerplate once we want to bundle <code>E →ₗ[R] F →ₗ[R] G</code> with other properties such as <code>is_bounded</code>.</p>\n</blockquote>\n<p>You can always add lemmas to \"get rid\" of the asymmetry, which still seems like less work that building a full API from scratch as you have to do with a structure.</p>",
        "id": 261953583,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637253714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> Just for clarity let me translate your proposal into the same notation as the low-level one I wrote, I think you're suggesting</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.module.linear_map</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R₁</span> <span class=\"n\">R₂</span> <span class=\"n\">S₁</span> <span class=\"n\">S₂</span> <span class=\"n\">M₁</span> <span class=\"n\">M₂</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₁</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₁</span> <span class=\"n\">M₁</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">M₂</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₁</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₂</span> <span class=\"n\">N</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">σ₁</span> <span class=\"o\">:</span> <span class=\"n\">R₁</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ₂</span> <span class=\"o\">:</span> <span class=\"n\">R₂</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">M₁</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"n\">M₂</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>",
        "id": 261958013,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637255309
    },
    {
        "content": "<p>When run this I hit the error</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>failed to synthesize type class instance for\n...\n⊢ module S₁ (M₂ →ₛₗ[σ₂] N)\n</code></pre></div>",
        "id": 261958313,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637255429
    },
    {
        "content": "<p>but I guess that's from not having assumed <code>[smul_comm_class S₁ S₂ N]</code> and also from <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.module\">docs#linear_map.module</a> not having been semilinearized yet</p>",
        "id": 261958404,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637255470
    },
    {
        "content": "<p>Yes, currently there is no module instance on <code>E →ₛₗ[σ] F</code> unless <code>σ</code> is the identity. We need to add one given an instance of <code>[module S F]</code>.</p>",
        "id": 261958412,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637255473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261958412\">said</a>:</p>\n<blockquote>\n<p>Yes, currently there is no module instance on <code>E →ₛₗ[σ] F</code> unless <code>σ</code> is the identity. We need to add one given an instance of <code>[module S F]</code>.</p>\n</blockquote>\n<p>This should be added, certainly.  (Is it part of your current PR?)</p>\n<p>Regarding the point you and Moritz were discussing, I don't think I have any intuition for whether it would be better to use <code>M₁ →ₛₗ[σ₁] M₂ →ₛₗ[σ₂] N</code> for bilinear maps or to keep a <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261951506\">separate definition</a> generalizing the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bilin_form\">docs#bilin_form</a> ... would be curious to hear more people's opinions.</p>",
        "id": 261959012,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637255722
    },
    {
        "content": "<p>Whatever we do I think we want <code>bilin_form</code> to exist as a type, so that we have a place for dot notation for things like <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bilin_form.nondegerate\">docs#bilin_form.nondegerate</a></p>",
        "id": 261981962,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265487
    },
    {
        "content": "<p>Even if we just define it in terms of linear maps</p>",
        "id": 261981988,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637265501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz</span> By the way, inspired by Frédéric's idea, I guess <code>E →L[𝕜] F →L[𝕜] G</code> over normed spaces is exactly equivalent to <code>is_bounded_bilinear_map</code>.  (The <code>→L[𝕜]</code> means <a href=\"https://leanprover-community.github.io/mathlib_docs/find/continuous_linear_map\">docs#continuous_linear_map</a>, and the equivalence between continuity and boundedness is in <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.mk_continuous\">docs#linear_map.mk_continuous</a>).  So if you just want some effective definition to go on with, that would work ...</p>",
        "id": 261995051,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637271713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> that only seems to work if we define a structure. I tried it with a <code>def bilin_form R M := bilin_map R R M M R</code>, where <code>bilin_map</code> is defined as was written by <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and I had to use the namespace <code>bilin_map</code>.</p>",
        "id": 262001583,
        "sender_full_name": "Moritz",
        "timestamp": 1637274922
    },
    {
        "content": "<p>Nevermind, I did a stupid mistake. It does work</p>",
        "id": 262001812,
        "sender_full_name": "Moritz",
        "timestamp": 1637275076
    },
    {
        "content": "<p>As soon as Frédéric's PR is merged I can do a refactor to the <code>bilinear_map</code> file, that should be easy because only one other file really depends on it</p>",
        "id": 262005697,
        "sender_full_name": "Moritz",
        "timestamp": 1637277276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261949674\">said</a>:</p>\n<blockquote>\n<p>Look at the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/sesq_form\">docs#sesq_form</a>, which is a map <code>M → M → R</code>, where the <code>R</code> is considered as being both an <code>R</code>-module and an <code>Rᵒᵖ</code>-module, so that a sesquilinear form is <code>R</code>-linear in the first argument and <code>(I : R ≃+* Rᵒᵖ)</code>-semilinear in the second argument.</p>\n</blockquote>\n<p>BTW I have now checked this in my PR, and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"bp\">ᵒᵖ</span><span class=\"o\">):</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">I</span><span class=\"o\">]</span> <span class=\"n\">R</span>\n</code></pre></div>\n<p>typechecks.</p>",
        "id": 262015482,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637284260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"311453\">@Frédéric Dupuis</span> did you check whether <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261958013\">this example</a>,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">M₁</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₁</span><span class=\"o\">]</span> <span class=\"n\">M₂</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₂</span><span class=\"o\">]</span> <span class=\"n\">N</span>\n</code></pre></div>\n<p>typechecks?</p>",
        "id": 262019002,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637287553
    },
    {
        "content": "<p>It doesn't, you need that <code>smul_comm_class</code> instance.</p>",
        "id": 262019312,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637287925
    },
    {
        "content": "<p>With <code>[smul_comm_class S₂ S₁ N]</code> it works.</p>",
        "id": 262019371,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637288030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262019371\">said</a>:</p>\n<blockquote>\n<p>With <code>[smul_comm_class S₂ S₁ N]</code> it works.</p>\n</blockquote>\n<p>Doesn't that mean that we can only define bilinear forms over commutative rings? because we would need <code>smul_comm_class R R R</code></p>",
        "id": 262099713,
        "sender_full_name": "Moritz",
        "timestamp": 1637343037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz</span> It sounds confusing, but in the case of <code>R</code> and <code>Rᵒᵖ</code>, the <code>smul_comm_class</code> instance states that multiplying on the left commutes with multiplying on the right. See <a href=\"https://leanprover-community.github.io/mathlib_docs/find/semigroup.opposite_smul_comm_class\">docs#semigroup.opposite_smul_comm_class</a> for the relevant instance.</p>",
        "id": 262104198,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637344821
    },
    {
        "content": "<p>Which is exactly what you want for a conjugate-linear form, as you can pass <a href=\"https://leanprover-community.github.io/mathlib_docs/find/star_ring_equiv\">docs#star_ring_equiv</a> <code>: R ≃+* Rᵐᵒᵖ</code> as <code>σ₂</code>.</p>",
        "id": 262106847,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637345945
    },
    {
        "content": "<p>The question was about the case of bilinear forms, so that <code>ρ = σ = ring_hom.id R</code></p>",
        "id": 262108232,
        "sender_full_name": "Moritz",
        "timestamp": 1637346522
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">semibilin_map</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₂</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₂</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">S₂</span> <span class=\"n\">R₂</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">ρ₁₂</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ₁₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">ρ₁₂</span><span class=\"o\">]</span> <span class=\"n\">N</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₁₂</span><span class=\"o\">]</span> <span class=\"n\">P</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bilin_map</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"n\">semibilin_map</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">P</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">bilin_form</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">R</span> <span class=\"n\">R</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n  <span class=\"o\">:=</span> <span class=\"n\">bilin_map</span> <span class=\"n\">R</span> <span class=\"n\">M</span> <span class=\"n\">M</span> <span class=\"n\">R</span>\n</code></pre></div>",
        "id": 262108335,
        "sender_full_name": "Moritz",
        "timestamp": 1637346580
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262108956,
        "sender_full_name": "Moritz",
        "timestamp": 1637346854
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 262110039,
        "sender_full_name": "Moritz",
        "timestamp": 1637347309
    },
    {
        "content": "<p>While the current <a href=\"https://leanprover-community.github.io/mathlib_docs/find/bilin_form\">docs#bilin_form</a>  only requires <code>semiring R</code>, it looks like the axioms pretty much force you to have <code>R</code> be commutative</p>",
        "id": 262110373,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637347436
    },
    {
        "content": "<p>They're enough to show that <code>(a * b) * self.bilin x y = (b * a) * self.bilin x y</code> for all <code>a</code>, <code>b</code>, <code>x</code>, <code>y</code>, which is only a few steps away from <code>a * b = b * a</code>. I guess you can happily use the <code>0</code> form in the noncommutative setting, but it's pretty useless.</p>",
        "id": 262110756,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637347569
    },
    {
        "content": "<p>If these sesquilinear forms are being forced to be trivial, I think something is wrong.  Because apparently this definition should be interesting over noncommutative rings:<br>\n<a href=\"https://en.wikipedia.org/wiki/Sesquilinear_form#Over_a_division_ring\">https://en.wikipedia.org/wiki/Sesquilinear_form#Over_a_division_ring</a></p>",
        "id": 262118771,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637350768
    },
    {
        "content": "<p>(I've never used sesquilinear forms over rings other than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">C</span></span></span></span>, myself, but presumably some people do, and it would be a shame to rule out their use case ...)</p>",
        "id": 262118958,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637350833
    },
    {
        "content": "<p>I'm talking about the bilinear ones not the sesquilinear ones</p>",
        "id": 262126556,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1637354289
    },
    {
        "content": "<p>I made the definition for semibilinear maps in both the version, which is used in <code>bilinear_map</code> (with modification that it is now a structure, so that we can use namespaces) as well as <code>bilinear_form</code>:<br>\n<a href=\"https://gist.github.com/mcdoll/7bd87a9a3e2f58b22f55dd43749d1dfe\">https://gist.github.com/mcdoll/7bd87a9a3e2f58b22f55dd43749d1dfe</a><br>\n<a href=\"https://gist.github.com/mcdoll/83c11d5d4422eb6552330a7b56f82077\">https://gist.github.com/mcdoll/83c11d5d4422eb6552330a7b56f82077</a></p>",
        "id": 262185056,
        "sender_full_name": "Moritz",
        "timestamp": 1637416702
    },
    {
        "content": "<p>while the first version has a way more satisfying definition, it is more tedious to interact with (you have to unpack more structure), but the later might give more boilerplate code.</p>",
        "id": 262185408,
        "sender_full_name": "Moritz",
        "timestamp": 1637417095
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"412682\">@Moritz</span> Did you consider a variant on the second thing you listed,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">semibilin_map</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">R₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S₂</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">R₂</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">S₂</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_monoid</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">R₂</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">S₂</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">smul_comm_class</span> <span class=\"n\">S₂</span> <span class=\"n\">R₂</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">ρ₁₂</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R₂</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">σ₁₂</span> <span class=\"o\">:</span> <span class=\"n\">S</span> <span class=\"bp\">→+*</span> <span class=\"n\">S₂</span><span class=\"o\">)</span>\n  <span class=\"o\">:=</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">ρ₁₂</span><span class=\"o\">]</span> <span class=\"n\">N</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ₁₂</span><span class=\"o\">]</span> <span class=\"n\">P</span>\n</code></pre></div>",
        "id": 262187306,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637419849
    },
    {
        "content": "<p>this has the issues that were mentioned by Eric: <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261981962\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261981962</a></p>",
        "id": 262187370,
        "sender_full_name": "Moritz",
        "timestamp": 1637419930
    },
    {
        "content": "<p>I made a mwe why this is not good: <a href=\"https://gist.github.com/mcdoll/dfdaffa35e5b66c442b910384b9086fe\">https://gist.github.com/mcdoll/dfdaffa35e5b66c442b910384b9086fe</a></p>",
        "id": 262187455,
        "sender_full_name": "Moritz",
        "timestamp": 1637420067
    },
    {
        "content": "<p>Come to think of it (sorry if you already answered this) -- is there a reason we need the definition <code>semibilin_map</code>?  (I agree that a definition <code>semibilin_form</code> for <code>M → M → R</code> or <code>M → M → N</code> would be useful but I don't yet see what lemmas would need a special namespace for <code>M → N → P</code>).</p>",
        "id": 262187581,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420250
    },
    {
        "content": "<p>Maybe the idea is to develop something parallel to <br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/multilinear/basic.html\">https://leanprover-community.github.io/mathlib_docs/linear_algebra/multilinear/basic.html</a><br>\n?</p>",
        "id": 262187806,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420500
    },
    {
        "content": "<p>we could unify all the calculation things for sesquilinear and bilinear maps/forms. Now there is a lot of copy&amp;paste stuff between <code>sesquilinear_form</code> and <code>bilinear_form</code> and we could remove most of it by defining <code>structure bilin_map extends semibilin_map R R R R M N P (ring_hom.id R) (ring_hom.id R)</code> and then invoking <code>B.to_semilin_map.stuff</code></p>",
        "id": 262187853,
        "sender_full_name": "Moritz",
        "timestamp": 1637420550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262187853\">said</a>:</p>\n<blockquote>\n<p>we could unify all the calculation things for sesquilinear and bilinear maps/forms.</p>\n</blockquote>\n<p>This part I am completely in favour with</p>",
        "id": 262187878,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420593
    },
    {
        "content": "<p>It would be quite parallel with the multilinear library</p>",
        "id": 262187923,
        "sender_full_name": "Moritz",
        "timestamp": 1637420642
    },
    {
        "content": "<p>At least the second version I wrote above</p>",
        "id": 262187972,
        "sender_full_name": "Moritz",
        "timestamp": 1637420716
    },
    {
        "content": "<p>But when we define the semibilinear version, I don't think we need a special name for the bilinear and sesquilinear versions -- you can just take as your input to a lemma a semibilinear form/map in which the arguments are appropriate</p>",
        "id": 262187974,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420722
    },
    {
        "content": "<p>And I'm also asking whether <code>semibilin_map</code> needs to be named, or whether <code>semibilin_form</code> is the first thing that needs a name.</p>",
        "id": 262188036,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420794
    },
    {
        "content": "<p>(Basically, as you have discovered yourself in these tests, every time you give a new name to something, Lean finds more trouble in discovering that it is equal to its definition when you need that.  So it's often better to minimize the number of things that get names ...)</p>",
        "id": 262188058,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637420875
    },
    {
        "content": "<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>",
        "id": 262188111,
        "sender_full_name": "Moritz",
        "timestamp": 1637420913
    },
    {
        "content": "<p>is there a possibility to do type-aliases in lean? so that we could write <code>bilinear_form R M</code> and it gets internally resolved to <code>semibilin_map R R R R M M R (ring_hom.id R) (ring_hom.id R)</code></p>",
        "id": 262188190,
        "sender_full_name": "Moritz",
        "timestamp": 1637421013
    },
    {
        "content": "<p>I agree with the too many definitions/namespaces argument</p>",
        "id": 262188220,
        "sender_full_name": "Moritz",
        "timestamp": 1637421068
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188111\">said</a>:</p>\n<blockquote>\n<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>\n</blockquote>\n<p>I think you can do</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bounded_bilinear_map</span> <span class=\"kd\">extends</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bounded</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">y</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 262188275,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421124
    },
    {
        "content": "<p>(not sure if this is the best way, just an argument that we don't <em>need</em> the definition <code>semibilin_map</code>)</p>",
        "id": 262188296,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421181
    },
    {
        "content": "<p>And another way is of course to just use <code>E →L[𝕜] F →L[𝕜] G</code> (see <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/261995051\">here</a>)</p>",
        "id": 262188362,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188190\">said</a>:</p>\n<blockquote>\n<p>is there a possibility to do type-aliases in lean? so that we could write <code>bilinear_form R M</code> and it gets internally resolved to <code>semibilin_map R R R R M M R (ring_hom.id R) (ring_hom.id R)</code></p>\n</blockquote>\n<p>Unfortunately not; you can define type-aliases but they don't unfold everywhere so to speak, so are not completely silent.</p>\n<p>A very common workaround in mathlib is <em>notation</em>, which is completely silent.  So for the case of linear/conjugate-linear/semilinear maps we have separate <em>notations</em> for the concepts, even though the first two are special cases of the last.</p>",
        "id": 262188446,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421431
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">notation</span> <span class=\"n\">M</span> <span class=\"bp\">`</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"n\">σ</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">M₂</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map</span> <span class=\"n\">σ</span> <span class=\"n\">M</span> <span class=\"n\">M₂</span>\n<span class=\"kd\">notation</span> <span class=\"n\">M</span> <span class=\"bp\">`</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"n\">R</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">M₂</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map</span> <span class=\"o\">(</span><span class=\"n\">ring_hom.id</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">M₂</span>\n<span class=\"kd\">notation</span> <span class=\"n\">M</span> <span class=\"bp\">`</span> <span class=\"bp\">→ₗ⋆</span><span class=\"o\">[</span><span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"n\">R</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"bp\">`</span><span class=\"o\">]</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"n\">M₂</span><span class=\"o\">:</span><span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"n\">linear_map</span> <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">star_ring_aut</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">M</span> <span class=\"n\">M₂</span>\n</code></pre></div>",
        "id": 262188513,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421495
    },
    {
        "content": "<p>This provides for</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₛₗ</span><span class=\"o\">[</span><span class=\"n\">σ</span><span class=\"o\">]</span> <span class=\"n\">M₂</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M₂</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→ₗ⋆</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">M₂</span>\n</code></pre></div>\n<p>semilinear, linear, conjugate-linear in that order.</p>\n<p>We might like to introduce some notation for bilinear and sesquilinear forms; then they could be silent special cases of semibilinear forms.</p>",
        "id": 262188618,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637421631
    },
    {
        "content": "<p>If the only reason we want those types to exist is to enable dot notation, what's wrong with putting the lemmas we want in the <code>linear_map</code> and <code>continuous_linear_map</code> namespaces, as is done in <code>bilinear_map.lean</code>?</p>",
        "id": 262188696,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637421735
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188275\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"412682\">Moritz</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188111\">said</a>:</p>\n<blockquote>\n<p>If we want that <code>bounded_bilinear_map</code> is an extension, then we have to use <code>semibilin_map</code></p>\n</blockquote>\n<p>I think you can do</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">analysis.normed_space.basic</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"bp\">𝕜</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_field</span> <span class=\"bp\">𝕜</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">F</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">F</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">𝕜</span> <span class=\"n\">G</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">bounded_bilinear_map</span> <span class=\"kd\">extends</span> <span class=\"n\">E</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">F</span> <span class=\"bp\">→ₗ</span><span class=\"o\">[</span><span class=\"bp\">𝕜</span><span class=\"o\">]</span> <span class=\"n\">G</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">bounded</span> <span class=\"o\">:</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"n\">ℝ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">&gt;</span> <span class=\"mi\">0</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">F</span><span class=\"o\">),</span> <span class=\"bp\">∥</span><span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"bp\">∥</span> <span class=\"bp\">≤</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">x</span><span class=\"bp\">∥</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"bp\">∥</span><span class=\"n\">y</span><span class=\"bp\">∥</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I did not know that that could work.</p>",
        "id": 262188828,
        "sender_full_name": "Moritz",
        "timestamp": 1637421938
    },
    {
        "content": "<p>Neither did I, till I tried it just now! :)</p>",
        "id": 262189022,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637422201
    },
    {
        "content": "<p>Sorry what! We can extend compound type? <span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span></p>",
        "id": 262189190,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1637422384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"311453\">Frédéric Dupuis</span> <a href=\"#narrow/stream/116395-maths/topic/Bounded.20bilinear.20forms/near/262188696\">said</a>:</p>\n<blockquote>\n<p>If the only reason we want those types to exist is to enable dot notation, what's wrong with putting the lemmas we want in the <code>linear_map</code> and <code>continuous_linear_map</code> namespaces, as is done in <code>bilinear_map.lean</code>?</p>\n</blockquote>\n<p>If the thing Heather posted works, I don't see any problems with that.</p>",
        "id": 262189470,
        "sender_full_name": "Moritz",
        "timestamp": 1637422727
    },
    {
        "content": "<p>Do try the <code>E →L[𝕜] F →L[𝕜] G</code> way, too!</p>",
        "id": 262189658,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1637422996
    },
    {
        "content": "<p>Yeah, I don't see why we want a structure for this -- what advantages would it have over just using <code>E →L[𝕜] F →L[𝕜] G</code>?</p>",
        "id": 262190542,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637424160
    },
    {
        "content": "<p>We can just use <code>linear_map.mk_continuous₂</code> to have a constructor similar to that structure, without having to start duplicating the API.</p>",
        "id": 262190663,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1637424340
    }
]
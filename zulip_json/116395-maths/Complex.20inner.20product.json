[
    {
        "content": "<p>I was thinking as my first contribution to mathlib making <code>complex_inner_product.lean</code> which basically duplicates <code>real_inner_product.lean</code> but for complex inner product spaces. Is this a good idea? If so what should I name the inner product operation? Right now there is the class <code>has_inner</code> with operation <code>inner : \\alpha \\to \\alpha \\to \\R</code>. Should I make a class <code>has_cinner</code> with operation <code>cinner : \\alpha \\to \\alpha \\to \\C</code> or generalize <code>has_inner</code> to have <code>inner : \\alpha \\to \\alpha \\to \\beta</code>?</p>",
        "id": 198757273,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590497847
    },
    {
        "content": "<p>I fear that the trouble with <code>\\a → \\a → \\b</code> is that it can't infer <code>\\b</code> from the arguments of the inner product. So you would have to mark <code>\\b</code> as an <code>out_param</code>, and I don't understand those.</p>",
        "id": 198758068,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498161
    },
    {
        "content": "<p>Last time I looked, this already existed, but in a completely different part of mathlib, I think.</p>",
        "id": 198758154,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590498197
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>  A <code>complex_inner_product.lean</code> file? I couldn't find anything in Linear Algebra. There was some other branch that was being developed but it seems to have been called off.</p>",
        "id": 198758285,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590498253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> <code>git grep inner</code> doesn't show anything interesting outside <code>real_inner_product.lean</code></p>",
        "id": 198758368,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> So <code>has_cinner</code> then?</p>",
        "id": 198758392,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590498311
    },
    {
        "content": "<p>Well....</p>",
        "id": 198758465,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498357
    },
    {
        "content": "<p>Am I confusing this with something else?</p>",
        "id": 198758474,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590498362
    },
    {
        "content": "<p>What if someone wants to do inner products over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mo stretchy=\"false\">(</mo><msqrt><mrow><mo>−</mo><mn>5</mn></mrow></msqrt><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}(\\sqrt{-5})</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.115555em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Q</span></span><span class=\"mopen\">(</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8655550000000001em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">−</span><span class=\"mord\">5</span></span></span><span style=\"top:-2.825555em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg height=\"1.08em\" preserveAspectRatio=\"xMinYMin slice\" viewBox=\"0 0 400000 1080\" width=\"400em\"><path d=\"M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z\"></path></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17444499999999996em;\"><span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>?</p>",
        "id": 198758556,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498396
    },
    {
        "content": "<p>We would end up with 10.000 classes. So I think we should search for a good generalisation.</p>",
        "id": 198758608,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498426
    },
    {
        "content": "<p>Maybe it was already refactored: <code>linear_algebra.sesquilinear_form</code></p>",
        "id": 198758615,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590498434
    },
    {
        "content": "<p>But it's not immediate (to me) what it should be.</p>",
        "id": 198758631,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498439
    },
    {
        "content": "<p>aha, so we already have a general theory...</p>",
        "id": 198758851,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span> Maybe this is not the best first project... how about doing so stuff over at the real side?</p>",
        "id": 198759090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498697
    },
    {
        "content": "<p>I would love to see Sylvester's law of inertia in mathlib</p>",
        "id": 198759110,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498710
    },
    {
        "content": "<p>Maybe something with diagonalizing matrices</p>",
        "id": 198759170,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498725
    },
    {
        "content": "<p>So should complex inner product not be defined as a class, just as write theorems about sesquilinear form with a specific anti-iso?</p>",
        "id": 198759323,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590498803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  I’m more of an analyst than an algebraist. I just wanted basic theory to get into Hilbert space stuff</p>",
        "id": 198759425,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590498855
    },
    {
        "content": "<p>Ok, I don't know anything about Hilbert spaces</p>",
        "id": 198759450,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498873
    },
    {
        "content": "<p>But we certainly want those</p>",
        "id": 198759539,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498916
    },
    {
        "content": "<p>I just basic stuff about complex inner product spaces. Existence of orthogonal projection. That sort of thing. A Hilbert space is just a complex inner product space that is complete w/r/t the norm metric</p>",
        "id": 198759576,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590498938
    },
    {
        "content": "<p>And I guess we want some form of notation for inner products... but the obvious angle brackets are reserved by Lean.</p>",
        "id": 198759608,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590498954
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span> If the notation mentions the ground field, then we can easily solve the problem.</p>",
        "id": 198759727,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499010
    },
    {
        "content": "<p>So first it makes sense to prove basic facts to prove stuff about complex inner product spaces. And yeah notation would be nice</p>",
        "id": 198759761,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590499024
    },
    {
        "content": "<p>any ideas?</p>",
        "id": 198759787,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590499034
    },
    {
        "content": "<p>You could write something like <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><msub><mo stretchy=\"false\">⟩</mo><mi>K</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\langle a, b \\rangle_K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mclose\"><span class=\"mclose\">⟩</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi><mo>=</mo><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">K = \\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span>.</p>",
        "id": 198759812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499045
    },
    {
        "content": "<p>Does that look acceptable?</p>",
        "id": 198759824,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499053
    },
    {
        "content": "<p>In Lean it would become something more like <code>⟨a,b⟩[K]</code></p>",
        "id": 198759931,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499091
    },
    {
        "content": "<p>Because we can't do proper subscripts</p>",
        "id": 198759954,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499101
    },
    {
        "content": "<p>The other option is to try the <code>out_param</code> thing</p>",
        "id": 198760022,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499128
    },
    {
        "content": "<p>I’m a bit confused as to why the output can’t be inferred. If there is no only one inner product instance over alpha can’t it figure out the output type?</p>",
        "id": 198760227,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590499205
    },
    {
        "content": "<p>Don't play the outparam game, because one day you may want to look at a complex vector space as a real vector space.</p>",
        "id": 198760276,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590499225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> But that would be <code>restrict_scalars real complex V</code>, right?</p>",
        "id": 198760451,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499313
    },
    {
        "content": "<p>Correct me if I’m wrong, but aren’t the only two proper inner product the real and complex inner products. Then one can worry about sesquilinear forms in a general algebraic setting, but it seems like it’d be fine to have a complex inner product class and a real inner product class</p>",
        "id": 198760896,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590499513
    },
    {
        "content": "<p>Maybe they cover all the cases where you want notation...</p>",
        "id": 198761129,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499631
    },
    {
        "content": "<p>I'm not sure though</p>",
        "id": 198761148,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499645
    },
    {
        "content": "<p>It wouldn't have to be <code>restrict_scalars real complex V</code>. This type synonym is helpful when you have many fields and you want to do algebra. The situation with complex and real is sufficiently canonical that we have instances declaring that a complex space is also a real space. For instance, we have</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">instance</span> <span class=\"n\">normed_space</span><span class=\"bp\">.</span><span class=\"n\">restrict_scalars_real</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"n\">ℂ</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">normed_space</span> <span class=\"n\">ℝ</span> <span class=\"n\">E</span>\n</code></pre></div>\n\n\n<p>in <code>analysis/complex/basic</code>. It makes it possible to apply for free theorems on the topology of real vector spaces to complex vector spaces.</p>",
        "id": 198761163,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590499656
    },
    {
        "content": "<p>My alter ego pretty often considers examples of inner products over number fields.</p>",
        "id": 198761197,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499679
    },
    {
        "content": "<p>And my alter ego does use bracket notation for them</p>",
        "id": 198761256,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> So, what do you suggest? Use notation that mentions the base field? Or no notation at all? Or separate classes for <code>R</code> and <code>C</code>?</p>",
        "id": 198761731,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590499919
    },
    {
        "content": "<p>I mean for now we can just do no notation explicit variable base field</p>",
        "id": 198762486,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590500264
    },
    {
        "content": "<p>I would say: keep the current notation for the real scalar product, and put an index <code>c</code> to denote a complex hermitian product. If we could have an index <code>ℂ</code> this would be awesome, but I am not sure unicode has considered this.</p>",
        "id": 198762498,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590500273
    },
    {
        "content": "<p>So separate classes, and ignore fields that aren't <code>real</code> or <code>complex</code>.</p>",
        "id": 198762651,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590500352
    },
    {
        "content": "<p>What should the class be called? has_cinner or has_innerc?</p>",
        "id": 198762713,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590500398
    },
    {
        "content": "<p>Yes, I would go for separate classes for now. I don't know if there is a satisfactory math unification.</p>",
        "id": 198762795,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590500427
    },
    {
        "content": "<p>Doesn't matter. I think I would go for <code>innerc</code></p>",
        "id": 198762798,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590500430
    },
    {
        "content": "<p>Maybe I've read that thread too quickly, but I don't understand this complex inner product non-sense. I don't think anyone use this. The definition of complex Hilbert spaces certainly don't, it's all about sesquilinear forms</p>",
        "id": 198766886,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590502174
    },
    {
        "content": "<p>If the issue is simply that you call complex inner product what is usually called hermitian product then the answer is we already have them</p>",
        "id": 198767246,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590502317
    },
    {
        "content": "<p>I can't find <code>hermitian</code> anywhere in mathlib.</p>",
        "id": 198767421,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1590502389
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  I don't see why you call this \"nonsense\". A <strong>very</strong> standard definition of a complex Hilbert space is a complex inner product space that is complete w/r/t to the norm metric. Do you have a better definition?</p>\n<p>Maybe you are right about the terminological confusion; I think \"complex inner product\" is standard, e.g. in Folland, Real Analysis. Are you thinking of complex inner product as symmetric as opposed to hermitian?</p>",
        "id": 198768307,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590502733
    },
    {
        "content": "<p>I think there was a branch that developed Hermitian inner products but it was closed/given up on for some reason and never merged to master.</p>",
        "id": 198768632,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590502877
    },
    {
        "content": "<p>There was also a <a href=\"#narrow/stream/113488-general/topic/Inner.20product.20space\">thread about this exact question</a> from July last year.</p>",
        "id": 198768849,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590502969
    },
    {
        "content": "<p>My suggestion from then had been:</p>\n<blockquote>\n<p>Looking at both Bourbaki and Pedersen, it seems that they really use a typeclass <code>is_R_or_C</code> on their field! That is, mostly they pretend they have an arbitrary field with conjugation, but occasionally they break into those two cases. It seems the majority of the times they need to case bash are to use polarisation identities (writing inner products as a linear combination of norms), but that the arguments nearly always converging quickly again after using polarisation.</p>\n</blockquote>",
        "id": 198768972,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503032
    },
    {
        "content": "<p>Bourbaki doesn't consider quaternionic Hilbert spaces??</p>",
        "id": 198769129,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590503097
    },
    {
        "content": "<p>Maybe this is a French/English translation issue</p>",
        "id": 198769132,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590503099
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span> what's wrong with <a href=\"https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html\">https://leanprover-community.github.io/mathlib_docs/linear_algebra/sesquilinear_form.html</a>?</p>",
        "id": 198769164,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590503115
    },
    {
        "content": "<p>(I don't know if these even make sense)</p>",
        "id": 198769169,
        "sender_full_name": "Reid Barton",
        "timestamp": 1590503116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span>  Sesquilinear forms aren't positive definite, correct?</p>",
        "id": 198769436,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590503222
    },
    {
        "content": "<p>positive definite ones are a special case</p>",
        "id": 198769617,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590503284
    },
    {
        "content": "<p>In general they aren't</p>",
        "id": 198769632,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1590503291
    },
    {
        "content": "<p>This had been my suggestion from last year (since then someone has done sesquilinear forms):</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">class</span> <span class=\"n\">sesquilinear_space</span> <span class=\"o\">(</span><span class=\"err\">𝕶</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">scalars</span> <span class=\"err\">𝕶</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">𝕶</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">inner_product</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"err\">𝕶</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">conj_symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">inner_product</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">inner_product</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"err\">†</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">linearity</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"err\">𝕶</span><span class=\"o\">),</span> <span class=\"n\">inner_product</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">a</span> <span class=\"bp\">*</span> <span class=\"n\">inner_product</span> <span class=\"n\">x</span> <span class=\"n\">z</span> <span class=\"bp\">+</span> <span class=\"n\">inner_product</span> <span class=\"n\">y</span> <span class=\"n\">z</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">inner_product_space</span> <span class=\"o\">(</span><span class=\"err\">𝕶</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">scalars</span> <span class=\"err\">𝕶</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"err\">𝕶</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">sesquilinear_space</span> <span class=\"err\">𝕶</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">normed_space</span> <span class=\"err\">𝕶</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">norm_sq</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">inner_product</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">norm</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">^</span><span class=\"mi\">2</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 198769691,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503322
    },
    {
        "content": "<p>Of course, a complex inner product is a type of sesquilinear form, but they have an additional axiom and some nice properties that don't hold in general. Don't they deserve to be developed in their own right? Perhaps for algebraists or whomever they aren't very special, but in functional analysis, they are usually developed in their own right.</p>",
        "id": 198769794,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590503375
    },
    {
        "content": "<p>I think Patrick is just saying they should be built on top of sesquilinear forms, rather than from scratch.</p>",
        "id": 198769912,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503408
    },
    {
        "content": "<p>There's no need to prove all the facts which are true for merely sesquilinear forms a second time for inner products.</p>",
        "id": 198769986,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> But will type class search work with your setup?</p>",
        "id": 198770071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590503468
    },
    {
        "content": "<p>If I have <code>x y : V</code>, and I write <code>inner x y</code> (or use whatever notation), then how will Lean figure out the scalars?</p>",
        "id": 198770127,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590503494
    },
    {
        "content": "<p>Shouldn't we define <code>innerc_product_space</code> as usual and then prove it is an instance of a sesquilinear form?</p>",
        "id": 198770280,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590503545
    },
    {
        "content": "<p>Oh, I see. I think you should have to specify the field, and you can use local notations to hide it when you want to specialise to <code>real</code> and <code>complex</code></p>",
        "id": 198770289,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503549
    },
    {
        "content": "<p>I think you pretty much always have to do the proof for real and complex separately, even though they are often similar.</p>",
        "id": 198770668,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590503706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span>, what do you mean by \"as usual\"? If it's going to be a structure with the same fields as <code>sesq_form</code> (and some extras) then it's seems pretty reasonable to begin by extending <code>sesq_form</code>.</p>",
        "id": 198770738,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503751
    },
    {
        "content": "<p>Those books I mentioned above, Bourbaki's Topological Vector Spaces and Pedersen's Analysis Now, both do what looks like a nice job of keeping the real and complex cases parallel.</p>",
        "id": 198770871,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503795
    },
    {
        "content": "<p>They need to case split whenever they use polarisation, but manage to get the statements parallel for a long time.</p>",
        "id": 198770913,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503823
    },
    {
        "content": "<p>My guess is that either would be a pretty nice to follow while formalising. (Even though Pedersen is not the greatest book to learn from.)</p>",
        "id": 198771162,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590503919
    },
    {
        "content": "<p>Ideally, most of this works for fields \"with a conjugation (which might be trivial)\"</p>",
        "id": 198771820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590504211
    },
    {
        "content": "<p>I'm really not sure how it would look to develop this in full proper generality. The standard informal development would have you working over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">F</mi><mo>=</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{F} = \\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">F</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> or <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> and then you write proofs for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span> that also work for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> (since there is an informal \"coercion\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>→</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R} \\to \\mathbb{C}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">C</span></span></span></span></span>).  But I don't see how we define inner products this way in Lean and even if we did I don't see how to do \"both proofs at once\". It seems much more staightforward to just define two classes and \"prove everything twice\", even though mostly the same proofs will work. Now if we are trying to do Johan's much more general situation, then it makes sense to try to do everything in much more generality. I'm not sure how the positive-definiteness condition works in this general case though.</p>",
        "id": 198779379,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590506952
    },
    {
        "content": "<p>I'd be interested in trying to express positivity as <code>∀ (x : α), sesq x x = (norm x)^2</code>.  That is, you separately assume <code>sesq_form</code> and <code>normed_space</code>, and assert positivity by saying they are related in this way. It covers the real and complex cases, at least, and then otherwise I don't know if it's useless or useful, but who cares.</p>",
        "id": 198784977,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590509223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span> I haven't thought through all the details, but there is the (useful to me) notion of \"totally definite\".</p>",
        "id": 198784991,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590509229
    },
    {
        "content": "<p>From my dim memory (I haven't looked since last July), this is how Bourbaki does it?</p>",
        "id": 198785040,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590509261
    },
    {
        "content": "<p>Do you need that <code>R</code> is totally ordered? Or is it enough to have a notion of positive elements?</p>",
        "id": 198785044,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590509268
    },
    {
        "content": "<p>(That might be totally wrong...)</p>",
        "id": 198785045,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590509268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> your suggestion requires a normed field.</p>",
        "id": 198785232,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590509346
    },
    {
        "content": "<p>Yes</p>",
        "id": 198785379,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590509403
    },
    {
        "content": "<p>I would like to experiment with how far you can get with a (non-totally) ordered field and a quadratic extension.</p>",
        "id": 198785408,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590509420
    },
    {
        "content": "<p>There are non-normed fields?! :-)</p>",
        "id": 198785409,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590509421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198785409\">said</a>:</p>\n<blockquote>\n<p>There are non-normed fields?! :-)</p>\n</blockquote>\n<p>Only on Wednesdays</p>",
        "id": 198785445,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590509436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> <span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span> This is probably both too complicated and not general enough...</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">logic</span><span class=\"bp\">.</span><span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">ordered_ring</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">field</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory</span><span class=\"bp\">.</span><span class=\"n\">maps</span>\n<span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">sesquilinear_form</span>\n<span class=\"kn\">import</span> <span class=\"n\">analysis</span><span class=\"bp\">.</span><span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">preps</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"n\">class</span> <span class=\"n\">ordered_field</span> <span class=\"o\">(</span><span class=\"n\">F</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">ordered_ring</span> <span class=\"n\">F</span><span class=\"o\">,</span> <span class=\"n\">field</span> <span class=\"n\">F</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_conj</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">C</span> <span class=\"bp\">→+*</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">involutive</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">involutive</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">conj</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">has_conj</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→+*</span> <span class=\"n\">C</span> <span class=\"o\">:=</span> <span class=\"n\">has_conj</span><span class=\"bp\">.</span><span class=\"n\">to_ring_hom</span> <span class=\"n\">C</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">conj_involutive</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">has_conj</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">involutive</span> <span class=\"o\">(</span><span class=\"n\">conj</span> <span class=\"o\">:</span> <span class=\"n\">C</span> <span class=\"bp\">→</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">involutive</span>\n\n<span class=\"n\">class</span> <span class=\"n\">real_complex_pair</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ordered_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_conj</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fix</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">conj</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">z</span> <span class=\"bp\">↔</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">preps</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ordered_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">has_conj</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">real_complex_pair</span> <span class=\"n\">R</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">conj_hom_anti_equiv</span> <span class=\"o\">:</span> <span class=\"n\">ring_anti_equiv</span> <span class=\"n\">C</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">conj</span><span class=\"o\">,</span>\n  <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"n\">conj</span><span class=\"o\">,</span>\n  <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">conj_involutive</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">left_inverse</span><span class=\"o\">,</span>\n  <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">conj_involutive</span> <span class=\"n\">C</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">right_inverse</span><span class=\"o\">,</span>\n  <span class=\"n\">anti_hom</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">map_one</span> <span class=\"o\">:=</span> <span class=\"n\">conj</span><span class=\"bp\">.</span><span class=\"n\">map_one</span><span class=\"o\">,</span>\n    <span class=\"n\">map_mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">conj</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n    <span class=\"n\">map_add</span> <span class=\"o\">:=</span> <span class=\"n\">conj</span><span class=\"bp\">.</span><span class=\"n\">map_add</span> <span class=\"o\">}}</span>\n\n<span class=\"n\">class</span> <span class=\"n\">inner_product_space</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">C</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">sesq_form</span> <span class=\"n\">C</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">conj_hom_anti_equiv</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">symm</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">sesq</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">conj</span> <span class=\"o\">(</span><span class=\"n\">sesq</span> <span class=\"n\">y</span> <span class=\"n\">x</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">pos</span>  <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∃</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"mi\">0</span> <span class=\"bp\">&lt;</span> <span class=\"n\">r</span> <span class=\"bp\">∧</span> <span class=\"n\">sesq</span> <span class=\"n\">x</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">algebra_map</span> <span class=\"n\">R</span> <span class=\"n\">C</span> <span class=\"n\">r</span><span class=\"o\">)</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">examples</span>\n<span class=\"kn\">open</span> <span class=\"n\">complex</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"n\">complex</span><span class=\"bp\">.</span><span class=\"n\">has_conj</span> <span class=\"o\">:</span> <span class=\"n\">has_conj</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">conj</span><span class=\"o\">,</span>\n  <span class=\"n\">map_one&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">conj_one</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">conj_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">map_zero&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">conj_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">conj_add</span><span class=\"o\">,</span>\n  <span class=\"n\">involutive</span> <span class=\"o\">:=</span> <span class=\"n\">conj_involutive</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">instance</span> <span class=\"n\">linear_ordered_field</span><span class=\"bp\">.</span><span class=\"n\">ordered_field</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">linear_ordered_field</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">ordered_field</span> <span class=\"n\">R</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"bp\">..</span><span class=\"n\">I</span><span class=\"o\">}</span>\n\n<span class=\"n\">noncomputable</span> <span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">real_complex_pair</span> <span class=\"n\">ℝ</span> <span class=\"n\">ℂ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">fix</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">eq_conj_iff_real</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">examples</span>\n</code></pre></div>",
        "id": 198790828,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590512011
    },
    {
        "content": "<p>One big downside is that we still can't have nice notation.</p>",
        "id": 198790885,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590512040
    },
    {
        "content": "<p>All this discussion has me wondering how much we will get out of working in this generality. Really I’m just interested in getting to Hilbert space and functional analysis and there’s not that much theory of general inner products that I’m familiar with so I can formalize. Would it be wrong to just do the complex inner product? How necessary is it to develop the theory in complete generality before doing the case that has extremely wide applicability?</p>",
        "id": 198841226,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590542701
    },
    {
        "content": "<p>Actually even having a typeclass <code>is_R_or_C</code> would be a bit challenging</p>",
        "id": 198841325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590542802
    },
    {
        "content": "<p>it's probably easier to define <code>is_R_or_C</code> to mean \"having all the common identities we want\" like polarization</p>",
        "id": 198841416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590542894
    },
    {
        "content": "<p>Why not just have a real inner product type class and a complex one?</p>",
        "id": 198841532,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590543015
    },
    {
        "content": "<p>presumably the reason the books talk about is_R_or_C is because there are a lot of duplicated lemmas</p>",
        "id": 198841584,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543093
    },
    {
        "content": "<p>we can also have a real and complex inner product type class if there is more structure there worth noting, but having one way to prove facts in both contexts seems good to me</p>",
        "id": 198841646,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543157
    },
    {
        "content": "<p>Yes, but it’s not clear that it’d make anything simpler doing it that way. Eg in the real case you won’t have trivial conjugations floating around. And I’m pretty sure to do any proof you would need to split by cases unless you compiled an absurdly long list of theorems that hold for R and C and show they hold for our <code>is_R_or_C</code> class.</p>",
        "id": 198841778,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590543295
    },
    {
        "content": "<p>I'm completely uncertain about the best approach here. It's a maintenance and pedagogical hassle later down the track if we have closely duplicated developments written at different times by different people. On the other hand:</p>\n<p>&lt;provocation&gt;At the end of the day all that matters is the complex case. :-) &lt;/provocation&gt;.</p>",
        "id": 198841791,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590543309
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span>, the contrary evidence is that there are textbooks that do this.</p>",
        "id": 198841812,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590543346
    },
    {
        "content": "<blockquote>\n<p>Eg in the real case you won’t have trivial conjugations floating around</p>\n</blockquote>\n<p>No, you will have exactly one trivial conjugation floating around</p>",
        "id": 198841882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543426
    },
    {
        "content": "<p>Textbooks are informal. They can write proofs for complex case and let the reader do the necessary mental rewrites, type coercion, and whatnot.</p>",
        "id": 198841886,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590543435
    },
    {
        "content": "<p>This \"R or C\" phenomenon is very widespread, and I have had to deal with it before in metamath. I stuck to my guns and just did \"trivial generalization\", using something like a division ring for as long as possible. It helped in that case that Norman Megill's personal research area was in orthonormal algebras and hilbert spaces over general division rings</p>",
        "id": 198841982,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543595
    },
    {
        "content": "<p>something to do with quantum logic</p>",
        "id": 198842029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543623
    },
    {
        "content": "<p>We also used the concept of a *-ring, which is a ring with an order two automorphism (aka conjugation)</p>",
        "id": 198842111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590543726
    },
    {
        "content": "<p>How about: a field with a conjugation such that the fixpoints of the conjugation form a complete ordered field</p>",
        "id": 198842278,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590544024
    },
    {
        "content": "<p>you don't even really need the order, since you can define it as \"x is nonnegative if it is the square of a formally real element\"</p>",
        "id": 198842357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590544113
    },
    {
        "content": "<p>What is the point of an arbitrary complete ordered field if that is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> upto iso?</p>",
        "id": 198842534,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590544360
    },
    {
        "content": "<p>Also what about the idea of being able to recover most of the theorems for the real case from the complex case by using complexification which gives us a linear isometry (not surjective), so e.g. for Cauchy Schwarz, we get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">⟩</mo><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">⟨</mo><mi>U</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>U</mi><mi>y</mi><mo stretchy=\"false\">⟩</mo><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi mathvariant=\"normal\">∥</mi><mi>U</mi><mi>x</mi><mi mathvariant=\"normal\">∥</mi><mi mathvariant=\"normal\">∥</mi><mi>U</mi><mi>y</mi><mi mathvariant=\"normal\">∥</mi><mo>=</mo><mi mathvariant=\"normal\">∥</mi><mi>x</mi><mi mathvariant=\"normal\">∥</mi><mi mathvariant=\"normal\">∥</mi><mi>y</mi><mi mathvariant=\"normal\">∥</mi></mrow><annotation encoding=\"application/x-tex\">|\\langle x ,y \\rangle | = |\\langle U x, U y \\rangle | \\leq \\| U x \\| \\| U y\\|  = \\|x\\| \\|y\\|</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">⟩</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">⟩</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">∥</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">∥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">∥</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">∥</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is the isometry? Perhaps many of the theorems can be recovered this way.</p>",
        "id": 198842798,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590544744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300684\">Keefer Rowan</span> <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842534\">said</a>:</p>\n<blockquote>\n<p>What is the point of an arbitrary complete ordered field if that is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> upto iso?</p>\n</blockquote>\n<p>That is the point. This is just <code>is_R_or_C</code>, but stated in a way that doesn't involve type equality or messy isomorphisms</p>",
        "id": 198843009,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590545045
    },
    {
        "content": "<p>also, we <em>still</em> have not proven that an arbitrary complete ordered field is just <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{R}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">R</span></span></span></span></span> up to iso and I have a vested interest in seeing that theorem proved, so writing things this way might encourage it</p>",
        "id": 198843036,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590545113
    },
    {
        "content": "<p>Besides, there are other things that satisfy is_R_or_C that might not be <code>real</code> or <code>complex</code>, for example <code>{x : complex // Re x = 0}</code> or <code>real^1</code></p>",
        "id": 198843106,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590545212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300684\">Keefer Rowan</span> <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842798\">said</a>:</p>\n<blockquote>\n<p>Also what about the idea of being able to recover most of the theorems for the real case from the complex case by using complexification which gives us a linear isometry (not surjective), so e.g. for Cauchy Schwarz, we get <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">⟨</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">⟩</mo><mi mathvariant=\"normal\">∣</mi><mo>=</mo><mi mathvariant=\"normal\">∣</mi><mo stretchy=\"false\">⟨</mo><mi>U</mi><mi>x</mi><mo separator=\"true\">,</mo><mi>U</mi><mi>y</mi><mo stretchy=\"false\">⟩</mo><mi mathvariant=\"normal\">∣</mi><mo>≤</mo><mi mathvariant=\"normal\">∥</mi><mi>U</mi><mi>x</mi><mi mathvariant=\"normal\">∥</mi><mi mathvariant=\"normal\">∥</mi><mi>U</mi><mi>y</mi><mi mathvariant=\"normal\">∥</mi><mo>=</mo><mi mathvariant=\"normal\">∥</mi><mi>x</mi><mi mathvariant=\"normal\">∥</mi><mi mathvariant=\"normal\">∥</mi><mi>y</mi><mi mathvariant=\"normal\">∥</mi></mrow><annotation encoding=\"application/x-tex\">|\\langle x ,y \\rangle | = |\\langle U x, U y \\rangle | \\leq \\| U x \\| \\| U y\\|  = \\|x\\| \\|y\\|</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">⟩</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">⟩</span><span class=\"mord\">∣</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">∥</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">∥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\">x</span><span class=\"mord\">∥</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord\">∥</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is the isometry? Perhaps many of the theorems can be recovered this way.</p>\n</blockquote>\n<p>Perhaps, but the theorems I am thinking about are simple calculational things that can be stated but possibly not proved in a generic way. We want these to be easy to apply without constructing some embedding to <code>complex</code> all the time</p>",
        "id": 198843182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590545358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Complex.20inner.20product/near/198842278\">said</a>:</p>\n<blockquote>\n<p>How about: a field with a conjugation such that the fixpoints of the conjugation form a complete ordered field</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> did you look at my code above? I drop the completeness, because I use hermitian forms over number fields</p>",
        "id": 198850747,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590557380
    },
    {
        "content": "<p>The nice thing about such a characterization is that there are obvious ways to weaken it when you don't need some properties like completeness. I would guess that for most algebraic properties of hilbert spaces you don't need completeness, but there are certainly theorems that need the vector space to be topologically complete, and it's not clear to me how often the scalar field also needs to be complete.</p>",
        "id": 198850972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590557730
    },
    {
        "content": "<p>In metamath we have a \"pre-Hilbert space\" which has all the structure of a Hilbert space but not the completeness requirements</p>",
        "id": 198851045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590557801
    },
    {
        "content": "<p>I forget if this is the same thing as an \"inner product space\"</p>",
        "id": 198851050,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590557827
    },
    {
        "content": "<p>Ah yes, a <a href=\"http://us.metamath.org/mpeuni/df-phl.html\">\"generalized pre-Hilbert space\", a.k.a inner product space</a> is a left module over a star-division-ring with an inner product that satisfies the usual rules</p>",
        "id": 198851195,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590558028
    },
    {
        "content": "<p>Metamath has the <a href=\"http://us.metamath.org/mpeuni/polid2i.html\">polarization identity</a>, but only for hilbert spaces over C, and the statement of the theorem explicitly uses <code>i</code> so it's not clear what the generalization is supposed to be</p>",
        "id": 198851373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590558331
    },
    {
        "content": "<p>The real polarization identity is &lt;f,g&gt; = (||f+g||^2 - ||f-g||^2)/4. But the formula itself often doesn't matter: you just need the observation that the inner product is determined by the norm. Maybe there are some intermediate situations where knowing that the inner product is <em>some</em> linear combination of norm-squareds of linear functions of the inputs is good enough too?</p>",
        "id": 198851900,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590558987
    },
    {
        "content": "<p>Oh interesting. <a href=\"http://us.metamath.org/mpeuni/polidi.html\">this version</a> looks closer to that but there are some additional terms:</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⟨</mo><mi>f</mi><mo separator=\"true\">,</mo><mi>g</mi><mo stretchy=\"false\">⟩</mo><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∥</mi><mi>f</mi><mo>+</mo><mi>g</mi><msup><mi mathvariant=\"normal\">∥</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant=\"normal\">∥</mi><mi>f</mi><mo>−</mo><mi>g</mi><msup><mi mathvariant=\"normal\">∥</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo>+</mo><mi>i</mi><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">∥</mi><mi>f</mi><mo>+</mo><mi>i</mi><mi>g</mi><msup><mi mathvariant=\"normal\">∥</mi><mn>2</mn></msup><mo>−</mo><mi mathvariant=\"normal\">∥</mi><mi>f</mi><mo>−</mo><mi>i</mi><mi>g</mi><msup><mi mathvariant=\"normal\">∥</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\langle f,g\\rangle = \\frac14 [(\\|f+g\\|^2 - \\|f-g\\|^2) + i(\\|f+ig\\|^2-\\|f-ig\\|^2)]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⟨</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">⟩</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">4</span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\">1</span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">[</span><span class=\"mopen\">(</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\">∥</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\">∥</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mopen\">(</span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\">∥</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∥</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord\"><span class=\"mord\">∥</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mclose\">]</span></span></span></span></span></p>",
        "id": 198852192,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590559365
    },
    {
        "content": "<p>perhaps there is some reason the latter two terms cancel on some additional assumption about the inner product</p>",
        "id": 198852216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590559395
    },
    {
        "content": "<p>The real inner product is the real part of the complex inner product (if you go from complex to real).</p>",
        "id": 198852998,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1590560169
    },
    {
        "content": "<p>/me wonders which meaning of \"real\" Scott meant</p>",
        "id": 198853194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590560347
    },
    {
        "content": "<p>I guess he meant real inner product space. You can complexify it (new vectors are <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>+</mo><mi>i</mi><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">f+ig</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span>), then apply the complex result, then use the fact that the original inner product was real.</p>",
        "id": 198853421,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1590560609
    },
    {
        "content": "<p>One thing that I took away from this thread is that the least we can do is to add a <code>has_star</code> class, which covers complex conjugation, but also the star operator on matrices.</p>",
        "id": 198853511,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590560702
    },
    {
        "content": "<p>And then we can bicker about what the weakest assumptions on a <code>is_R_or_C</code> class should be.</p>",
        "id": 198853540,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1590560732
    },
    {
        "content": "<p>I'm starting to think this project is a bit beyond me, as an analysis person, I'm not even really familiar with what ought to be formalized in this generality.</p>",
        "id": 198880036,
        "sender_full_name": "Keefer Rowan",
        "timestamp": 1590580038
    },
    {
        "content": "<p>It is true that in the study of unitary groups, number theorists definitely need sesquilinear forms defined in number field situations. But this shouldn't be stopping an analyst from formalising Hilbert spaces. What is going on here? What is missing?</p>",
        "id": 198880132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590580104
    },
    {
        "content": "<p>My suggestion for a first pass is to do \"trivial generalization\" from what you know about complex inner product spaces. Use a general field or division ring, but make it C in your head and just ignore the fact that it is more general than that. Whenever a theorem fails to hold, add an assumption to make it hold</p>",
        "id": 198880282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1590580248
    },
    {
        "content": "<p>Sorry, <span class=\"user-mention\" data-user-id=\"300684\">@Keefer Rowan</span>, you also shouldn't take our bikeshedding over the generality too seriously.</p>",
        "id": 198880416,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590580326
    },
    {
        "content": "<p>Right, this is what I'm saying. There are some issues here but I don't understand why it should affect Keefer</p>",
        "id": 198880464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590580359
    },
    {
        "content": "<p>In my experience an excellent way to get the generality right is to first get it wrong, thereby inspiring someone to take a second pass.</p>",
        "id": 198880471,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1590580362
    },
    {
        "content": "<p>i.e. just ignore all this stuff and write the code anyway</p>",
        "id": 198880497,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1590580388
    },
    {
        "content": "<p>Hi,</p>\n<p>It turns out that I got started on this exact project to start learning Lean and I just found this thread now that I got far enough for it to potentially turn it into a PR someday. I basically followed the approach that Keefer was proposing initially: just copy real_inner_product.lean into complex_inner_product.lean and get going. So far the result is basically what you'd expect: the awkward duplication with the real case, the lack of connection with the existing sesquilinear form code (that I only discovered when I almost done), and coded by an obvious beginner.</p>\n<p>Anyway, in case anybody is interested, I put it on github here:<br>\n<a href=\"https://github.com/dupuisf/mathlib/blob/hilbert/src/analysis/normed_space/complex_inner_product.lean\">https://github.com/dupuisf/mathlib/blob/hilbert/src/analysis/normed_space/complex_inner_product.lean</a></p>",
        "id": 200795959,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1592101291
    },
    {
        "content": "<p>I should mention that there is a flaw in the current design of the real inner product space (you can not put an instance on reals, because this leads to two norms which are not seen as the same norm by Lean kernel, which creates a lot of issue). This is fixed in <a href=\"https://github.com/leanprover-community/mathlib/issues/3060\">#3060</a>.</p>",
        "id": 200804710,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1592120098
    },
    {
        "content": "<p>I just had a look -- that clears up some questions I had while writing this... In any case, it would be nice to have a plan to get to the complex case. I guess the options would be (1) basically port this fix to the code I wrote, i.e. have a complex_inner_product.lean file that mostly duplicates the real case, (2) build it on top of sesquilinear products, but still independently from the real case, or (3) try to find a suitable generalization that works for both the real and complex case. Probably (3) would be best if we could find something that's not too awkward...</p>",
        "id": 200847140,
        "sender_full_name": "Frédéric Dupuis",
        "timestamp": 1592193125
    }
]
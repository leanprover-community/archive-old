[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span> and <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> I spend two days trying to work with the linear algebra and affine geometry library but it's 100% suffering. Everything around linear independence, bases, affine independence... can be expressed in terms of indexed families, sets, finsets, subtypes and it's a nightmare when there is more than only set/family involved, especially when I want to extend of modify a family. I don't know if it means the API lacks millions of lemmas to go back and forth between various representations, or there is a secret way to consistently use the right one and switch only at the beginning and end of  proofs.</p>\n<p>For instance, I'd need something like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">affine_space</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">finite_dimensional</span> <span class=\"n\">set</span>\n\n<span class=\"kn\">variables</span>  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>  <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n           <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">fin</span> <span class=\"o\">(</span><span class=\"n\">findim</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">q</span> <span class=\"bp\">∧</span> <span class=\"n\">range</span> <span class=\"n\">p</span> <span class=\"err\">⊆</span> <span class=\"n\">range</span> <span class=\"n\">q</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>I tried to define intermediate stuff like </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">def</span> <span class=\"n\">affine_independent_set</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">i</span> <span class=\"bp\">//</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span>\n\n<span class=\"kn\">example</span>  <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">affine_independent_set</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">S</span> <span class=\"err\">⊆</span> <span class=\"n\">T</span> <span class=\"bp\">∧</span> <span class=\"n\">affine_independent_set</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">T</span> <span class=\"bp\">∧</span> <span class=\"n\">affine_span</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">T</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">affine_independent_set</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">h&#39;</span> <span class=\"o\">:</span> <span class=\"n\">affine_span</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"err\">↑</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">S</span><span class=\"bp\">.</span><span class=\"n\">card</span> <span class=\"bp\">=</span> <span class=\"n\">findim</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>but everything seem <em>so</em> painful. Do you have any advice?</p>",
        "id": 206353687,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596902903
    },
    {
        "content": "<p>For instance, the things I tried to glue are <a href=\"https://leanprover-community.github.io/mathlib_docs/find/exists_subset_is_basis\">docs#exists_subset_is_basis</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/affine_independent_iff_linear_independent_vsub\">docs#affine_independent_iff_linear_independent_vsub</a></p>",
        "id": 206353892,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596903192
    },
    {
        "content": "<p>I've found that generally manipulating subtypes, and manipulating sums when there are multiple subtypes and finsets involved, is painful. That's why <code>affine_independent_iff_linear_independent_vsub</code> has a long proof with essentially no mathematical content, it needs to convert between sums over (a finset of) ι and sums over (a finset of) a subtype of all but one value of ι.</p>\n<p>My guess is that for your intermediate result using <code>affine_independent_set</code>, it would be helpful to prove a version of <code>affine_independent_iff_linear_independent_vsub</code> that relates <code>affine_independent_set</code> on a set of points to <code>linear_independent</code> for the identity map on a set of vectors (i.e. <code>linear_independent</code> in exactly the form used by <code>exists_subset_is_basis</code>). There's a bijection between the index type you'd get from <code>affine_independent_iff_linear_independent_vsub</code> when using a set (a subtype of points) and the one you'd need for <code>exists_subset_is_basis</code> (a subtype of vectors), given in one direction by <code>vadd_const</code> composed on either side with the manipulations needed to go between type and subtype, so it should be possible to use injectivity plus <code>linear_independent.comp</code> to go between linear independence of the same vectors with the two different index types. There will still be quite a lot of fiddling around with subtypes involved, but hopefully you don't actually need to get into explicit summation over the different types.</p>",
        "id": 206355440,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596905756
    },
    {
        "content": "<p>Thanks for your answer Joseph. Too bad it confirms what I feared. There must be a better way. Again we should probably have a look at what other libraries do.</p>",
        "id": 206360979,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596915377
    },
    {
        "content": "<p>I guess look at how other systems handle this sort of moving between types and subtypes, and between two types related by an injection or bijection, since that's where most of the pain seems to come from.</p>",
        "id": 206361738,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596916559
    },
    {
        "content": "<p>This is probably very different in Isabelle or Mizar, but people using Coq have almost certainly met those issues ten years ago.</p>",
        "id": 206361789,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596916643
    },
    {
        "content": "<p>We can use <code>finset</code>s, then we won't need <code>subtype</code>s.</p>",
        "id": 206363494,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1596919677
    },
    {
        "content": "<p>finset don't even have a coercion to Sort, which makes them even more painful to convert to indexed families.</p>",
        "id": 206364011,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596920734
    },
    {
        "content": "<p>The main definitions of <code>linear_independent</code> and <code>affine_independent</code> use indexed families (for good reason, it's desirable to be able to talk about a family with multiple identical vectors not being linearly independent). Using a subtype in some way thus seems unavoidable when relating <code>affine_independent</code> to <code>linear_independent</code>, because the independent family of vectors is one smaller than the family of points. Unless you complicate the definitions so they aren't \"this family is independent\" but \"the subset of this family given by this subset of the index type is independent\", I suppose.</p>",
        "id": 206364113,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596920896
    },
    {
        "content": "<p>What would be good to avoid is all the tedious fiddling around with trivialities that results from involving subtypes.</p>",
        "id": 206364131,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596920997
    },
    {
        "content": "<p>I remember someone explaining to me some years ago an argument that it's wrong (in maths, not just in formalization) to say that a basis is a \"set\" of vectors with certain properties, because sets go wrong there as soon as you do any manipulations that might involve two vectors being or becoming equal. (I think he was arguing for \"multiset\" as the right thing to use, but in Lean it seems to be \"indexed family\".)</p>",
        "id": 206364290,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596921252
    },
    {
        "content": "<p>My first guess would be to make the primitive notion \"this family of sets is linear/affine independent on this subset of <code>\\i</code>\":</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"n\">def</span> <span class=\"n\">my_affine_independent</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"n\">t</span> <span class=\"err\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">k</span><span class=\"o\">),</span> <span class=\"err\">∑</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span> <span class=\"n\">t</span><span class=\"bp\">.</span><span class=\"n\">weighted_vsub</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">w</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span> <span class=\"bp\">→</span>\n  <span class=\"bp\">∀</span> <span class=\"n\">i</span> <span class=\"err\">∈</span> <span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">w</span> <span class=\"n\">i</span> <span class=\"bp\">=</span> <span class=\"mi\">0</span>\n</code></pre></div>\n\n\n<p>(you could argue whether the domain of <code>p</code> should be <code>\\i</code> or <code>s</code>. I think <code>\\i</code> is more convenient to work with)<br>\nThe fact that you add a set as an argument means you don't have to talk about subtypes, but can talk about subsets, intersections of sets and so on.<br>\nThis also makes it more convenient to formulate Patrick extension problem:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span>  <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">field</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">vector_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n           <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">}</span>\n  <span class=\"o\">(</span><span class=\"n\">hp</span> <span class=\"o\">:</span> <span class=\"n\">my_affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"err\">↑</span><span class=\"o\">(</span><span class=\"n\">findim</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">&lt;</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">ι</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">∧</span> <span class=\"n\">cardinal</span><span class=\"bp\">.</span><span class=\"n\">mk</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"n\">findim</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span> <span class=\"bp\">∧</span> <span class=\"n\">my_affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">p</span> <span class=\"n\">t</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n</code></pre></div>\n\n\n<p>(though maybe the use of <code>cardinal.mk</code> for finite things is not ideal)</p>",
        "id": 206379001,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1596948738
    },
    {
        "content": "<p>Maybe Floris is right, and we could have a notation to handle the case <code>s = univ</code>.</p>",
        "id": 206386335,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596963793
    },
    {
        "content": "<p>In the mean I think I have found a way to bypass the issue. But this is the first time I really feel like dependent types don't allow me to easily express a statement.</p>",
        "id": 206386382,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596963850
    },
    {
        "content": "<p>It makes sense that we try dividing responsibilities between re-indexing a family and taking a subset. Perhaps the <code>∀ (t : finset ι) (w : ι -&gt; k)</code> should be bundled into a <code>finsupp</code>?</p>",
        "id": 206393016,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1596976309
    },
    {
        "content": "<p>Using a <code>finsupp</code> would probably run into the usual issues with there being a much better API for manipulating sums over <code>finset</code>s than those over <code>finsupp</code>s. But there are lemmas relating <code>linear_independent</code> to both <code>finset</code> and <code>finsupp</code>, so if <code>finsupp</code> helps here you can always use a different lemma to get it.</p>\n<p>As it turns out, a proof of the version of <code>affine_independent_iff_linear_independent_vsub</code> for sets (which should be usable with <code>exists_subset_is_basis</code>) is short, but painful to write because it involves dealing with a subtype of a subtype.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">affine_space</span><span class=\"bp\">.</span><span class=\"n\">independent</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">add_torsor</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">add_torsor</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">G</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">add_group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_torsor</span> <span class=\"n\">G</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">vsub_left_injective</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p1</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">p2</span> <span class=\"n\">p3</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">vsub_left_cancel</span> <span class=\"n\">G</span> <span class=\"n\">h</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">add_torsor</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">add_action</span> <span class=\"n\">add_torsor</span> <span class=\"n\">affine_space</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">add_comm_group</span> <span class=\"n\">V</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"n\">k</span> <span class=\"n\">V</span><span class=\"o\">]</span>\n<span class=\"kn\">variables</span> <span class=\"o\">[</span><span class=\"n\">affine_space</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- A set is affinely independent if and only if the differences from</span>\n<span class=\"cm\">a base point in that set are linearly independent. -/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">affine_independent_set_iff_linear_independent_vsub</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"o\">{</span><span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hp1</span> <span class=\"o\">:</span> <span class=\"n\">p1</span> <span class=\"err\">∈</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">↔</span>\n    <span class=\"n\">linear_independent</span> <span class=\"n\">k</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">p1</span><span class=\"o\">})</span> <span class=\"bp\">→</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">rw</span> <span class=\"n\">affine_independent_iff_linear_independent_vsub</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">⟨</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"n\">hp1</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">p1</span><span class=\"o\">}),</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"err\">∈</span> <span class=\"n\">s</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">p1</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_image_of_injective</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_injective</span> <span class=\"n\">V</span> <span class=\"n\">p1</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"mi\">1</span>\n             <span class=\"o\">((</span><span class=\"n\">vadd_vsub</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">p1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">▸</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">),</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">p1</span><span class=\"o\">})</span> <span class=\"bp\">→</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"bp\">⟨</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"n\">hp1</span><span class=\"bp\">⟩</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨⟨</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"bp\">+</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">mem_of_mem_diff</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n            <span class=\"bp\">λ</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">set</span><span class=\"bp\">.</span><span class=\"n\">not_mem_of_mem_diff</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">vadd_right_cancel</span> <span class=\"n\">p1</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hx</span><span class=\"o\">))))),</span>\n    <span class=\"n\">ext</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">vadd_vsub</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"n\">p1</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n    <span class=\"k\">let</span> <span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">//</span> <span class=\"n\">x</span> <span class=\"bp\">≠</span> <span class=\"bp\">⟨</span><span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"n\">hp1</span><span class=\"bp\">⟩</span><span class=\"o\">}</span> <span class=\"bp\">→</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span> <span class=\"o\">:</span> <span class=\"n\">V</span><span class=\"o\">))</span> <span class=\"err\">&#39;&#39;</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"err\">\\</span> <span class=\"o\">{</span><span class=\"n\">p1</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n      <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"o\">((</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">-</span><span class=\"err\">ᵥ</span> <span class=\"n\">p1</span><span class=\"o\">,</span> <span class=\"bp\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">⟨⟨</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">s</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">property</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">property</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"n\">hx</span><span class=\"o\">)</span><span class=\"bp\">⟩</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"bp\">⟩⟩⟩</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">comp</span> <span class=\"n\">f</span>\n      <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">x1</span> <span class=\"n\">x2</span> <span class=\"n\">hx</span><span class=\"o\">,</span> <span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">vsub_left_cancel</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"n\">subtype</span><span class=\"bp\">.</span><span class=\"n\">ext_iff</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">hx</span><span class=\"o\">))))</span> <span class=\"o\">}</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 206393904,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596977640
    },
    {
        "content": "<p>I've now got the result extending an affine independent set to one that is also spanning. I'll PR once <a href=\"https://github.com/leanprover-community/mathlib/issues/3727\">#3727</a> is in, to avoid introducing more complications to the merges for that PR. Part of the difficulty here is certainly the difficulty of manipulating subtypes, but part is also that the API for affine spaces is still being built out and more lemmas like this still need adding to mathlib. (I don't plan to try to prove the results about finite dimension and cardinality for now.)</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- An affinely independent set of vectors can be extended to such a</span>\n<span class=\"cm\">set that spans the whole space. -/</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">exists_subset_affine_independent_affine_span_eq_top</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">}</span>\n    <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∃</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">P</span><span class=\"o\">,</span> <span class=\"n\">s</span> <span class=\"err\">⊆</span> <span class=\"n\">t</span> <span class=\"bp\">∧</span> <span class=\"n\">affine_independent</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"n\">P</span><span class=\"o\">)</span> <span class=\"bp\">∧</span> <span class=\"n\">affine_span</span> <span class=\"n\">k</span> <span class=\"n\">V</span> <span class=\"n\">t</span> <span class=\"bp\">=</span> <span class=\"err\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"c1\">-- proof omitted here</span>\n</code></pre></div>",
        "id": 206405995,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1596997232
    },
    {
        "content": "<p>Nice! I'm also experimenting (in a slightly different direction), but everything is difficult because cardinal universes come in, as well as the usual inconvenience of finite types.</p>",
        "id": 206406781,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1596998464
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/3794\">#3794</a> has the proof that an affine independent set of points can be extended to one that is spanning.</p>",
        "id": 207027377,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1597507079
    },
    {
        "content": "<p>Great. What is the status of convexity? Is there anything I can do to help?</p>",
        "id": 207028335,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597508609
    },
    {
        "content": "<p>I guess maybe merging master into convex-affine and fixing things up until it builds? (<a href=\"https://github.com/leanprover-community/mathlib/issues/2910\">#2910</a> has a summary of some things that should be done.)</p>",
        "id": 207034857,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1597518743
    },
    {
        "content": "<p>Ok, I'll try to work on this tomorrow.</p>",
        "id": 207037701,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597523040
    },
    {
        "content": "<p>Is there  a way to bookmark threads on Zulip? I ask because the discussion here has information that I want to come back to: roughly speaking that some ways of doing math \"on paper\" when you can hand-wave away all the details doesn't make for a pleasant experience when formalized.  Things like \"finite types\", which are an obvious translation of what is done by hand, seem to end up causing more pain than not.</p>\n<p>I should go through the Lean docs and see what 'conventional-formalization-in-Lean' wisdom you've already accumulated + documented.</p>",
        "id": 207145387,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1597671898
    },
    {
        "content": "<p>you can star messages</p>",
        "id": 207145446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597671937
    },
    {
        "content": "<p>You can also hit <code>S</code> to focus on this stream, and then bookmark it in your browser.</p>",
        "id": 207146128,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597672311
    },
    {
        "content": "<p>I'm using the Zulip desktop app to view this.  <code>S</code> didn't seem to do anything?</p>",
        "id": 207147816,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1597673201
    },
    {
        "content": "<p>Aah, I guess that the second part of my sentence doesn't make sense either, in that case.</p>",
        "id": 207148055,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1597673316
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/116395-maths/topic/linear.20suffering/near/207034857\">said</a>:</p>\n<blockquote>\n<p>I guess maybe merging master into convex-affine and fixing things up until it builds? (<a href=\"https://github.com/leanprover-community/mathlib/issues/2910\">#2910</a> has a summary of some things that should be done.)</p>\n</blockquote>\n<p>I should report on this: I think too many things have changed so to allow merging, but I'll look at it for inspiration. I'm waiting for <a href=\"https://github.com/leanprover-community/mathlib/issues/3728\">#3728</a> to land anyway.</p>",
        "id": 207150301,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1597674487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326322\">Jacques Carette</span> <a href=\"#narrow/stream/116395-maths/topic/linear.20suffering/near/207147816\">said</a>:</p>\n<blockquote>\n<p>I'm using the Zulip desktop app to view this.  <code>S</code> didn't seem to do anything?</p>\n</blockquote>\n<p>It's <code>Ctrl-S</code> for me.</p>",
        "id": 207151273,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1597674963
    },
    {
        "content": "<p>the keyboard shortcuts in the Zulip app can be accessed with by clicking the cog in the top right and then selecting keyboard shortcuts. Perhaps the shortcuts are OS-dependent?</p>",
        "id": 207151407,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597675042
    },
    {
        "content": "<p>On linux narrow-to-stream is S and star message is Ctrl-S</p>",
        "id": 207151459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1597675076
    },
    {
        "content": "<p>wait. I misunderstood Jacques' message. It's the same for me <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 207151587,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1597675140
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"326322\">@Jacques Carette</span>  If you're viewing \"All messages\" then pressing <code>S</code> will focus to the stream that the message highlighted is in.</p>",
        "id": 207151748,
        "sender_full_name": "Shing Tak Lam",
        "timestamp": 1597675227
    },
    {
        "content": "<p>Ah, I see.  I'm actually navigating to each of the streams one-by-one. It lets me more easily catch up (and also mark-read the ones I am not interested in).</p>",
        "id": 207152227,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1597675479
    },
    {
        "content": "<p>You can do that navigation automatically with <code>n</code></p>",
        "id": 207153327,
        "sender_full_name": "Reid Barton",
        "timestamp": 1597676074
    }
]
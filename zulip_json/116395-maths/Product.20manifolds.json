[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267205\">@Nicol√≤ Cavalleri</span> has just told me about a problem he met when defining product manifolds, and I would like to hear opinions on this. Currently, a charted space <code>M</code> with model <code>H</code> is a set of local charts from <code>M</code> to <code>H</code> covering the space. Every space is registered as a charted space over itself, using the only chart <code>id</code>, in <code>charted_space_self</code>. You can also define a product of charted space <code>M</code> and <code>M'</code> (with model space <code>H \\times H'</code>) by taking the products of the charts. Now, on <code>H \\times H'</code>, you have two charted space structures with model space <code>H \\times H'</code> itself, the one coming from <code>charted_space_self</code>, and the one coming from the product of the two <code>charted_space_self</code> on each component. They are equal, but not defeq (because the product of <code>id</code> and <code>id</code> is not defeq to <code>id</code>), which is bad as we know. </p>\n<p>I don't see how to solve this cleanly: forgetful inheritance is not really relevant, and both instances are important (you definitely want to think of a vector space as a manifold over itself, and also you want to be able to talk of product manifolds). Thoughts welcome!</p>",
        "id": 202357475,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593459080
    },
    {
        "content": "<p>Would it help if we use a type synonym for the model?</p>",
        "id": 202358738,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459699
    },
    {
        "content": "<p>So that a vector space <code>V</code> has model <code>model V</code></p>",
        "id": 202358764,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459716
    },
    {
        "content": "<p>And then <code>V √ó V'</code> is a manifold over <code>(model V) √ó (model V')</code> and over <code>model (V √ó V')</code>.</p>",
        "id": 202358855,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459755
    },
    {
        "content": "<p>Wait... I need type signatures.</p>",
        "id": 202358891,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459780
    },
    {
        "content": "<p>The model is an explicit parameter, right?</p>",
        "id": 202358909,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459792
    },
    {
        "content": "<p>That's a good idea. It seems cheaper to do it for products, though: the model space for <code>M \\times M'</code> could be <code>model_prod H H'</code>.</p>",
        "id": 202358948,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593459827
    },
    {
        "content": "<p>Aha, that's probably even better.</p>",
        "id": 202359100,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593459898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> <a href=\"#narrow/stream/116395-maths/topic/Product.20manifolds/near/202358948\">said</a>:</p>\n<blockquote>\n<p>That's a good idea. It seems cheaper to do it for products, though: the model space for <code>M \\times M'</code> could be <code>model_prod H H'</code>.</p>\n</blockquote>\n<p>Well renaming that for products seems to break this definition:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c\">/-</span><span class=\"cm\">- The product of two smooth manifolds with corners is naturally a smooth manifold with corners. -/</span>\n<span class=\"kn\">instance</span> <span class=\"n\">prod_smooth_manifold_with_corners</span> <span class=\"o\">{</span><span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E&#39;</span><span class=\"o\">]</span>\n  <span class=\"o\">{</span><span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">)</span>\n  <span class=\"o\">{</span><span class=\"n\">H&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">H&#39;</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I&#39;</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E&#39;</span> <span class=\"n\">H&#39;</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">M&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">topological_space</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">charted_space</span> <span class=\"n\">H&#39;</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I&#39;</span> <span class=\"n\">M&#39;</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">smooth_manifold_with_corners</span> <span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">prod</span> <span class=\"n\">I&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span><span class=\"bp\">√ó</span><span class=\"n\">M&#39;</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span>\n  <span class=\"n\">compatible</span> <span class=\"o\">:=</span>\n  <span class=\"k\">begin</span>\n    <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">rintros</span> <span class=\"bp\">‚ü®</span><span class=\"n\">f1</span><span class=\"o\">,</span> <span class=\"n\">hf1</span><span class=\"o\">,</span> <span class=\"n\">f2</span><span class=\"o\">,</span> <span class=\"n\">hf2</span><span class=\"o\">,</span> <span class=\"n\">hf</span><span class=\"bp\">‚ü©</span> <span class=\"bp\">‚ü®</span><span class=\"n\">g1</span><span class=\"o\">,</span> <span class=\"n\">hg1</span><span class=\"o\">,</span> <span class=\"n\">g2</span><span class=\"o\">,</span> <span class=\"n\">hg2</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"bp\">‚ü©</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">hf</span><span class=\"o\">,</span> <span class=\"n\">hg</span><span class=\"o\">,</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">prod_symm</span><span class=\"o\">,</span> <span class=\"n\">local_homeomorph</span><span class=\"bp\">.</span><span class=\"n\">prod_trans</span><span class=\"o\">],</span>\n    <span class=\"k\">have</span> <span class=\"n\">h1</span> <span class=\"o\">:=</span> <span class=\"n\">has_groupoid</span><span class=\"bp\">.</span><span class=\"n\">compatible</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"err\">‚ä§</span> <span class=\"n\">I</span><span class=\"o\">)</span> <span class=\"n\">hf1</span> <span class=\"n\">hg1</span><span class=\"o\">,</span>\n    <span class=\"k\">have</span> <span class=\"n\">h2</span> <span class=\"o\">:=</span> <span class=\"n\">has_groupoid</span><span class=\"bp\">.</span><span class=\"n\">compatible</span> <span class=\"o\">(</span><span class=\"n\">times_cont_diff_groupoid</span> <span class=\"err\">‚ä§</span> <span class=\"n\">I&#39;</span><span class=\"o\">)</span> <span class=\"n\">hf2</span> <span class=\"n\">hg2</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">times_cont_diff_groupoid_prod</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n<span class=\"o\">}</span>\n</code></pre></div>\n\n\n<p>with this error:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">failed</span> <span class=\"n\">to</span> <span class=\"n\">synthesize</span> <span class=\"n\">type</span> <span class=\"n\">class</span> <span class=\"kn\">instance</span> <span class=\"n\">for</span>\n<span class=\"err\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_7</span> <span class=\"o\">:</span> <span class=\"n\">nondiscrete_normed_field</span> <span class=\"err\">ùïú</span><span class=\"o\">,</span>\n<span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_8</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_9</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">,</span>\n<span class=\"n\">E&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_10</span> <span class=\"o\">:</span> <span class=\"n\">normed_group</span> <span class=\"n\">E&#39;</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_11</span> <span class=\"o\">:</span> <span class=\"n\">normed_space</span> <span class=\"err\">ùïú</span> <span class=\"n\">E&#39;</span><span class=\"o\">,</span>\n<span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_12</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E</span> <span class=\"n\">H</span><span class=\"o\">,</span>\n<span class=\"n\">H&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_13</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">H&#39;</span><span class=\"o\">,</span>\n<span class=\"n\">I&#39;</span> <span class=\"o\">:</span> <span class=\"n\">model_with_corners</span> <span class=\"err\">ùïú</span> <span class=\"n\">E&#39;</span> <span class=\"n\">H&#39;</span><span class=\"o\">,</span>\n<span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_14</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_15</span> <span class=\"o\">:</span> <span class=\"n\">charted_space</span> <span class=\"n\">H</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_16</span> <span class=\"o\">:</span> <span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n<span class=\"n\">M&#39;</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"err\">?</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_17</span> <span class=\"o\">:</span> <span class=\"n\">topological_space</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_18</span> <span class=\"o\">:</span> <span class=\"n\">charted_space</span> <span class=\"n\">H&#39;</span> <span class=\"n\">M&#39;</span><span class=\"o\">,</span>\n<span class=\"bp\">_</span><span class=\"n\">inst_19</span> <span class=\"o\">:</span> <span class=\"n\">smooth_manifold_with_corners</span> <span class=\"n\">I&#39;</span> <span class=\"n\">M&#39;</span>\n<span class=\"err\">‚ä¢</span> <span class=\"n\">charted_space</span> <span class=\"o\">(</span><span class=\"n\">H</span> <span class=\"bp\">√ó</span> <span class=\"n\">H&#39;</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">√ó</span> <span class=\"n\">M&#39;</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>that seems to require naturally the charted space built on the product of both the model spaces and the charts, even if I think I never mentioned <code>H \\times H'</code> anywhere in the manifold file. (I am not too sure why as I did not look to closely into the details of models with corners).<br>\nIn case we adjust it, just to know, is it cheaper for products in terms of amount of code to be rewritten or like computationally? The cool thing about the product is that notationally everything involved in the product is written as a product and a lot of symmetric lemmas like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">chart_of_prod_eq_prod_of_charts_coe</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">chart_at</span> <span class=\"o\">(</span><span class=\"n\">H</span><span class=\"bp\">√ó</span><span class=\"n\">H&#39;</span><span class=\"o\">)</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">√ó</span> <span class=\"n\">M&#39;</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">H</span> <span class=\"bp\">√ó</span> <span class=\"n\">H&#39;</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">chart_at</span> <span class=\"n\">H</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">chart_at</span> <span class=\"n\">H&#39;</span> <span class=\"n\">x</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">))</span>\n</code></pre></div>\n\n\n<p>become notationally quite dirty!</p>",
        "id": 202375209,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1593469402
    },
    {
        "content": "<p>I will defer to <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> ...<br>\nI haven't had time to dive into the details of this part of the library yet.</p>",
        "id": 202394882,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1593491733
    },
    {
        "content": "<p>Yes, things will need fixing after this change, but it's worth it. I can take care of it, if you give me access to your files.</p>",
        "id": 202397056,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593495037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span>  I am having some problems with this new definition of <code>model_prod</code>. The first problem is directly connected to it: it broke my definition of <code>prod_Lie_group</code>. I do not understand why the library keeps requiring instances built on <code>H \\times H'</code>even after you replaced everything with <code>model_prod</code>. I uploaded everything on a branch of Mathlib if you want to have a look: <a href=\"https://github.com/leanprover-community/mathlib/tree/Lie_groups/src/geometry\">https://github.com/leanprover-community/mathlib/tree/Lie_groups/src/geometry</a><br>\nThe second problem is in the second point below.</p>\n<p>In this light I am still wondering why was it a good idea to use the synonym for products instead that for <code>charted_space_self</code>. I am clearly a newbie here so I don't want to question your choice, but I'd be very curious just to know the reason behind it. To me (again, a complete newbie) there's two big cons:</p>\n<ul>\n<li>it looks to me that the theory of smooth manifolds over R^n is very common, in that the basics are taught in every undergraduate course in physics and maths worldwide, whereas the theory of general charted spaces is less common: I did Part III in geometry but if I have to be sincere it is the first time I hear the term \"charted spaces\". For this reason I believe that newbies who will start working with the library in the future will almost surely encounter and use the instance of product manifolds many times, whereas the instance <code>charted_space_self</code> that is much more technical might remain buried under the whole math build upon it and people might never encounter it and need to use it (I mean I don't know but I never used it in my definitions up to now). This means that, provided that in both cases things will require adjustments every time they are used, as it looks to be the case, people who will use the geometry section of the library will first of all need to know and learn these technicalities about the library in order to use it, whereas, again, in the other case they probably won't need to learn the details of the library too much as <code>charted_space_self</code> might not be needed again. Hence, people who are not Lean expert will need to rely on your help each time to ask you for adjustments as I am doing now (whereas before I was able to state these particular definitions without asking your help) therefore loosing independence and making you loose time.</li>\n<li>Secondly goals in results that use product manifolds become more technical and cryptic and it's harder, for who does not know Lean well,  to understand if sometimes Lean does not recognize things because this <code>model_prod</code> is being used or if the problem is elsewhere. Take for example the lemma <code>tangent_bundle_proj_smooth</code> in the file constructions that I put in this branch <code>Lie_groups</code> the last simp does not simplify terms of the form</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"o\">(</span><span class=\"n\">x_1</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">√ó</span> <span class=\"n\">E</span><span class=\"o\">),</span> <span class=\"err\">‚áë</span><span class=\"o\">((</span><span class=\"n\">chart_at</span> <span class=\"o\">(</span><span class=\"n\">model_prod</span> <span class=\"n\">H</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">x</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"err\">‚áë</span><span class=\"o\">(</span><span class=\"n\">I</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">)</span> <span class=\"n\">x_1</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span> <span class=\"n\">x_1</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>by breaking up <code>(chart_at (model_prod H E) x)</code> as the apposite simp lemma requires, and I do not understand if in this case it is because the normal simp lemmas do not imply that the coercions should get simplified (as it looks it should however be the case from what you told me in the last PR we made together), or if it is <code>model_prod</code> that is creating problems. Again, I guess this kind of problems would be there also with the other synonym, but again I guess people would encounter it much less frequently.</p>\n<p>Let me know what you think</p>",
        "id": 202873623,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1593868824
    },
    {
        "content": "<p>We have to introduce a type synonym to avoid typeclass issues. The idea is to insert it where it is least annoying, i.e., where people will encounter it less often. I have the impression that product manifolds will appear way less often than <code>charted_space_self</code>, which is why I introduced the type synonym on product manifolds. Indeed, whenever you speak of a smooth function from a vector space to a manifold or conversely, you are using a manifold structure on the vector space, which is precisely <code>charted_space_self</code>. And this happens all the time! (for instance when saying that charts are smooth).</p>\n<p>Of course, we should also make sure that working with product manifolds is as easy as possible. The library is just in its infancy in this direction (you have only introduced them in the last PR), so there are still a lot of rough edges, that we will hopefully be able to smoothen. I will have a look at tour branch.</p>",
        "id": 202875322,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593871705
    },
    {
        "content": "<p>Sorry where is <code>charted_space_self</code> introduced in the library? I cannot find it! (VScode tells me it does not exist)</p>",
        "id": 202875943,
        "sender_full_name": "Nicol√≤ Cavalleri",
        "timestamp": 1593872741
    },
    {
        "content": "<p>Woops, that's the name in the version on my computer, not yet PRed to mathlib. In current mathlib, it is still named <code>manifold_model_space</code>.</p>",
        "id": 202878322,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1593876331
    }
]
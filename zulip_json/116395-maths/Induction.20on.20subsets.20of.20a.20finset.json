[
    {
        "content": "<p>Is there a way to do induction on subsets of a finset? Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 217570612,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606079912
    },
    {
        "content": "<p>This works:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">tactic</span>\n\n<span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">q</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n    <span class=\"n\">apply</span> <span class=\"n\">this</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">refl</span><span class=\"o\">),</span>\n  <span class=\"k\">have</span> <span class=\"n\">hq₁</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"bp\">∅</span><span class=\"o\">,</span>\n    <span class=\"n\">rintro</span> <span class=\"bp\">-</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h₁</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">finset.induction</span> <span class=\"n\">hq₁</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hqs</span><span class=\"o\">,</span>\n  <span class=\"n\">rintro</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">h₂</span> <span class=\"n\">has</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hqs</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">finset.subset.trans</span> <span class=\"n\">_</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset.subset_insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset.mem_insert_self</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">refine</span> <span class=\"n\">finset.subset.trans</span> <span class=\"n\">_</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">finset.subset_insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n<p>and I'm sure it can be golfed. The idea is to beef <code>p</code> up into a predicate <code>q</code> which is true for all finsets and then prove it by the finset induction lemma in mathlib. Might be worth a PR if you can tidy up the proof a bit?</p>",
        "id": 217573629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606084147
    },
    {
        "content": "<p>that seems like a decent way to do it. I was trying to do it by working on <code>finset (subtype (λ x, x ∈ S))</code>, but it wasn't pretty</p>",
        "id": 217573897,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606084529
    },
    {
        "content": "<p>An analogous question came up recently (Eric, Reid and I were talking about some induction principle for submodules) and the same sort of idea worked there, that's why I went for it first on this occasion.</p>",
        "id": 217573950,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606084586
    },
    {
        "content": "<p>I have really got into the habit of using <code>apply</code> to take shortcuts (why use <code>refine h _ _</code> when you can just <code>apply h</code>?) but actually I am now coming back to <code>refine</code>. Lean's unifier works best if it knows exactly what goal it is supposed to be proving. If you turn the <code>apply</code>s into <code>refine</code>s by inserting the appropriate <code>_</code>s then you will be able to compress this a bunch.</p>",
        "id": 217574029,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606084731
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"k\">let</span> <span class=\"n\">q</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">T</span><span class=\"o\">,</span>\n  <span class=\"k\">suffices</span> <span class=\"o\">:</span> <span class=\"n\">q</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">this</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">S</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n  <span class=\"n\">apply</span> <span class=\"n\">finset.induction_on</span> <span class=\"n\">S</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span> <span class=\"o\">},</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hqs</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">h₂</span> <span class=\"n\">has</span> <span class=\"o\">(</span><span class=\"n\">hqs</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 217574341,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606085180
    },
    {
        "content": "<p>should I PR it?</p>",
        "id": 217574369,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606085250
    },
    {
        "content": "<p>I think you can combine the suffices and the let</p>",
        "id": 217574371,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606085256
    },
    {
        "content": "<p>The similar lemma Kevin is referring to is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/submonoid.closure_induction'\">docs#submonoid.closure_induction'</a></p>",
        "id": 217574416,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606085297
    },
    {
        "content": "<p>Before I PR, what's preferable for mathlib: The above tactic mode proof of this term mode proof?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">finset.induction_on</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hqs</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">h₂</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">1</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span>\n  <span class=\"n\">has</span> <span class=\"o\">(</span><span class=\"n\">hqs</span> <span class=\"o\">(</span><span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)))</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 217574597,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606085610
    },
    {
        "content": "<p><code>finset</code> was mostly written by Mario and I can guess what he'd prefer, from <code>induction</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[elab_as_eliminator]</span>\n<span class=\"kn\">protected</span> <span class=\"kd\">theorem</span> <span class=\"n\">induction</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">⦄</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">p</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"o\">⟨</span><span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">nd</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">multiset.induction_on</span> <span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">IH</span> <span class=\"n\">nd</span><span class=\"o\">,</span> <span class=\"kd\">begin</span>\n    <span class=\"n\">cases</span> <span class=\"n\">nodup_cons.1</span> <span class=\"n\">nd</span> <span class=\"k\">with</span> <span class=\"n\">m</span> <span class=\"n\">nd'</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">←</span> <span class=\"o\">(</span><span class=\"n\">eq_of_veq</span> <span class=\"n\">_</span> <span class=\"o\">:</span> <span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">finset.mk</span> <span class=\"n\">s</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">⟨</span><span class=\"n\">a</span> <span class=\"o\">::</span><span class=\"bp\">ₘ</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">nd</span><span class=\"o\">⟩)],</span>\n    <span class=\"o\">{</span> <span class=\"n\">exact</span> <span class=\"n\">h₂</span> <span class=\"o\">(</span><span class=\"kd\">by</span> <span class=\"n\">exact</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">IH</span> <span class=\"n\">nd'</span><span class=\"o\">)</span> <span class=\"o\">},</span>\n    <span class=\"o\">{</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">insert_val</span><span class=\"o\">,</span> <span class=\"n\">ndinsert_of_not_mem</span> <span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n  <span class=\"kd\">end</span><span class=\"o\">)</span> <span class=\"n\">nd</span>\n</code></pre></div>",
        "id": 217574769,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606085826
    },
    {
        "content": "<p>Oh actually that is mostly tactic mode :-) But I'd say the term mode proof. It's not like that there's anything mathematically complex going on. Why not <code>set_option profiler true</code> and see if the term mode version is faster?</p>",
        "id": 217574840,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606085900
    },
    {
        "content": "<p>You can golf it a bit more by pattern matching <code>finset.insert_subset.1 hs</code></p>",
        "id": 217574842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606085914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Induction.20on.20subsets.20of.20a.20finset/near/217574842\">said</a>:</p>\n<blockquote>\n<p>You can golf it a bit more by pattern matching <code>finset.insert_subset.1 hs</code></p>\n</blockquote>\n<p>I can't quite see how to do it. What's the trick?</p>",
        "id": 217574881,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606086001
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>elaboration of induction_on'_tactic took 32.1ms\nelaboration of induction_on'_term took 4.68ms\n</code></pre></div>\n<p>A huge difference, in some sense.</p>",
        "id": 217574946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086051
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">finset.induction_on</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hqs</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">hS</span><span class=\"o\">,</span> <span class=\"n\">sS</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span> <span class=\"k\">in</span> <span class=\"bp\">@</span><span class=\"n\">h₂</span> <span class=\"n\">a</span> <span class=\"n\">hS</span> <span class=\"n\">s</span> <span class=\"n\">sS</span> <span class=\"n\">has</span> <span class=\"o\">(</span><span class=\"n\">hqs</span> <span class=\"n\">sS</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 217574967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606086087
    },
    {
        "content": "<p>I would also change the implicit binders a bit:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">theorem</span> <span class=\"n\">induction_on'</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">decidable_eq</span> <span class=\"n\">α</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"bp\">∅</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">∈</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">s</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">∉</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">s</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">insert</span> <span class=\"n\">a</span> <span class=\"n\">s</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"bp\">@</span><span class=\"n\">finset.induction_on</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">T</span><span class=\"o\">,</span> <span class=\"n\">T</span> <span class=\"bp\">⊆</span> <span class=\"n\">S</span> <span class=\"bp\">→</span> <span class=\"n\">p</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"n\">S</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">_</span><span class=\"o\">,</span> <span class=\"n\">h₁</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">s</span> <span class=\"n\">has</span> <span class=\"n\">hqs</span> <span class=\"n\">hs</span><span class=\"o\">,</span>\n  <span class=\"k\">let</span> <span class=\"o\">⟨</span><span class=\"n\">hS</span><span class=\"o\">,</span> <span class=\"n\">sS</span><span class=\"o\">⟩</span> <span class=\"o\">:=</span> <span class=\"n\">finset.insert_subset.1</span> <span class=\"n\">hs</span> <span class=\"k\">in</span> <span class=\"n\">h₂</span> <span class=\"n\">hS</span> <span class=\"n\">sS</span> <span class=\"n\">has</span> <span class=\"o\">(</span><span class=\"n\">hqs</span> <span class=\"n\">sS</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">finset.subset.refl</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 217575071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606086197
    },
    {
        "content": "<p>See? It was an easy two-liner after all :P</p>",
        "id": 217575081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086215
    },
    {
        "content": "<p>Length of proof is disconcertingly similar to length of statement.</p>",
        "id": 217575167,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086329
    },
    {
        "content": "<p>I wonder what percentage of mathlib theorems are longer than their proofs</p>",
        "id": 217575219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606086382
    },
    {
        "content": "<p>More interesting would to see how the answers changed as you move further down the heirarchy. IIRC most of the proofs in data.complex.basic are <code>by ext; simp</code> whereas most of the proofs in <code>discrete_valuation_ring</code> are 10 line tactic proofs.</p>",
        "id": 217575256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086450
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/5087\">#5087</a></p>",
        "id": 217575301,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606086488
    },
    {
        "content": "<p>I was looking through old branches of mine today and I found <a href=\"https://github.com/leanprover-community/mathlib/compare/complex-tidyup#diff-83b09052d14afe3d83c572b16c9cc307a6360889b3a9d8a71525f6260786dc23\">this</a>; golfing <code>data.complex.basic</code>. I never PR'ed it because I wasn't sure there was much point :-)</p>",
        "id": 217575322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086560
    },
    {
        "content": "<p>was this back when you were working on the complex number game?</p>",
        "id": 217575384,
        "sender_full_name": "Thomas Browning",
        "timestamp": 1606086633
    },
    {
        "content": "<p>lol Eric and I had the same thought whilst reviewing :-)</p>",
        "id": 217575481,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1606086819
    },
    {
        "content": "<p>My only experience with <code>recursor</code> is it not working for the case I cared about and no one responding to my <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> showing the failure...</p>",
        "id": 217575559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1606086950
    },
    {
        "content": "<p>there will be this issue that you won't be able to touch the goal while proving the induction hypothesis if you have <code>classical.dec</code> as local instance</p>",
        "id": 217576885,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1606088861
    }
]
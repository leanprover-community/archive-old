[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110087\">Scott Morrison</span> <a href=\"#narrow/stream/116395-maths/topic/sheaves.20of.20modules/near/205001614\">said</a>:</p>\n<blockquote>\n<p>Then commutative monoid objects in a braided category, then the tensor product on their module objects.</p>\n</blockquote>\n<p>I am working on this <a href=\"https://github.com/mattearnshaw/mathlib/blob/monoid_objects/src/category_theory/monoidal/monoid_object.lean\">here</a><br>\nNow (referring to the linked file/branch) I would like to add something along the lines of</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">structure</span> <span class=\"n\">ComMon</span> <span class=\"kn\">extends</span> <span class=\"n\">Mon_in</span> <span class=\"n\">C</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">comm</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"err\">≫</span> <span class=\"n\">μ</span> <span class=\"bp\">=</span> <span class=\"n\">μ</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>but this doesn't work verbatim. what incantations do I need?</p>",
        "id": 205029515,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595725368
    },
    {
        "content": "<p>What goes wrong?</p>",
        "id": 205029537,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725432
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"err\">≫</span> <span class=\"n\">μ</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">μ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_category</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Mon_in</span> <span class=\"n\">C</span><span class=\"o\">),</span>\n     <span class=\"n\">Mon_in</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"err\">⊗</span> <span class=\"n\">Mon_in</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">Mon_in</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">)</span>\n    <span class=\"n\">to_Mon_in</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">X</span> <span class=\"err\">⊗</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"err\">?</span><span class=\"n\">m_1</span>\n</code></pre></div>",
        "id": 205029576,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595725450
    },
    {
        "content": "<p>ah!</p>",
        "id": 205029590,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725528
    },
    {
        "content": "<p><code>Mon_in</code> should not be a class.</p>",
        "id": 205029594,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725535
    },
    {
        "content": "<p>Let's just make it a fully bundled object.</p>",
        "id": 205029599,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725547
    },
    {
        "content": "<p>(Certainly at least this will fix your problem here.)</p>",
        "id": 205029646,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725606
    },
    {
        "content": "<p>But if we want to discuss making it a class again, that's probably a good discussion to have.</p>",
        "id": 205029651,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725626
    },
    {
        "content": "<p>Some requests:</p>\n<ol>\n<li>don't assume <code>symmetric</code>, or even <code>braided</code>, just to define a <code>Mon_in</code>.</li>\n<li>only assume <code>braided</code> when defining <code>CommMon_in</code>. (I have applications later that need this, and the symmetry is irrelevant.)</li>\n<li>It should be <code>CommMon_in</code>, not <code>ComMon</code>.</li>\n</ol>",
        "id": 205029695,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725706
    },
    {
        "content": "<p>a suggestion for the naming for internal objects: how about we drop the <code>in</code>, and just write <code>Mon_</code>? Then users will write it as <code>X : Mon_ C</code>, which looks quite nice to me. </p>\n<p>It's also slightly consistent with the existing notation conventions for monoidal categories, using <code>α_ X Y Z</code> for the associator, etc.</p>",
        "id": 205029735,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725802
    },
    {
        "content": "<p>(To clarify my comment above, changing <code>Mon_in</code> back from a class to a structure will resolve your type mismatch error.)</p>",
        "id": 205029763,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595725837
    },
    {
        "content": "<p>agreed with the naming and thanks for the comments. sadly, changing <code>class</code> to <code>structure</code> still gives me a variant of the above error:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">type</span> <span class=\"n\">mismatch</span> <span class=\"n\">at</span> <span class=\"n\">application</span>\n  <span class=\"o\">(</span><span class=\"n\">σ</span> <span class=\"n\">X</span> <span class=\"n\">X</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">hom</span> <span class=\"err\">≫</span> <span class=\"n\">μ</span>\n<span class=\"n\">term</span>\n  <span class=\"n\">μ</span>\n<span class=\"n\">has</span> <span class=\"n\">type</span>\n  <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span> <span class=\"o\">:</span> <span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"bp\">_</span><span class=\"n\">inst_2</span> <span class=\"o\">:</span> <span class=\"n\">monoidal_category</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">Mon_in</span> <span class=\"n\">C</span><span class=\"o\">),</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"err\">⊗</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"n\">c</span><span class=\"bp\">.</span><span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">to_Mon_in</span>\n<span class=\"n\">but</span> <span class=\"n\">is</span> <span class=\"n\">expected</span> <span class=\"n\">to</span> <span class=\"k\">have</span> <span class=\"n\">type</span>\n  <span class=\"n\">X</span> <span class=\"err\">⊗</span> <span class=\"n\">X</span> <span class=\"err\">⟶</span> <span class=\"err\">?</span><span class=\"n\">m_1</span>\n</code></pre></div>",
        "id": 205029829,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595725970
    },
    {
        "content": "<p>what's the relationship between <code>monoidal_category</code> and <code>symmetric_monoidal_category</code>?</p>",
        "id": 205029897,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595726134
    },
    {
        "content": "<p><code>symmetric extends braided extends monoidal</code>:<br>\n<a href=\"https://github.com/mattearnshaw/mathlib/blob/monoid_objects/src/category_theory/monoidal/category.lean#L475\">https://github.com/mattearnshaw/mathlib/blob/monoid_objects/src/category_theory/monoidal/category.lean#L475</a></p>",
        "id": 205029944,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595726239
    },
    {
        "content": "<p>oh!</p>",
        "id": 205029946,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726246
    },
    {
        "content": "<p>I assumed you were building on top of <a href=\"https://github.com/leanprover-community/mathlib/issues/3550\">#3550</a>, which is slightly different</p>",
        "id": 205029951,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726262
    },
    {
        "content": "<p>You don't want both classes as <code>variables</code> then</p>",
        "id": 205029953,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595726271
    },
    {
        "content": "<p>There <code>braided</code> is an additional typeclass beyond <code>monoidal</code>, while <code>symmetric</code> extends <code>braided</code>.</p>",
        "id": 205029990,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726288
    },
    {
        "content": "<p>aha</p>",
        "id": 205029992,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595726305
    },
    {
        "content": "<p>This was on the principle that <code>braided</code> has extra data, and <code>symmetric</code> is just a condition, but maybe that is applying a bad principle.</p>",
        "id": 205029993,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726309
    },
    {
        "content": "<p>What would you suggest for this Reid?</p>",
        "id": 205029996,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726323
    },
    {
        "content": "<p>My version is pretty verbose, requiring us to write <code>[category C] [monoidal_category C] [braided_monoidal_category C]</code>, but I'm really hoping to have <code>[[ ]]</code> soon. :-)</p>",
        "id": 205030002,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726358
    },
    {
        "content": "<p>I should also rename <code>braided_monoidal_category</code> down to <code>braided_category</code>, and similarly for <code>symmetric</code>, I guess.</p>",
        "id": 205030008,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595726379
    },
    {
        "content": "<p>I'm very happy to change anything in <a href=\"https://github.com/leanprover-community/mathlib/issues/3550\">#3550</a> as suits you. I just sent you an invite giving you commit access to non-master branches, as well. (It's often easier to work on a branch of the main repo, rather than a fork, because you get included in our CI.)</p>",
        "id": 205030778,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595727967
    },
    {
        "content": "<p>Just let me know!</p>",
        "id": 205030783,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595727982
    },
    {
        "content": "<p>What's this about <code>[[ ]]</code>?</p>",
        "id": 205030800,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595728050
    },
    {
        "content": "<p>There's a suggestion that we add syntax for typeclasses that automatically pulls in any \"missing\" typeclasses.</p>",
        "id": 205030804,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595728082
    },
    {
        "content": "<p>Oh that would be nice!</p>",
        "id": 205030843,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1595728101
    },
    {
        "content": "<p>So merely typing <code>variables (C: Type) [[monoidal_category C]]</code> would be sugar for <code>variables (C: Type) [category C] [monoidal_category C]</code>.</p>",
        "id": 205030849,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595728125
    },
    {
        "content": "<p>Someone had a truly spectacular typeclass chain when setting up Lie groups. So perhaps the time has come.</p>",
        "id": 205030855,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595728145
    },
    {
        "content": "<p>Have we considered just making <code>[]</code> do this?</p>",
        "id": 205030860,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595728198
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> – I don't have a strong opinion on how this should be set up so I'm happy to adapt to what you have in <a href=\"https://github.com/leanprover-community/mathlib/issues/3550\">#3550</a></p>",
        "id": 205030861,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595728199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, sounds good to me! Hopefully if someone implements it, that will be easy to field test.</p>",
        "id": 205030955,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595728354
    },
    {
        "content": "<p>I mean I'm not sure if it is crazy, but if it is then probably <code>[[ ]]</code> has problems as well.</p>",
        "id": 205031018,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595728456
    },
    {
        "content": "<p>I guess maybe it might hide problems? At least using the <code>[[ ]]</code> might be a reminder to check the signature of your function afterwards to see if it is what you expected.</p>",
        "id": 205031031,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595728520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247064\">@Matt Earnshaw</span>, not sure if you saw, but Exercise 7 of the category theory tutorial for LftCM2020 includes, in the solutions, the construction of <code>category (Mon_in C)</code>.</p>",
        "id": 205031360,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729181
    },
    {
        "content": "<p>well that seems a bit more concise :-)</p>",
        "id": 205031480,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595729447
    },
    {
        "content": "<p>Obsessive use of <code>obviously</code> in parameter fields, and appropriate <code>simp</code> lemmas. :-) Eventually it breaks down, but it's nice while it lasts.</p>",
        "id": 205031492,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729499
    },
    {
        "content": "<p>I would like to have a go at <code>Mon_in Mon ≌ CommMon</code>, and made a start but there seems to be some finicky things required in handling the cartesian monoidal structure and so on. in any case, it will have to wait until tomorrow</p>",
        "id": 205031540,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595729598
    },
    {
        "content": "<p>The things I'd like to try are:</p>\n<ol>\n<li>check <code>Mon_ Type ~ Mon</code></li>\n<li>check <code>Mon_ Mon ~ CommMon</code></li>\n<li>check <code>Mon_ Ab ~ Ring</code></li>\n<li>construct <code>Mod_ R C</code>, where <code>R : Mon_ C</code></li>\n<li>show <code>Mon_ C</code> and <code>Mod_ R C</code> are monoidal when <code>C</code> is braided</li>\n<li>check that <code>Mod_ R Ab ~ Module R'</code>, where <code>R : Mon_ Ab</code>, and <code>R'</code> is the corresponding honest <code>Ring</code>.</li>\n<li>check that <code>Mon_ (C ⥤ D) ~ C ⥤ (Mon_ D)</code> (is that even the right statement?)</li>\n</ol>",
        "id": 205031546,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729640
    },
    {
        "content": "<p>Yeah, I didn't attempt that, but even trying <code>Mon_ Type ~ Mon</code> it was clear we need some infrastructure first.</p>",
        "id": 205031586,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729676
    },
    {
        "content": "<p>Maybe I will have a go at that today, and if it works move on to <code>Mon_ Ab ~ Ring</code>, leaving <code>Mon_ Mon ~ CommMon</code> for you tomorrow. :-)</p>",
        "id": 205031599,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729716
    },
    {
        "content": "<p>The cartesian monoidal structure on <code>Mon</code> at least is available from <a href=\"https://github.com/leanprover-community/mathlib/issues/3463\">#3463</a>, which hopefully will land soon.</p>",
        "id": 205031648,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595729794
    },
    {
        "content": "<p>now working <a href=\"https://github.com/leanprover-community/mathlib/blob/monoid_objects/src/category_theory/monoidal/monoid_object.lean\">here</a>, with shameless inspiration</p>",
        "id": 205031977,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595730453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247064\">@Matt Earnshaw</span>, I got as far as <a href=\"https://github.com/leanprover-community/mathlib/issues/3562\">#3562</a>, showing <code>Mon_ (Type u) ≌ Mon.{u}</code>.</p>",
        "id": 205050719,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595767331
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> I've merged <a href=\"https://github.com/leanprover-community/mathlib/issues/3463\">#3463</a> into a branch but I'm getting grief from various <code>coe</code>related things in trying to write down this proof, see the commented lines <a href=\"https://github.com/leanprover-community/mathlib/blob/44c1aa5b237f1818560e57ccde0bf755045a6b1e/src/category_theory/monoidal/internal/Mon.lean\">here</a>. any hints would be much appreciated!</p>",
        "id": 205067802,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1595798269
    },
    {
        "content": "<p>I'm guessing this is related to the sleight of hand used at <a href=\"https://github.com/leanprover-community/mathlib/pull/3562/files#diff-bf95aa3a2dfae4af9442dade82298849R18\">https://github.com/leanprover-community/mathlib/pull/3562/files#diff-bf95aa3a2dfae4af9442dade82298849R18</a></p>",
        "id": 205069408,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595801433
    },
    {
        "content": "<p>IMO, this approach is not really sustainable.</p>",
        "id": 205069431,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595801492
    },
    {
        "content": "<p>However, you could imitate it--or just define the monoidal structure of <code>Mon</code> manually.</p>",
        "id": 205069496,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595801627
    },
    {
        "content": "<p>Yeah, I am really torn about those simp lemmas that Reid calls \"sleight of hand\". :-) It seems there are two choices: completely refuse to look at the definition of the limits you've constructed in the particularly concrete category you're working with, and just use the limits API, or write simp lemmas to get the limits API completely out of the way. For <code>Mon_ Type ~ Mon</code>, I took the later approach, but I fully endorse Reid's concern about this.</p>\n<p>I did try the first approach, and really struggled. :-(</p>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span>, do you have a suggestion about an alternate approach? Or advice on how to prove things like this without \"peeking at the definitions\"?</p>",
        "id": 205070684,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595804039
    },
    {
        "content": "<p>I actually tried to link to the line</p>\n<div class=\"codehilite\"><pre><span></span><code> <span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"kn\">instance</span><span class=\"o\">]</span> <span class=\"n\">types</span><span class=\"bp\">.</span><span class=\"n\">types_has_terminal</span> <span class=\"n\">types</span><span class=\"bp\">.</span><span class=\"n\">types_has_binary_products</span>\n</code></pre></div>\n\n\n<p>but linking to a specific line in a PR doesn't seem to work so well.</p>",
        "id": 205070728,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595804099
    },
    {
        "content": "<p>The one in <code>category_theory.monoidal.types</code>.</p>",
        "id": 205070735,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595804111
    },
    {
        "content": "<p>I was wondering how you were going to do this given the inconvenient definition of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>⊗</mo></mrow><annotation encoding=\"application/x-tex\">\\otimes</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">⊗</span></span></span></span>--the solution was to replace it by a convenient one</p>",
        "id": 205070787,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595804187
    },
    {
        "content": "<p>With the benefit of hindsight, it seems like we ended up with the worst of both worlds with the classes like <code>has_binary_products</code>--we have a pretty large API to deal with anyways (and a larger one would be useful), but we don't have the flexibility to choose convenient instances.</p>",
        "id": 205070798,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595804276
    },
    {
        "content": "<p>I think the design you may have had in the pre-mathlib days (or perhaps it was one of several possible designs) was better--just have a totally separate, elementary definition of binary products and then have an equivalence with limits over a two-object category available for when you don't care about the specific construction.</p>",
        "id": 205070941,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595804463
    },
    {
        "content": "<p>Where is the first place we're going to see this inflexibility of in choosing limits cause pain, if we use this <code>local attribute [instance]</code> trick to produce definitionally more convenient limits in some places, but also have global instances with different definitions available?</p>\n<p>Presumably we going to get to some situation where we have two copies of <code>limits.prod X Y</code>, but they have two unrelated instances making the choices. We're still going to be able to use <code>def cone_point_unique_up_to_iso {s t : cone F} (P : is_limit s) (Q : is_limit t) : s.X ≅ t.X :=</code> (or possibly even more convenient formulations) to obtain an isomorphism between them.</p>",
        "id": 205071287,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1595805177
    },
    {
        "content": "<p>Well any definition with a <code>[has_binary_products]</code> are going to have to be transported manually across those isomorphisms</p>",
        "id": 205071388,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805366
    },
    {
        "content": "<p>For example, if you proved a locally compact space was exponentiable with respect to some local notion of products you will need to do some work to show it's exponentiable with respect to some other products</p>",
        "id": 205071396,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805412
    },
    {
        "content": "<p>and most likely this will manifest as some unification problem failing to solve for no apparent reason</p>",
        "id": 205071402,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805450
    },
    {
        "content": "<p>Mathematicians don't need to do any work, right?</p>",
        "id": 205071403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805453
    },
    {
        "content": "<p>What do we have that this system doesn't?</p>",
        "id": 205071405,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805464
    },
    {
        "content": "<p>I would argue that you do have to do some work</p>",
        "id": 205071406,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805471
    },
    {
        "content": "<p>or alternatively that, in category theory, we have an extra layer of \"reasonableness\" for definitions on top of the basic one</p>",
        "id": 205071449,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805497
    },
    {
        "content": "<p>If we could rewrite along isomorphisms would it all be easy?</p>",
        "id": 205071451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805519
    },
    {
        "content": "<p>it's not really the usual kind of rewriting along isomorphisms</p>",
        "id": 205071457,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805566
    },
    {
        "content": "<p>You shouldn't be proving things about some explicit definition of a product, if you're in a category, right? You should be proving things about anything satisfying the universal property of a product</p>",
        "id": 205071464,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805598
    },
    {
        "content": "<p>rewriting along isomorphisms would be like, if an object X of C is exponentiable, and C' is another category isomorphic to C, then the corresponding object X' of C' is exponentiable</p>",
        "id": 205071506,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805622
    },
    {
        "content": "<p>This is what we do in localisation now, we don't prove things about R[1/S], we prove things about R-algebras satisfying the universal property that R[1/S] has</p>",
        "id": 205071509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805650
    },
    {
        "content": "<p>okay I guess maybe you can always swap two isomorphic objects of a category? but it's very unnatural</p>",
        "id": 205071511,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805660
    },
    {
        "content": "<p>Not if they're canonically isomorphic</p>",
        "id": 205071519,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805687
    },
    {
        "content": "<p>no I mean, find an automorphism of the category which interchanges the objects</p>",
        "id": 205071520,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805712
    },
    {
        "content": "<p>that requires LEM for example</p>",
        "id": 205071522,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805717
    },
    {
        "content": "<p>We really do also consider notions in category theory which are not isomorphism-independent in this sense--I think this generally manifests as the notion itself not being equivalence-invariant</p>",
        "id": 205071562,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805763
    },
    {
        "content": "<p>I was just imagining some internal rewriting -- if P is a predicate on objects tagged with the magic sauce, then P(X) iff P(Y) if Y is isomorphic to X</p>",
        "id": 205071565,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805778
    },
    {
        "content": "<p>It's possible that there is a framework which covers both of these kinds of problems</p>",
        "id": 205071570,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805806
    },
    {
        "content": "<p>but anyways, you would still have to use it explicitly, presumably</p>",
        "id": 205071571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805815
    },
    {
        "content": "<p>if you were foolish enough to prove things about a product rather than all things satisfying the universal property of a product</p>",
        "id": 205071613,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805862
    },
    {
        "content": "<p>like I was with localisations</p>",
        "id": 205071614,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805868
    },
    {
        "content": "<p>but I don't really understand the extra complications categories bring to this issue</p>",
        "id": 205071616,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595805896
    },
    {
        "content": "<p>Maybe it's really that what we usually think about as transport across isomorphisms is a special case of this? but I'm not convinced that category theory is really a good framework to think about that problem</p>",
        "id": 205071620,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805908
    },
    {
        "content": "<p>Doesn't the characterization of localizations itself use products? I think they are kind of too fundamental to do the same thing</p>",
        "id": 205071666,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595805968
    },
    {
        "content": "<p>Strickland's characterisation for f:R-&gt;A to be R[1/S]  has a line \"if a in A then there exists r in R and s in S with a*f(s)=f(r)\"</p>",
        "id": 205071681,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595806062
    },
    {
        "content": "<p>Anyways these are not facts of a formal nature I have in mind. For example <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mo>×</mo><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">- \\times Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> preserves colimits if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> is locally compact--obviously it can't be too formal because it has the condition \"<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Y</mi></mrow><annotation encoding=\"application/x-tex\">Y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">Y</span></span></span></span> locally compact\". In principle you could prove statements like this from the universal property of the product but I think the proof would basically amount to building the usual product and arguing there.</p>",
        "id": 205071781,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806256
    },
    {
        "content": "<p>The actual product has some bonus technical features too, like a computation rule and elimination into any universe</p>",
        "id": 205071787,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806276
    },
    {
        "content": "<p>and now you want to prove that any functor satisfying the universal property of x Y preserves colimits.</p>",
        "id": 205071836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595806326
    },
    {
        "content": "<p>meh yeah it's kind of like one level up from the localisation situation</p>",
        "id": 205071839,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1595806348
    },
    {
        "content": "<p>The situation in homotopy theory is particularly striking because the fact that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">- \\times [0,1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> is characterized by some universal property literally never comes up. I use it to define homotopies and I want to know that I can glue homotopies together to get a homotopy on a space that was glued together, and in order to do this I need to know various point-set facts about the space <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> and its <code>prod</code> with other spaces</p>",
        "id": 205071896,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806482
    },
    {
        "content": "<p>and at some point I need to write down an explicit formula for a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>→</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>×</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0, 1] \\times [0, 1] \\to [0, 1] \\times [0, 1]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> and check that it's continuous, and I need to know what the domain is to do this</p>",
        "id": 205071907,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806545
    },
    {
        "content": "<p>Like, I need the fact that addition and multiplication are continuous</p>",
        "id": 205071949,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806613
    },
    {
        "content": "<p>and this is phrased in terms of <code>prod</code></p>",
        "id": 205071950,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806619
    },
    {
        "content": "<p>so it's all extremely convenient; but in mathlib the products in <code>Top</code> are defined by some different construction</p>",
        "id": 205072007,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806691
    },
    {
        "content": "<p>(incidentally, <code>Mon_ Top</code> would be good to add to the above list!)</p>",
        "id": 205072020,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595806754
    },
    {
        "content": "<p><a href=\"https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/category.lean#L42-L80\">https://github.com/rwbarton/lean-homotopy-theory/blob/lean-3.4.2/src/homotopy_theory/topological_spaces/category.lean#L42-L80</a> is basically the whole \"theory\" of products I worked with</p>",
        "id": 205072190,
        "sender_full_name": "Reid Barton",
        "timestamp": 1595807043
    },
    {
        "content": "<p>rewinding to something more mundane, I am defining the monoidal structure of <code>Mon</code> manually in an attempt to ameliorate my problems above but now really fumbling with this simple lemma:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Mon</span><span class=\"bp\">.</span><span class=\"n\">limits</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">monoidal</span><span class=\"bp\">.</span><span class=\"n\">category</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">limits</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">iso</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">monoidal</span>\n\n<span class=\"n\">def</span> <span class=\"n\">assoc</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">Z</span> <span class=\"o\">:</span> <span class=\"n\">Mon</span><span class=\"o\">),</span> <span class=\"n\">Mon</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">Mon</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"err\">↥</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"err\">↥</span><span class=\"n\">Y</span><span class=\"o\">))</span> <span class=\"bp\">×</span> <span class=\"err\">↥</span><span class=\"n\">Z</span><span class=\"o\">)</span> <span class=\"err\">≅</span> <span class=\"n\">Mon</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"err\">↥</span><span class=\"n\">X</span> <span class=\"bp\">×</span> <span class=\"err\">↥</span><span class=\"o\">(</span><span class=\"n\">Mon</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"o\">(</span><span class=\"err\">↥</span><span class=\"n\">Y</span> <span class=\"bp\">×</span> <span class=\"err\">↥</span><span class=\"n\">Z</span><span class=\"o\">)))</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">intros</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">mul_equiv</span><span class=\"bp\">.</span><span class=\"n\">to_Mon_iso</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">inv_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">right_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">},</span>\n  <span class=\"n\">intro</span><span class=\"o\">,</span>\n  <span class=\"c1\">--- ?</span>\n  <span class=\"c\">/-</span><span class=\"cm\"> a: ↥(Mon.of (↥X × ↥Y)) × ↥Z</span>\n<span class=\"cm\">     ⊢ ↥X × ↥(Mon.of (↥Y × ↥Z)) -/</span>\n<span class=\"kn\">end</span>\n</code></pre></div>",
        "id": 205427139,
        "sender_full_name": "Matt Earnshaw",
        "timestamp": 1596066730
    },
    {
        "content": "<p>Did the <code>a</code> come from <code>intros</code>? Why not replace with a fancy <code>rintro</code>?</p>",
        "id": 205448586,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1596094009
    }
]
[
    {
        "content": "<p>Mathlib has the unbundled <code>is_mul_hom</code> class (a Prop), and then it has <code>mul_equiv</code> which references this unbundled <code>is_mul_hom</code>. If we were to bundle <code>mul_hom</code>s, how would we define <code>mul_equiv</code>?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Mathlib:</span>\n\n<span class=\"cm\">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>\n<span class=\"cm\">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>\n\n<span class=\"cm\">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>\n<span class=\"cm\">(hom : is_mul_hom to_fun)</span>\n\n<span class=\"cm\">notation ≃* for mul_equiv, proved to be reflexive, symmetric and transitive</span>\n\n<span class=\"cm\">-- not yet found a use for this instance. Should `is_mul_hom` be a structure?</span>\n<span class=\"cm\">instance (h : α ≃* β) : is_mul_hom h.to_equiv := h.hom</span>\n\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mul</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- bundled homs FTW -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">hom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- but now if I delete `is_mul_hom`, how do I define `mul_equiv`?</span>\n<span class=\"c1\">-- notation for homs</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">→*</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">hom</span>\n</pre></div>",
        "id": 171137073,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423707
    },
    {
        "content": "<p><code>mul_equiv A B extends equiv A B, mul_hom A B</code></p>",
        "id": 171137127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423764
    },
    {
        "content": "<p>Should I be using old or new structures for these things?</p>",
        "id": 171137144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423798
    },
    {
        "content": "<p>old structures FTW</p>",
        "id": 171137148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423808
    },
    {
        "content": "<p>Is what you call <code>mul_hom</code> what I called <code>mul.hom</code>?</p>",
        "id": 171137150,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423817
    },
    {
        "content": "<p>Did I name it wrong?</p>",
        "id": 171137154,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423830
    },
    {
        "content": "<p>I don't think so</p>",
        "id": 171137158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423836
    },
    {
        "content": "<p><code>mul_hom A B</code> for me is the type of augmented functions from A to B</p>",
        "id": 171137201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423859
    },
    {
        "content": "<p>but <code>mul.hom</code> has got a field <code>f</code> and <code>equiv</code> has got a field <code>to_fun</code> and these are supposed to be defeq and have the same name.</p>",
        "id": 171137203,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423878
    },
    {
        "content": "<p>I don't see <code>mul.hom</code> in the example</p>",
        "id": 171137204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423884
    },
    {
        "content": "<p>Oh there it is</p>",
        "id": 171137215,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423911
    },
    {
        "content": "<p>I'm talking about my attempt to bundle homs.</p>",
        "id": 171137216,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563423916
    },
    {
        "content": "<p>I think that should be <code>mul_hom</code></p>",
        "id": 171137218,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423920
    },
    {
        "content": "<p><code>mul</code> isn't a namespace</p>",
        "id": 171137219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423927
    },
    {
        "content": "<p><code>mul_hom</code> should have a field called <code>to_fun</code></p>",
        "id": 171137266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423977
    },
    {
        "content": "<p>so that <code>mul_equiv</code> works</p>",
        "id": 171137267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563423987
    },
    {
        "content": "<p><code>to_fun</code> is such a horrible name for a function. I guess its canonical name is the coercion so maybe it doesn't matter. Wait -- the map from <code>mul_equiv X Y</code> to <code>mul_hom X Y</code> -- that is no longer an instance, because <code>mul_hom</code> isn't a class. Is this still done with coercions somehow?</p>",
        "id": 171137396,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563424298
    },
    {
        "content": "<p>it's a function called <code>to_mul_hom</code></p>",
        "id": 171137439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563424344
    },
    {
        "content": "<p>You can try using a coercion but this one tends to trigger rarely</p>",
        "id": 171137444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563424374
    },
    {
        "content": "<p>given that the parent functions are always called <code>to_*</code>, <code>to_fun</code> seems to match that naming convention</p>",
        "id": 171137498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563424456
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">mul_hom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>Should this have a coercion to fun?</p>",
        "id": 171138143,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563425745
    },
    {
        "content": "<p>yes</p>",
        "id": 171138188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563425792
    },
    {
        "content": "<p>My <code>map_mul</code> is crappy:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- bundled homs FTW -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">mul_hom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- notation for homs</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">→*</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">mul_hom.map_mul : ∀ (c : ?M_1 →* ?M_2) (x y : ?M_1), c.to_fun (x * y) = c.to_fun x * c.to_fun y</span>\n<span class=\"cm\">-- yeah but I want it to be the coercion, not `c.to_fun`</span>\n<span class=\"cm\">-/</span>\n</pre></div>\n\n\n<p>It has come out non-canonically. Am I supposed to be doing this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">M</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span>\n</pre></div>\n\n\n<p>?</p>",
        "id": 171138401,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563426237
    },
    {
        "content": "<p>with the primes inverted</p>",
        "id": 171138447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563426262
    },
    {
        "content": "<p>So you're saying I need to change mathlib</p>",
        "id": 171138449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563426283
    },
    {
        "content": "<p>no</p>",
        "id": 171138452,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563426295
    },
    {
        "content": "<p>you're saying I need to change my structure field's name.</p>",
        "id": 171138456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563426303
    },
    {
        "content": "<p>yes</p>",
        "id": 171138463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563426311
    },
    {
        "content": "<p>Should this</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">mul_equiv&#39;</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">mul_hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n</pre></div>\n\n\n<p>have a coercion to fun?</p>",
        "id": 171139112,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563427505
    },
    {
        "content": "<p>yes</p>",
        "id": 171139294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563427864
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">group</span>\n<span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">algebra</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">γ</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">P</span><span class=\"o\">]</span>\n\n<span class=\"c1\">-- Recall that the unbundled definition of a mul_hom</span>\n<span class=\"c1\">-- and the definition of a mul_equiv, with notation ≃*, are in mathlib.</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"> Mathlib:</span>\n\n<span class=\"cm\">-- in root namespace</span>\n<span class=\"cm\">class is_mul_hom {α β : Type*} [has_mul α] [has_mul β] (f : α → β) : Prop :=</span>\n<span class=\"cm\">(map_mul : ∀ x y, f (x * y) = f x * f y)</span>\n\n<span class=\"cm\">-- root namespace</span>\n<span class=\"cm\">structure mul_equiv (α β : Type*) [has_mul α] [has_mul β] extends α ≃ β :=</span>\n<span class=\"cm\">(hom : is_mul_hom to_fun)</span>\n\n<span class=\"cm\">notation ≃*, proved to be reflexive, symmetric and transitive (note: it is not a Prop)</span>\n<span class=\"cm\">-/</span>\n\n\n<span class=\"c1\">--. We will define</span>\n<span class=\"c1\">-- bundled homomorphisms of muls, with notation →*, and bundled</span>\n<span class=\"c1\">-- equivs, with notation ≃*&#39;</span>\n\n\n<span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- bundled homs -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">mul_hom</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">to_fun</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">to_fun</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- notation for homs</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"bp\">→*</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span>\n\n<span class=\"c1\">-- I want to think of a hom as a function sometimes</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">M</span> <span class=\"bp\">→</span> <span class=\"n\">N</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- the statement that mul_homs preserve mul, in its canonical form -/</span>\n<span class=\"n\">def</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→*</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span> <span class=\"o\">:=</span> <span class=\"n\">mul_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul&#39;</span>\n\n<span class=\"c1\">-- for structures like this you need to prove `id` and `comp` next.</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">mul_hom</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- the identity is a mul_hom-/</span>\n<span class=\"n\">def</span> <span class=\"n\">id</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">M</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">}</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- composite of mul_homs is a mul_hom -/</span>\n<span class=\"n\">def</span> <span class=\"n\">comp</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→*</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"bp\">→*</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→*</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">m</span><span class=\"o\">),</span>\n  <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">map_mul</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">map_mul</span> <span class=\"n\">g</span><span class=\"o\">]</span> <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">mul_hom</span>\n\n<span class=\"c\">/-</span><span class=\"cm\">- mul_equiv&#39; (bundled mul_equiv -- the name mul_equiv is currently nicked by unbundled mul_equiv) -/</span>\n<span class=\"kn\">structure</span> <span class=\"n\">mul_equiv&#39;</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">B</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">A</span> <span class=\"n\">B</span><span class=\"o\">,</span> <span class=\"n\">mul_hom</span> <span class=\"n\">A</span> <span class=\"n\">B</span>\n\n<span class=\"c1\">-- notation for mul_equiv&#39;</span>\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">mul_equiv&#39;</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">),</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span>\n<span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span><span class=\"bp\">.</span><span class=\"n\">map_mul&#39;</span>\n\n<span class=\"c1\">-- now need reflexive, symmetric and transitive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mul_equiv&#39;</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_mul</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n<span class=\"bp\">..</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- this one did not go so well.</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">symm</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">n₁</span> <span class=\"n\">n₂</span><span class=\"o\">,</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective_of_left_inverse</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"k\">begin</span>\n    <span class=\"k\">show</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"n\">n₂</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">inv_fun</span> <span class=\"n\">n₂</span><span class=\"o\">),</span> <span class=\"c1\">-- annoying to have to `show`</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span>\n    <span class=\"n\">convert</span> <span class=\"n\">rfl</span><span class=\"o\">,</span> <span class=\"c1\">-- annoying to have to `convert`. This should surely just be rewrites.</span>\n      <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">right_inv</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"kn\">end</span><span class=\"o\">,</span>\n  <span class=\"bp\">..</span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">}</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">trans</span><span class=\"o\">]</span> <span class=\"n\">def</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h2</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">,</span>\n    <span class=\"k\">show</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">*</span> <span class=\"n\">h2</span> <span class=\"o\">(</span><span class=\"n\">h1</span> <span class=\"n\">y</span><span class=\"o\">),</span>\n    <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">],</span>\n  <span class=\"bp\">..</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"o\">}</span>\n\n<span class=\"c1\">-- an ≃*&#39; is a hom</span>\n<span class=\"n\">def</span> <span class=\"n\">equiv&#39;</span><span class=\"bp\">.</span><span class=\"n\">to_hom</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"bp\">→*</span> <span class=\"n\">N</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"o\">,</span>\n    <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">map_mul&#39;</span>\n  <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">equiv&#39;</span><span class=\"bp\">.</span><span class=\"n\">inv_hom</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">M</span> <span class=\"err\">≃</span><span class=\"bp\">*</span><span class=\"err\">&#39;</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span> <span class=\"bp\">→*</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"o\">,</span>\n  <span class=\"n\">map_mul&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span>\n  <span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">mul_equiv&#39;</span>\n</pre></div>\n\n\n<p><code>equiv'.symm</code> didn't go well but most of the other stuff looks OK to me</p>",
        "id": 171140149,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563429398
    },
    {
        "content": "<p>People will complain about the order of arguments to <code>comp</code></p>",
        "id": 171140287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563429608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>",
        "id": 171140312,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563429700
    },
    {
        "content": "<p>What's wrong with <code>symm</code>? It looks like that's the sort of thing that is mathematically substantive anyway</p>",
        "id": 171140315,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563429707
    },
    {
        "content": "<p>In fact, that's the most important reason for bundling in the first place. That this is a simp-lemma that actually triggers.</p>",
        "id": 171140359,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563429726
    },
    {
        "content": "<p>Also, we'll want simp-lemmas <code>id_apply</code> and <code>comp_apply</code>.</p>",
        "id": 171140363,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563429743
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> You probably know this but <code>mul_hom.map_mul</code> should be a <em>lemma</em>, and it is a very good simp-lemma.</p>\n</blockquote>\n<p>I'm not very good at <code>simp</code> still.</p>",
        "id": 171141338,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563431116
    },
    {
        "content": "<p>So anyway, there is a bunch of structure most of which is correctly named, and hopefully defined sensibly.  Do we want all all of this in mathlib? And then there's the equivalent stuff for <code>semigroup</code>, for <code>monoid</code> and for <code>group</code>. I don't care about the <code>mul</code> stuff really, I was just practicing. I <em>do</em> care about equivs of monoids and of groups and would like some students to prepare a mathlib PR. </p>\n<p>What are we looking for in such a PR? Should the students try and define everything for <code>semigroup</code> when we don't really need it? Is a PR of this nature for <code>group</code> welcome? <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> do you have any opinions on this? I've talked to you before about it and you seem to have a clear head about what should be there.</p>",
        "id": 171161924,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563450569
    },
    {
        "content": "<p>Note that we can define <code>group.hom</code> to be <code>mul_hom</code></p>",
        "id": 171161956,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563450602
    },
    {
        "content": "<p>I think the last time we talked about this, you liked that idea.</p>",
        "id": 171161995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563450614
    },
    {
        "content": "<p>Don't bother with <code>semigroup</code> stuff unless it's virtually no effort. I'd actually prefer <code>group_hom</code> and <code>monoid_hom</code> to be the same, since these are the two that are actually used. You could write a custom constructor without the unnecessary axiom.</p>\n<p>Same idea goes for <code>ring_hom</code> and <code>semiring_hom</code></p>",
        "id": 171163113,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563451707
    },
    {
        "content": "<p>so you're saying you want <code>group.hom</code> to be called <code>group_hom</code> and to demand that <code>f(1)=1</code>?</p>",
        "id": 171163615,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563452181
    },
    {
        "content": "<p>What should the custom constructor be called?</p>",
        "id": 171163633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563452217
    },
    {
        "content": "<p>Yes <code>@[reducible] def group_hom := monoid_hom</code>. </p>\n<p><code>group_hom.mk</code></p>",
        "id": 171164305,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563452773
    },
    {
        "content": "<p>That way, simp lemmas you prove about <code>monoid_hom</code>s will work with group homs.</p>",
        "id": 171164339,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563452821
    },
    {
        "content": "<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">monoid_equiv</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n</pre></div>",
        "id": 171195355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563473707
    },
    {
        "content": "<p>Is it clear that making some of these definitions does not create leakage?</p>",
        "id": 171195654,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563473911
    },
    {
        "content": "<p>I am just experimenting. I will certainly report back.</p>",
        "id": 171195706,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563473950
    },
    {
        "content": "<p>Also, I think Lean is quite bad at dealing with situations like this:<br>\nI have <code>M1 M2 : Type</code> and <code>[monoid M1] [monoid M2]</code><br>\nI also have <code>f : monoid_hom M1 M2</code>.<br>\nThen, for some reason, it happens that I can actually prove that <code>M1</code> and <code>M2</code> are groups.<br>\nNow I need to work to turn <code>f</code> into a group hom. And if I don't do that, certain lemma's can't be applied, and <code>simp</code> gets stuck etc...</p>",
        "id": 171195897,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474081
    },
    {
        "content": "<p>This won't happen with Chris' suggesting of defining <code>group_hom</code> to be equal to <code>monoid_hom</code></p>",
        "id": 171195995,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474137
    },
    {
        "content": "<p>I know it is not very beginner-friendly. But I'm becoming more and more of the opinion that we shouldn't have these \"shadowing\" classes. Like <code>vector_space</code> (and even <code>module</code>). And so, maybe we should also just get rid of <code>group_hom</code>s</p>",
        "id": 171196002,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474140
    },
    {
        "content": "<p>Nope, that's not true.</p>",
        "id": 171196013,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474149
    },
    {
        "content": "<p>and making it reducible</p>",
        "id": 171196022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474159
    },
    {
        "content": "<p>If I have a module over a field, I can't apply linear algebra results.</p>",
        "id": 171196045,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474171
    },
    {
        "content": "<p>Even if <code>vector_space</code> is reducibly defined to be a module.</p>",
        "id": 171196071,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474185
    },
    {
        "content": "<p>This has bitten me several times.</p>",
        "id": 171196081,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474192
    },
    {
        "content": "<p>We need some way of being able to talk about group homomorphisms. What is your suggestion? Unbundled homs? I thought this had problems too?</p>",
        "id": 171196137,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474241
    },
    {
        "content": "<p>No, it's somewhat orthogonal to bundling, but it's very much related to refactoring.</p>",
        "id": 171196206,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474273
    },
    {
        "content": "<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>",
        "id": 171196222,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474291
    },
    {
        "content": "<p>Just write <code>monoid_hom.mk'</code> for the case that you construct monoid homs between groups.</p>",
        "id": 171196270,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474320
    },
    {
        "content": "<p>It doesn't look nice... but it is more flexible.</p>",
        "id": 171196299,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474349
    },
    {
        "content": "<blockquote>\n<p>This has bitten me several times.</p>\n</blockquote>\n<p>If you try to fix it by making the actual object you want from the object you have (e.g. the vector space over the field from the module), then you then have two objects which mathematicians find completely indistinguishable, but for which Lean finds it hard to port results about one object to results from the other. This sounds like a good place to try out a transfer tactic, no?</p>",
        "id": 171196390,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474395
    },
    {
        "content": "<p>Meh... I would rather let the problem go away.</p>",
        "id": 171196448,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474441
    },
    {
        "content": "<p>Maybe <code>group_hom</code> can be an <code>abbreviation</code>?? I still don't know what this does exactly.</p>",
        "id": 171196468,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474464
    },
    {
        "content": "<p>But it seems to be something like <code>hyper-super-duper-reducible</code>.</p>",
        "id": 171196531,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474490
    },
    {
        "content": "<blockquote>\n<p>And should this be reducible too? [sorry for prime on mul_equiv, mathlib has a slightly more unbundled one]</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">monoid_equiv</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n</pre></div>\n\n\n</blockquote>\n<p>That shouldn't exist</p>",
        "id": 171196542,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563474503
    },
    {
        "content": "<p>For the same reason that <code>vector_space</code> shouldn't exist?</p>",
        "id": 171196594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563474562
    },
    {
        "content": "<blockquote>\n<p>I want to propose/discuss just ditching <code>group_hom</code> altogether.</p>\n</blockquote>\n<p>If we ditch <code>group_hom</code> altogether, what will be the canonical way of representing the concept of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo>:</mo><mi>G</mi><mo>→</mo><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">f:G\\to H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(xy)=f(x)f(y)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span> with <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding=\"application/x-tex\">H</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.08125em;\">H</span></span></span></span> groups?</p>",
        "id": 171197093,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474868
    },
    {
        "content": "<blockquote>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">monoid_equiv</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">M</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">N</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">mul_equiv&#39;</span> <span class=\"n\">M</span> <span class=\"n\">N</span>\n</pre></div>\n\n\n</blockquote>\n<p>That shouldn't exist</p>\n</blockquote>\n<p>If that doesn't exist <em>at all</em>, then what happens to the poor newbie who shows up with their two monoids and wants to know where the equiv is?</p>",
        "id": 171197171,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563474952
    },
    {
        "content": "<p>We tell them to use <code>M1 =* M2</code>.</p>",
        "id": 171197298,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563475033
    },
    {
        "content": "<p>If we ditch <code>group_hom</code> you just write <code>f : G →m H</code></p>",
        "id": 171197330,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563475065
    },
    {
        "content": "<p>Or whatever the notation for monoid homs will be.</p>",
        "id": 171197341,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563475076
    },
    {
        "content": "<p>I started on <code>-&gt;1*</code>, but I propose <code>-&gt;*</code>, and screw mul homs notation.</p>",
        "id": 171197626,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563475296
    },
    {
        "content": "<p>So notation can attempt to solve the issue. Chris are you proposing the notation with no 1 to be overloaded? I am mostly interested in group homs and isoms because a student of mine needs them asap</p>",
        "id": 171200197,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563477086
    },
    {
        "content": "<p>I'm proposing no notation for mul homs, since they're rarely used.</p>",
        "id": 171200648,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563477387
    },
    {
        "content": "<p>then what term is <code>-&gt;*</code> notation for?</p>",
        "id": 171205025,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563480729
    },
    {
        "content": "<p>I am happy to implement your idea but I don't understand it yet. I would just like isomorphisms and bundled homomorphisms of groups sooner rather than later.</p>",
        "id": 171205059,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563480772
    },
    {
        "content": "<p>I want to do more experiments with the bundled morphisms approach.</p>",
        "id": 171205087,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563480793
    },
    {
        "content": "<p>monoid homs</p>",
        "id": 171205114,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1563480811
    },
    {
        "content": "<p>A monoid hom has this extra condition that 1 goes to 1. So we define <code>monoid_hom</code>, and we can make <code>\\equiv\\_g</code> be notation for <code>monoid_hom</code>.</p>",
        "id": 171205228,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563480874
    },
    {
        "content": "<p>Sure, so Chris is saying <code>→*</code> for monoid homs and group homs. No notation for <code>mul_hom</code>.</p>",
        "id": 171205262,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563480909
    },
    {
        "content": "<p>and we could also make <code>\\equiv\\_m</code> be notation for <code>monoid_hom</code> for when we're working with moniods, and then Lean's prettyprinter would have an impossible notation problem to solve.</p>",
        "id": 171205276,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563480927
    },
    {
        "content": "<p>And <code>\\equiv*</code> might be a nice fit for <code>mul_equiv</code> (and we don't need <code>monoid_equiv</code> or <code>group_equiv</code>).</p>",
        "id": 171205291,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563480941
    },
    {
        "content": "<p>So we just tell the user in comments in the group section: \"the notation for group homomorphisms is <code>-&gt;*</code> and the notation for group isomorphisms is <code>\\equiv*</code>\"</p>",
        "id": 171205394,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481013
    },
    {
        "content": "<p>Sure... and because the notation is somewhat natural it is even avoiding the awkard <code>f : monoid_hom G H</code> for group homs.</p>",
        "id": 171205428,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481058
    },
    {
        "content": "<p>I think this is quite a nice solution.</p>",
        "id": 171205435,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481066
    },
    {
        "content": "<p>That's quite interesting that the force of the mathematical interpretation <code>-&gt;*</code> is \"I preserve everything relevant to multiplication that is present\"</p>",
        "id": 171205545,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481140
    },
    {
        "content": "<p>The special constructor could be</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">group_hom</span> <span class=\"o\">{</span><span class=\"n\">G</span> <span class=\"n\">H</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">G</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">group</span> <span class=\"n\">H</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"bp\">*</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">G</span> <span class=\"bp\">→*</span> <span class=\"n\">H</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 171205587,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481170
    },
    {
        "content": "<p>If you defined monoids to mathematicians and then said \"OK now what do you think <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi><msup><mo>→</mo><mo>∗</mo></msup><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">M\\to^*N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.688696em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">→</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.688696em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> means?\" they'd be like \"monoid hom I guess\"</p>",
        "id": 171205607,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481202
    },
    {
        "content": "<p>(That example didn't type check, but you get the idea.)</p>",
        "id": 171205656,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481216
    },
    {
        "content": "<p>But Chris seems to be explictly suggesting that the name <code>group_hom</code> is never assigned. Is this what you think <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> ?</p>",
        "id": 171205696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481270
    },
    {
        "content": "<p>What I'm saying is that <code>monoid_hom.mk</code> is a bad name for constructing monoid homs between groups.</p>",
        "id": 171205723,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481311
    },
    {
        "content": "<p>These are all such irrelevances, there must be some solution with automation or something. Mathematically we are doing absolutely nothing at all.</p>",
        "id": 171205791,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481327
    },
    {
        "content": "<p>I've been saying time and again that Fabian can auto-generate all of these.</p>",
        "id": 171205833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481358
    },
    {
        "content": "<p>But people don't really seem to care.</p>",
        "id": 171205839,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1563481364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> we need computer science help. We have a very rigorous notion of \"the same\" here -- this seems to me like this is type class inference in a tangle. Do you understand why we are struggling? Why can't Johan do linear algebra with a module over a field? <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span>  can you give a MWE? We need to get good at this.</p>",
        "id": 171206136,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563481564
    },
    {
        "content": "<p>I think that more names for the same thing is bad for formalization, although I understand why it is mathematically desirable. I am on board with Chris's suggestions</p>",
        "id": 171207184,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563482480
    },
    {
        "content": "<p>We also need the <code>additive</code> version of everything, I suppose? That entire process can be automated. Can you literally to a regex on the file to generate its additive version? And then you can look observe the funny fact that there are two olean files which are exactly the same</p>",
        "id": 171207355,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563482641
    },
    {
        "content": "<p>While I don't want to minimize Fabian's work, the proofs are not the hard part here. This is all API design questions</p>",
        "id": 171207395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563482645
    },
    {
        "content": "<p>Right. I'm trying really hard to make a mathematician's API.</p>",
        "id": 171207424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563482671
    },
    {
        "content": "<p>I now have a much better understanding of the issues here and I think it's a really important question for drawing mathematicians in. We want to make it look easy.</p>",
        "id": 171207460,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563482709
    },
    {
        "content": "<p>I think we might be losing half our audience at</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">nat</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">what</span> <span class=\"n\">does</span> <span class=\"n\">all</span> <span class=\"n\">this</span> <span class=\"n\">weird</span> <span class=\"n\">stuff</span> <span class=\"n\">mean</span>\n</pre></div>\n\n\n<p>We just want to say \"The naturals are <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">N</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{N}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">N</span></span></span></span></span>, typed <code>\\N</code> and they work exactly as you would expect them to\". Implementing this is not a trivial thing at all!</p>",
        "id": 171207636,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563482854
    },
    {
        "content": "<p>I heartily disagree</p>",
        "id": 171207846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483005
    },
    {
        "content": "<p>\"It goes without saying that if <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> are isomorphic <code>comm_ring</code>s then <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is Gorenstein iff <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is. It does not need a proof. \"</p>",
        "id": 171207866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483014
    },
    {
        "content": "<p>that one is not proving trivial to implement</p>",
        "id": 171207881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483027
    },
    {
        "content": "<p>hardcoding what \"they work exactly as you would expect\" means is just making lean more \"magical\" and less comprehensible</p>",
        "id": 171207901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483046
    },
    {
        "content": "<p>which is setting yourself up for failure</p>",
        "id": 171207910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483061
    },
    {
        "content": "<p>You guys worry too much about these tedious implementation issues</p>",
        "id": 171207959,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483111
    },
    {
        "content": "<p>That's not an implementation issue, it's a pedagogy issue</p>",
        "id": 171208007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483127
    },
    {
        "content": "<p>We're never going to run the code we're making, you don't need to optimise it</p>",
        "id": 171208014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483131
    },
    {
        "content": "<p>We just want to eat every proposition and every proof bit by bit</p>",
        "id": 171208031,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483158
    },
    {
        "content": "<p>if lean has tons of special cases then it's big and complicated to learn. This is not an exaggeration, it's already the case</p>",
        "id": 171208037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483166
    },
    {
        "content": "<p>implementing <code>transfer</code> is hard because type theory is big and complicated</p>",
        "id": 171208306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483373
    },
    {
        "content": "<p>You should just solve it with pointers or something</p>",
        "id": 171208404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563483468
    },
    {
        "content": "<p><span aria-label=\"expressionless\" class=\"emoji emoji-1f611\" role=\"img\" title=\"expressionless\">:expressionless:</span></p>",
        "id": 171208783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483814
    },
    {
        "content": "<p>That said, <code>transfer</code> is already implemented and mostly works. As I've said many times, what is needed is not a tactic but lemmas for it to use</p>",
        "id": 171208911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563483909
    },
    {
        "content": "<p>So mathematicians have a gigantic list of abstract mathematical ideas. And for each of these ideas computer scientists have developed some term in type theory, or perhaps some token (the mathematical symbol of isomorphism comes to mind), and said \"look here it is\", and then we say \"Thanks. Does it do this, this, that and this?\" and you guys go \"Yes of course. And it does a gazillion other things too like look you can see inside it and you can do that if you want\" and we say \"no thanks, we just need this this that and this. We will now promise that any future terms will be built using that interface. In return, you must understand our notion of equality, which you can work out from the interface I suppose\"</p>\n<p>Examples: the real numbers, a group, the localisation of a ring, the module of one-forms for an algebra over a ring, or a sheaf on a space.</p>",
        "id": 171209157,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563484109
    },
    {
        "content": "<p>Except that sometimes you break the interface and pretend you didn't</p>",
        "id": 171209258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484189
    },
    {
        "content": "<p>Reading the MO question I was amused that no one noticed that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb R\\subseteq\\Bbb C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.82486em;vertical-align:-0.13597em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> is not an isomorphism-invariant statement. They say \"we know isomorphisms don't matter so we may as well assume it's the case\" but then it's not isomorphism invariant anymore</p>",
        "id": 171209368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484261
    },
    {
        "content": "<p>I find those endless comments very hard to read.</p>",
        "id": 171209485,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563484339
    },
    {
        "content": "<p>I think that statement showed up in one of the answers</p>",
        "id": 171209570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484407
    },
    {
        "content": "<p>Was it the one I accepted?</p>",
        "id": 171209585,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563484431
    },
    {
        "content": "<p><a href=\"https://mathoverflow.net/a/336233/34444\" target=\"_blank\" title=\"https://mathoverflow.net/a/336233/34444\">https://mathoverflow.net/a/336233/34444</a></p>",
        "id": 171209699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484516
    },
    {
        "content": "<blockquote>\n<p>Relatedly, we can assume that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">R</mi><mo>⊆</mo><mi mathvariant=\"double-struck\">C</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb R\\subseteq\\Bbb C</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.82486em;vertical-align:-0.13597em;\"></span><span class=\"mord mathbb\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">⊆</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">C</span></span></span></span> because we only care about the axiomatized properties of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span>, which are preserved under isomorphism. One could manually preserve the original <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">R</mi></mrow><annotation encoding=\"application/x-tex\">\\Bbb R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord mathbb\">R</span></span></span></span> as an actual subset of its quadratic extension, but that is unnecessary for the reason I just stated.</p>\n</blockquote>\n<p>This reasoning fails to take into account that by taking advantage of isomorphism invariance you break it</p>",
        "id": 171209790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484594
    },
    {
        "content": "<p>There are also two deleted answers with positive scores which degenerated into flamewars resulting in the OP just deleting everything</p>",
        "id": 171209797,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563484603
    },
    {
        "content": "<p>I saw the comment but I'm not high rep on MO so I can't read it :(</p>",
        "id": 171209818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484638
    },
    {
        "content": "<p>Andrej usually has interesting things to say</p>",
        "id": 171209828,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484659
    },
    {
        "content": "<p>To me the process is tedious but straightforward. We need <code>equiv.rel</code> in mathlib, and then a bunch of isomorphism builders, and a bunch of isomorphism statements, and then this will be easy</p>",
        "id": 171210056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484850
    },
    {
        "content": "<p>Don't come to me about making a tactic to do it until you've already done it 10 times and know what it looks like</p>",
        "id": 171210162,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563484934
    },
    {
        "content": "<p>I think Andrej and I follow each other on Twitter; I'll prod him.</p>",
        "id": 171210188,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563484975
    },
    {
        "content": "<p>What is the role that this predicate should play? We define the Cauchy reals, and we prove that they are a complete arch field, and then we prove that any two complete arch fields are uniquely isomorphic as ordered fields. We then have this type <code>real</code> and this promise that we will only use <code>complete_archimedean_ordered_field real</code> or whatever. We have given you a precise interface here. What you now need to do somehow is to make this a primitive object -- I would quite happily be in an environment where the real type and its instance as a complete archimedean ordered field was some structure and a bunch of axioms. Why can't we use this abstraction for the reals and only have access to this interface?</p>",
        "id": 171210886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485572
    },
    {
        "content": "<p>It would presumably be easier to reason about proof transportability if you knew the proof had stuck to the interface.</p>",
        "id": 171210999,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485648
    },
    {
        "content": "<p>I'm talking about transfer specifically. This is independent of any interface to the reals you may or may not be adhering to</p>",
        "id": 171211008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485659
    },
    {
        "content": "<p>I want a little bit of HoTT magic at exactly this point</p>",
        "id": 171211014,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485668
    },
    {
        "content": "<p>So tell me again what transfer specifically means?</p>",
        "id": 171211022,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485689
    },
    {
        "content": "<blockquote>\n<p>To me the process is tedious but straightforward. We need <code>equiv.rel</code> in mathlib, and then a bunch of isomorphism builders, and a bunch of isomorphism statements, and then this will be easy</p>\n</blockquote>",
        "id": 171211046,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485722
    },
    {
        "content": "<p>The only way to get, provably in lean, invariance from syntax generically is if you have a deeply embedded language and express all your properties in that language. I'm sure we don't want to do that</p>",
        "id": 171211077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485762
    },
    {
        "content": "<p>Will this tedious but straightforward process be easier to do in Lean 4?</p>",
        "id": 171211123,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485773
    },
    {
        "content": "<p>not particularly</p>",
        "id": 171211143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485804
    },
    {
        "content": "<p>So we may as well start right away :-)</p>",
        "id": 171211156,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485819
    },
    {
        "content": "<p>like I said, stop thinking of tactics and start thinking about the problem</p>",
        "id": 171211181,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485821
    },
    {
        "content": "<p>Isn't the immediate problem that someone has to write some meta code?</p>",
        "id": 171211212,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563485853
    },
    {
        "content": "<p>Once you know what the problem is and what the solution is the tactic writes itself</p>",
        "id": 171211217,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485855
    },
    {
        "content": "<p>no</p>",
        "id": 171211219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485860
    },
    {
        "content": "<p>meta code comes later</p>",
        "id": 171211232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485874
    },
    {
        "content": "<p>proofs come first</p>",
        "id": 171211235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563485880
    },
    {
        "content": "<p>Tactics never allow you to prove something you couldn't prove before. They just make it easier to do things you already knew how to do</p>",
        "id": 171211403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486004
    },
    {
        "content": "<p>So maybe a tactic which does this would be interesting: I will define the Dedekind reals in Lean, prove they're a complete arch ordered field, and then demand from you a copy of the Bochner integral but all with Dedekind reals instead of Cauchy reals.</p>",
        "id": 171211411,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486013
    },
    {
        "content": "<p>Do I \"know how to do that\"? Is this one we're going to solve with tags?</p>",
        "id": 171211423,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486029
    },
    {
        "content": "<p>You don't, that's the problem</p>",
        "id": 171211444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486062
    },
    {
        "content": "<p>the idea is that any PR to mathlib which didn't use the allowable interface would not be accepted.</p>",
        "id": 171211458,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486090
    },
    {
        "content": "<p>So you just have to write some regex to check that people aren't fiddling with the real's privates</p>",
        "id": 171211483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486121
    },
    {
        "content": "<p>and run all PR's through the regex to check for safety</p>",
        "id": 171211533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486137
    },
    {
        "content": "<p>The safety check is not the problem, the equivalence proofs are</p>",
        "id": 171211542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486154
    },
    {
        "content": "<p>and if they pass you can accept the PR and then some Lean code generates a proof that all the stuff in mathlib is still \"safe\"</p>",
        "id": 171211551,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486162
    },
    {
        "content": "<p>Even if we know everything is safe that doesn't provide a proof of equivalence</p>",
        "id": 171211570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486189
    },
    {
        "content": "<p>So what formally is the problem?</p>",
        "id": 171211576,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486193
    },
    {
        "content": "<p>You have already stated it: Given a concrete predicate P on rings prove that if A and B are isomorphic rings then P(A) iff P(B)</p>",
        "id": 171211616,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486226
    },
    {
        "content": "<p>Surely it provides a proof that the term exists, it just doesn't actually make the term.</p>",
        "id": 171211617,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486227
    },
    {
        "content": "<p>Why isn't that P(A) iff P(B) thing easy?</p>",
        "id": 171211673,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486259
    },
    {
        "content": "<p>It is</p>",
        "id": 171211685,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486270
    },
    {
        "content": "<p>You just peel P apart and do it by induction</p>",
        "id": 171211690,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486275
    },
    {
        "content": "<p>Yes, so do it</p>",
        "id": 171211693,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486280
    },
    {
        "content": "<p>You mean it's hard to implement?</p>",
        "id": 171211695,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486288
    },
    {
        "content": "<p>No, it's easy</p>",
        "id": 171211700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486293
    },
    {
        "content": "<p>but it's work</p>",
        "id": 171211705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486296
    },
    {
        "content": "<p>I can't do it, I have my decency.</p>",
        "id": 171211709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486301
    },
    {
        "content": "<p>and it needs to actually be in mathlib</p>",
        "id": 171211715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486303
    },
    {
        "content": "<p>It's not maths.</p>",
        "id": 171211720,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486307
    },
    {
        "content": "<p><code>transfer</code> will not work until mathlib is full of theorems like that</p>",
        "id": 171211738,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486333
    },
    {
        "content": "<p>that's an axiom, you guys have to do that one :-) I would have no idea how to do it. Is it the sort of thing a novice tactic-writer could try?</p>",
        "id": 171211744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486342
    },
    {
        "content": "<p>If you don't know how to do it, how would a novice know?</p>",
        "id": 171211807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486364
    },
    {
        "content": "<p>I mean maybe they can just read Programming In Lean and then just do it</p>",
        "id": 171211828,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486386
    },
    {
        "content": "<p>A novice tactic writer can generalize from examples, but we have none</p>",
        "id": 171211829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486387
    },
    {
        "content": "<p>once we have done it by hand 10 times a novice tactic writer can do the rest</p>",
        "id": 171211841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486413
    },
    {
        "content": "<p>So what needs doing in practice?</p>",
        "id": 171211843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486413
    },
    {
        "content": "<p>What's the <em>first thing</em> that needs to be done?</p>",
        "id": 171211866,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486428
    },
    {
        "content": "<p><code>equiv.rel</code>, isomorphism builders, and theorems of the form A ~= B -&gt; P(A) &lt;-&gt; P(B)</p>",
        "id": 171211882,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486450
    },
    {
        "content": "<p>Are there some sorts of milestones which you can see to making this <code>transfer</code> tactic?</p>",
        "id": 171211887,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486456
    },
    {
        "content": "<p>So what is the type of <code>equiv.rel</code>?</p>",
        "id": 171211900,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486479
    },
    {
        "content": "<p><code>equiv.rel (e : A ~= B) : A -&gt; B -&gt; Prop := \\lam a b, e a = b</code></p>",
        "id": 171211957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486502
    },
    {
        "content": "<p>This allows you to state a theorem of the form <code>A ~= B -&gt; P(A) &lt;-&gt; P(B)</code> as <code>e.rel =&gt; iff</code> where <code>=&gt;</code> is that funny relator operation</p>",
        "id": 171212015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486582
    },
    {
        "content": "<p>oh so that one's done now, right?</p>",
        "id": 171212016,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486582
    },
    {
        "content": "<p>You need a few theorems about it</p>",
        "id": 171212024,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486600
    },
    {
        "content": "<p>the most important ones for transfer is that it is left and right unique</p>",
        "id": 171212083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486621
    },
    {
        "content": "<p>OK so is there some structure I need to make on equiv.rel?</p>",
        "id": 171212099,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563486643
    },
    {
        "content": "<p>and the converse is given by equiv.rel of the inverse equiv</p>",
        "id": 171212102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486646
    },
    {
        "content": "<p>I think <code>left_unique</code> and <code>right_unique</code> are typeclasses</p>",
        "id": 171212127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486672
    },
    {
        "content": "<p>If you look at <code>logic.relator</code> there are several functions related to this sort of thing</p>",
        "id": 171212202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563486731
    },
    {
        "content": "<p>Just to be clear -- the <code>e : A =~ B</code> notation -- the type of <code>e</code> is just some random type <code>T A B</code>, or does it have to have some sort of equivalence relation properties?</p>",
        "id": 171212535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563487036
    },
    {
        "content": "<p><code>e</code> is an equiv</p>",
        "id": 171212624,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563487117
    },
    {
        "content": "<p>not a fancy equiv, just an <code>equiv</code></p>",
        "id": 171212645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563487149
    },
    {
        "content": "<p>More complicated things would have something like <code>(e.to_equiv.rel =&gt; iff) Gorenstein Gorenstein</code> where <code>e</code> is a ring equiv</p>",
        "id": 171212758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563487233
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I can't resist a bit of history here. Read Dedekind's <em>Was sind und was sollen die Zahlen</em> (1888), roughly \"What are the [natural] numbers and what should they be.\" See especially the introduction. (It is the second essay here: <a href=\"http://www.gutenberg.org/files/21016/21016-pdf.pdf\" target=\"_blank\" title=\"http://www.gutenberg.org/files/21016/21016-pdf.pdf\">http://www.gutenberg.org/files/21016/21016-pdf.pdf</a>.) The answer to the question posed in the title is expressed more clearly in his letter to Keferstein: <a href=\"http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf\" target=\"_blank\" title=\"http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf\">http://www.bris.ac.uk/media-library/sites/structuralism/migrated/documents/kerfstein.pdf</a>. It is as you say: We don't care what they are, as long as they satisfy the properties we want. We only need to construct one to show that the notion is coherent. Then, if as long as we respect the interface, anything we say about one will be true of the other. (The part about respecting the interface is in Section 134 on page 48 of the essay.) In modern terms, he gave an axiomatic characterization of the natural numbers, a set theoretic construction (from the assumption that there exists an infinite set), and a proof that any two systems satisfying the axioms are isomorphic.</p>\n<p>Dedekind was an early proponent of a modern, structural view of mathematics, at a time when the subject had a much more calculational style. According to van der Waerden, Emmy Noether used to say \"Es steht alles schon bei Dedekind,\" i.e. everything is already there, in Dedekind.</p>",
        "id": 171212776,
        "sender_full_name": "Jeremy Avigad",
        "timestamp": 1563487253
    },
    {
        "content": "<p>I have seen all this stuff before but I  just never really understood its depth until recently</p>",
        "id": 171213470,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563487885
    },
    {
        "content": "<p>But in some sense it really is not mathematics. This whole thing is just a tedious implementation issue.</p>",
        "id": 171216483,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563491407
    },
    {
        "content": "<p>Everything is already there, in Dedekind.</p>",
        "id": 171216489,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563491423
    },
    {
        "content": "<p>Maybe the old usage of  <code>transfer</code> to prove properties about ints-as-pairs-of-naturals should be the in mathlib docs, i.e. <a href=\"https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean\" target=\"_blank\" title=\"https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean\">https://github.com/leanprover/lean/blob/6ab792733d09878d82ce98d88f6f476c8e0f34d8/library/init/data/int/basic.lean</a></p>",
        "id": 171247808,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1563533824
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">logic</span><span class=\"bp\">.</span><span class=\"n\">relator</span>\n\n<span class=\"n\">def</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">≃</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→</span> <span class=\"n\">B</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">e</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">b</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">≃</span> <span class=\"n\">B</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">left_unique</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a₁</span> <span class=\"n\">b</span> <span class=\"n\">a₂</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"n\">e</span> <span class=\"err\">$</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"bp\">.</span><span class=\"n\">symm</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">relator</span><span class=\"bp\">.</span><span class=\"n\">right_unique</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">rel</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b₁</span> <span class=\"n\">b₂</span> <span class=\"n\">h1</span> <span class=\"n\">h2</span><span class=\"o\">,</span> <span class=\"n\">eq</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">h1</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"n\">h2</span>\n</pre></div>\n\n\n<p>What next?</p>",
        "id": 171281201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563560537
    },
    {
        "content": "<p>pick a simple predicate or construction and try to prove its isomorphism theorem</p>",
        "id": 171281396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563560682
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rel_imp</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">iff</span> <span class=\"err\">⇒</span> <span class=\"o\">(</span><span class=\"n\">iff</span>  <span class=\"err\">⇒</span> <span class=\"n\">iff</span><span class=\"o\">))</span> <span class=\"n\">implies</span> <span class=\"n\">implies</span> <span class=\"o\">:=</span>\n</pre></div>\n\n\n<p>this <code>logic.relator</code> file is pretty cool :-)</p>\n<p>But didn't <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span>  and/or <span class=\"user-mention\" data-user-id=\"110026\">@Simon Hudon</span>  write a bunch of this sort of code years ago?</p>",
        "id": 171284929,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563562929
    },
    {
        "content": "<p>the lemma below looks like some experimental new one way traffic system</p>",
        "id": 171284930,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563562929
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">rel_iff</span> <span class=\"o\">:</span> <span class=\"o\">((</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"err\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"err\">⇒</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">↔</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</pre></div>",
        "id": 171284931,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563562929
    },
    {
        "content": "<p>It's a new way to write <code>*_congr</code> lemmas</p>",
        "id": 171285022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563005
    },
    {
        "content": "<p>For the proof, I would just unfold the notations straight away until I know what I'm doing. The <code>transfer</code> tactic knows how to put the lemmas together without unfolding them</p>",
        "id": 171285117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563073
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706\" title=\"#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/how.20to.20use.20transfer/near/135299706</a></p>",
        "id": 171285290,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563208
    },
    {
        "content": "<p>We've talked about this stuff before and I have just about enough control of Zulip search to be able to find some of it.</p>",
        "id": 171285318,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563236
    },
    {
        "content": "<p>There's another old post where I prove isomorphism theorem for maximal ideals this way</p>",
        "id": 171285368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563280
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751\" title=\"#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Perfectoid.20spaces/near/159808751</a></p>",
        "id": 171285436,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563308
    },
    {
        "content": "<p>And there was definitely one where I started talking about this sort of thing and was asking how to make a transfer tactic, and Simon and Scott just talked about it for a while and then I think Scott wrote a tonne of code, and there was quite an active period during which you (Mario) were asleep, and then you woke up and checked Zulip and were like \"wooah you guys have moved fast\" or something. I'd really like to find that thread.</p>",
        "id": 171285491,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563373
    },
    {
        "content": "<p>At the time I just remember not understanding the issues well enough, and hence being unable to understand the code properly</p>",
        "id": 171285566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563410
    },
    {
        "content": "<p>It was some code which went through a fair few primitives and proved a lemma about each of them, and then started proving lemmas about other things all hands-on.</p>",
        "id": 171285655,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563495
    },
    {
        "content": "<p>Maybe there was also talk about using tags for transfer, and using typeclass resolution to tag more and more stuff as \"still OK if replaced by isomorphic thing\"</p>",
        "id": 171285726,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563545
    },
    {
        "content": "<p>oh that's right there was a <code>respects_isomorphism</code> typeclass IIRC</p>",
        "id": 171285749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563578
    },
    {
        "content": "<p>I forget the actual name</p>",
        "id": 171285761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563563587
    },
    {
        "content": "<p>Each time this transfer conversation occurs I learn quite a lot about the idea, but I still have work to do.</p>",
        "id": 171285782,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563563611
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">real</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">instance</span> <span class=\"kn\">notation</span><span class=\"bp\">.</span><span class=\"n\">sub_eq_add_neg</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_add</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_neg</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">has_sub</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"bp\">-</span><span class=\"n\">b</span><span class=\"bp\">⟩</span>\n\n<span class=\"n\">class</span> <span class=\"n\">has_field_notation</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">has_zero</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">has_one</span> <span class=\"n\">X</span><span class=\"o\">,</span>\n<span class=\"n\">has_mul</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">has_add</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">has_neg</span> <span class=\"n\">X</span> <span class=\"c1\">-- note: don&#39;t use has_sub</span>\n<span class=\"c1\">-- because it might cause a diamond now</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_field_notation</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">refine</span> <span class=\"o\">{}</span><span class=\"bp\">;</span><span class=\"n\">apply_instance</span>\n\n<span class=\"n\">class</span> <span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_field_notation</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">all_the_axioms</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span> <span class=\"bp\">=</span> <span class=\"n\">y</span> <span class=\"bp\">+</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- ...</span>\n<span class=\"o\">(</span><span class=\"n\">etc</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"mi\">1</span> <span class=\"bp\">*</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- boring proof omitted</span>\n<span class=\"kn\">instance</span> <span class=\"n\">cauchy_reals_are_complete</span> <span class=\"o\">:</span> <span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"n\">ℝ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">Reals</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">has_field_notation</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">CauchyReals</span> <span class=\"o\">:</span> <span class=\"n\">Reals</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span>\n  <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n  <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">cauchy_reals_are_complete</span>\n<span class=\"o\">}</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">ordered_field_equiv</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_field_notation</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">has_field_notation</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"n\">Y</span><span class=\"o\">]</span>\n  <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"c1\">-- add extra axioms here</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">all_reals_are_the_same</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_field_notation</span> <span class=\"n\">X</span><span class=\"o\">]</span>\n  <span class=\"o\">[</span><span class=\"n\">complete_ordered_archimedean_field</span> <span class=\"n\">X</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"bp\">∃</span> <span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">ordered_field_equiv</span> <span class=\"n\">X</span> <span class=\"n\">ℝ</span><span class=\"o\">,</span> <span class=\"n\">true</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- boring proof omitted</span>\n\n<span class=\"n\">class</span> <span class=\"n\">platonist_friendly</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Reals</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Reals</span><span class=\"o\">,</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"n\">CauchyReals</span><span class=\"o\">)</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"n\">Q</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">Reals</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">platonist_friendly</span> <span class=\"n\">P</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">platonist_friendly</span> <span class=\"n\">Q</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">platonist_friendly</span> <span class=\"o\">(</span><span class=\"n\">P</span> <span class=\"err\">∩</span> <span class=\"n\">Q</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"k\">begin</span>\n  <span class=\"k\">show</span> <span class=\"n\">P</span> <span class=\"n\">X</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"n\">X</span> <span class=\"bp\">↔</span> <span class=\"n\">P</span> <span class=\"n\">CauchyReals</span> <span class=\"bp\">∧</span> <span class=\"n\">Q</span> <span class=\"n\">CauchyReals</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"bp\">_</span><span class=\"n\">inst_1</span><span class=\"bp\">.</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"bp\">_</span><span class=\"n\">inst_2</span><span class=\"bp\">.</span><span class=\"n\">e</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span><span class=\"bp\">⟩</span>\n</pre></div>\n\n\n<p>I didn't look at your work yet, I just thought I'd try and work out some concepts with this Cauchy / Dedekind reals thing.</p>\n<p>One could even play the same game with the Lau Rationals (the field of fractions of <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68889em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathbb\">Z</span></span></span></span></span>) vs the computer science rationals in mathlib.</p>",
        "id": 171301894,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563580521
    },
    {
        "content": "<p>Is the idea that a tactic can generate instances of the <code>platonist_friendly</code> class, by induction on P somehow? There are no relators above so they are also clearly offering something which I've not yet understood. And finally there is this question which does not appear to be addressed by the above -- if I prove some theorem about some Bochner integral of some function being equal to pi, how do I mark this theorem with the \"there is a version of me for Dedekind reals and indeed for all terms of type Reals\" tag?</p>",
        "id": 171302165,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563580922
    },
    {
        "content": "<p>What relators bring to the table is the ability to deal with n-ary predicates, with a variety of equivalences on the inputs (one type might be in bijection, the other is a module and there's a module iso, and then relative to the first equiv some elements a and b are related)</p>",
        "id": 171302966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563582177
    },
    {
        "content": "<p>This is necessary for making the \"proof by induction\" go through</p>",
        "id": 171302975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563582203
    },
    {
        "content": "<p>which is why I'm not supportive of the typeclass approach</p>",
        "id": 171302977,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563582219
    },
    {
        "content": "<p>The relator way to write <code>platonist_friendly P</code> is <code>(e.rel =&gt; iff) P P</code> where <code>e</code> is an ordered field equiv</p>",
        "id": 171303040,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563582338
    },
    {
        "content": "<p>well that's not quite accurate since you bundled <code>Reals</code>. Normally you would use some relation <code>R : Reals -&gt; Reals -&gt; Prop</code> asserting that the two elements of <code>Reals</code> are isomorphic, but in the case of <code>Reals</code> that's the trivially true relation</p>",
        "id": 171303147,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563582490
    },
    {
        "content": "<p>Yes, the reals are somehow an easier case, the universal predicate applies to types with field notation and is just the assertion that they're complete ordered Archimedean fields which is enough to make them \"the same as\" the platonic reals</p>",
        "id": 171318944,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563612941
    },
    {
        "content": "<p>I bundled subthings and morphisms of things!</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">data</span><span class=\"bp\">.</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"n\">class</span> <span class=\"n\">thing</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">.</span> <span class=\"c1\">-- insert data here (usually notation and some axioms)</span>\n\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"n\">γ</span><span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">γ</span><span class=\"o\">]</span>\n\n<span class=\"n\">class</span> <span class=\"n\">is_subthing</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- this class should not exist. Sometimes you see it in mathlib though.</span>\n\n<span class=\"kn\">set_option</span> <span class=\"n\">old_structure_cmd</span> <span class=\"n\">true</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">subthing</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"k\">proof</span> <span class=\"o\">:</span> <span class=\"n\">is_subthing</span> <span class=\"n\">carrier</span><span class=\"o\">)</span> <span class=\"c1\">-- replace with notation closure axioms e.g. one_mem, mul_mem etc. Note that is_subthing is never used again.</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">subthing</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨_</span><span class=\"o\">,</span> <span class=\"n\">subthing</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">subthing</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">set</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">subthing</span><span class=\"bp\">.</span><span class=\"n\">carrier</span><span class=\"bp\">⟩</span>\n\n<span class=\"c1\">-- another deprecated class</span>\n<span class=\"n\">def</span> <span class=\"n\">is_thing_morphism</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">true</span> <span class=\"c1\">-- this class should not exist. Sometimes you see it in mathlib though.</span>\n<span class=\"c1\">-- I won&#39;t bother making it into a class. It&#39;s deprecated.</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">thing_morphism</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">β</span><span class=\"o\">]:=</span>\n<span class=\"o\">(</span><span class=\"n\">to_fun</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">is_thing_morphism</span> <span class=\"n\">to_fun</span><span class=\"o\">)</span> <span class=\"c1\">-- replace with notation-preserving axioms e.g. map_one, map_mul.... Note that `is_thing_morphism`  never occurs again</span>\n\n<span class=\"kn\">infixr</span> <span class=\"bp\">`</span> <span class=\"bp\">→</span><span class=\"n\">t</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">thing_morphism</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"n\">t</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span>\n  <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">thing_morphism</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span><span class=\"o\">}</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">thing_morphism</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span><span class=\"n\">t</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"bp\">→</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">intro</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span>\n  <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">rwa</span> <span class=\"n\">thing_morphism</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"c1\">-- bundled equivs using old structure command so no `to_fun` problems</span>\n<span class=\"kn\">structure</span> <span class=\"n\">thing_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">thing_morphism</span> <span class=\"n\">α</span> <span class=\"n\">β</span>\n\n<span class=\"kn\">infix</span> <span class=\"bp\">`</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"bp\">`</span><span class=\"o\">:</span><span class=\"mi\">25</span> <span class=\"o\">:=</span> <span class=\"n\">thing_equiv</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">thing_equiv</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">thing_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">F</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">,</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"n\">to_fun</span><span class=\"o\">}</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">ext</span> <span class=\"o\">{</span><span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">thing_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n  <span class=\"n\">cases</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">cases</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">thing_equiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj_eq</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">mk</span><span class=\"bp\">.</span><span class=\"n\">inj</span> <span class=\"bp\">_;</span><span class=\"n\">try</span> <span class=\"o\">{</span><span class=\"n\">assumption</span><span class=\"o\">},</span>\n  <span class=\"n\">change</span> <span class=\"n\">f_to_fun</span> <span class=\"bp\">=</span> <span class=\"n\">g_to_fun</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">ext</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">exact</span> <span class=\"n\">congr_fun</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">lemma</span> <span class=\"n\">coe_inj</span> <span class=\"o\">:</span> <span class=\"n\">function</span><span class=\"bp\">.</span><span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">thing_equiv</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span> <span class=\"o\">:</span> <span class=\"n\">thing_equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"bp\">→</span> <span class=\"n\">equiv</span> <span class=\"n\">α</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">f</span> <span class=\"n\">g</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- is this idiomatic?</span>\n  <span class=\"k\">show</span> <span class=\"err\">⇑</span><span class=\"o\">(</span><span class=\"n\">to_equiv</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">refl</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">refl</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">refl</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span><span class=\"o\">,</span><span class=\"bp\">..</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">α</span><span class=\"o\">}</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">symm</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span><span class=\"o\">,</span><span class=\"bp\">..</span><span class=\"n\">e</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"o\">}</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">trans</span><span class=\"o\">]</span> <span class=\"kn\">protected</span> <span class=\"n\">def</span> <span class=\"n\">trans</span> <span class=\"o\">(</span><span class=\"n\">e1</span> <span class=\"o\">:</span> <span class=\"n\">β</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">γ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e2</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"err\">≃</span><span class=\"n\">t</span> <span class=\"n\">γ</span> <span class=\"o\">:=</span> <span class=\"o\">{</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">trivial</span><span class=\"o\">,</span><span class=\"bp\">..</span><span class=\"n\">e2</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span> <span class=\"n\">e1</span><span class=\"bp\">.</span><span class=\"n\">to_equiv</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- perms</span>\n<span class=\"n\">def</span> <span class=\"n\">perm</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">thing</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"n\">thing_equiv</span> <span class=\"n\">α</span> <span class=\"n\">α</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_one</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">thing_equiv</span><span class=\"bp\">.</span><span class=\"n\">refl</span> <span class=\"n\">α</span><span class=\"bp\">⟩</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mul</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">thing_equiv</span><span class=\"bp\">.</span><span class=\"n\">trans</span><span class=\"bp\">⟩</span> <span class=\"c1\">-- goodness knows if this is &quot;right&quot; or whether I should swap</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_inv</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">thing_equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span><span class=\"bp\">⟩</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">group</span> <span class=\"o\">(</span><span class=\"n\">perm</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">),</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span><span class=\"bp\">⁻¹</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"n\">rfl</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_left_inv</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">ext</span> <span class=\"err\">$</span> <span class=\"k\">begin</span> <span class=\"n\">funext</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"n\">x</span> <span class=\"kn\">end</span><span class=\"o\">}</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">thing_equiv</span>\n</pre></div>\n\n\n<p>I got as far as the automorphism group of a thing.</p>",
        "id": 171351722,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563675918
    },
    {
        "content": "<p>Now someone can knock off a tactic and we can just bundle everything instantly.</p>",
        "id": 171351886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563676283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228602\">@Sian Carey</span></p>",
        "id": 171351888,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563676313
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> my understanding is that you want bundled <code>monoid_hom</code> but no definition of <code>group_hom</code>. Could there still be a <code>group_hom</code> namespace though?</p>",
        "id": 171354903,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563682455
    },
    {
        "content": "<p>I want to define field homomorphisms between $fields$ which I guess are called <code>discrete_field</code>. Chris / <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  -- what do you people want the bundled class to be called (<code>discrete_field_hom</code>, <code>field_hom</code>, <code>ring_hom</code>, <code>semiring_hom</code>...) and exactly what instances to you want Lean to ask for in the actual definition of the structure? (e.g. <code>map_zero</code> follows from <code>map_add</code> because everything is a field in my case of interest, so we don't need it, but I don't care if <code>map_zero</code> is a field or not, I just want to do it right).</p>",
        "id": 171355738,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684356
    },
    {
        "content": "<p>Are <code>semiring_hom</code>, <code>ring_hom</code> and <code>field_hom</code> all the same?</p>",
        "id": 171355785,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684441
    },
    {
        "content": "<p>yes but I thought Chris was arguing that some of these things shouldn't even be tokens.</p>",
        "id": 171355790,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684478
    },
    {
        "content": "<p>Of those <code>ring_hom</code> is my favorite</p>",
        "id": 171355830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684511
    },
    {
        "content": "<p>I thought he suggested that <code>group_hom</code> be not defined, <code>-&gt;*</code> be notation for <code>monoid_hom</code> which also demands <code>map_one</code> and just tell the user to use the right notation for group homs which happens to coincide with the notation for monoid homs. They will never have to make one with their bare hands hopefully :-)</p>",
        "id": 171355843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684583
    },
    {
        "content": "<p>We can do the same thing with field homs - call it <code>ring_hom</code>, but it's really a semiring hom and you use it for semirings and fields too</p>",
        "id": 171355887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684615
    },
    {
        "content": "<p>If <code>field_hom</code> is not even defined, can there still be a <code>field_hom</code> namespace? Does that ever happen in mathlib?</p>",
        "id": 171355889,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684637
    },
    {
        "content": "<p>There can be a namespace</p>",
        "id": 171355891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684653
    },
    {
        "content": "<p>Although you will miss out on dot notation</p>",
        "id": 171355898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684691
    },
    {
        "content": "<p>but theorems which are specific for fields, such as injectivity of the underlying map, naturally live there I think...oh, I see your point.</p>",
        "id": 171355940,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684730
    },
    {
        "content": "<p>Is <code>-&gt;*+</code> horrible notation for a ring hom?</p>",
        "id": 171355953,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684787
    },
    {
        "content": "<p>lgtm</p>",
        "id": 171356000,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684870
    },
    {
        "content": "<p>I want a LaTeX right-arrow with a + and a * floating over it when we're doing the controlled natural language thing; this notation is just a temporary thing</p>",
        "id": 171356004,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684899
    },
    {
        "content": "<p>You don't have to convince me, I find this kind of notation more palatable than random selections from the unicode arrow palette</p>",
        "id": 171356061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1563684984
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> what is the categorification of <code>subring R</code>?</p>",
        "id": 171356062,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563684988
    },
    {
        "content": "<p>mathematically?</p>",
        "id": 171356066,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563684999
    },
    {
        "content": "<p>Is it <code>ring_hom A R</code> or <code>injective_ring_hom A R</code>?</p>",
        "id": 171356071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685021
    },
    {
        "content": "<p>Is the question mathematically meaningful?</p>",
        "id": 171356077,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685034
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/subobject\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/subobject\">https://ncatlab.org/nlab/show/subobject</a></p>",
        "id": 171356078,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563685045
    },
    {
        "content": "<p>it's an isomorphism class of monomorphisms</p>",
        "id": 171356080,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563685059
    },
    {
        "content": "<p>Thanks.</p>",
        "id": 171356081,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685066
    },
    {
        "content": "<p>So I think you're saying it's <code>injective_ring_hom</code>.</p>",
        "id": 171356249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685420
    },
    {
        "content": "<p><code>injective</code> is a predicate on <code>ring_hom</code>.</p>",
        "id": 171356266,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685443
    },
    {
        "content": "<p>which implies <code>monic</code></p>",
        "id": 171356296,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685484
    },
    {
        "content": "<p>Is this something to do with topologies on categories?</p>",
        "id": 171356310,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685525
    },
    {
        "content": "<p>These categories -- lattices -- are the best categories in Lean. Do we have topologies on these categories?</p>",
        "id": 171356360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563685659
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">ring_equiv</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">ring</span> <span class=\"n\">S</span><span class=\"o\">]</span> <span class=\"kn\">extends</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"err\">≃</span> <span class=\"n\">S</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"bp\">→+*</span> <span class=\"n\">S</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 171356833,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563686632
    },
    {
        "content": "<p>end of definition</p>",
        "id": 171356875,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563686669
    },
    {
        "content": "<blockquote>\n<p>These categories -- lattices -- are the best categories in Lean. Do we have topologies on these categories?</p>\n</blockquote>\n<p>we have... Groethendieck topologies</p>",
        "id": 171357396,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563687699
    },
    {
        "content": "<p>Is <code>monic</code> an example?</p>",
        "id": 171359520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563691672
    },
    {
        "content": "<p>of what?</p>",
        "id": 171359644,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563691838
    },
    {
        "content": "<p>Something that satisfies the axioms for the admissible morphisms in a grothendieck topology</p>",
        "id": 171359960,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563692318
    },
    {
        "content": "<p>grothendieck topology needs admissible <strong>families</strong> of morphisms right</p>",
        "id": 171360072,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563692478
    },
    {
        "content": "<p>I can say that { A_i -&gt; A } is admissible if the images generate the whole ring</p>",
        "id": 171360083,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1563692510
    },
    {
        "content": "<p><code>abbreviation ring_equiv (R S : Type) [ring R] [ring S] := Ring.of R ≅ Ring.of S</code></p>",
        "id": 171362426,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1563696877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> The definition with <code>≅</code> has two drawbacks.<br>\n1. It only works for <code>R</code> and <code>S</code> in the same universe.<br>\n2. It's harder to define elements of this type. Currently, <code>≃*</code> etc ask for a proof of <code>to_fun</code> being a <code>hom</code>, and automatically deduce that <code>inv</code> is a <code>hom</code>.</p>",
        "id": 171364205,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1563700256
    },
    {
        "content": "<p>2 can be solved with a constructor. 1 I personally don't care about because I am a mathematician</p>",
        "id": 171370079,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563711029
    },
    {
        "content": "<p>Can we use function composition notation with bundled homs? If <code>f : thing_hom A B</code> and <code>g : thing_hom B C</code> then can we have <code>f \\circ g : thing_hom A C</code> or whichever way round you want it? Does one just overload notation in this situation?</p>",
        "id": 171377241,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563723805
    },
    {
        "content": "<p>Possibly, we can have something like <code>has_comp</code> and use it.</p>",
        "id": 171383082,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1563734578
    },
    {
        "content": "<p>Though it means overriding notation from core.</p>",
        "id": 171383091,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1563734604
    },
    {
        "content": "<p>(of course, we can use some other symbol)</p>",
        "id": 171383136,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1563734647
    },
    {
        "content": "<p>... Kevin, is bring able to talk about things in different universes so important to you that you're willing to give up the completely uniform notation for morphisms, composition, isomorphism, tensor product, etc, notation that the category theory API provides?</p>",
        "id": 171386180,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1563740030
    },
    {
        "content": "<p>I know I know, but the category theory API bundles objects which makes it scary. I don't know how to glue sheaves using the category theory version of sheaves.</p>",
        "id": 171387802,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1563743075
    },
    {
        "content": "<p><code>linear_equiv</code> is defined with the old structure command, and <code>mul_equiv</code> with the new one. In practice this means that <code>mul_equiv</code> just has a field <code>to_equiv</code> and then all the equiv stuff like <code>left_inv</code> comes off that:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">import</span> <span class=\"n\">linear_algebra</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">linear_equiv</span> <span class=\"c1\">-- long</span>\n<span class=\"bp\">#</span><span class=\"kn\">print</span> <span class=\"n\">mul_equiv</span> <span class=\"c1\">-- short</span>\n\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">linear_equiv</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"c1\">-- works</span>\n<span class=\"bp\">#</span><span class=\"kn\">check</span> <span class=\"n\">mul_equiv</span><span class=\"bp\">.</span><span class=\"n\">left_inv</span> <span class=\"c1\">-- fails</span>\n</pre></div>\n\n\n<p>Which is best?</p>",
        "id": 171899451,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564339369
    },
    {
        "content": "<p>Old structures are the best.</p>",
        "id": 171901720,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1564343477
    },
    {
        "content": "<p>So the disadvantage with the new structure command is that if you want to use properties of <code>equiv</code>, you have to explicitly write <code>to_equiv</code>. The advantage of new structures is that they are faster.</p>",
        "id": 171901723,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564343508
    },
    {
        "content": "<p>My rule of thumb is: use old structures if the thing you are describing is a genuine mathematical object. Use a new structure if it's just a universal property.</p>",
        "id": 171901784,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564343607
    },
    {
        "content": "<p>So all the structures we built in the perfectoid project -- for example adic spaces -- should all be using the old structure command?</p>",
        "id": 171901885,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564343791
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> it's about time we started calling them \"good old structures\" and \"the good old structure command\".</p>",
        "id": 171901895,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564343829
    },
    {
        "content": "<p>well, they're equivalent, in a sense, so no need to rewrite things that don't need to be rewritten</p>",
        "id": 171901900,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564343863
    },
    {
        "content": "<p>in fact, if you've already done it using new structures</p>",
        "id": 171901902,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564343869
    },
    {
        "content": "<p>you should keep them that way. after all, they are faster</p>",
        "id": 171901907,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564343876
    },
    {
        "content": "<p>maybe a better rule of thumb is: use a new structure, unless you get annoyed with always having to write <code>to_equiv</code></p>",
        "id": 171902046,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344097
    },
    {
        "content": "<p>the most important difference is new structures can't have duplicate fields</p>",
        "id": 171902101,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344191
    },
    {
        "content": "<p>It's just a pain to use the constructor for new structures.</p>",
        "id": 171902184,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1564344358
    },
    {
        "content": "<p>yes, in the original description of new structures, Leo assumed a bunch of the tactics would be updated to transparently handle it all. Well, it didn't</p>",
        "id": 171902230,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344414
    },
    {
        "content": "<p>We never really ran into these issues as far as I remember -- our main goal was a definition, and our structures just got bigger and bigger but we were lucky not to ever run into duplicate substructures.</p>",
        "id": 171902238,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564344436
    },
    {
        "content": "<p>The tactics didn't get updated, or they couldn't be updated?</p>",
        "id": 171902243,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564344452
    },
    {
        "content": "<p>didn't get updated</p>",
        "id": 171902244,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344459
    },
    {
        "content": "<p>I guess also since we have no idea what's happening in Lean 4, maybe prefer and start with new structures and hope they are easier to work with whenever the new version gets released</p>",
        "id": 171902303,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344546
    },
    {
        "content": "<p>ahh, so you see, in my last three paras I've given completely contradictory advise</p>",
        "id": 171902365,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344640
    },
    {
        "content": "<p>I suppose I don't know which one to prefer either :)</p>",
        "id": 171902371,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1564344661
    },
    {
        "content": "<p>Here's a question about <code>mul_equiv</code>s. I really don't know how to set these up. So far I have gone for the old structure command, extending <code>equiv</code> and adding a field <code>map_mul</code>. The problem is with proving things like symmetry. I have goals like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">((</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">to_equiv</span> <span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">(</span><span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"n\">n₂</span><span class=\"o\">))</span> <span class=\"bp\">=</span>\n    <span class=\"n\">h</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"o\">((</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">to_equiv</span> <span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">n₁</span> <span class=\"bp\">*</span> <span class=\"o\">(</span><span class=\"n\">equiv</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"o\">(</span><span class=\"n\">to_equiv</span> <span class=\"n\">h</span><span class=\"o\">))</span><span class=\"bp\">.</span><span class=\"n\">to_fun</span> <span class=\"n\">n₂</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>which I really just want to put into a canonical form and then rewrite/simp to death. But the problem is that the canonical form of <code>h.inv_fun</code> seems to be <code>h.symm</code> when <code>h</code> is an <code>equiv</code>, and if I define <code>symm</code> on <code>mul_equiv</code> then I have to reprove stuff like <code>symm_apply_apply</code> in this situation.</p>",
        "id": 171957333,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564415167
    },
    {
        "content": "<p>yeah but the proof is just <code>equiv.symm_apply_apply</code></p>",
        "id": 171957542,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1564415314
    },
    {
        "content": "<p>but I can't rewrite it</p>",
        "id": 171957569,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564415339
    },
    {
        "content": "<p>In fact my first question is what the canonical notation for the inverse bijection should be with <code>h : mul_equiv G H</code></p>",
        "id": 171957626,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564415381
    },
    {
        "content": "<p>Prove that <code>f.symm.to_equiv = f.to_equiv.symm</code> and make it <code>simp</code></p>",
        "id": 171957789,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1564415461
    },
    {
        "content": "<p>I think my issue is that I am in the middle of defining <code>mul_equiv.symm</code> and I am complaining about not being able to use the canonical notation <code>h.symm</code> when stating some intermediate result, but this is spurious because <code>h.symm</code> is in the process of being defined.</p>",
        "id": 171957872,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1564415509
    },
    {
        "content": "<p>Hi, I was away for some time. It seems that <code>monoid_hom</code> and <code>add_monoid_hom</code> are already bundled. I have a few questions about the implementation:<br>\n1. Why do we repeat all the proofs instead of using <code>to_additive</code>? My guess is “to provide docstrings” but we can use <code>tactic.add_doc_string</code>. Actually, the new docstring can be turned into the second optional argument to <code>to_additive</code>.<br>\n2. I see that <code>M</code>, <code>N</code>, <code>G</code>, <code>H</code> is used for monoids/groups. Doesn't it break the naming conventions? I'm trying to understand how strict is the style guide w.r.t. naming convention.<br>\n3. If I want to migrate, say, <code>polynomial.C</code> to <code>monoid_hom</code>, the definition will look like <code>def C {α} ... : α →* polynomial α</code>, and <code>C (1 : α)</code> fails to coerce <code>C</code> to a function. It works, if I make <code>α</code> a mandatory argument but this is not convenient.</p>",
        "id": 172877572,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565376008
    },
    {
        "content": "<p>1. because I only really worked out the full power of <code>to_additive</code> today (see a thread in #general). <br>\n2. Yes it breaks the naming conventions. Computer scientists get a lot of things right about names, but I believe that one of very few exceptions is here. If a computer scientist wants to a call a group alpha and a normal subgroup beta and then some auxiliary set gamma then that's fine by me, but if we call the group G and the normal subgroup N and the auxiliary set S then it is much easier to see at a glance what is happening, especially if variables are being used and the definitions of alpha and beta are 150 lines up. <br>\n3. Probably <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> will have something to say on the matter.</p>",
        "id": 172877963,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376233
    },
    {
        "content": "<p><a href=\"#narrow/stream/113488-general/topic/to_additive.20and.20tags\" title=\"#narrow/stream/113488-general/topic/to_additive.20and.20tags\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/to_additive.20and.20tags</a></p>",
        "id": 172878140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376270
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344\">https://github.com/leanprover-community/mathlib/blob/659533e1dc63074d3386ffb8b2fbed50151dd34c/src/group_theory/submonoid.lean#L344</a> for the kind of code I am writing now. I think this is better -- I repeat almost nothing.</p>",
        "id": 172878257,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Thanks for explanations. I'd like to help with migrating to bundled hom. What can I work on to avoid duplication of effort?</p>",
        "id": 172878506,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565376500
    },
    {
        "content": "<p>You would be more than welcome to help <span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span>  and me with all the to_additive stuff. As you can see we got up to line 569. Amelia also refactored <code>localisation.lean</code> in that branch, to see how things look with the changes, and they seemed fine. We did not think about polynomials though.</p>",
        "id": 172878798,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376610
    },
    {
        "content": "<p>E.g., I can rewrite <code>algebra/group/hom</code> using <code>to_additive</code>. Is it OK?</p>",
        "id": 172878881,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565376692
    },
    {
        "content": "<p>Here's a message I sent Amelia earlier today:</p>\n<blockquote>\n<p>So what I currently believe is this. Say you have made 10 definitions and proved 20 lemmas in the namespace submonoid and you want to get additive versions in add_submonoid. The one thing which can almost always be avoided is having to write out a proof twice, once in the multiplicative and once in the additive case.</p>\n<p>The best possible scenario is when defining a lemma; in this case you can use @[to_additive add_submonoid.foo] and that might be almost all you need to do; this will hopefully generate the proof automatically. Unfortunately it doesn't generate the docstring automatically and you have to add it with this run_cmd which which I don't really understand. There are plenty of examples in the commit I pushed today (all in this bundled_submonoids branch of mathlib).</p>\n<p>More complicated is a definition. I have been writing definition submonoid.foo ..., getting it working, and then writing #print prefix submonoid.foo (note that you need submonoid even if you're in the submonoid namespace). You then see submonoid.foo but also perhaps submonoid.foo.match_1 or submonoid.foo.equations_eqn3 or something. For structures you see loads of things. After the definition you can write to_additive [add_submonoid.foo.proof_3] submonoid.foo.proof_3 and this needs to be done for everything in the output. However it all has to be done in the right order. If you get red squiggles under a to_additive then look at the error, see if it mentions add_submonoid.foo.equation_2 and then move the corresponding to_additive line above the line with the error. In all cases I got this to work. And don't forget the docstring. Note that in one case the errors I got were errors involving functions which I had not defined -- other people had missed out the to_additive tags on other functions, so I had to add those in (they should probably be moved to the correct part of mathlib at some point).</p>\n<p>Even more complicated is a structure. I have been defining the additive ones by hand. And there are some lemmas or definitions which don't port, for example those involving powers x^n turn into ones involving smultiples n \\bub x and because the order got switched to_additive sometimes can't handle it. In these cases I leave the submonoid namespace immediately, define the additive one by hand (i.e. write the same code again), do all the to_additive tags and the docstring, and then go back into the submonoid namespace. You then have to re-input all the variables which you had open in that namespace. Variables outside a namespace survive inside it, but variables inside a namespace die once the namespace is closed, even if you go back in.</p>\n</blockquote>",
        "id": 172878892,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376705
    },
    {
        "content": "<p>Everything we have done is in the <code>bundled_submonoids</code> branch of mathlib and our plan was to finish <code>submonoid.lean</code> and then make a PR.</p>",
        "id": 172879013,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376803
    },
    {
        "content": "<p>We didn't touch the <code>hom</code> file so it will be OK.</p>",
        "id": 172879187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565376922
    },
    {
        "content": "<p>Probably, one of us should learn more about Lean tactic language, and let <code>to_additive</code> handle <code>mydef._proof_n</code> and all those <code>mystruct.cases_on</code> etc.<br>\nAnother idea is to have <code>@[bundled_hom]</code> user attr that defines <code>has_coe_to_fun</code> and restates all axioms using <code>coe</code> instead of <code>f.to_fun</code>.</p>",
        "id": 172879215,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565376948
    },
    {
        "content": "<p>OK, then I'll go through <code>hom</code>, then I'll try to migrate concrete categories (<code>Mon</code> etc.) to bundled homs.</p>",
        "id": 172879305,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565377034
    },
    {
        "content": "<p>Bundling group and monoid and ring stuff (subthings, homs and isomorphisms) is just a one-off job which needs to be done once. The reason I am motivated to do it now is because I think it makes it easier for mathematicians -- but I am not sure about this. Other people also believe it's best to do things like bundle homs and subobjects, for other reasons. What became clear to me was that the task of actually <em>removing</em> unbundled homs and replacing them with bundled ones is a vast task, because is_submonoid appears 200 times in the library and one of the appearances is in the definition of <code>is_subgroup</code> which appears 200 more times, and then <code>is_subring</code> uses both of these etc etc.</p>",
        "id": 172879418,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565377124
    },
    {
        "content": "<p>Furthermore, the switch would be one huge PR which would take a very long time to write and would have to constantly be playing catch-up with the library. This sounded very unappealing. So my plan is to bundle stuff, leave the unbundled stuff in for now (but mention that it is deprecated in docstrings) and then start changing leaf nodes to see if things work. Amelia changed <code>localisation.lean</code> and it worked fine. But changing stuff deeper in mathlib is painful. So our plan is to work from the outside in. The disadvantage of our approach is that ultimately it will in some sense be more work, probably. The advantage is that we can access bundled homs immediately, which is what I wanted really.</p>",
        "id": 172879696,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565377272
    },
    {
        "content": "<p>I'm very worried about this thread. For the sensitivity conjecture project, I worked seriously with linear maps for the first time. They are bundled, and it simply does not work. The coercion to function works completely randomly, and there are instance search timeout all over the place. It's extremely time-consuming and frustrating to fight that</p>",
        "id": 172883788,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565380482
    },
    {
        "content": "<p>Bundled maps have much <em>lower</em> pressure on the typeclass system, because you aren't inferring the fact that the function is a hom anymore</p>",
        "id": 172884037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565380661
    },
    {
        "content": "<p>I can believe that the coercion is problematic sometimes though. The alternative is to write <code>.to_fun</code></p>",
        "id": 172884116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565380701
    },
    {
        "content": "<p>but coercions are part of the type class system</p>",
        "id": 172884125,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565380708
    },
    {
        "content": "<p>The alternative doesn't work, because lemmas are stated without <code>.to_fun</code></p>",
        "id": 172884141,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565380729
    },
    {
        "content": "<p>Personally, I would happily live with <code>to_fun</code> everywhere. I put the coercions in because you guys are always going on about nice looking notation and lean 3 provides few other opportunities for this kind of thing</p>",
        "id": 172884226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565380794
    },
    {
        "content": "<p>This is really sad</p>",
        "id": 172884304,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565380835
    },
    {
        "content": "<p>/me prefers <code>Python</code>-style <code>obj.__call__</code> convention over typeclass resolution</p>",
        "id": 172884313,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565380841
    },
    {
        "content": "<p>I agree completely (to both statements)</p>",
        "id": 172884356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565380867
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span>  What's are the other opportunities in Lean 3 for this kind of thing?</p>",
        "id": 172884966,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565381349
    },
    {
        "content": "<p>for zero-notation functions, nothing, but if you are willing to accept a character or two you can use a notation</p>",
        "id": 172885066,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565381404
    },
    {
        "content": "<p>BTW, what's wrong with dropping <code>has_coe_to_fun</code> and using <code>f.1</code>?</p>",
        "id": 172885219,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565381532
    },
    {
        "content": "<p>Forgot to tag <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span></p>",
        "id": 172885280,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565381615
    },
    {
        "content": "<p>This is really not how we think about maps</p>",
        "id": 172885296,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565381634
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> I see the following options:<br>\n1. the old way; <strong>pros</strong>: already implemented; easy to say that the same map can be <code>is_mul_hom</code> or <code>is_monoid_hom</code> under different assumptions; <strong>cons</strong>: need to find <code>is_*_hom</code> instances here and there; what else?<br>\n2. bundled homs, implicit coercion; <strong>pros</strong>: <code>map_mul</code> and <code>map_one</code> are right there; <code>M →* N</code> is exactly <code>Mon.of M \\--&gt; Mon.of N</code> (not yet); <strong>cons</strong>: need to find <code>has_coe_to_fun</code> every time; sometimes this coercion fails;<br>\n3. bundled homs, <code>f.1</code>; <strong>pros</strong>: see 2 + no class instance resolution at all; <strong>cons</strong>: unnatural notation.<br>\nWhat do I miss?</p>",
        "id": 172885925,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565382144
    },
    {
        "content": "<p>I don't see what I could add here. Type class inference doesn't work in Lean 3, and it doesn't provide error messages</p>",
        "id": 172888189,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565384143
    },
    {
        "content": "<blockquote>\n<p>2. Yes it breaks the naming conventions. Computer scientists get a lot of things right about names, but I believe that one of very few exceptions is here. If a computer scientist wants to a call a group alpha and a normal subgroup beta and then some auxiliary set gamma then that's fine by me, but if we call the group G and the normal subgroup N and the auxiliary set S then it is much easier to see at a glance what is happening, especially if variables are being used and the definitions of alpha and beta are 150 lines up. </p>\n</blockquote>\n<p>I also wanted to comment on that. The linear algebra library uses the random greek letter convention, and it's really a nightmare. They are lots of type involved, and not knowing which one is meant to be a base field, an indexing type or a vector space is really awful. They are tons of lemmas whose statements are very hard to parse, and would be very easy with reasonable type naming conventions.</p>",
        "id": 172888724,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565384552
    },
    {
        "content": "<p>Then maybe <code>docs/contribute/naming.md</code> should be adjusted.</p>",
        "id": 172889261,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565385006
    },
    {
        "content": "<p>With some sensible theory-specific naming conventions.</p>",
        "id": 172889262,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565385006
    },
    {
        "content": "<p>I'd love that</p>",
        "id": 172889279,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1565385034
    },
    {
        "content": "<p>+1 from me.</p>",
        "id": 172893316,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565388610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"214703\">@Yury G. Kudryashov</span> the reason I'm bundling is because the community seems to think it's the best idea. To a certain extent it might just be about experimenting to find out what works best. I have seen coercions fail before and you can just write (f : G -&gt; H) to make them happen; I quite like that notation</p>",
        "id": 172893457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565388729
    },
    {
        "content": "<p>The one place where I feel that the alpha beta notation is natural is when dealing with types that really are that -- just types. For example <code>equiv alpha beta</code> seems fine to me because for all I know this is what computer scientists really call types. But types which are playing a mathematical role such as groups have got such a history of notation behind them and it's used to guide readers, and I don't see the point of throwing it away. Sure some people use <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> for a number field and some use <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07153em;\">K</span></span></span></span>, but nobody uses <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">\\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span>. The number field library that will one day be written will need to choose a notation, but it should, in my opinion, use one which is already in use.</p>",
        "id": 172896705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565391811
    },
    {
        "content": "<p>morally speaking isn't it <code>[G : group alpha]</code>?</p>",
        "id": 172901583,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1565398255
    },
    {
        "content": "<p>It is really unfortunate the coercions to function types barely work. I think this is the main pain point with bundling.</p>",
        "id": 172902177,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1565399223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110025\">@Andrew Ashworth</span> Groups are not bundled, so after <code>[G : group α]</code> you still have to say <code>x : α</code>, and this is not very readable, especially if you have, e.g., a group acting on a space.</p>",
        "id": 172916158,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565426648
    },
    {
        "content": "<p>Mathematicians read <code>x : α</code> as <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>x</mi><mo>∈</mo><mi>α</mi></mrow><annotation encoding=\"application/x-tex\">x\\in\\alpha</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.0037em;\">α</span></span></span></span> and they are far more used to <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">g\\in G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span>. In fact this is in some sense exactly the point -- if I see <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">g\\in G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> in the middle of a maths paper without any context then I would be likely to guess that <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding=\"application/x-tex\">G</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">G</span></span></span></span> was a group and <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">g</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span></span></span></span> an element. If I see <code>x : α</code> in a library file then I have no clue.</p>",
        "id": 172917010,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565428369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> I rewrote <code>to_additive</code> to automatically take care of many things. I'll try to PR it tonight or tomorrow. Current state (no docs, WIP) is available at <a href=\"https://github.com/urkud/mathlib/blob/to_additive/src/algebra/group/to_additive.lean\" target=\"_blank\" title=\"https://github.com/urkud/mathlib/blob/to_additive/src/algebra/group/to_additive.lean\">https://github.com/urkud/mathlib/blob/to_additive/src/algebra/group/to_additive.lean</a></p>",
        "id": 173309300,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565891319
    },
    {
        "content": "<p>Namely, (1) it automatically adds <code>to_additive</code> attribute to structure fields; (2) it looks for <em>prefixes</em> in <code>dict</code> instead of full names; (3) it automatically transfers <code>decl._proof_1</code>, <code>decl._match_1</code> etc . With (2), we don't need to have <code>attribute [to_additive add_monoid_hom.cases_on]  monoid_hom.cases_on</code> etc.</p>",
        "id": 173309526,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565891508
    },
    {
        "content": "<p>I'm away from Lean until Monday (camping)</p>",
        "id": 173309592,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565891528
    },
    {
        "content": "<p>Feel free to take a look at the bundled submonoids branch</p>",
        "id": 173309612,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565891550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Good luck with camping!</p>",
        "id": 173309650,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565891596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> did you push everything you have? The submonoid.lean file is half toadditiveised</p>",
        "id": 173309654,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1565891598
    },
    {
        "content": "<p>Not yet, I'm tidying things up a bit but I will push today. I've not toadditiveised anything yet.</p>",
        "id": 173309815,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1565891729
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> It should be easier to use <code>@[to_additive]</code> with my changes, so you should probably postpone <code>to_additive</code>isation for a day or two. I'll try to tidy my patch tonight.</p>",
        "id": 173311052,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565892594
    },
    {
        "content": "<p>Okay. Thank you for working on it!</p>",
        "id": 173311158,
        "sender_full_name": "Amelia Livingston",
        "timestamp": 1565892642
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118107\">@Amelia Livingston</span> I pushed a new version of <code>@[to_additive]</code> to the <code>to_additive</code> branch of <code>urkud/mathlib</code>.<br>\nIt automates:</p>\n<ul>\n<li>mapping of structure fields;</li>\n<li>mapping of hidden defs like <code>name._proof_1</code>, <code>name._match_1</code>;</li>\n<li>mapping of projections like <code>semigroup.to_has_mul</code> (relies on <code>@[ancestor]</code> attributes);</li>\n<li>mapping of <code>name.cases_on</code> by mapping prefixes instead of names.</li>\n</ul>",
        "id": 173379405,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565966992
    },
    {
        "content": "<p>Other items I want to add before making a PR:</p>\n<ul>\n<li>take docstring as an optional argument; alternative is to use <code>run_cmd add_doc_string</code> after each definition;</li>\n<li>autogenerate target namespace using <code>to_additive_attr.get_param src.get_prefix</code>; ask for the suffix only;</li>\n<li>make “target name” argument optional;<ul>\n<li>simple: use the same suffix as in the source name, e.g. <code>monoid_hom.comp</code> → <code>add_monoid_hom.comp</code>;</li>\n<li>advanced: parse suffix replacing <code>mul→add</code>, <code>one→zero</code>, <code>prod→sum</code> (what else?).</li>\n</ul>\n</li>\n<li>automatically create <code>target.equations._eqn_1</code>.</li>\n</ul>",
        "id": 173380631,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565967827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> what is responsible for creating <code>my_name.equations._eqn_1</code>? Is it intentional that this thing is called after normal <code>def</code>s but not after <code>add_decl</code>s?</p>",
        "id": 173381636,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565968577
    },
    {
        "content": "<p>I think it's the equation compiler who adds those equalities. <code>add_decl</code> (and its relatives, like <code>add_inductive</code>) indeed doesn't have the same side effects (like creating auxiliary definitions) as adding a declaration normally. It's probably useful to have both the version with and without side-effects, and it was suggested previously to expose versions with side effects in the community fork of Lean.</p>",
        "id": 173383070,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1565969710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span> Then I'll postpone automatic handling of equations till we have <code>add_decl_with_side_effects</code>.</p>",
        "id": 173384538,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1565970696
    },
    {
        "content": "<p>it's already available in community lean</p>",
        "id": 173389424,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1565974724
    },
    {
        "content": "<p>See <a href=\"https://github.com/leanprover-community/mathlib/pull/1345\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/pull/1345\">https://github.com/leanprover-community/mathlib/pull/1345</a> for the new <code>to_additive</code>. It seems that I've broken compilation in one of the last commits. I'll fix it tonight.</p>",
        "id": 173491594,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1566142960
    }
]
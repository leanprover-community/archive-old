[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"224323\">@Junyan Xu</span> <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> <span class=\"user-mention\" data-user-id=\"321459\">@Damiano Testa</span> and whoever else works in algebraic geometry: in about a month's time I will be giving four two-hour \"lectures\" on algebraic geometry in Lean for PhD students (having spent 4 more lectures beforehand teaching them the basics), and these \"lectures\" will mostly be me doing live coding of mathlib PRs. Does anyone have any requests as to what I should work on? Looking at the \"classic\" project <a href=\"https://github.com/leanprover-community/mathlib/projects/13\">https://github.com/leanprover-community/mathlib/projects/13</a> I see that defining various typeclasses for morphisms looks interesting -- I know that we got things like formally etale, formally smooth etc recently; should I go for separated/proper, and affine, or does anyone have any other requests? Is there any movement on sheaves of modules? What do we need for etale cohomology? (just a definition, not any theorems about it)</p>",
        "id": 303616632,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665577651
    },
    {
        "content": "<p>We really need to get an API for flat morphisms. That seems to be blocking a bunch of other stuff.</p>",
        "id": 303617747,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578056
    },
    {
        "content": "<p>And closed immersions.</p>",
        "id": 303617783,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578077
    },
    {
        "content": "<p>Flat morphisms: I was holding off on developing an API for flat modules/algebras until we had some homological algebra, because it seemed to me that there are some pretty slick proofs of flatness results using Tor. Did we balance Tor yet?</p>",
        "id": 303618786,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665578442
    },
    {
        "content": "<p>We first need to be able to use the definition of flatness, right?</p>",
        "id": 303618843,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578464
    },
    {
        "content": "<p>I think closed immersions would be a reasonable target.</p>",
        "id": 303618898,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665578494
    },
    {
        "content": "<p>I don't think we have a proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>C</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes M \\to B \\otimes M \\to C \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> stays exact, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a flat module.</p>",
        "id": 303618910,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578499
    },
    {
        "content": "<p>Flat morphisms of schemes would need sheaves of modules, right?</p>",
        "id": 303618941,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665578512
    },
    {
        "content": "<p>We only have this file with a stubbed out definition, about tensoring with inclusions of ideals.</p>",
        "id": 303618944,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/303618910\">said</a>:</p>\n<blockquote>\n<p>I don't think we have a proof that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>B</mi><mo>⊗</mo><mi>M</mi><mo>→</mo><mi>C</mi><mo>⊗</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">A \\otimes M \\to B \\otimes M \\to C \\otimes M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">⊗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> stays exact, if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is a flat module.</p>\n</blockquote>\n<p>This is waiting for the proof that R-Mod has enough injectives, which is on its way.</p>",
        "id": 303619136,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665578579
    },
    {
        "content": "<p>Ooh! Do you have a proof sketch somewhere?</p>",
        "id": 303619226,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578607
    },
    {
        "content": "<p>The proof in Stacks doesn't need \"enough injectives\", does it?</p>",
        "id": 303619268,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665578623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/303618941\">said</a>:</p>\n<blockquote>\n<p>Flat morphisms of schemes would need sheaves of modules, right?</p>\n</blockquote>\n<p>We could technically bypass this by defining flat morphisms to be morphisms that are flat on stalks?</p>",
        "id": 303620146,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665578941
    },
    {
        "content": "<p><a href=\"#narrow/stream/116395-maths/topic/flat.20modules/near/290089813\">This</a> is the proof I am thinking of, which only needs the existence of a cogenerator and Baer's criterion.</p>",
        "id": 303620229,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665578971
    },
    {
        "content": "<p>Aah, nice!</p>",
        "id": 303620606,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665579106
    },
    {
        "content": "<p>How long do you think it'll take to get there?</p>",
        "id": 303620706,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665579132
    },
    {
        "content": "<p>It is apparently quite easy: <a href=\"https://gist.github.com/erdOne/db56ba0d1c00ffc7159c909c268e0f0c#file-flat-lean-L199\">See this gist</a>.<br>\nThe catch is that Baer's criterion was not proven for f.g. ideals, so we do not yet have the iff to the mathlib definition.<br>\nBut I think we might as well remove the f.g. requirement for the mathlib definition and move on.</p>",
        "id": 303679277,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665593333
    },
    {
        "content": "<p>Wonderful! And what's the status with getting enough injectives?</p>",
        "id": 303700992,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665600585
    },
    {
        "content": "<p>This should be \"easy'(ish) with \"cofree\" modules</p>",
        "id": 303702273,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665601041
    },
    {
        "content": "<p>Do we know that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Q</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Q}/\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Q</span><span class=\"mord\">/</span><span class=\"mord mathbb\">Z</span></span></span></span> is injective over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span>?</p>",
        "id": 303702315,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665601054
    },
    {
        "content": "<p>Yup, we recently had a PR on divisible groups</p>",
        "id": 303702594,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665601139
    },
    {
        "content": "<p>It seems like we are two PRs away from knowing that Ab has enough injectives.<br>\nAfter that, since mathlib knows that injective objects are preserved by right adjoints, and we have the adjoint between Ab and R-Mod, it should be relatively easy to get.<br>\nAll these work are due to <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> and he probably has a better grasp at the amount of stuff remaining.</p>",
        "id": 303712500,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665604976
    },
    {
        "content": "<p>Yes, two PRs from Ab having enough objectives, in <a href=\"https://github.com/leanprover-community/mathlib/pull/15232\">this</a> PR, it is shown that adjoins functor a transfers enough injectives, then apply to <a href=\"https://github.com/leanprover-community/mathlib/pull/15958\">this</a> PR and an easy adjunction between restriction and coextension of scalars, then we have enough injectives for any R-mod</p>",
        "id": 303715162,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1665605982
    },
    {
        "content": "<p>I've also been sitting on some work since March that shows any module is isomorphic to the direct limit of its finitely generated submodules. I don't know if it's very helpful, but if anyone wants to use it to bridge the gap from f.g. ideals to all ideals feel free to copy whatever you want from it: <a href=\"https://github.com/mpenciak/flat_modules/blob/main/src/finite_submodules.lean\">https://github.com/mpenciak/flat_modules/blob/main/src/finite_submodules.lean</a>. (I bumped the mathlib version in July though)</p>\n<p>I was hoping I'd use it to prove some stuff about flat modules but life got in the way, and I never got around to working on it more.</p>",
        "id": 303727459,
        "sender_full_name": "Matej Penciak",
        "timestamp": 1665611698
    },
    {
        "content": "<p>By the way, what is the current status on sheaves of modules? Have we settled on an approach? Is anyone building stuff on top of some approach to determine which is the most practical?</p>",
        "id": 304114162,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1665780398
    },
    {
        "content": "<p>At least to me, it's not clear that we've converged on a certain design</p>",
        "id": 304154836,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1665812644
    },
    {
        "content": "<p>My understanding was that <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> was working on one of the choices and we were going to see how it turned out (but the last time we spoke he had Covid)</p>",
        "id": 304158880,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665816900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span> <span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here's a quick update on sheaves of modules:</p>\n<p>After considering the options and some zulip discussions (see <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules\">#maths &gt; Definition of presheaf of modules</a>) with <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, I am convinced that the only sustainable way to do sheaves of modules is to define them as module objects over monoid objects in the category of sheaves of abelian groups. </p>\n<p>This removes the need to redo a bunch of code that already exists, and the code written in the process will also be useful for things like group schemes. I'm pretty sure that even if we do one of the other options, eventually it'll have to be rewritten this way. The disadvantage is that it's a bit of a challenge to prove that for a sheaf of modules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span>, there is  a module structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>. </p>\n<p>To demonstrate the viability of this approach, I set out to show that for a sheaf of monoids <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span></span></span></span>, there is a monoid structure on <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{F}(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>. Unfortunately there have been a lot of false starts. Essentially, I spent most of the summer trying to prove a worse version of <a href=\"https://github.com/leanprover-community/mathlib/blob/4d0b6301ef962e6bd74462998943ce38b7adb132/src/category_theory/monoidal/internal/types.lean#L25\">https://github.com/leanprover-community/mathlib/blob/4d0b6301ef962e6bd74462998943ce38b7adb132/src/category_theory/monoidal/internal/types.lean#L25</a>,<br>\nwhich I wasn't aware was in mathlib (apparently the people in <a class=\"stream-topic\" data-stream-id=\"116395\" href=\"/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules\">#maths &gt; Definition of presheaf of modules</a> weren't either?). After discovering this, essentially all that's left for this proof of concept (other than putting all the pieces together) should be proving that certain functors are lax monoidal based on the fact that they preserve limits (see <a class=\"stream-topic\" data-stream-id=\"217875\" href=\"/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Monoidal.20functor.20from.20preserves.20limits.2Fcolimits\">#Is there code for X? &gt; Monoidal functor from preserves limits/colimits</a>). I'm not exactly sure why I'm struggling so much, perhaps I'm not using zulip correctly, or maybe it's just because I'm still very new? </p>\n<p>Anyways, after this, I got a bit busy, but I want to take another crack sometime soon, like next week or the week after.</p>",
        "id": 304222955,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1665852146
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> what do you think?</p>",
        "id": 304247836,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1665871630
    },
    {
        "content": "<p>We should have module objects over monoid objects in monoidal categories <em>anyway</em> so we may as well start there.</p>",
        "id": 304248623,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1665872376
    },
    {
        "content": "<p>I am not very familiar with the maths of this approach, it sounds like a unified approach. In this approach, how easy/hard it would be to define coherent and quasi coherent sheaves of modules?</p>",
        "id": 304249083,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1665872880
    },
    {
        "content": "<p>We already have module objects over monoid objects in monoidal categories. <a href=\"https://leanprover-community.github.io/mathlib_docs/find/Mod\">docs#Mod</a></p>",
        "id": 304270228,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665897969
    },
    {
        "content": "<p>I'm embarrassed to have lost track of this, but someone did the 2-category of algebras/bimodules/intertwiners internal to a monoidal category, as well.</p>",
        "id": 304270335,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1665898148
    },
    {
        "content": "<p>Dear All,</p>\n<p>sorry for coming late to this discussion: I am having a bad case of teaching and Covid and am still struggling to recover from both!</p>\n<p>I see that there are already quite a few people working on a categorical approach to algebraic geometry.</p>\n<p>I know that I have said this in the past, but a quick way to start proving stuff about algebraic varieties is to use the functor of points (maybe even simply on affine schemes).  I think that this could also be suitable for an \"independent start\".</p>\n<p>For a concrete proposal, defining and computing the set of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-valued points of affine space over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span></span></span></span> could be a fun project.</p>",
        "id": 306043890,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1666708929
    },
    {
        "content": "<p>I think the right approach is to define the Zariski topology on the category of rings, show that representable presheaves are sheaves, and show an equivalence of categories between the category of schemes and the sheaves on this topology which are locally representable.</p>",
        "id": 306047259,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666709920
    },
    {
        "content": "<p>Sorry to hear about covid/teaching. I hope things are better now!</p>",
        "id": 306048505,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666710249
    },
    {
        "content": "<p>Thanks, Adam!  I am feeling better, but still have some side-effects.  I am also recovering from Covid!  <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 306049500,
        "sender_full_name": "Damiano Testa",
        "timestamp": 1666710532
    },
    {
        "content": "<p>I have been thinking of a different approach for (pre)sheaves of modules. Instead of using the symmetric monoidal structure given by the tensor product of (pre)sheaves of abelian groups, and taking modules over monoid objects, a more direct (and lower tech) approach would be to develop notions of (abelian) group objects, ring objects, module objects, internally to categories. In the case of (pre)sheaves of sets, this would give the notion of (pre)sheaves of modules (over a \"nonconstant\" ring). In the case of the category of schemes, this also allows the definition of groups schemes.</p>\n<p>I recently had the idea of defining internal <code>A</code> objects in a category <code>C</code>, when <code>A</code> is a concrete category, as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"sd\">/-- The category of internal `A`-objects in the category `C`. -/</span>\n<span class=\"kd\">structure</span> <span class=\"n\">internal</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₂</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₂</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">concrete_category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n  <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u₁</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category.</span><span class=\"o\">{</span><span class=\"n\">v₁</span><span class=\"o\">}</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">presheaf</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">iso</span> <span class=\"o\">:</span> <span class=\"n\">yoneda.obj</span> <span class=\"n\">obj</span> <span class=\"bp\">≅</span> <span class=\"n\">presheaf</span> <span class=\"bp\">⋙</span> <span class=\"n\">forget</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Abelian group objects in <code>C</code> are <code>internal Ab C</code>. Ring objects are <code>internal Ring C</code>. All the structure is on the yoneda presheaf associated to a certain object. This is very much the way group schemes are sometimes defined in the literature: this is a scheme <code>G</code> for which the functor <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>H</mi><mi>o</mi><mi>m</mi><mo stretchy=\"false\">(</mo><mo>−</mo><mo separator=\"true\">,</mo><mi>G</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Hom(-,G)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">Ho</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">(</span><span class=\"mord\">−</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mclose\">)</span></span></span></span> is endowed with a functorial structure of group. (Note that I do not assume that the category <code>C</code> has finite products, but I can show that if <code>C</code> has some binary products and a terminal object, an <code>internal Ab C</code> structure on <code>X : C</code> is basically the same as the datum of a <code>zero</code> morphism from the terminal object, a <code>neg</code> automorphism and an addition morphism <code>prod X X ⟶ X</code> satisfying some relations).</p>\n<p>Then, given <code>R : internal Ring C</code> and <code>M : internal Ab C</code>, an <code>R</code>-module structure <code>module R M</code> can be introduced. If <code>F : C ⥤ D</code> is a functor which preserves finite products, then there are induced functors <code>internal Ab C ⥤ internal Ab D</code>, and with some extra work, the same would be true for <code>Ring</code>-objects, and modules. Then, using that internal abelian group objects in <code>Type</code> are abelian groups, etc, we can get module structures on the section of a sheaf of Modules using the evaluation functors.</p>\n<p>I have been able to define most of this (and also construct the additive group scheme <code>Gₐ : internal Ab Scheme</code> in this manner).<br>\nMy very draft code (with a few unsignificant sorries) is in the <code>group-object</code> branch of mathlib<br>\n<a href=\"https://github.com/leanprover-community/mathlib/compare/master...group-object\">https://github.com/leanprover-community/mathlib/compare/master...group-object</a></p>",
        "id": 306654505,
        "sender_full_name": "Joël Riou",
        "timestamp": 1666963337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> this is similar to an idea I had while doing some experiments with universal algebra (in lean4). What I want to do is write some macros/commands that would generate classes in the algebraic hierarchy, as well as the relevant category of bundled objects, and this was essentially the idea I had to generate the category of internal objects associated to an algebraic gadget. Doing this for structures with more than one sort adds a layer of complexity though.</p>",
        "id": 306657912,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666964224
    },
    {
        "content": "<p>In case you're interested, here's what I wrote so far along these lines -- it's mostly hacked together at this point, and so far it's just about \"introducing operations and notations.\" Adding axioms is the next step. I haven't had much time to work on this for a little while, unfortunately.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">Lean</span>\n<span class=\"kn\">open</span> <span class=\"n\">Lean</span> <span class=\"n\">Elab</span> <span class=\"n\">Command</span>\n\n<span class=\"kd\">inductive</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">generic</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">const</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">unary</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"n\">binfix</span> <span class=\"o\">:</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">String</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"n\">deriving</span> <span class=\"n\">Inhabited</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OpKind.arity</span> <span class=\"o\">:</span> <span class=\"n\">OpKind</span> <span class=\"bp\">→</span> <span class=\"n\">Nat</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">generic</span> <span class=\"n\">_</span> <span class=\"n\">n</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">n</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">0</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">unary</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">1</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">binfix</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"mi\">2</span>\n\n<span class=\"n\">declare_syntax_cat</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"generic\"</span> <span class=\"n\">str</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"const\"</span> <span class=\"n\">str</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"unary\"</span> <span class=\"n\">str</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"infix\"</span> <span class=\"n\">str</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"zero\"</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n<span class=\"n\">syntax</span> <span class=\"s2\">\"one\"</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">lang_gen</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">TSyntax.toOpKind</span> <span class=\"o\">:</span> <span class=\"n\">TSyntax</span> <span class=\"bp\">`</span><span class=\"n\">lang_gen</span> <span class=\"bp\">→</span> <span class=\"n\">OpKind</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lang_gen</span><span class=\"bp\">|</span> <span class=\"n\">generic</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"bp\">$</span><span class=\"n\">n</span><span class=\"o\">:</span><span class=\"n\">num</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OpKind.generic</span> <span class=\"n\">s.getString</span> <span class=\"n\">n.getNat</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lang_gen</span><span class=\"bp\">|</span> <span class=\"n\">one</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OpKind.one</span> <span class=\"n\">s.getString</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lang_gen</span><span class=\"bp\">|</span> <span class=\"n\">zero</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OpKind.zero</span> <span class=\"n\">s.getString</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">lang_gen</span><span class=\"bp\">|</span> <span class=\"kd\">infix</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">str</span> <span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">:</span><span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">OpKind.binfix</span> <span class=\"n\">s.getString</span> <span class=\"n\">t.getString</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"oops!\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">OpKind.toIdent</span> <span class=\"o\">:</span> <span class=\"n\">OpKind</span> <span class=\"bp\">→</span> <span class=\"n\">Ident</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">generic</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIdent</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIdent</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">s</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIdent</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">binfix</span> <span class=\"n\">s</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">mkIdent</span> <span class=\"n\">s</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"oops!\"</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkType</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Term</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">n</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">t</span><span class=\"o\">)</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"bp\">$</span><span class=\"n\">t</span> <span class=\"bp\">→</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkType</span> <span class=\"n\">t</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">mkTypes</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">ns</span> <span class=\"o\">:</span> <span class=\"n\">Array</span> <span class=\"n\">Nat</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"o\">(</span><span class=\"n\">Array</span> <span class=\"n\">Term</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">mut</span> <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"bp\">#</span><span class=\"o\">[]</span>\n  <span class=\"n\">for</span> <span class=\"n\">i</span> <span class=\"k\">in</span> <span class=\"n\">ns</span> <span class=\"k\">do</span>\n    <span class=\"n\">out</span> <span class=\"o\">:=</span> <span class=\"n\">out.push</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkType</span> <span class=\"n\">t</span> <span class=\"n\">i</span><span class=\"o\">)</span>\n  <span class=\"n\">return</span> <span class=\"n\">out</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">addNotation</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">:</span> <span class=\"n\">OpKind</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">Ident</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">MacroM</span> <span class=\"n\">Syntax</span> <span class=\"o\">:=</span>\n<span class=\"k\">match</span> <span class=\"n\">op</span> <span class=\"k\">with</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">binfix</span> <span class=\"n\">nm</span> <span class=\"n\">nt</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">infix</span><span class=\"o\">:</span><span class=\"mi\">12</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">Syntax.mkStrLit</span> <span class=\"n\">nt</span><span class=\"o\">):</span><span class=\"n\">str</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">nm</span><span class=\"o\">))</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">one</span> <span class=\"n\">nm</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">instance</span> <span class=\"n\">OfNatOne</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">nm</span><span class=\"o\">)⟩)</span>\n<span class=\"bp\">|</span> <span class=\"bp\">.</span><span class=\"n\">zero</span> <span class=\"n\">nm</span> <span class=\"bp\">=&gt;</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">instance</span> <span class=\"n\">OfNatZero</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">OfNat</span> <span class=\"n\">α</span> <span class=\"o\">(</span><span class=\"n\">nat_lit</span> <span class=\"mi\">0</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"n\">mkIdent</span> <span class=\"n\">nm</span><span class=\"o\">)⟩)</span>\n<span class=\"bp\">|</span> <span class=\"n\">_</span> <span class=\"bp\">=&gt;</span> <span class=\"n\">panic</span><span class=\"bp\">!</span> <span class=\"s2\">\"oops!\"</span>\n\n<span class=\"n\">elab</span> <span class=\"s2\">\"mk_raw_class\"</span> <span class=\"n\">s</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"s2\">\"[\"</span> <span class=\"n\">xs</span><span class=\"o\">:</span><span class=\"n\">lang_gen</span><span class=\"o\">,</span><span class=\"bp\">*</span> <span class=\"s2\">\"]\"</span> <span class=\"o\">:</span> <span class=\"n\">command</span> <span class=\"bp\">=&gt;</span> <span class=\"k\">do</span>\n  <span class=\"k\">let</span> <span class=\"n\">args</span> <span class=\"o\">:=</span> <span class=\"n\">xs.getElems.map</span> <span class=\"n\">TSyntax.toOpKind</span>\n  <span class=\"k\">let</span> <span class=\"n\">names</span> <span class=\"o\">:=</span> <span class=\"n\">args.map</span> <span class=\"n\">OpKind.toIdent</span>\n  <span class=\"k\">let</span> <span class=\"n\">e</span> <span class=\"o\">:=</span> <span class=\"n\">liftMacroM</span> <span class=\"k\">do</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">class</span> <span class=\"bp\">$</span><span class=\"n\">s</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"n\">where</span> <span class=\"bp\">$</span><span class=\"o\">[</span><span class=\"bp\">$</span><span class=\"n\">names</span><span class=\"o\">:</span><span class=\"n\">ident</span> <span class=\"o\">:</span> <span class=\"bp\">$</span><span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">mkTypes</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">α</span><span class=\"o\">))</span> <span class=\"bp\">$</span> <span class=\"n\">args.map</span> <span class=\"n\">OpKind.arity</span><span class=\"o\">)]</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">e</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kn\">namespace</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span>\n  <span class=\"n\">for</span> <span class=\"n\">arg</span> <span class=\"k\">in</span> <span class=\"n\">args</span> <span class=\"k\">do</span>\n    <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"n\">liftMacroM</span> <span class=\"bp\">$</span> <span class=\"n\">addNotation</span> <span class=\"n\">arg</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n  <span class=\"n\">elabCommand</span> <span class=\"o\">(</span><span class=\"bp\">←</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"kd\">end</span> <span class=\"bp\">$</span><span class=\"n\">s</span><span class=\"o\">))</span>\n\n<span class=\"n\">mk_raw_class</span> <span class=\"n\">gadget</span> <span class=\"o\">[</span>\n  <span class=\"kd\">infix</span> <span class=\"s2\">\"operation\"</span> <span class=\"s2\">\"*\"</span><span class=\"o\">,</span>\n  <span class=\"kd\">infix</span> <span class=\"s2\">\"another_operation\"</span> <span class=\"s2\">\"+\"</span><span class=\"o\">,</span>\n  <span class=\"kd\">infix</span> <span class=\"s2\">\"yet_another\"</span> <span class=\"s2\">\"*+\"</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"s2\">\"mulId\"</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"s2\">\"addId\"</span><span class=\"o\">]</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">+</span> <span class=\"n\">y</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"n\">y</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"n\">x</span> <span class=\"bp\">*+</span> <span class=\"n\">y</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span>\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span>\n\n<span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">_</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">gadget</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">gadget.mulId</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"mi\">1</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n</code></pre></div>\n</div></div>",
        "id": 306658930,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666964538
    },
    {
        "content": "<p>One issue is to understand what conditions on <code>A</code> one needs to impose to ensure that this category of internal <code>A</code>-objects is well-behaved (whatever that means). Certainly if <code>A</code> is the category of algebras for some Lawvere theory would suffice. Is there a simple characterization of such categories?</p>",
        "id": 306660041,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666964875
    },
    {
        "content": "<p>I think <a href=\"https://ncatlab.org/nlab/show/finitary+monad\">https://ncatlab.org/nlab/show/finitary+monad</a> gives a characterisation of Lawvere theories among concrete categories?</p>",
        "id": 306662102,
        "sender_full_name": "David Wärn",
        "timestamp": 1666965416
    },
    {
        "content": "<p>Does that only work for finitary Lawvere theories?</p>",
        "id": 306662239,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666965460
    },
    {
        "content": "<p>Of course for algebra we're really only interested in finitary theories so that's okay</p>",
        "id": 306662586,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666965546
    },
    {
        "content": "<p>So I guess the category needs to be concrete, monadic w.r.t. the forgetful functor, and the forgetful functor should commute with filtered colimits.</p>",
        "id": 306662853,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666965618
    },
    {
        "content": "<p>To be a bit more precise, what I had in mind is something along these lines:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.yoneda</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"n\">β</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">β</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">monoid</span> <span class=\"n\">β</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">map_id</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"mi\">1</span> <span class=\"bp\">=</span> <span class=\"mi\">1</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">map_mul</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"n\">y</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">*</span> <span class=\"n\">f</span> <span class=\"n\">y</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">internal_monoid</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">obj</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">,</span> <span class=\"n\">monoid</span> <span class=\"o\">((</span><span class=\"n\">yoneda.obj</span> <span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">opposite.op</span> <span class=\"n\">Y</span><span class=\"o\">))]</span>\n<span class=\"o\">(</span><span class=\"n\">is_monoid_hom_map</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">Y₁</span> <span class=\"n\">Y₂</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">Y₁</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y₂</span><span class=\"o\">),</span> <span class=\"n\">is_monoid_hom</span> <span class=\"o\">((</span><span class=\"n\">yoneda.obj</span> <span class=\"n\">obj</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">f.op</span><span class=\"o\">))</span>\n</code></pre></div>\n<p>The benefit here is that we get a monoid instance \"for free\" on the hom sets, whereas with the approach above you would have to transfer that instance along some bijection.<br>\nOn the other hand, to avoid replication with this approach we would have to use some metaprogramming, which is what I was (barely) starting to do with the code block above.</p>",
        "id": 306693948,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666973220
    },
    {
        "content": "<p>Also, if we replace <code>yoneda</code> with the <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.ihom\">docs#category_theory.ihom</a> analogue, we could generalize this to (closed) monoidal categories which are not just cartesian.</p>",
        "id": 306694410,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666973365
    },
    {
        "content": "<p>In my approach, in order to avoid too much code replication, I have used <code>n</code>-ary operations on the forgetful functor of the concrete category <code>A</code> for <code>n=0,1,2,3</code>... For example, on <code>Ab</code>, we have the 2-ary operation given by <code>+</code>; then, the yoneda presheaf <code>M.presheaf</code> of any <code>Ab</code>-object is equipped with a 2-ary operation, and if some binary product exists, it corresponds to a morphism <code>prod M.obj M.obj ⟶ M.obj</code>. The commutativity of <code>+</code> as a <code>2</code>-ary operation on <code>Ab</code> implies the same for the corresponding operations on <code>M.presheaf</code> and <code>M.obj</code>.<br>\n(In order to do group schemes, the fact that there is a presheaf iso in my structure <code>internal A C</code> is very useful: in order to define the additive group scheme [actually a commutative ring scheme], I just consider the presheaf of abelian groups which sends a scheme to the global sections of the structure sheaf, and I check that when we apply the forgetful functor, the presheaf of sets we get is representable by <code>Spec(ℤ[X])</code>. If we had <code>monoid/comm_group</code> instances directly in the definition of internal group objects, I would think the definition of such group schemes would be slightly harder.</p>",
        "id": 306714126,
        "sender_full_name": "Joël Riou",
        "timestamp": 1666978878
    },
    {
        "content": "<p>For the various algebraic categories where objects are just types bundled with some structure and the forgetful functor is the \"identity\" on morphisms, constructing internal objects in the two approaches would be essentially equivalent since the isomorphism in your approach would be essentially some wrapper around the identity.</p>",
        "id": 306721831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666981294
    },
    {
        "content": "<p>Of course the correct answer is to do both things and provide an API to go back and forth ;)</p>",
        "id": 306721992,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666981339
    },
    {
        "content": "<p>Unfortunately, that assumes we have an infinite amount of time.</p>",
        "id": 306722118,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1666981391
    },
    {
        "content": "<p>I do not think so. In my file <code>algebraic_geometry.group_schemes</code>, I define the groupe scheme <code>Gₐ</code> like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">Gₐ'</span> <span class=\"o\">:</span> <span class=\"n\">internal</span> <span class=\"n\">CommRing</span> <span class=\"n\">Scheme.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"n\">Spec.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"n\">CommRing.of</span> <span class=\"o\">(</span><span class=\"n\">polynomial</span> <span class=\"o\">(</span><span class=\"n\">ulift.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">ℤ</span><span class=\"o\">)))),</span>\n  <span class=\"n\">presheaf</span> <span class=\"o\">:=</span> <span class=\"bp\">Γ</span><span class=\"o\">,</span>\n  <span class=\"n\">iso</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">Γ</span><span class=\"n\">_Spec.adjunction.yoneda_nat_iso</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">≪≫</span>\n    <span class=\"o\">(</span><span class=\"bp\">Γ.</span><span class=\"n\">comp_yoneda_obj</span> <span class=\"n\">_</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">symm</span> <span class=\"bp\">≪≫</span> <span class=\"n\">iso_whisker_left</span> <span class=\"bp\">Γ</span> <span class=\"n\">polynomial_coyoneda_iso</span><span class=\"o\">,</span> <span class=\"o\">}</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">Gₐ</span> <span class=\"o\">:</span> <span class=\"n\">internal</span> <span class=\"n\">Ab</span> <span class=\"n\">Scheme.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">internal.forget₂</span> <span class=\"n\">CommRing</span> <span class=\"n\">Ring</span> <span class=\"n\">Scheme.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"bp\">⋙</span>\n  <span class=\"n\">internal.forget₂</span> <span class=\"n\">Ring</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">Scheme.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span><span class=\"bp\">.</span><span class=\"n\">obj</span> <span class=\"n\">Gₐ'</span>\n</code></pre></div>\n<p>This <code>iso</code> is not at all the identity. If I had to define <code>comm_group</code> instances directly on the Hom-sets, the construction would be more painful. On the contrary here, the definition above is very easy.</p>",
        "id": 306800278,
        "sender_full_name": "Joël Riou",
        "timestamp": 1667030957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> I think your approach is interesting. Does it allow us to define representations of group schemes in a similar way?</p>",
        "id": 307930383,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1667559609
    },
    {
        "content": "<p>Of course, one may define a linear representation of a group scheme as a morphism <code>G ⟶ GL n</code> for some <code>n</code> (assuming the linear group <code>GL</code> has been defined), but this is presumably not the best approach.</p>\n<p>Alternatively, in general, one may introduce the notion of internal <code>G</code>-set in a category <code>C</code>, i.e. an object <code>X : C</code> equipped with an internal (yoneda) operation of <code>G</code>. Then, if <code>X</code> is also equipped with a structure of <code>R</code>-module, one may require that the action is <code>R</code>-linear.</p>\n<p>If we apply this to the case <code>R</code> is the affine line, and put some restrictions on <code>M</code> (like \"free of finite type\"), this should give a reasonable definition of representations of group schemes in the sense that for any scheme <code>S</code>, the group of points <code>G(S)</code> would act linearly on <code>M(S)</code>.</p>",
        "id": 307965454,
        "sender_full_name": "Joël Riou",
        "timestamp": 1667570808
    },
    {
        "content": "<p>I can't get the coercion from <code>SheavedSpace Ab</code> to <code>Top</code> working. What am I doing wrong? Looks like a universe issue? I think putting all the <code>{0}</code>s there is really ugly. Can I get rid of them somehow?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.sheafed_space</span>\n\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">already in mathlib:</span>\n\n<span class=\"cm\">instance algebraic_geometry.SheafedSpace.coe_carrier : has_coe (SheafedSpace C) Top :=</span>\n<span class=\"cm\">{ coe := λ X, X.carrier }</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"c1\">--example : has_coe (algebraic_geometry.SheafedSpace Ab) Top := infer_instance -- fails</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">forget1</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Top.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">X</span> <span class=\"c1\">-- works</span>\n<span class=\"c1\">--def forget2 (X : algebraic_geometry.SheafedSpace Ab) : Top := X -- fails</span>\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe</span> <span class=\"o\">(</span><span class=\"n\">algebraic_geometry.SheafedSpace</span> <span class=\"n\">Ab</span><span class=\"o\">)</span> <span class=\"n\">Top</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">coe</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span><span class=\"o\">,</span> <span class=\"n\">X.carrier</span><span class=\"o\">}</span>\n<span class=\"c1\">-- def forget3 (X : algebraic_geometry.SheafedSpace Ab) : Top := X -- still fails</span>\n</code></pre></div>",
        "id": 308081201,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667613947
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X0</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- works fine</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X0</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"c1\">-- maximum class-instance resolution depth has been reached</span>\n</code></pre></div>",
        "id": 308083520,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667616234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/308083520\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">example</span> <span class=\"o\">(</span><span class=\"n\">X0</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">false</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span> <span class=\"c1\">-- works fine</span>\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X0</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">}</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"mi\">0</span><span class=\"o\">})</span> <span class=\"c1\">-- maximum class-instance resolution depth has been reached</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think Lean is having trouble inferring the has_products instance, because this error goes away if you do <a href=\"https://github.com/leanprover-community/mathlib/pull/17361/files\">these changes</a>.</p>",
        "id": 308084215,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1667616869
    },
    {
        "content": "<p>Even with that PR, some universe ascriptions are still necessary; the minimum you can get away with seems to be</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n<span class=\"kd\">def</span> <span class=\"n\">forget1</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">algebraic_geometry.SheafedSpace</span> <span class=\"n\">Ab.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">Top.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:=</span> <span class=\"n\">X</span>\n</code></pre></div>",
        "id": 308084264,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1667616922
    },
    {
        "content": "<p>Shouldn't the unused arguments linter be complaining before your PR?</p>",
        "id": 308084509,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667617128
    },
    {
        "content": "<p>In the max class instance logs there are things like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">[</span><span class=\"n\">class_instances</span><span class=\"o\">]</span> <span class=\"n\">caching</span> <span class=\"kd\">instance</span> <span class=\"n\">for</span> <span class=\"kt\">Type</span> <span class=\"bp\">→</span> <span class=\"bp\">@</span><span class=\"n\">limits.has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n<span class=\"bp\">λ</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">),</span>\n  <span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n    <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n       <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n          <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n             <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n                <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n                   <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n                      <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n                         <span class=\"o\">(</span><span class=\"bp\">@</span><span class=\"n\">limits.has_smallest_limits_of_has_limits</span> <span class=\"n\">CommRing</span> <span class=\"n\">CommRing.large_category</span>\n                            <span class=\"n\">CommRing.has_limits</span><span class=\"o\">))))))))</span>\n</code></pre></div>\n<p>That does not look like a good thing to cache to me.</p>",
        "id": 308084553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1667617171
    },
    {
        "content": "<p>I think <code>limits.has_smallest_limits_of_has_limits</code> should not be an instance.</p>",
        "id": 308087138,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1667619990
    },
    {
        "content": "<p>This is a problem because all the index categories for the finite limits were changed to be in universe 0</p>",
        "id": 308087931,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1667620895
    },
    {
        "content": "<p>We still have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.limits.has_finite_limits_of_has_limits_of_size\">docs#category_theory.limits.has_finite_limits_of_has_limits_of_size</a> so things should be fine.<br>\n<code>limits.has_finite_limits_of_has_limits_of_size</code> almost always causes type interference loops and it was added as an instance due to my oversight. I thought we removed the instance tag during the preserves-limit-universe-generalization but it seems like it is still around.</p>",
        "id": 308088267,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1667621183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/308084509\">said</a>:</p>\n<blockquote>\n<p>Shouldn't the unused arguments linter be complaining before your PR?</p>\n</blockquote>\n<p>Not sure why the linter didn't complain, but now I've completely removed the need of has_product for restricting a sheaf to an open subspace in <a href=\"https://github.com/leanprover-community/mathlib/pull/17361\">#17361</a>.</p>",
        "id": 308103942,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1667637023
    },
    {
        "content": "<p>Hello. This is Deepak. I am one of the graduate students taking Kevin Buzzard's TCC course on formalizing math this term. I was hoping to add some results on Noetherian Schemes following the Stacks project to get some credits for the course. I am just a beginner so I will probably need some help going forward and thank you all in advance. I have two questions at the moment. First of all it would be great to know if it is okay to go ahead with working on Noetherian schemes? I have looked at the mathlib rep and the pending pull requests which doesn't seem to have anything on the topic but Kevin suggested me to ask here and be sure.</p>",
        "id": 311474686,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669064644
    },
    {
        "content": "<p>Welcome! I believe no one is working on noetherian schemes.</p>",
        "id": 311510865,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669086586
    },
    {
        "content": "<p>You might want to imitate <a href=\"https://tqft.net/mathlib/algebraic_geometry/morphisms/basic\">file#algebraic_geometry/morphisms/basic</a>. Alternatively, you might be able to (ab)use the API on morphisms.</p>",
        "id": 311529456,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669100383
    },
    {
        "content": "<p>Hello Andrew and thank you very much for your reply.  Actually so far I have been having difficulties even with rather basic things like making some definitions and lemmas. The key reason being that there are so many layers of structure to schemes that I am often not even able to get to the correct types of objects to work with and poring over the documentation hasn't helped much especially with my limited understanding of lean. In particular, perhaps you could answer the following hopelessly ignorant question. Given a scheme how do I get to it's ring of global sections? There is a small section on the global section functor in the file on locally ringed spaces but I don't understand how to use it apparently. I need it to state the lemma below where I want to show that being a locally noetherian scheme implies existence of a noetherian affine cover. </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">exists_noetherian_affine_cover_of_is_locally_noetherian</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">is_locally_noetherian</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"bp\">𝒰</span> <span class=\"o\">:</span> <span class=\"n\">Scheme.open_cover</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">𝒰.</span><span class=\"n\">J</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_affine</span> <span class=\"o\">(</span><span class=\"bp\">𝒰.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">)],</span>\n<span class=\"o\">(</span><span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"bp\">𝒰.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">))</span><span class=\"bp\">.Γ</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div>\n<p>However I get the following error-</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">function</span> <span class=\"n\">expected</span> <span class=\"n\">at</span> <span class=\"n\">Scheme.</span><span class=\"bp\">Γ</span>\n<span class=\"n\">term</span> <span class=\"n\">has</span> <span class=\"n\">type</span>  <span class=\"n\">Scheme</span><span class=\"bp\">ᵒᵖ</span> <span class=\"bp\">⥤</span> <span class=\"n\">CommRing</span>\n</code></pre></div>\n<p>I suppose I need to pass an argument that converts a scheme to the underlying topological space as an open subset. Not clear at all how to do it though. Any help would be much appreciated. And apologies for such silly queries, I imagine I will probably have a few of those before I become a bit more proficient at this.</p>",
        "id": 311678798,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669140930
    },
    {
        "content": "<p>No, I think rather the problem is the <code>Scheme.\\Gamma</code> is a functor, rather than a function that takes a <code>Scheme</code> as an argument.</p>",
        "id": 311681532,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669141764
    },
    {
        "content": "<p>Where possible, please post examples as a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> (i.e. with the imports required), so someone can just copy and paste your code into an editor and see the same error message.</p>",
        "id": 311681673,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669141805
    },
    {
        "content": "<p>I could easily show you the right syntax, except that I'm too lazy to reconstruct your imports and variables. :-)</p>",
        "id": 311681809,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1669141835
    },
    {
        "content": "<p>It should be <code>Scheme.Γ.obj (op (𝒰.obj i))</code>. For a functor <code>F</code>, <code>F.obj</code> is the map on objects, and <code>F.map</code> is the map on arrows.</p>",
        "id": 311682145,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669141919
    },
    {
        "content": "<p>Hello Scott. Yes, thank you very much for telling me about MWEs! l will keep it in mind next time. :)</p>",
        "id": 311687357,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669143643
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311682145\">said</a>:</p>\n<blockquote>\n<p>It should be <code>Scheme.Γ.obj (op (𝒰.obj i))</code>. For a functor <code>F</code>, <code>F.obj</code> is the map on objects, and <code>F.map</code> is the map on arrows.<br>\n`<br>\nAndrew, I see what you mean, however the error persists. Let me share a MWE below.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.AffineScheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.nilpotent</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.sheaves.sheaf_condition.sites</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.binary_products</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.constructions</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.noetherian</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.local_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.Scheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.properties</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">opposite</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span> <span class=\"n\">Top</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">algebraic_geometry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Scheme</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_locally_noetherian</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">locally_noetherian</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X.carrier</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X.affine_opens</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">X.presheaf.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))))</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">is_locally_noetherian</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">exists_noetherian_affine_cover_of_is_locally_noetherian</span> <span class=\"o\">:</span>\n<span class=\"o\">(</span><span class=\"n\">is_locally_noetherian</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"bp\">𝒰</span> <span class=\"o\">:</span> <span class=\"n\">Scheme.open_cover</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"bp\">𝒰.</span><span class=\"n\">J</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">is_affine</span> <span class=\"o\">(</span><span class=\"bp\">𝒰.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">)],</span>\n<span class=\"o\">(</span><span class=\"n\">is_noetherian_ring</span> <span class=\"o\">((</span><span class=\"bp\">𝒰.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.Γ.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"o\">(</span><span class=\"bp\">𝒰.</span><span class=\"n\">obj</span> <span class=\"n\">i</span><span class=\"o\">))))</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 311689881,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669144528
    },
    {
        "content": "<p><code>(𝒰.obj i).Γ.obj (op (𝒰.obj i))</code> -&gt; <code>Scheme.Γ.obj (op (𝒰.obj i))</code></p>",
        "id": 311690907,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669144913
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311690907\">said</a>:</p>\n<blockquote>\n<p><code>(𝒰.obj i).Γ.obj (op (𝒰.obj i))</code> -&gt; <code>Scheme.Γ.obj (op (𝒰.obj i))</code></p>\n</blockquote>\n<p>Yes, haha, success! It works. Sorry, I misunderstood you at first. Thanks.</p>",
        "id": 311692502,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669145436
    },
    {
        "content": "<p>Another issue I have struggled with is how to define quasi-compactness for schemes. <br>\nThere is a function is_compact for topological spaces however it takes as input a subset of the underlying space.<br>\nBut again I am not sure how to convert a scheme into a set since Scheme.carrier only gives me a Top type.<br>\nBelow is the corresponding MWE.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.AffineScheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.nilpotent</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.sheaves.sheaf_condition.sites</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.binary_products</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.constructions</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.noetherian</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.local_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.Scheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.zfc.basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">opposite</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span> <span class=\"n\">Top</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">algebraic_geometry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Scheme</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_locally_noetherian</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">locally_noetherian</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X.carrier</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X.affine_opens</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">X.presheaf.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))))</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">noetherian_scheme</span>\n\n<span class=\"k\">#check</span> <span class=\"n\">is_compact</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_noetherian</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">locally_noetherian</span> <span class=\"o\">:</span> <span class=\"n\">is_locally_noetherian</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">quasi_compact</span> <span class=\"o\">:</span> <span class=\"n\">is_compact</span> <span class=\"n\">X.carrier</span><span class=\"o\">)</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">noetherian_scheme</span>\n<span class=\"kd\">end</span> <span class=\"n\">algebraic_geometry</span>\n</code></pre></div>",
        "id": 311695920,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669146552
    },
    {
        "content": "<p>We use <code>compact_space</code> for types, and <code>is_compact</code> for subsets. A <code>Top</code> type has a coercion to <code>Type</code>, so <code>compact_space X.carrier</code> should work.</p>",
        "id": 311696402,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669146691
    },
    {
        "content": "<p>By the way, the <code>(x : set U)</code> in the definition <code>is_locally_noetherian</code> means \"let <code>x</code> be an arbitrary subset of <code>U</code>\". You should write <code>(h : x ∈ U.val)</code> instead. (<code>U.val</code> is the underlying open set of <code>U : X.affine_opens</code>)</p>",
        "id": 311697995,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669147187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"384245\">@Deepak Kamlesh</span> the whole thing might look completely intimidating right now but there is a logic to all of this, and you'll figure it out if you keep working on problems. Mathematicians are for example constantly using the \"fact\" that a functor \"is\" a function, but in Lean a functor has a component which is a function on objects and another component which is a function on morphisms, and after a while you'll start thinking about these things in the correct way, and learning about how you can look up what the answer to your questions are rather than having to ask them. Until that point please continue asking! I am also learning algebraic geometry in Lean right now, I'm trying to define sheaves of modules and it's the first time I've used the alg geom API, but I'm at the stage where I can figure out most things myself. My experimental repo is here <a href=\"https://github.com/ImperialCollegeLondon/tcc-lean-alg-geom-2022\">https://github.com/ImperialCollegeLondon/tcc-lean-alg-geom-2022</a> .</p>",
        "id": 311722958,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669156960
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439483\">Andrew Yang</span> <a href=\"#narrow/stream/116395-maths/topic/Algebraic.20geometry.20development/near/311697995\">said</a>:</p>\n<blockquote>\n<p>By the way, the <code>(x : set U)</code> in the definition <code>is_locally_noetherian</code> means \"let <code>x</code> be an arbitrary subset of <code>U</code>\". You should write <code>(h : x ∈ U.val)</code> instead. (<code>U.val</code> is the underlying open set of <code>U : X.affine_opens</code>)</p>\n</blockquote>\n<p>Thanks a lot for pointing this out! I was unsure about that part of my definition.</p>",
        "id": 311728059,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669159448
    },
    {
        "content": "<p>Thanks for your support Kevin! I will keep working on it indeed. :)</p>",
        "id": 311728123,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669159480
    },
    {
        "content": "<p>By the way I'm learning by teaching and I'm uploading my classes to YouTube on the Xena project channel</p>",
        "id": 311729629,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1669160257
    },
    {
        "content": "<p>Hello. I am trying to prove (2 implies 1) of Lemma 28.5.2 from the Stacks projects (<a href=\"http://url\">https://stacks.math.columbia.edu/tag/01OU</a>) which says that if every affine open subset of a scheme has a noetherian ring of global sections then the scheme itself is locally noetherian. My strategy is to just make use of the affine cover that exists for a scheme to do this. Of course there are more steps to actually implement this in Lean and along the way I reach a stage where I have to prove that a certain open subset is affine. And I do have an isomorphism with Spec R for some R which is what the goal is asking for but there is some subtle distinction that I am not able to resolve and it's causing a type mismatch. I would be grateful in case anyone can illuminate what's going on. I am providing a minimal code below. Thank you.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.AffineScheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.nilpotent</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology.sheaves.sheaf_condition.sites</span>\n<span class=\"kn\">import</span> <span class=\"n\">category_theory.limits.constructions.binary_products</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.Ring.constructions</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.integral_domain</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.noetherian</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.local_properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.Scheme</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebraic_geometry.properties</span>\n<span class=\"kn\">import</span> <span class=\"n\">set_theory.zfc.basic</span>\n\n\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span> <span class=\"n\">opposite</span> <span class=\"n\">category_theory</span> <span class=\"n\">category_theory.limits</span> <span class=\"n\">Top</span>\n<span class=\"kn\">open</span> <span class=\"n\">algebraic_geometry.Scheme</span>\n<span class=\"kn\">open</span> <span class=\"n\">classical</span>\n<span class=\"kn\">namespace</span> <span class=\"n\">algebraic_geometry</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Scheme</span><span class=\"o\">)</span>\n\n<span class=\"kd\">class</span> <span class=\"n\">is_locally_noetherian</span><span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">locally_noetherian</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X.carrier</span><span class=\"o\">),</span> <span class=\"bp\">∃</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X.affine_opens</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"n\">U</span><span class=\"o\">),</span>\n<span class=\"o\">(</span><span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">X.presheaf.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))))</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_locally_noetherian_of_forall_affine_open_global_section_is_noetherian_ring</span>\n  <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">X.affine_opens</span><span class=\"o\">),</span> <span class=\"n\">is_noetherian_ring</span> <span class=\"o\">(</span><span class=\"n\">X.presheaf.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">)))</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">is_locally_noetherian</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n<span class=\"n\">split</span><span class=\"o\">,</span>\n<span class=\"n\">intro</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"k\">have</span> <span class=\"n\">h2</span><span class=\"o\">:=</span> <span class=\"n\">Scheme.local_affine</span> <span class=\"n\">X</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">rcases</span> <span class=\"n\">h2</span> <span class=\"k\">with</span> <span class=\"o\">⟨</span><span class=\"n\">U</span><span class=\"o\">,</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">hU</span><span class=\"o\">⟩,</span>\n<span class=\"k\">have</span> <span class=\"n\">h3</span><span class=\"o\">:</span> <span class=\"n\">is_affine</span> <span class=\"o\">(</span><span class=\"n\">X.restrict</span> <span class=\"o\">(</span><span class=\"n\">U.obj</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">open_embedding</span><span class=\"o\">),</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span> <span class=\"n\">mem_Spec_ess_image</span><span class=\"o\">,</span>\n    <span class=\"n\">split</span><span class=\"o\">,</span>\n    <span class=\"o\">{</span>\n      <span class=\"k\">have</span> <span class=\"n\">hiso</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty.some</span> <span class=\"n\">hU</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">hsymm</span> <span class=\"o\">:=</span> <span class=\"n\">iso.symm</span> <span class=\"n\">hiso</span><span class=\"o\">,</span>\n      <span class=\"k\">have</span> <span class=\"n\">hnew</span> <span class=\"o\">:=</span> <span class=\"n\">nonempty.intro</span> <span class=\"n\">hsymm</span><span class=\"o\">,</span>\n      <span class=\"n\">exact</span> <span class=\"n\">hnew</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n    <span class=\"o\">{</span>\n      <span class=\"n\">exact</span> <span class=\"n\">op</span> <span class=\"n\">R</span><span class=\"o\">,</span>\n    <span class=\"o\">},</span>\n  <span class=\"o\">},</span>\n  <span class=\"gr\">sorry</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">algebraic_geometry</span>\n</code></pre></div>",
        "id": 312747376,
        "sender_full_name": "Deepak Kamlesh",
        "timestamp": 1669681999
    },
    {
        "content": "<p><a href=\"https://stacks.math.columbia.edu/tag/01OU\">stacks#01OU</a></p>",
        "id": 312753963,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1669686885
    },
    {
        "content": "<p>Your def of locally Noetherian seems wrong.</p>",
        "id": 312754122,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1669687014
    },
    {
        "content": "<p>the second <code>x</code> is unrelated to the first one in the condition there.</p>",
        "id": 312754148,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1669687043
    },
    {
        "content": "<p>Right, you presumably meant <code> ∃ (U : X.affine_opens), x \\in U \\and ...</code></p>",
        "id": 312768319,
        "sender_full_name": "Reid Barton",
        "timestamp": 1669698661
    },
    {
        "content": "<p>By the way, the easiest method to obtain an affine open containing some <code>x : X.carrier</code> is either <code>(X.affine_cover.map x).opens_range</code> or to use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.algebraic_geometry.is_basis_affine_open\">docs#algebraic_geometry.algebraic_geometry.is_basis_affine_open</a> and use the basis API.</p>",
        "id": 312768676,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669698923
    },
    {
        "content": "<p>For the former, the proof that it contains <code>x</code> is <code>X.affine_cover.covers x</code>, and you can show that it is an affine open using <a href=\"https://leanprover-community.github.io/mathlib_docs/find/algebraic_geometry.range_is_affine_open_of_open_immersion\">docs#algebraic_geometry.range_is_affine_open_of_open_immersion</a></p>",
        "id": 312769007,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1669699091
    }
]
[
    {
        "content": "<p>I'm working on the unit disc with <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> and <span class=\"user-mention\" data-user-id=\"304228\">@James Arthur</span>,  and we'd like to start with this definition: <br>\n<code>def unit_disc : set (euclidean_space ℝ (fin 2)) := metric.ball 0 1</code>.</p>\n<p>Ideally, we hope to keep the whole proof inside of <code>euclidean_space ℝ (fin 2)</code>. However, we expect to use Fubini's Theorem, and it seems <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.integral_prod\">docs#measure_theory.integral_prod</a> can only handle <code>ℝ × ℝ</code>. </p>\n<p><span class=\"user-mention\" data-user-id=\"111080\">@Floris van Doorn</span>, did you have any plans to work on Fubini's theorem for <code>(fin 2) → ℝ</code>? If not, we'll try to figure out some work-arounds.</p>",
        "id": 222194513,
        "sender_full_name": "Andrew  Souther",
        "timestamp": 1610234271
    },
    {
        "content": "<p>I haven't worked on Fubini's theorem for finitary products yet, since I don't know the most convenient statements in applications. There is definitely a lot of API missing from <code>measure.pi</code> to make this convenient.</p>\n<p>I expect/hope that this particular statement should follow without too much effort by the measurable equivalence <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_equiv.pi_measurable_equiv_tprod\">docs#measurable_equiv.pi_measurable_equiv_tprod</a> and the fact that this map is measure-preserving (for that we probably need an extensionality lemma similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.prod_eq\">docs#measure_theory.measure.prod_eq</a>). Though there will be some annoyances along the way (for example, <code>tprod ...</code> will be definitionally equal to <code>ℝ × ℝ × punit</code> instead of <code>ℝ × ℝ</code>).</p>\n<p>Though maybe \"Fubini for <code>fin 2</code>\" is the wrong theorem to formalize. Better would be to have something that is generally applicable. Now that I think about good ways to formalize Fubini, I'm thinking that we need to have a more general definition of <code>measure.pi</code>, that measures only a subspace, something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">measure_theory.pi</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">measure_theory</span> <span class=\"n\">measure_theory.measure</span>\n<span class=\"n\">open_locale</span> <span class=\"n\">classical</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">ι</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">π</span> <span class=\"o\">:</span> <span class=\"n\">ι</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measurable_space</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n  <span class=\"o\">{</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)}</span> <span class=\"o\">[</span><span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">sigma_finite</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"n\">i</span><span class=\"o\">)]</span>\n\n<span class=\"kd\">instance</span> <span class=\"n\">measurable_space.finset_pi</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">measurable_space</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">measure.finset_pi</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">μ</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">:</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">let</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">measure</span> <span class=\"o\">(</span><span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">μ</span> <span class=\"k\">in</span> <span class=\"gr\">sorry</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_pi_eq_lintegral_finset_pi</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">ι</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">measure.pi</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">x</span> <span class=\"n\">i</span> <span class=\"o\">(</span><span class=\"n\">finset.mem_univ</span> <span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">measure.finset_pi</span> <span class=\"n\">finset.univ</span> <span class=\"n\">μ</span> <span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"gr\">sorry</span>\n\n<span class=\"sd\">/-- Tonelli for finitary product measures -/</span>\n<span class=\"c1\">-- Fubini will look similar</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">lintegral_finset_pi_split</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">finset</span> <span class=\"n\">ι</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">t</span> <span class=\"bp\">⊆</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"n\">i</span> <span class=\"bp\">∈</span> <span class=\"n\">s</span><span class=\"o\">,</span> <span class=\"n\">π</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ennreal</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hf</span> <span class=\"o\">:</span> <span class=\"n\">measurable</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">measure.finset_pi</span> <span class=\"n\">μ</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"bp\">=</span>\n  <span class=\"bp\">∫⁻</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"bp\">∫⁻</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">_</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">measure.finset_pi</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"bp\">\\</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"bp\">∂</span><span class=\"o\">(</span><span class=\"n\">measure.finset_pi</span> <span class=\"n\">t</span> <span class=\"n\">μ</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"gr\">sorry</span>\n</code></pre></div>",
        "id": 222196784,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1610237933
    },
    {
        "content": "<p>In the short term, I think there are two possible workarounds for Andrew and James.  One way would be as Floris suggests:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"111080\">Floris van Doorn</span> <a href=\"#narrow/stream/116395-maths/topic/Fubini's.20for.20fin.202.20-.3E.20R/near/222196784\">said</a>:</p>\n<blockquote>\n<p>I expect/hope that this particular statement should follow without too much effort by the measurable equivalence <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measurable_equiv.pi_measurable_equiv_tprod\">docs#measurable_equiv.pi_measurable_equiv_tprod</a> and the fact that this map is measure-preserving (for that we probably need an extensionality lemma similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/measure_theory.measure.prod_eq\">docs#measure_theory.measure.prod_eq</a>). Though there will be some annoyances along the way (for example, <code>tprod ...</code> will be definitionally equal to <code>ℝ × ℝ × punit</code> instead of <code>ℝ × ℝ</code>).</p>\n</blockquote>\n<p>effectively, temporarily jumping from <code>(fin 2) → ℝ</code> to <code>ℝ × ℝ</code> during the Fubini step of the proof.</p>\n<p>The alternative would be to work in <code>ℝ × ℝ</code> throughout, having defined a new (Euclidean) product metric on <code>ℝ × ℝ</code>, by analogy with <a href=\"https://leanprover-community.github.io/mathlib_docs/find/pi_Lp\">docs#pi_Lp</a>.  Is there any harm (or, on the other hand, any longer-term benefit) in doing this, i.e., in writing a full file <code>topology.metric_space.prod_Lp</code>, which is a line-by-line port of <code>pi_Lp</code>?</p>",
        "id": 222198621,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1610241182
    },
    {
        "content": "<p>Yeah, the easiest short-term solution is indeed  to do all measure theory in <code>ℝ × ℝ</code>. For <code>prod</code> I think we have all the facts that should make the proof smooth.</p>",
        "id": 222214634,
        "sender_full_name": "Floris van Doorn",
        "timestamp": 1610271809
    },
    {
        "content": "<p>You can just deal with <code>volume {p : ℝ × ℝ | p.1 ^ 2 + p.2 ^ 2 &lt; 1}</code> without introducing <code>normed_space</code> structure.</p>",
        "id": 222257039,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1610335755
    }
]
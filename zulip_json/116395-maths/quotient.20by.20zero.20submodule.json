[
    {
        "content": "<p>Does Lean know how to \"canonically identify\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn><mo>≅</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M/0 \\cong M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>? And to treat the quotient map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">M \\to M/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> like the identity map?</p>",
        "id": 197054048,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589115498
    },
    {
        "content": "<p>I'm trying to show that a field is a Henselian local ring, and part of the definition of a Henselian ring involves lifting along <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"fraktur\">m</mi></mrow><annotation encoding=\"application/x-tex\">R \\to R/\\mathfrak{m}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathfrak\">m</span></span></span></span></span>. But if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">R = k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"fraktur\">m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">\\mathfrak{m} = 0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.47534em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathfrak\">m</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> then this is just the identity...</p>",
        "id": 197054069,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589115550
    },
    {
        "content": "<p>Or is the right thing to do to show that <code>residue R</code> is a bijection in this case (when we have <code>[field R]</code>)?</p>",
        "id": 197054138,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589115625
    },
    {
        "content": "<p>I think perhaps the correct way to do quotients is to prove every theorem about quotients on rings that satisfy the universal property of the quotient. That way you can prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is the quotient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>.  The library unfortunately hasn't been set up to make this easy, but I think it should be refactored.</p>",
        "id": 197054735,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1589116590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"235423\">Ashwin Iyengar</span> <a href=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054048\" title=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054048\">said</a>:</p>\n<blockquote>\n<p>Does Lean know how to \"canonically identify\" <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn><mo>≅</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M/0 \\cong M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≅</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span>? And to treat the quotient map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">M \\to M/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> like the identity map?</p>\n</blockquote>\n<p>No. Once you write down a construction of the quotient <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">M/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span>, it is whatever it is and it's highly unlikely to be \"the same\" as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> in Lean's eyes. There are basically two approaches:</p>\n<ol>\n<li>Use <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">/</mi><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">M \\to M/0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord\">0</span></span></span></span> as an isomorphism (it's easy to write down an inverse) and then lift along this isomorphism (which is just composition with the inverse).</li>\n<li>Don't work with a specific model for the quotient map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi><mi mathvariant=\"normal\">/</mi><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">M \\to M/I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span></span></span></span>, but characterize what it means to be one (e.g., surjective with kernel <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span></span></span></span>); then the identity <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M \\to M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> will qualify.</li>\n</ol>",
        "id": 197054773,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589116635
    },
    {
        "content": "<p>Also, we don't yet have the definition of a Henselian ring in mathlib, do we? I'd be very interested to see what you are working on!</p>",
        "id": 197055364,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589117166
    },
    {
        "content": "<p>As much as it pains me to say it, it's usually better for technical reasons to choose definitions which don't involve quantifying over <code>Type</code></p>",
        "id": 197055424,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589117253
    },
    {
        "content": "<p>On my job list is bundling <code>normal_subgroup G</code> and then rewriting quotients in group theory to use bundled normal subgroups.</p>",
        "id": 197056750,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589118849
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197055364\" title=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197055364\">said</a>:</p>\n<blockquote>\n<p>Also, we don't yet have the definition of a Henselian ring in mathlib, do we? I'd be very interested to see what you are working on!</p>\n</blockquote>\n<p>Yeah I'm working on this now! I'll push some more in a bit.</p>",
        "id": 197056780,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589118886
    },
    {
        "content": "<p>But I have a lot of marking and a grant application deadline to juggle right now, as well as trying to write this Mathematics in Lean book with Jeremy, Patrick and Rob.</p>",
        "id": 197056783,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589118898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054735\" title=\"#narrow/stream/116395-maths/topic/quotient.20by.20zero.20submodule/near/197054735\">said</a>:</p>\n<blockquote>\n<p>I think perhaps the correct way to do quotients is to prove every theorem about quotients on rings that satisfy the universal property of the quotient. That way you can prove that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is the quotient of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span></span></span></span> at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>.  The library unfortunately hasn't been set up to make this easy, but I think it should be refactored.</p>\n</blockquote>\n<p>I could try defining the notion of a quotient of a <code>nonzero_comm_ring</code> by an ideal using the universal property. Are there already examples of things defined using universal properties in Lean that I could use as a starting point?</p>",
        "id": 197057369,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589119826
    },
    {
        "content": "<p>Localisation of rings was set up this way in <span class=\"user-mention\" data-user-id=\"132858\">@Ramon Fernandez Mir</span> 's MSc thesis</p>",
        "id": 197057424,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589119923
    },
    {
        "content": "<p>It's available in the links on the leanprover-community website. Can I write some hashtag to link to this nowadays?</p>",
        "id": 197057446,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589119987
    },
    {
        "content": "<p>He defined what it meant for a homomorphism of rings to be isomorphic to a localisation, following an API idea of Strickland</p>",
        "id": 197057492,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589120042
    },
    {
        "content": "<p>For technical reasons this concept of being isomorphic to a localisation turned out to be very useful. Life was a lot more unbundled in those days though</p>",
        "id": 197057556,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589120150
    },
    {
        "content": "<p>You should make a new predicate for a ring homomorphism R -&gt; A saying that it is surjective and its kernel is I, and then every theorem that is proved for R/I you should prove as well for all rings A equipped with a map from R satisfying the predicate</p>",
        "id": 197057744,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589120293
    },
    {
        "content": "<p>We are still experimenting in this area</p>",
        "id": 197057779,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589120323
    },
    {
        "content": "<p>Ok. Then if I have a local ring, there should not be \"the residue field <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"fraktur\">m</mi></mrow><annotation encoding=\"application/x-tex\">R/\\mathfrak{m}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathfrak\">m</span></span></span></span></span>\", instead there should be a predicate <code>is_residue_field f</code> which is an alias of <code>is_quotient f m</code> where <code>f</code> is a ring homomorphism and <code>m</code> is the unique maximal ideal. And then maybe one proves the lemma that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>→</mo><mi>R</mi><mi mathvariant=\"normal\">/</mi><mi mathvariant=\"fraktur\">m</mi></mrow><annotation encoding=\"application/x-tex\">R \\to R/\\mathfrak{m}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord mathfrak\">m</span></span></span></span></span> constructed in the usual way is a residue field?</p>",
        "id": 197058560,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589121053
    },
    {
        "content": "<p>Yeah I guess the proof of the pudding will be in the eating here. I would just experiment.</p>",
        "id": 197058859,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589121288
    },
    {
        "content": "<p>fair enough, will do</p>",
        "id": 197059228,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589121606
    },
    {
        "content": "<p>With localisations we were well on the way to defining schemes, and then discovered that we had proved a sequence involving <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mi>g</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[1/fg]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span> was exact, but we needed it for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>g</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[1/f][1/g]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span>. We realised later on that we should have proved exactness of the sequence for any ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> which was isomorphic to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mi mathvariant=\"normal\">/</mi><mi>f</mi><mi>g</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">R[1/fg]</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.00773em;\">R</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mord\">/</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">]</span></span></span></span>.</p>",
        "id": 197059263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589121688
    },
    {
        "content": "<p>This is the difference between <a href=\"https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/1819-ug-projects/Fernandez-I-MirR-Schemes-in-Lean.pdf\" title=\"https://www.imperial.ac.uk/media/imperial-college/faculty-of-engineering/computing/public/1819-ug-projects/Fernandez-I-MirR-Schemes-in-Lean.pdf\">Ramon's work</a> and <a href=\"https://github.com/kbuzzard/lean-stacks-project\" title=\"https://github.com/kbuzzard/lean-stacks-project\">my earlier work with Kenny and Chris</a> which we wrote after only a few months of working with Lean and which contained several serious design flaws (but which taught us a lot about Lean).</p>",
        "id": 197059349,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1589121812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"235423\">@Ashwin Iyengar</span> After defining Henselian local rings, I think the first step to do is prove that:</p>\n<ol>\n<li>For every Henselian local ring, you can lift along every surjective <code>f : R → K</code>, where <code>K</code> is a field.</li>\n<li>If <code>R</code> is a local ring, and satisfies lifting for some surjective <code>f : R → K</code>, where <code>K</code> is a field, then <code>R</code> is local Henselian.</li>\n</ol>",
        "id": 197059593,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589122189
    },
    {
        "content": "<p>Or better yet, prove some lemma from the stacks project giving 11 equivalent characterisations. (But modify the statement so that it works for surjective ring maps to fields, instead of only <code>R/m</code>.)</p>",
        "id": 197059812,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1589122544
    },
    {
        "content": "<p>In that case does</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span>\n\n<span class=\"n\">class</span> <span class=\"n\">henselian</span> <span class=\"kn\">extends</span> <span class=\"n\">local_ring</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_henselian</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">polynomial</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a₀</span> <span class=\"o\">:</span> <span class=\"n\">residue_field</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">monic</span> <span class=\"n\">p</span> <span class=\"bp\">∧</span> <span class=\"n\">is_root</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">residue</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"n\">a₀</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span><span class=\"n\">is_root</span><span class=\"o\">(</span><span class=\"n\">derivative</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">(</span><span class=\"n\">residue</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"n\">p</span><span class=\"o\">))</span> <span class=\"n\">a₀</span> <span class=\"bp\">→</span> <span class=\"bp\">∃</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">R</span><span class=\"o\">,</span> <span class=\"n\">is_root</span> <span class=\"n\">p</span> <span class=\"n\">a</span> <span class=\"bp\">∧</span> <span class=\"n\">residue</span> <span class=\"n\">R</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a₀</span><span class=\"o\">)</span>\n</code></pre></div>\n\n\n<p>look like a sensible definition or should I <em>define</em> it using (2)?</p>",
        "id": 197059928,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589122719
    },
    {
        "content": "<p>if you define it using (2) you will run into universe issues</p>",
        "id": 197059936,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589122744
    },
    {
        "content": "<p>or maybe not</p>",
        "id": 197059939,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589122757
    },
    {
        "content": "<p>btw does this imply the more general Hensel theorem about factorizing polynomials, or does that require algebraic closure?</p>",
        "id": 197060012,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1589122853
    },
    {
        "content": "<p>The universe issues aren't a serious obstruction, but either way you are going to want to prove the equivalence of the two definitions and if you are going to do that anyways it's more ergonomic to use the one that doesn't involve quantification over Type as the definition.</p>",
        "id": 197060202,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589123125
    },
    {
        "content": "<p>Typically you actually have some statements like (lifting for rings in Type u) =&gt; (some polynomial thing) =&gt; (lifting for rings in all universes), but the last one can't be expressed as the definition</p>",
        "id": 197060267,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589123224
    },
    {
        "content": "<p>and in a hypothetical future world where we can automatically transfer properties from <code>R</code> to <code>ulift R</code>, it's a lot harder to do it if your definition involves quantification over types</p>",
        "id": 197060325,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589123317
    },
    {
        "content": "<p>Ok I'll stick with my definition. And yes, it's equivalent to the definition which says that you can lift factorizations.</p>",
        "id": 197060404,
        "sender_full_name": "Ashwin Iyengar",
        "timestamp": 1589123428
    },
    {
        "content": "<p>One suggestion though, use more newlines!</p>",
        "id": 197060421,
        "sender_full_name": "Reid Barton",
        "timestamp": 1589123468
    },
    {
        "content": "<p>I'm going to submit a PR including the linear equivalence between <code>M</code> and <code>M/0</code> today or tomorrow, see <a href=\"https://github.com/leanprover-community/mathlib/blob/closed-complement/src/linear_algebra/basic.lean#L1673\" title=\"https://github.com/leanprover-community/mathlib/blob/closed-complement/src/linear_algebra/basic.lean#L1673\">here</a>.</p>",
        "id": 197063034,
        "sender_full_name": "Yury G. Kudryashov",
        "timestamp": 1589126306
    },
    {
        "content": "<p>If it helps, what Kevin was referring to can be found here: <a href=\"https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean\" title=\"https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean\">https://github.com/ramonfmir/lean-scheme/blob/master/src/to_mathlib/localization/localization_alt.lean</a></p>",
        "id": 197065805,
        "sender_full_name": "Ramon Fernandez Mir",
        "timestamp": 1589129736
    }
]
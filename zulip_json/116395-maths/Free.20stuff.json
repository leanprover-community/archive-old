[
    {
        "content": "<p>I'm wondering about the recent PR <a href=\"https://github.com/leanprover-community/mathlib/issues/4077\">#4077</a> and the related <a href=\"https://github.com/leanprover-community/mathlib/issues/4079\">#4079</a> and <a href=\"https://github.com/leanprover-community/mathlib/issues/4078\">#4078</a> that <span class=\"user-mention\" data-user-id=\"110087\">@Scott Morrison</span> made.</p>\n<p>I'm mainly wondering about the design choices here. Namely, the free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra on a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-tensor-algebra on the free module generated by <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>, whereas these PRs construct the tensor algebra as a quotient of the free algebra. Certainly I think the constructions of the free module and free algebra should interact, but the question is, in which way. With the PRs mentioned above, it would not be immediate that the free algebra is the tensor algebra of the free module, but what would be immediate is that the tensor algebra is a quotient of the free algebra. </p>\n<p>A related question: We could take the approach from these PRs even further -- we can define the free <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebra on a type <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> as a quotient of the free (semi)ring on generated by the disjoint union of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">S</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span>. Does it make sense to do this? I certainly think it is important to have some consistency in the way such free objects are constructed, and the \"top-down/make the free-est thing possible first\" approach might be a way to make everything more uniform.</p>",
        "id": 209502556,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599653740
    },
    {
        "content": "<p>All of these things should really be constructed by some metapprogram that looks at the equations and universal axioms of the objects involved a la universal algebra. And the approach taken by these PRs is presumably how such metaprograms would operate in practice.</p>",
        "id": 209503279,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599654209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110064\">@Kenny Lau</span> <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> what do you think?</p>",
        "id": 209503755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599654555
    },
    {
        "content": "<p>One more thing to note: the previous construction of the tensor algebra was already as a quotient of some gigantic free thing with no relations, so the refactoring that Scott did in those PRs definitely makes sense.</p>",
        "id": 209505835,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599655914
    },
    {
        "content": "<p>I think that with most of these free objects, the universal property on its own is not that useful, and there is usually some other construction that tells you more about the object. E.g. It is hard to define the coefficient or degree of a polynomial directly from the universal property. I've been working with free groups lately, and some theory depends on induction on the length of a normalised word.</p>\n<p>If you do use universal algebra to define these objects then you probably end up having to effectively prove isomorphism with some other construction to prove any non trivial theorem about the object.</p>",
        "id": 209511088,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599658727
    },
    {
        "content": "<p>I think it would be handy for a universal algebra to be able to deal with equational theories that aren't type classes, e.g. Rings with a root of a particular polynomial. I think maybe avoiding meta code for the bulk of the theory might be a good idea for this reason, and have a small amount of code to turn a structure like <code>group</code> into the appropriate term of a non-meta type <code>equational_theory </code> or something like that.</p>",
        "id": 209512054,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599659164
    },
    {
        "content": "<p>Of course, I agree that in the \"usual\" cases from algebra it's more useful to have a concrete construction of the free objects. But this is really an \"accident\" of the construction, and usually does not generalize.</p>",
        "id": 209512364,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599659295
    },
    {
        "content": "<p>Induction on the length of a normalized word in a free group is a good example.</p>",
        "id": 209512423,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599659323
    },
    {
        "content": "<p>Concerning metaprogramming, I think to make it actually useful you would need some code to go in both directions -- from classes like group to <code>equational_theory</code>, and some code to go from some equational theory thing back to a typeclass. This would let you carry out whatever general constructions you need in the universal world, and pass back to the concrete world if necessary</p>",
        "id": 209512776,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599659474
    },
    {
        "content": "<p>I agree that the concrete constructions can't be generalised, that's why I'm slightly skeptical that it would be useful to attempt to generalise free objects. I disagree that these are \"accidents\", it's almost the whole point of distributivity that the free commutative ring is also the free abelian group over the free monoid. Similarly the whole point of associativity is that free monoids are list. This is a slightly meaningless discussion I know.</p>",
        "id": 209514297,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599660098
    },
    {
        "content": "<p>I envision a world where I can write the following and have the class <code>monoid</code> generated for me, as well as code for free monoids, colimits of monoids, etc.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">monoid</span>\n<span class=\"n\">def</span> <span class=\"n\">ops</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[</span> <span class=\"o\">(</span><span class=\"n\">one</span><span class=\"o\">,</span> <span class=\"mi\">0</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">mul</span><span class=\"o\">,</span> <span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"o\">]</span>\n\n<span class=\"n\">def</span> <span class=\"n\">axioms</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n  <span class=\"o\">[</span> <span class=\"o\">(</span><span class=\"n\">mul_assoc</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">b</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">mul</span> <span class=\"n\">c</span> <span class=\"n\">b</span><span class=\"o\">)),</span>\n    <span class=\"o\">(</span><span class=\"n\">one_mul</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"n\">one</span> <span class=\"n\">a</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">),</span>\n    <span class=\"o\">(</span><span class=\"n\">mul_one</span><span class=\"o\">,</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">mul</span> <span class=\"n\">a</span> <span class=\"n\">one</span> <span class=\"bp\">=</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">]</span>\n\n<span class=\"n\">run_cmd</span> <span class=\"n\">make_alg</span> <span class=\"n\">ops</span> <span class=\"n\">axioms</span>\n<span class=\"kn\">end</span> <span class=\"n\">monoid</span>\n</code></pre></div>",
        "id": 209514991,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599660341
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"326322\">@Jacques Carette</span> is working on a prover-independent version of this.</p>",
        "id": 209515277,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599660470
    },
    {
        "content": "<p>I haven't had a chance to check it out yet though.</p>",
        "id": 209515354,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599660485
    },
    {
        "content": "<p>I would do it very similarly to this, but with a custom, non-meta <code>expr</code></p>",
        "id": 209515720,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599660646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315523\">@Colter MacDonald</span> and I did some non-meta stuff like this here: <a href=\"https://github.com/adamtopaz/UnivAlg\">https://github.com/adamtopaz/UnivAlg</a><br>\nI still don't know how to make it actually useful.</p>",
        "id": 209515819,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599660692
    },
    {
        "content": "<p>I also dream of a world where I can write this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">namespace</span> <span class=\"n\">ring</span>\n<span class=\"n\">def</span> <span class=\"n\">ops</span> <span class=\"o\">:=</span> <span class=\"n\">monoid</span><span class=\"bp\">.</span><span class=\"n\">ops</span> <span class=\"bp\">++</span> <span class=\"n\">add_comm_group</span><span class=\"bp\">.</span><span class=\"n\">ops</span>\n<span class=\"n\">def</span> <span class=\"n\">axioms</span> <span class=\"o\">:=</span> <span class=\"n\">monoid</span><span class=\"bp\">.</span><span class=\"n\">axioms</span> <span class=\"bp\">++</span>\n  <span class=\"n\">add_comm_group</span><span class=\"bp\">.</span><span class=\"n\">axioms</span> <span class=\"bp\">++</span>\n  <span class=\"o\">[</span> <span class=\"o\">(</span><span class=\"n\">left_distrib</span><span class=\"o\">,</span> <span class=\"bp\">...</span><span class=\"o\">),</span> <span class=\"o\">(</span><span class=\"n\">right_distrib</span><span class=\"o\">,</span> <span class=\"bp\">...</span><span class=\"o\">)</span> <span class=\"o\">]</span>\n<span class=\"n\">run_cmd</span> <span class=\"n\">make_alg</span> <span class=\"n\">ops</span> <span class=\"n\">axioms</span>\n<span class=\"kn\">end</span> <span class=\"n\">ring</span>\n</code></pre></div>\n\n\n<p>and have lean generate code for monoid rings, etc.</p>",
        "id": 209516043,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599660773
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210057\">@Fabian Glöckle</span> had written quite a bunch of meta code like that.</p>",
        "id": 209516185,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599660824
    },
    {
        "content": "<p>It could generate <code>ring_hom</code> and the category <code>Ring</code> from the lean code of <code>ring</code></p>",
        "id": 209516276,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599660846
    },
    {
        "content": "<p>And similarly for the rest of the algebraic hierarchy.</p>",
        "id": 209516301,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599660859
    },
    {
        "content": "<p>Oh cool! Is there a repo somewhere?</p>",
        "id": 209516307,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599660861
    },
    {
        "content": "<p>The stuff I'd most like to see universal algebra do is develop my whole subobject library for me. I think that there's an awful lot of random little theorems about subobjects and quotients etc. that apply in a broad setting.</p>",
        "id": 209516316,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599660865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210057\">@Fabian Glöckle</span> is your code available somewhere?</p>",
        "id": 209516327,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599660868
    },
    {
        "content": "<p>I've written several times that I think such things are a key component of the future of proof assistants, together with more proof automation. See also <a href=\"https://hal.inria.fr/hal-02478907v5\">https://hal.inria.fr/hal-02478907v5</a></p>",
        "id": 209516540,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1599660955
    },
    {
        "content": "<p>We should have human readable input files generating class and structures definitions, handling all the variations around binding, extending or parametrizing correctly etc.</p>",
        "id": 209516709,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1599661006
    },
    {
        "content": "<p>We (my student Yasmine and I) are definitely working on this. I can see how open she'd be to targetting Lean. It's in scope, for sure, but she's also hoping to finish her Ph.D. this term, so...</p>",
        "id": 209518061,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599661566
    },
    {
        "content": "<p>Having the input files being human-readable, as <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> mentions, is very important. I also think that the output should be human-readable too, as the aim is for human-based reuse.  It turns out that that is not so hard [see my work on GOOL for a very concrete example.]</p>",
        "id": 209518400,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599661695
    },
    {
        "content": "<p>What I'm still looking for is a good list of what we should be generating. We have a long list of things we can generate, but I'm quite sure that 1) it's missing useful things, 2) it has useless things on it.</p>",
        "id": 209518596,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599661797
    },
    {
        "content": "<p>Can we see the list that you have? Or is that nontrivial?</p>",
        "id": 209519136,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599662021
    },
    {
        "content": "<p>Hmm, I can't upload a PDF to here, can I?  There was a decent list on Yasmine's slides for her talk about our work at CICM 2020.</p>",
        "id": 209519365,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662132
    },
    {
        "content": "<p>Let me try to cut-and-paste from it...</p>\n<p>Signature, Product Algebra, Basic Term Language, Homomorphism, Closed Term<br>\nLanguage, Open Term Language, Evaluator, Simpli\fcation rules, Staged terms, Finally<br>\ntagless representations, induction principle, Relational Interpretation, Monomorphism,<br>\nIsomorphism, Endomorphism, Congruence relation, Quotient algebra, Trivial<br>\nsubtheory, Flipped theory, Monoid action, Monoid Cosets, composition of morphisms,<br>\nkernel of homomorphisms, parse trees.</p>",
        "id": 209519469,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662166
    },
    {
        "content": "<p>Aha... (you can upload PDF's btw)</p>",
        "id": 209519611,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599662240
    },
    {
        "content": "<p>See the <span aria-label=\"paperclip\" class=\"emoji emoji-1f4ce\" role=\"img\" title=\"paperclip\">:paperclip:</span> below the input box where you write posts.</p>",
        "id": 209519647,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599662260
    },
    {
        "content": "<p><a href=\"/user_uploads/3121/ye3ISRIX4j_qVslPvvkwNJAa/slides-1.pdf\">slides-1.pdf</a></p>",
        "id": 209519649,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662261
    },
    {
        "content": "<p>Indeed I can!  Slide 16. But it's perhaps better seen in context.</p>",
        "id": 209519712,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662282
    },
    {
        "content": "<p>There is another list in her PhD proposal (<a href=\"https://github.com/ysharoda/PhD-Proposal\">https://github.com/ysharoda/PhD-Proposal</a>). It has lots of overlap, but it is a different set.</p>",
        "id": 209519932,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662387
    },
    {
        "content": "<p>If you already target at least one similar language (Agda or Coq) then it might make sense for Lean/mathlib people to work on the Lean target--as you can see there's no shortage of people who would be interested.</p>",
        "id": 209520823,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599662755
    },
    {
        "content": "<p>We are actively targeting Agda.</p>",
        "id": 209520994,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662808
    },
    {
        "content": "<p>Having some Lean/mathlib person who is Haskell-literate (our host implementation language for our infrastructure) would be fantastic.</p>",
        "id": 209521102,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1599662850
    },
    {
        "content": "<p>Getting back to the current PRs --- one change I've made here is marking things as irreducible at the end of the file. So hopefully it will be a moot point whether we <em>define</em> <code>tensor_algebra</code> as a quotient or as a free construction.</p>\n<p>Nevertheless, I agree we should add sometime the isomorphism between these two ways of building <code>tensor_algebra</code> (and the compatibility of that isomorphism with the <code>\\iota</code> and <code>lift</code>).</p>",
        "id": 209578458,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599692056
    },
    {
        "content": "<p>Sorry, the discussion wandered a little bit :)</p>",
        "id": 209578503,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599692098
    },
    {
        "content": "<p>It wandered it very appealing directions! We want all this stuff, of course.</p>",
        "id": 209578698,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599692273
    },
    {
        "content": "<p>I've added <code>free_algebra R X ≃ₐ[R] monoid_algebra R (free_monoid X)</code> to <a href=\"https://github.com/leanprover-community/mathlib/issues/4077\">#4077</a>.</p>",
        "id": 209590935,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599705875
    },
    {
        "content": "<p>Why have both constructions in the first place if they're isomorphic?</p>",
        "id": 209591454,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599706793
    },
    {
        "content": "<p>Because it's a hassle to have to think of a free algebra in this way?</p>",
        "id": 209591657,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599707091
    },
    {
        "content": "<p>Maybe this is dumb, I'm really not sure.</p>",
        "id": 209591671,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599707108
    },
    {
        "content": "<p>I was actually tempted just now to go even further in the same direction --- define <code>free_module R X</code>, even though it is isomorphic to <code>X \\to\\_0 R</code>, just to protect me from having to look at the <code>finsupp</code> API. :-)</p>\n<p>What I actually want at the moment is to know that I can construct a linear map out of a free algebra by specifying its values on elements of <code>free_monoid X</code>.</p>\n<p>Options:</p>\n<ol>\n<li>use <code>free_algebra R X ≃ₐ[R] monoid_algebra R (free_monoid X)</code>, and then unfold the definition of <code>monoid_algebra</code> in terms of <code>finsupp</code>, and muck around with finsupps by hand</li>\n<li>use <code>free_algebra R X ≃ₗ[R] free_module R (free_monoid X)</code> (doesn't exist), and use <code>free_module.lift</code> (also doesn't exist) to do the construction, without ever having to know that <code>finsupp</code> was involved.</li>\n</ol>",
        "id": 209591900,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599707413
    },
    {
        "content": "<p>Sounds like the <code>finsupp</code> API isn't very good. <code>finsupp</code> is so close to <code>free_module</code> already that we shouldn't need to redefine it. It can't be that hard to define the UMP of free modules on <code>finsupp</code> using the UMP of <code>finsupp</code> right? Isn't it supposed to make it easier to have that API available? I don't see why it's good to not have to know <code>finsupp</code> was involved; it has almost exactly the property you want.</p>",
        "id": 209592520,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599708269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326322\">Jacques Carette</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209518596\">said</a>:</p>\n<blockquote>\n<p>What I'm still looking for is a good list of what we should be generating. We have a long list of things we can generate, but I'm quite sure that 1) it's missing useful things, 2) it has useless things on it.</p>\n</blockquote>\n<p>I tried to assemble a list without looking at yours too closely. I'll fix \"group\" as the theory in question for concreteness.</p>\n<ul>\n<li>Definition of a group.</li>\n<li>Definition of group homomorphisms, group isomorphisms.</li>\n<li>Products of groups (nullary <code>(p)unit</code> and binary <code>prod</code>, as well as indexed <code>Pi</code>)</li>\n<li>Definition of a subgroup. A subgroup also forms a group, with a group hom to the original group. Image and preimage of a subgroup under a group hom. Subgroup generated by a subset.</li>\n<li>Definition of a congruence. The quotient by a congruence forms a group, with a group hom from the original group. Image(?) and preimage of a congruence under a group hom. Congruence generated by a relation.</li>\n<li>Free group on a set, along with its associated structure: a function from a set to a group extends uniquely to a group hom from the free group; the free group on a group has an \"evaluation\" map back to the group; the free group is functorial in the group; etc.</li>\n</ul>\n<p>Along with these come many lemmas, e.g. \"the subgroup generated by a subgroup is the original subgroup\" and \"if two group homomorphisms agree on a subset, they agree on the subgroup generated by that subset\".</p>",
        "id": 209644026,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599746037
    },
    {
        "content": "<p>I would add the \"groupification\" of a monoid as well (i.e. the left adjoint to the forgetful functor from groups to monoids).</p>",
        "id": 209645266,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599746344
    },
    {
        "content": "<p>If you allow \"subgroup generated by\" then you probably want that there's a Galois insertion between <code>set</code> and <code>subgroup</code>?</p>",
        "id": 209645685,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599746498
    },
    {
        "content": "<p>Then there are statements in category theory, for example</p>\n<ul>\n<li>monomorphisms in Grp are the injective functions,</li>\n<li>Grp is a cocomplete, even locally presentable category,</li>\n<li>Grp is monadic over Set,</li>\n<li>the forgetful functor Grp -&gt; Set preserves filtered colimits,</li>\n</ul>\n<p>etc. This list is basically endless, so I suggest the following approach.<br>\nInside the target theorem prover, we can also do universal algebra and prove all these statements for categories of models of algebraic theories of various sorts. So, we can generate a representation of the theory internal to the target language, e.g., as a handful of (inductive) types describing the function symbols, equations, etc. of the theory. Then, your system would emit the following:</p>\n<ul>\n<li>The category Grp, defined directly in terms of the notions of \"group\" and \"group homomorphism\" from above.</li>\n<li>The (faithful) forgetful functor Grp -&gt; Set (in the case of a single sorted theory), making Grp into a concrete category.</li>\n<li>Some data G that describe the theory of groups together with an equivalence of concrete categories between Grp and Alg G, where Alg is something defined once and for all in the target language.</li>\n</ul>\n<p>Then the target library (mathlib, say) can go off and prove things about monads, Lawvere theories, sketches, first order logic, whatever as it pleases, decoupled from your system.<br>\nNow, it could happen that we actually want a tighter integration, say to know that the objects of the Lawvere theory for groups really are literally <code>free_group (fin n)</code> or something, but this seems like a reasonable place to start.</p>",
        "id": 209647611,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599746804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209645685\">said</a>:</p>\n<blockquote>\n<p>If you allow \"subgroup generated by\" then you probably want that there's a Galois insertion between <code>set</code> and <code>subgroup</code>?</p>\n</blockquote>\n<p>Right, I guess this more or less qualifies as \"lemmas\" given what I listed, but it's good to mention it specifically.</p>",
        "id": 209647762,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599746865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209645266\">said</a>:</p>\n<blockquote>\n<p>I would add the \"groupification\" of a monoid as well (i.e. the left adjoint to the forgetful functor from groups to monoids).</p>\n</blockquote>\n<p>This arises from some kind of morphism between theories--what to generate for those is a separate and probably more interesting list.</p>",
        "id": 209647917,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599746921
    },
    {
        "content": "<p>I think even the question of how to write down a \"morphism between theories\" is an interesting one.</p>",
        "id": 209651831,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599747554
    },
    {
        "content": "<p>There's a rigorous notion of morphism between Lawvere theories right? It basically boils down to a way of defining the operations of structure X in terms of the operations of structure Y.</p>",
        "id": 209653708,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599748393
    },
    {
        "content": "<p>Yeah, it's just a functor that preserves finite products.</p>",
        "id": 209653753,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748408
    },
    {
        "content": "<p>But once the system defines free objects, that already defines the corresponding monad, at least on objects.</p>",
        "id": 209653896,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748459
    },
    {
        "content": "<p>The morphisms between theories are then \"just\" morphisms of monads.</p>",
        "id": 209653939,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748480
    },
    {
        "content": "<p>Or you can say a morphism of theories is an adjunction between locally presentable categories. But these are not syntactic descriptions.</p>",
        "id": 209654058,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599748533
    },
    {
        "content": "<p>There's such a thing as a multi-sorted Lawvere theory right? Are these worth doing? It might be handy to have stuff like morphism of groups that preserve an action on a particular set.</p>",
        "id": 209654060,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599748534
    },
    {
        "content": "<p>Yeah, certainly two-sorted things are important if you want modules :)</p>",
        "id": 209654168,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748560
    },
    {
        "content": "<p>I think the main challenge in this abstract approach (using monads or Lawvere theories, for example), is to generate the moprhism of theories when you recognize that it should exist, for example going from groups to monoids.</p>",
        "id": 209654911,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748629
    },
    {
        "content": "<p>Use type class inference? Inspect <code>group.to_monoid</code>.</p>",
        "id": 209655295,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1599748784
    },
    {
        "content": "<p>In the universal algebra repo I mentioned above, I defined a language <code>L</code> as a function from N to Type*, and rules as a relation on some inductive gadget built out of a language. A \"morphism\" of theories was then a function <code>L1 n \\to L2 n</code> for every n, such that the induced map on the inductive gadget gave an implication on rules. This is not the most general thing you can do, since you can have two pairs of languages/rules which give the same theory.</p>",
        "id": 209655381,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599748810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110044\">Chris Hughes</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209655295\">said</a>:</p>\n<blockquote>\n<p>Use type class inference? Inspect <code>group.to_monoid</code>.</p>\n</blockquote>\n<p>I think the point is that we want some metacode to generate the classes <code>group</code> and <code>monoid</code>, and to also be able to notice, for example, that <code>group</code> should extend <code>monoid</code>.</p>",
        "id": 209659716,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599750291
    },
    {
        "content": "<p>Don't forget that all this discussion is only about the trivial example (only one type involved). The first interesting case is module over a (semi)ring. This is where beginners (and not so beginners) get confused about parameters vs extension etc.</p>",
        "id": 209665826,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1599752512
    },
    {
        "content": "<p>Will all this help with sheaves of modules over a sheaf of rings?</p>",
        "id": 209668788,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599753655
    },
    {
        "content": "<p>Sure, replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Set</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span> with a sheaf topos and you're good.</p>",
        "id": 209668939,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599753717
    },
    {
        "content": "<p>On a more serious note, all this universal algebra stuff can, in principle, help in defining (and working with) internal algebraic objects in categories.</p>",
        "id": 209669181,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599753805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209668939\">said</a>:</p>\n<blockquote>\n<p>Sure, replace <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">Set</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">t</span></span></span></span> with a sheaf topos and you're good.</p>\n</blockquote>\n<p>I might get a bit confused about parameters vs extension</p>",
        "id": 209669207,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599753816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110038\">Kevin Buzzard</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209668788\">said</a>:</p>\n<blockquote>\n<p>Will all this help with sheaves of modules over a sheaf of rings?</p>\n</blockquote>\n<p>What kind of help are you looking for?</p>",
        "id": 209776322,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599828802
    },
    {
        "content": "<p>I guess he doesn't want to manually duplicate the entire (constructive part of the) API</p>",
        "id": 209776471,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599828890
    },
    {
        "content": "<p>What API though?</p>",
        "id": 209776504,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599828911
    },
    {
        "content": "<p>What I meant was \"I cannot even formalise the statements of the theorems I want to work on, because we do not have the definition of a sheaf of modules over a sheaf of rings in mathlib as far as I know\".</p>",
        "id": 209776778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599829070
    },
    {
        "content": "<blockquote>\n<ul>\n<li>Definition of a sheaf of modules.</li>\n<li>Definition of sheaf of module homomorphisms, sheaf of module isomorphisms.</li>\n<li>Products of sheaf of modules (nullary <code>(p)unit</code> and binary <code>prod</code>, as well as indexed <code>Pi</code>)</li>\n<li>Definition of a subsheaf of modules. A subsheaf of modules also forms a sheaf of modules, with a sheaf of module hom to the original sheaf of module hom. Image and preimage of a subsheaf of module hom under a sheaf of module hom. </li>\n<li>... &lt;snip&gt;</li>\n</ul>\n</blockquote>",
        "id": 209776867,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599829106
    },
    {
        "content": "<p>I mean, as all automation, I don't think it's going to help with something that there are currently 0 examples of</p>",
        "id": 209776927,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599829134
    },
    {
        "content": "<p>at least it can't help you until after you've gone and written example 1</p>",
        "id": 209776980,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599829159
    },
    {
        "content": "<p>Sorry, where am I looking? I can't find sheaf of modules in the docs, in mathlib or in the PR's.</p>",
        "id": 209777180,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599829238
    },
    {
        "content": "<p>That's exactly Reid's point.</p>",
        "id": 209777252,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599829271
    },
    {
        "content": "<p>If M is an R-module, I bet I can make a sheaf of modules on Spec(R).</p>",
        "id": 209777449,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599829355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209776867\">said</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>Definition of a sheaf of modules.</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>Already there are many possibilities for this definition</p>",
        "id": 209777484,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599829378
    },
    {
        "content": "<p>Right, and I can't prove that the category of sheaves of modules on Spec(R) is equivalent to R-mod because I can't currently state it.</p>",
        "id": 209777535,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599829412
    },
    {
        "content": "<p>It seems that the approach used to define ringed spaces won't extend easily, because the value of a sheaf of modules on an open set U is an object in a category that depends on U.</p>",
        "id": 209778503,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599829943
    },
    {
        "content": "<p>Anyway, that was what I meant by \"will all this abstract stuff help\".</p>",
        "id": 209778597,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599829999
    },
    {
        "content": "<p>But it could be a sheaf of abelian groups + extra data expressed in a non-categorical manner.</p>",
        "id": 209778637,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599830020
    },
    {
        "content": "<p>It could be but then it's hard to see how to generate <em>that</em> description from the theory of a module over a ring written in the first-order style that we use in mathlib and presumably would have in the abstract definitions of theories as well.</p>",
        "id": 209778790,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599830107
    },
    {
        "content": "<p>Of course the real point of a ring is that it's a monoid object in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">A</mi><mi mathvariant=\"normal\">b</mi></mrow><mo separator=\"true\">,</mo><mo>⊗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{Ab}, \\otimes)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">A</span><span class=\"mord mathrm\">b</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">⊗</span><span class=\"mclose\">)</span></span></span></span> (or maybe in the associated multicategory) but we don't have this information in mathlib AFAIK.</p>",
        "id": 209778996,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599830206
    },
    {
        "content": "<p>I  mentioned the following code in the <code>status of schemes</code> thread we were in a little while ago. </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">topology</span><span class=\"bp\">.</span><span class=\"n\">sheaves</span><span class=\"bp\">.</span><span class=\"n\">local_predicate</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">Top</span>\n<span class=\"kn\">open</span> <span class=\"n\">topological_space</span>\n<span class=\"kn\">universe</span> <span class=\"n\">v</span>\n<span class=\"kn\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"n\">Top</span><span class=\"bp\">.</span><span class=\"o\">{</span><span class=\"n\">v</span><span class=\"o\">}}</span>\n<span class=\"kn\">variables</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span> <span class=\"n\">v</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">local_ring_predicate</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"kn\">extends</span> <span class=\"n\">local_predicate</span> <span class=\"n\">T</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_subring</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">},</span> <span class=\"n\">is_subring</span> <span class=\"o\">(</span><span class=\"n\">pred</span> <span class=\"o\">:</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">U</span><span class=\"o\">),</span> <span class=\"n\">T</span> <span class=\"n\">x</span><span class=\"o\">)))</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">local_module_predicate</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">ring</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">local_ring_predicate</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n  <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">add_comm_group</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"o\">[</span><span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">S</span> <span class=\"n\">x</span><span class=\"o\">)]</span> <span class=\"kn\">extends</span> <span class=\"n\">local_predicate</span> <span class=\"n\">S</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_submodule</span> <span class=\"o\">:</span> <span class=\"n\">sorry</span><span class=\"o\">)</span> <span class=\"c1\">-- is_submodule doesn&#39;t exist in mathlib, but you get the idea.</span>\n</code></pre></div>\n\n\n<p>This approach should presumably work in the universal case as well.</p>",
        "id": 209784170,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599832884
    },
    {
        "content": "<p>Assuming the metacode produces <code>is_subfoo</code> classes...</p>",
        "id": 209784231,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599832921
    },
    {
        "content": "<p><code>local_ring_predicate</code> should be read <code>local_(ring_predicate)</code> and not <code>(local_ring)_predicate</code></p>",
        "id": 209786286,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599833991
    },
    {
        "content": "<p>I think this is addressing a slightly later question--here the issue is how to represent even the data of a sheaf of modules</p>",
        "id": 209787016,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834315
    },
    {
        "content": "<p>A sheaf of modules is a <code>local_module_predicate</code> satsifying some gluing axioms.</p>",
        "id": 209787272,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834420
    },
    {
        "content": "<p>Hang on, I don't know what a <code>local_predicate</code> is.</p>",
        "id": 209787511,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834512
    },
    {
        "content": "<p>I guess I'm confused by the language. Surely what a sheaf of modules <strong>is</strong> is the stuff that comes earlier: <code>[Π (x : X), add_comm_group (S x)] [Π (x : X), module (T x) (S x)]</code></p>",
        "id": 209787849,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834651
    },
    {
        "content": "<p>maybe together with some more stuff</p>",
        "id": 209787929,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834694
    },
    {
        "content": "<p>This isn't how I'm used to thinking about things</p>",
        "id": 209787937,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834699
    },
    {
        "content": "<p>This comes from the representation of a sheaf as a subpresheaf of the rule sending <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi><mo stretchy=\"false\">(</mo><mi>u</mi><mo>:</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>T</mi><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">\\Pi (u : U), T u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">u</span></span></span></span>.</p>",
        "id": 209788111,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834771
    },
    {
        "content": "<p>Where you are meant to think of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>T</mi><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">T u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">u</span></span></span></span> as some set which contains the stalk of the sheaf at <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span>.</p>",
        "id": 209788164,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834794
    },
    {
        "content": "<p>The <code>local_predicate</code> thing is essentially saying that this gives you a presheaf, and there is another structure which ensures the sheaf axiom.</p>",
        "id": 209788224,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834829
    },
    {
        "content": "<p>Errr sorry, in mathlib <code>local_predicate</code> is satisfies the sheaf axiom, but there is also a <code>prelocal_predicate</code> which gives you presheaves.</p>\n<p><a href=\"https://github.com/leanprover-community/mathlib/blob/0c57b2da3c4e821fb2e1e351409e61e039fd7ea6/src/topology/sheaves/local_predicate.lean#L87\">https://github.com/leanprover-community/mathlib/blob/0c57b2da3c4e821fb2e1e351409e61e039fd7ea6/src/topology/sheaves/local_predicate.lean#L87</a></p>",
        "id": 209788391,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834905
    },
    {
        "content": "<p>So if I have an open set <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> how do I get out the <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi mathvariant=\"script\">O</mi><mi>X</mi></msub><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}_X(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07847em;\">X</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>-module?</p>",
        "id": 209788395,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599834907
    },
    {
        "content": "<p>it's the subset of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Π</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>:</mo><mi>U</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo><mi>T</mi><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">\\Pi (x : U), T u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">Π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">u</span></span></span></span> given by the local predicate.</p>",
        "id": 209788482,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834957
    },
    {
        "content": "<p>Hence the <code>is_submodule</code></p>",
        "id": 209788534,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599834966
    },
    {
        "content": "<p>If <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">M</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{M}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">M</span></span></span></span></span> is a sheaf of modules over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span></span> then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>u</mi><mo>:</mo><mi>U</mi></mrow></msub><msub><mi mathvariant=\"script\">M</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_{u : U} \\mathcal{M}_u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17862099999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mrel mtight\">:</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\">M</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is a module over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∏</mo><mrow><mi>u</mi><mo>:</mo><mi>U</mi></mrow></msub><msub><mi mathvariant=\"script\">O</mi><mi>u</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\prod_{u : U} \\mathcal{O}_u</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0497100000000001em;vertical-align:-0.29971000000000003em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∏</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17862099999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span><span class=\"mrel mtight\">:</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.29971000000000003em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>.</p>",
        "id": 209788651,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599835037
    },
    {
        "content": "<p>I guess to me this seems more like a way of avoiding answering the question of what is a sheaf of modules</p>",
        "id": 209788696,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599835062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209788696\">said</a>:</p>\n<blockquote>\n<p>I guess to me this seems more like a way of avoiding answering the question of what is a sheaf of modules</p>\n</blockquote>\n<p>I don't disagree, but what's the alternative aside from working internally in the sheaf topos?</p>",
        "id": 209788882,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599835156
    },
    {
        "content": "<p>Well, there is the hands-on definition. (A sheaf of modules over <code>O</code> is a sheaf <code>M</code>, + for each <code>U</code> an add-group structure on <code>M U</code> and a <code>O U</code>-module structure on <code>M U</code>.</p>",
        "id": 209789134,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599835278
    },
    {
        "content": "<p>Yes of course, but I think this would be harder to automate</p>",
        "id": 209789259,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599835342
    },
    {
        "content": "<p>You also need all the restriction maps to be morphisms in the correct category, etc</p>",
        "id": 209789316,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599835371
    },
    {
        "content": "<p>Ramon Mir used an extremely hands-on definition when making schemes for his MSc project last year, and then Kenny went on to prove things like Gamma-Spec adjointness using this definition. However, when Ramon went to port his stuff to mathlib he discovered that Scott had already put the definition of a presheaf in, and it used categories (which Ramon didn't), so we decided to wait.</p>",
        "id": 209789820,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599835617
    },
    {
        "content": "<p>Another option is to define the tensor product of presheaves of abelian groups (ideally, also of sheaves by applying sheafification) and say a sheaf of modules is a module object over the monoid object that is a sheaf of rings</p>",
        "id": 209791027,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599836183
    },
    {
        "content": "<p>Another option is to consider the (pseudo)functor <code>Mod(O_X(-)) : opens X -&gt; Cat</code> and define a sheaf of modules to be some kind of enhancement of a sheaf to the category of lax sections of this functor</p>",
        "id": 209791306,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599836311
    },
    {
        "content": "<p>Anyways the issue here seems to be that we don't know what we want the definition to be, not an automation problem.</p>",
        "id": 209791441,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599836376
    },
    {
        "content": "<p>Probably the right thing to do is to go look up how Lurie defines sheaves of modules in SAG.</p>",
        "id": 209791612,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599836456
    },
    {
        "content": "<p>Looks like Lurie defines sheaves of abelian groups, he then defines sheaves of rings as monoid objects there, and modules as (<em>internal</em>) modules over those monoid objects.</p>",
        "id": 209792681,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599836945
    },
    {
        "content": "<p>Definition 2.1.0.1 here <a href=\"https://www.math.ias.edu/~lurie/papers/SAG-rootfile.pdf\">https://www.math.ias.edu/~lurie/papers/SAG-rootfile.pdf</a></p>",
        "id": 209792730,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599836970
    },
    {
        "content": "<p>I'm happy with that, but I was under the impression that people wanted to avoid the internal definitions.</p>",
        "id": 209793062,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599837135
    },
    {
        "content": "<p>But this definition does have an automation problem if you define sheaves of abelian groups as sheaves <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span></span></span></span> such that for every open <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">A</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{A}(U)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathcal\">A</span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> has an abelian group structure, such that blah blah blah, and then you go and define sheaves of rings as something internal to the category of sheaves of abelian groups. How would you tell the computer to decide to define sheaves of abelian groups \"externally\" like above, while defining sheaves of rings internally to the corresponding category of abelian sheaves? </p>\n<p>I thought the whole point of this discussion was to tell the computer: \"Here are the operations and axioms for an abelian group,  here are the operations and axioms for a ring, and here is how to forget the ring structure to get an abelian group, now go and make me some categories of sheaves\".</p>",
        "id": 209797241,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599838895
    },
    {
        "content": "<p>I guess this gets back to my original question as well then. I don't understand what there is to automate. Don't we already have sheaves of abelian groups, which we could presumably make into a monoidal category, and monoid objects in a monoidal category, and modules over them (I'm not sure if they exist yet, but they are no harder than monoid objects)?</p>",
        "id": 209804241,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842128
    },
    {
        "content": "<p>I was envisioning automating the creation of sheaves of <code>foo</code> where <code>foo</code>is any (possibly multi-sorted) Lawvere theory (or variety in the sense of universal algebra, or ...).</p>",
        "id": 209804549,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599842290
    },
    {
        "content": "<p>But maybe this just amounts to making sheaves valued in categories with enough colimits, and automating the creation of such categories from universal algebra.</p>",
        "id": 209804753,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599842402
    },
    {
        "content": "<p>This is somehow easier, right? This occurred to me as well--there's some category of \"rings plus modules over them\"; and a sheaf of modules over a sheaf of rings is a sheaf of one of those.</p>",
        "id": 209804923,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842487
    },
    {
        "content": "<p>Yeah, you can look at the category of pairs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R,M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> where <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> is a ring and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> is an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module, with the obvious morphisms.</p>",
        "id": 209804996,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599842519
    },
    {
        "content": "<p>I don't know if <span class=\"user-mention\" data-user-id=\"110031\">@Patrick Massot</span> would be happy with that approach.</p>",
        "id": 209805061,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599842538
    },
    {
        "content": "<p>That's an interesting approach!</p>",
        "id": 209805136,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599842588
    },
    {
        "content": "<p>A sheaf of modules is a dependent sheaf, so surely dependent type theory should just love them :-)</p>",
        "id": 209805187,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1599842624
    },
    {
        "content": "<p>It sounds pretty awkward to formulate statements like \"O_{Spec R}-mod is equivalent to R-mod\" in this language, though</p>",
        "id": 209805195,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842628
    },
    {
        "content": "<p>Well that's the thing. Dependent type theory loves them, which is why the hands on approach didn't run into any of these questions.</p>",
        "id": 209805269,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842656
    },
    {
        "content": "<p>You need to work with the \"forgetful functor\" from this category to the category of rings.</p>",
        "id": 209805274,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599842663
    },
    {
        "content": "<p>For the category theory version you would need consider some kind of \"dependent functor\", which is essentially the idea of<br>\n<span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209791306\">said</a>:</p>\n<blockquote>\n<p>Another option is to consider the (pseudo)functor <code>Mod(O_X(-)) : opens X -&gt; Cat</code> and define a sheaf of modules to be some kind of enhancement of a sheaf to the category of lax sections of this functor</p>\n</blockquote>",
        "id": 209805403,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842724
    },
    {
        "content": "<p>Using sheaves of pairs <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>R</mi><mo separator=\"true\">,</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(R, M)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> is the analogue of getting rid of dependent types by using a Sigma type</p>",
        "id": 209805794,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599842914
    },
    {
        "content": "<p>then you start getting equality of types</p>",
        "id": 209805900,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1599842994
    },
    {
        "content": "<p>Yes, or you could insert an isomorphism--that is where things start to get awkward</p>",
        "id": 209806003,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599843048
    },
    {
        "content": "<p>I tried playing with this idea a bit. Even the \"dependent functor\" idea gives trouble. See the two sorry's below.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Cat</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra</span><span class=\"bp\">.</span><span class=\"n\">category</span><span class=\"bp\">.</span><span class=\"n\">Module</span><span class=\"bp\">.</span><span class=\"n\">basic</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">category_theory</span>\n\n<span class=\"n\">def</span> <span class=\"n\">restrict_scalars</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"o\">:</span> <span class=\"n\">Ring</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"err\">⟶</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"o\">(</span><span class=\"n\">Module</span> <span class=\"n\">B</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Module</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">carrier</span> <span class=\"o\">:=</span> <span class=\"n\">M</span><span class=\"o\">,</span>\n    <span class=\"n\">is_add_comm_group</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n    <span class=\"n\">is_module</span> <span class=\"o\">:=</span>\n    <span class=\"o\">{</span> <span class=\"n\">smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"n\">a</span> <span class=\"err\">•</span> <span class=\"n\">m</span><span class=\"o\">,</span>\n      <span class=\"n\">one_smul</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">mul_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_mul</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">mul_smul</span> <span class=\"o\">},</span>\n      <span class=\"n\">smul_add</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">smul_add</span> <span class=\"o\">},</span>\n      <span class=\"n\">smul_zero</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span>\n      <span class=\"n\">add_smul</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"o\">{</span><span class=\"n\">change</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"err\">•</span> <span class=\"bp\">_</span> <span class=\"bp\">=</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">rw</span> <span class=\"n\">ring_hom</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span> <span class=\"n\">apply</span> <span class=\"n\">add_smul</span> <span class=\"o\">},</span>\n      <span class=\"n\">zero_smul</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">simp</span> <span class=\"o\">}},</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">M</span> <span class=\"n\">N</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">to_fun</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"o\">,</span>\n    <span class=\"n\">map_add&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">map_add</span><span class=\"o\">,</span>\n    <span class=\"n\">map_smul&#39;</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"k\">by</span> <span class=\"n\">rw</span> <span class=\"n\">g</span><span class=\"bp\">.</span><span class=\"n\">map_smul</span> <span class=\"o\">}</span> <span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">Mod</span> <span class=\"o\">:</span> <span class=\"n\">functor</span> <span class=\"n\">Ring</span><span class=\"err\">ᵒᵖ</span> <span class=\"n\">Cat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">obj</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">Cat</span><span class=\"bp\">.</span><span class=\"n\">of</span> <span class=\"err\">$</span> <span class=\"n\">Module</span> <span class=\"n\">A</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"o\">,</span>\n  <span class=\"n\">map</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">A</span> <span class=\"n\">B</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">restrict_scalars</span> <span class=\"n\">f</span><span class=\"bp\">.</span><span class=\"n\">unop</span><span class=\"o\">,</span>\n  <span class=\"n\">map_id&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span><span class=\"o\">,</span> <span class=\"c1\">-- oh no!</span>\n  <span class=\"n\">map_comp&#39;</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"o\">}</span>\n</code></pre></div>",
        "id": 209835369,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599858479
    },
    {
        "content": "<p>I think you'd want to use pseudofunctors anyways</p>",
        "id": 209835453,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599858523
    },
    {
        "content": "<p>Yeah for sure.</p>",
        "id": 209835488,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599858549
    },
    {
        "content": "<p>although this is probably not that bad to prove</p>",
        "id": 209835530,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599858601
    },
    {
        "content": "<p>Yeah, but the fact that <code>tidy</code> didn't even get the <code>map_id</code> field was a bad sign.</p>",
        "id": 209835582,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599858624
    },
    {
        "content": "<p>By the way, does mathlib have the restriction of scalars functor above for possibly noncommutative rings?</p>",
        "id": 209835607,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599858645
    },
    {
        "content": "<p>I know there is restriction of scalars for algebras, but that assumes some commutativity.</p>",
        "id": 209835616,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599858658
    },
    {
        "content": "<p>Ha. <code>tidy</code> is happy with the second sorry.</p>",
        "id": 209836255,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599859049
    },
    {
        "content": "<p>yep, with eta for structures, the first would be okay too</p>",
        "id": 209836382,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859133
    },
    {
        "content": "<p>at least, I think it would? I guess this is a level up from the usual situation</p>",
        "id": 209836520,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859215
    },
    {
        "content": "<p>namely, composition of bundled maps (of whatever kind, e.g., continuous maps) is definitionally associative, but not definitionally unital</p>",
        "id": 209836563,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859246
    },
    {
        "content": "<p>But I think when you go to write down the lax limit of categories you'll end up needing to turn these equalities of functors/objects into isomorphisms anyways</p>",
        "id": 209836924,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859480
    },
    {
        "content": "<p>so, it's probably easier to just work with isomorphisms (that is, a pseudofunctor) from the start</p>",
        "id": 209836982,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859519
    },
    {
        "content": "<p>Yeah I agree.</p>",
        "id": 209836989,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599859526
    },
    {
        "content": "<p>I was just playing with what's currently in mathlib.</p>",
        "id": 209837013,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599859541
    },
    {
        "content": "<p>Which doesn't have pseudofunctors, right?</p>",
        "id": 209837021,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599859552
    },
    {
        "content": "<p>Or 2 categories.</p>",
        "id": 209837028,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599859559
    },
    {
        "content": "<p>I don't think so.</p>",
        "id": 209837072,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859565
    },
    {
        "content": "<p>I wonder whether it would be possible to have a version of <code>tidy</code> that could be trusted to produce sufficiently trivial data</p>",
        "id": 209837180,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859650
    },
    {
        "content": "<p>I wouldn't bother with 2-categories for this purpose--Cat is the only one that matters</p>",
        "id": 209837350,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859743
    },
    {
        "content": "<p>In fact, I think we already basically prove a bunch of things are pseudofunctors but we lack the language to say that that's what we're doing</p>",
        "id": 209837412,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599859790
    },
    {
        "content": "<p>I guess it's possible we could need pseudofunctors valued in some flavor of monoidal categories</p>",
        "id": 209837886,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599860052
    },
    {
        "content": "<p>Also, bicategories wouldn't be that hard--I think it basically amounts to taking the existing monoidal category code and inserting a bunch more indices everywhere.</p>",
        "id": 209837944,
        "sender_full_name": "Reid Barton",
        "timestamp": 1599860092
    },
    {
        "content": "<p>I think if/when we end up having some higher category theory, it would be nice if <code>tidy</code> can put in simple data like <code>\\lam X, X</code>for us.</p>",
        "id": 209839017,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1599860724
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209778996\">said</a>:</p>\n<blockquote>\n<p>Of course the real point of a ring is that it's a monoid object in <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">A</mi><mi mathvariant=\"normal\">b</mi></mrow><mo separator=\"true\">,</mo><mo>⊗</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(\\mathrm{Ab}, \\otimes)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathrm\">A</span><span class=\"mord mathrm\">b</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">⊗</span><span class=\"mclose\">)</span></span></span></span> (or maybe in the associated multicategory) but we don't have this information in mathlib AFAIK.</p>\n</blockquote>\n<p>Still catching up on this thread, but we do have this: <a href=\"https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal/Module.lean#L136\">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal/Module.lean#L136</a> proves that monoid objects in R-modules are the same thing as R-algebras.</p>",
        "id": 209847119,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599867138
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209804241\">said</a>:</p>\n<blockquote>\n<p>I guess this gets back to my original question as well then. I don't understand what there is to automate. Don't we already have sheaves of abelian groups, which we could presumably make into a monoidal category, and monoid objects in a monoidal category, and modules over them (I'm not sure if they exist yet, but they are no harder than monoid objects)?</p>\n</blockquote>\n<p>We have the monoidal structure on presheaves in <code>C</code> when <code>C</code> is monoidal, from <a href=\"https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/functor_category.lean#L61\">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/functor_category.lean#L61</a>. There is still some work to do to get this for sheaves.</p>\n<p>We have modules over monoid objects, as <a href=\"https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal.lean#L188\">https://github.com/leanprover-community/mathlib/blob/7bade58/src/category_theory/monoidal/internal.lean#L188</a>, although almost nothing is proved about them (besides the <code>comap</code> construction).</p>",
        "id": 209847543,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599867521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209837180\">said</a>:</p>\n<blockquote>\n<p>I wonder whether it would be possible to have a version of <code>tidy</code> that could be trusted to produce sufficiently trivial data</p>\n</blockquote>\n<p>Somewhere there is a <code>follow_your_nose</code> tactic on a branch, which is essentially a cut-down version of <code>tidy</code>, further empowered to insert identity morphisms and a few other things. It's been a long time, but I'll try to find it.</p>",
        "id": 209847699,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1599867668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112680\">Johan Commelin</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/209516327\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"210057\">Fabian Glöckle</span> is your code available somewhere?</p>\n</blockquote>\n<p>(Back from holidays, sorry for moving back in the discussion.)<br>\nI shared the code some while ago in this thread <a href=\"#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Generate.20homomorphism.20types.20for.20algebraic.20structures/</a><br>\nIt generates homomorphism types for structures defined in regular lean code, no extra \"structure description format\" is required.<br>\nSee it as a proof of concept that such things work in lean metaprogramming - the code itself might not be the cleanest.</p>",
        "id": 209873309,
        "sender_full_name": "Fabian Glöckle",
        "timestamp": 1599903413
    },
    {
        "content": "<p>Thanks... I had lost track of the other thread already...</p>",
        "id": 209873379,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599903560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span> <span aria-label=\"up\" class=\"emoji emoji-2b06\" role=\"img\" title=\"up\">:up:</span></p>",
        "id": 209873383,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1599903566
    },
    {
        "content": "<p>Sorry to have 'disappeared' from this thread. I was expecting to get some kind of notification that it was active, but nope. Only when I tried to catch up on \"everything\" did I noticed it had been resurrected.</p>\n<p><span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> thanks a lot for that list. Luckily, it overlaps a lot with our list, as most of these constructions are indeed polymorphic over (a presentation of) an algebraic theory. So indeed at least that much automation should be in scope.</p>\n<p>When moving away from single-sorted theories, things do get tricky quite quickly. I'd eventually like to get to 'essentially algebraic theories', but that's a steep hill to climb.</p>",
        "id": 210461465,
        "sender_full_name": "Jacques Carette",
        "timestamp": 1600383430
    },
    {
        "content": "<p>Vaguelly related to this thread: Is it true that <code>function.injective (free_algebra.ι R : X → free_algebra R X)</code>?</p>",
        "id": 212413785,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601983743
    },
    {
        "content": "<p>I can't get beyond</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ι_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">free_algebra</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">ι</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold_coes</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">pre.of.inj</span> <span class=\"n\">R</span> <span class=\"n\">infer_instance</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"c1\">-- h: quot.mk (rel R X) (pre.of a) = quot.mk (rel R X) (pre.of b)</span>\n  <span class=\"c1\">-- ⊢ pre.of a = pre.of b</span>\n  <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 212414930,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601984541
    },
    {
        "content": "<p>I guess you need <code>nontrivial R</code>, right?</p>",
        "id": 212415362,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1601984824
    },
    {
        "content": "<p>I think that's implied by the fact I have a <code>submodule R X</code> instance, but I may be mistaken</p>",
        "id": 212416044,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601985273
    },
    {
        "content": "<p>Isn't the zero ring a (semi)module of itself in Lean?</p>",
        "id": 212416122,
        "sender_full_name": "Anne Baanen",
        "timestamp": 1601985319
    },
    {
        "content": "<p>And my issue right now is more with finding a suitable induction principle.</p>",
        "id": 212416224,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601985367
    },
    {
        "content": "<p>Inducting on <code>quot.eq.mp h</code> loses the information that I started with <code>pre.of</code></p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code>  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">quot.eq.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n</code></pre></div>",
        "id": 212416381,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601985476
    },
    {
        "content": "<p>And using <code>set</code> to try and keep that information gives an <code>app_builder</code> error:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">ι_inj</span> <span class=\"o\">:</span> <span class=\"n\">function.injective</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">free_algebra</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"kd\">begin</span>\n  <span class=\"n\">intros</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold</span> <span class=\"n\">ι</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">unfold_coes</span> <span class=\"n\">at</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">apply</span> <span class=\"bp\">@</span><span class=\"n\">pre.of.inj</span> <span class=\"n\">R</span> <span class=\"n\">infer_instance</span> <span class=\"n\">X</span> <span class=\"n\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">replace</span> <span class=\"n\">h</span> <span class=\"o\">:=</span> <span class=\"n\">quot.eq.mp</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">pa</span> <span class=\"o\">:</span> <span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">pre.of</span> <span class=\"n\">a</span><span class=\"o\">,</span>\n  <span class=\"n\">set</span> <span class=\"n\">pb</span><span class=\"o\">:</span> <span class=\"n\">pre</span> <span class=\"n\">R</span> <span class=\"n\">X</span> <span class=\"o\">:=</span> <span class=\"n\">pre.of</span> <span class=\"n\">b</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">h</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span>\n    <span class=\"n\">intro</span><span class=\"o\">,</span>\n    <span class=\"c1\">-- [app_builder] failed to infer universe level for type</span>\n    <span class=\"c1\">-- (let pa : pre R X := pre.of a, pb : pre R X := pre.of b in</span>\n    <span class=\"c1\">-- λ (h : eqv_gen (rel R X) pa pb), pre.of a = pre.of b) h_x h_y (eqv_gen.rel h_x h_y h_a)</span>\n  <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 212417942,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601986344
    },
    {
        "content": "<p>Moved discussion to <a href=\"#narrow/stream/113488-general/topic/.60sorry.60.20tactic.20fails/near/212418947\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/.60sorry.60.20tactic.20fails/near/212418947</a> - even <code>sorry</code>is failing, so this looks like a deeper problem</p>",
        "id": 212419082,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601986982
    },
    {
        "content": "<p>It's not clear to me how you would continue anyways. Did you have a math proof of this in mind?</p>",
        "id": 212423010,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601988999
    },
    {
        "content": "<p>As I recall, <code>free_algebra R M</code> is basically constructed so that by definition it has the universal property for <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-algebras with an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module map from <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>.</p>",
        "id": 212423241,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601989098
    },
    {
        "content": "<p>This function is injective assuming <code>R</code> is nontrivial. If you can construct some ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> with a map <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>X</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">X \\to A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> which is injective, then it has to factor through <code>free_algebra R X</code> via <code>\\iota</code> by the universal property, so the map will be injective for free.</p>",
        "id": 212423489,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989205
    },
    {
        "content": "<p>You can probably just map into the <code>mv_polynomial</code>ring.</p>",
        "id": 212423846,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989382
    },
    {
        "content": "<p>If you only care about this <code>injective</code> statement then you could get away with much less. Namely, any <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> defines a square-zero extension <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mo>⊕</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">R \\oplus M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">⊕</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> by defining the product of two elements of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> to be zero.</p>",
        "id": 212423893,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601989402
    },
    {
        "content": "<p>That's a ring into which <code>M</code> maps injectively :)</p>",
        "id": 212423925,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989424
    },
    {
        "content": "<p>I was suggesting to use some explicit ring. The square-zero extension is a good choice.</p>",
        "id": 212423964,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989442
    },
    {
        "content": "<p>The <code>mv_polynomial</code>ring is another one.</p>",
        "id": 212424010,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989450
    },
    {
        "content": "<p>Note that the free algebra is no longer the tensor algebra (this was refactored by Scott)</p>",
        "id": 212424054,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601989474
    },
    {
        "content": "<p>If you want to understand what <code>free_algebra R M</code> looks like as an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">R</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>-module then often a good way is to give a second construction (as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>⨁</mo><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msup><mi>M</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msup></mrow><annotation encoding=\"application/x-tex\">\\bigoplus_{n \\ge 0} M^{\\otimes n}</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.16622em;vertical-align:-0.39488900000000005em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">⨁</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139799999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mrel mtight\">≥</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.39488900000000005em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.771331em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">⊗</span><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span> in this case) and check it also satisfies the universal property.</p>",
        "id": 212424064,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601989481
    },
    {
        "content": "<p>Sorry, my internet cut out in the middle of writing this.</p>",
        "id": 212424107,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601989498
    },
    {
        "content": "<p>Perhaps I should un- <a href=\"https://en.wikipedia.org/wiki/XY_problem\">#xy</a> this - I'm trying to prove that <code>algebra.adjoin R (set.range (ι R : X → free_algebra R X)) = ⊤</code></p>",
        "id": 212425015,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601989946
    },
    {
        "content": "<p>Oh this should be easier.</p>",
        "id": 212425258,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990052
    },
    {
        "content": "<p>This sounds a lot easier, and also pretty much unrelated to injectivity...?</p>",
        "id": 212425268,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601990058
    },
    {
        "content": "<p>Yeah, this amounts to proving that every element of the free algebra is some sum/product of elements in the image of <code>\\iota</code>.</p>",
        "id": 212425316,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990088
    },
    {
        "content": "<p>And this comes essentially from the inductive definition of <code>free_algebra.pre</code></p>",
        "id": 212425366,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990115
    },
    {
        "content": "<p>Injectivity came up because it looked like it was sufficient for the proof, and also seemed obviously true</p>",
        "id": 212425503,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601990170
    },
    {
        "content": "<p>And you give me some code with imports?</p>",
        "id": 212425629,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990241
    },
    {
        "content": "<p>I think I can prove the <code>adjoin</code> statement above using <a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a>, but my goal was to replace <a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a> with a proof via <code>adjoin</code> instead</p>",
        "id": 212425642,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601990248
    },
    {
        "content": "<p>I'll try to put something together.</p>",
        "id": 212425643,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990248
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.free_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.adjoin</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">free_algebra</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ι_generator</span> <span class=\"o\">:</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">free_algebra</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</code></pre></div>",
        "id": 212426113,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601990502
    },
    {
        "content": "<p>This should get you started:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.free_algebra</span>\n<span class=\"kn\">import</span> <span class=\"n\">ring_theory.adjoin</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">free_algebra</span>\n\n<span class=\"kn\">local</span> <span class=\"kn\">attribute</span> <span class=\"o\">[</span><span class=\"n\">reducible</span><span class=\"o\">]</span> <span class=\"n\">free_algebra</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">ι_generator</span> <span class=\"o\">:</span> <span class=\"n\">algebra.adjoin</span> <span class=\"n\">R</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">free_algebra</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">))</span> <span class=\"bp\">=</span> <span class=\"bp\">⊤</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">ext</span><span class=\"o\">,</span>\n  <span class=\"n\">refine</span> <span class=\"o\">⟨</span><span class=\"kd\">by</span> <span class=\"n\">simp</span><span class=\"o\">,</span><span class=\"n\">_</span><span class=\"o\">⟩,</span>\n  <span class=\"n\">intro</span> <span class=\"n\">hx</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">induction</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">sorry</span> <span class=\"o\">},</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 212426474,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990683
    },
    {
        "content": "<p>Of course, I'm cheating because I know the construction of <code>free_algebra</code> which I'm not supposed to use.</p>",
        "id": 212426553,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990724
    },
    {
        "content": "<p>Hence the <code>local attribute [reducible] free_algebra</code>.</p>",
        "id": 212426571,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990734
    },
    {
        "content": "<p>Yeah, I was hoping to either avoid cheating or make some extra statement about the universal property before we sealed the construction</p>",
        "id": 212426674,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601990773
    },
    {
        "content": "<p>Is the stronger statement <code>(lift R f).range = algebra.adjoin R (set.range f)</code> also true? (generalizing <code>ι R</code> to <code>f</code>)</p>",
        "id": 212426734,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601990800
    },
    {
        "content": "<p>Yeah that's also true.</p>",
        "id": 212426778,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601990824
    },
    {
        "content": "<p>The induction principle in <a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a> seems like a sensible thing to have (though we generally wouldn't bundle the conditions into a structure). I don't understand the proof in <a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a>, but it can just be proved directly.</p>",
        "id": 212426988,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601990908
    },
    {
        "content": "<p>Yeah if we don't want to temporarily make things reducible (which we probably don't), then it looks like we're missing some induction principles.</p>",
        "id": 212427229,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1601991009
    },
    {
        "content": "<blockquote>\n<p>I don't understand the proof in <a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a></p>\n</blockquote>\n<p>What proof?</p>",
        "id": 212427267,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601991029
    },
    {
        "content": "<p>everything after line 303</p>",
        "id": 212427407,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601991094
    },
    {
        "content": "<p>The proof should just be: since <code>free_algebra</code> is a quotient it suffices to check <code>C</code> holds on things of the form <code>quot.mk</code> of something. Now define <code>C' x</code> to be <code>C (quot.mk _ x)</code> (or whatever the syntax is). Then the conditions on <code>C</code> turn into the conditions on <code>C'</code> needed to apply induction on <code>pre</code>.</p>",
        "id": 212427628,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601991181
    },
    {
        "content": "<p>Ah, the point was to generate the inductive principle from the universal property alone</p>",
        "id": 212427699,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601991216
    },
    {
        "content": "<p>I see. That's also possible but it seems unnecessary.</p>",
        "id": 212428636,
        "sender_full_name": "Reid Barton",
        "timestamp": 1601991627
    },
    {
        "content": "<p>I've realized that most of that proof is actually just a crutch for <code>has_coe_to_sort (subalgebra R A)</code> not existing</p>",
        "id": 212434635,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601994144
    },
    {
        "content": "<p>Or rather, something wacky going on with typeclass resolution</p>",
        "id": 212443394,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601997532
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/issues/4335\">#4335</a> updated, the proof is now much shorter</p>",
        "id": 212443422,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1601997544
    },
    {
        "content": "<p>I found myself needing a lemma something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_semiring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">semiring</span> <span class=\"n\">A</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">algebra</span> <span class=\"n\">R</span> <span class=\"n\">A</span><span class=\"o\">]</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">A</span><span class=\"o\">)</span>  <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">A</span> <span class=\"bp\">→ₐ</span><span class=\"o\">[</span><span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"n\">free_algebra</span> <span class=\"n\">R</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- better as  `ι R = (g.comp (lift R f)) ∘ ι R ↔ alg_hom.id R _ = g.comp (lift R f)`?</span>\n<span class=\"kd\">lemma</span> <span class=\"n\">forall_ι_iff_forall</span><span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">x</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">R</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">)))</span> <span class=\"bp\">↔</span> <span class=\"bp\">∀</span> <span class=\"n\">z</span><span class=\"o\">,</span> <span class=\"n\">z</span> <span class=\"bp\">=</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">lift</span> <span class=\"n\">R</span> <span class=\"n\">f</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">split</span><span class=\"o\">,</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">alg_hom.comp_apply</span><span class=\"o\">,</span>\n    <span class=\"n\">conv_lhs</span> <span class=\"o\">{</span><span class=\"n\">rw</span> <span class=\"bp\">←@</span><span class=\"n\">alg_hom.id_apply</span> <span class=\"n\">R</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">z</span><span class=\"o\">},</span>\n    <span class=\"n\">revert</span> <span class=\"n\">z</span><span class=\"o\">,</span>\n    <span class=\"n\">rw</span> <span class=\"bp\">←</span><span class=\"n\">alg_hom.ext_iff</span><span class=\"o\">,</span>\n    <span class=\"n\">refine</span> <span class=\"n\">free_algebra.hom_ext</span> <span class=\"o\">(</span><span class=\"n\">funext</span> <span class=\"bp\">$</span> <span class=\"bp\">λ</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">_</span><span class=\"o\">),</span>  <span class=\"c1\">-- ext, but written to make clear what lemma I use</span>\n    <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">alg_hom.id_apply</span><span class=\"o\">,</span> <span class=\"n\">alg_hom.comp_apply</span><span class=\"o\">,</span> <span class=\"n\">function.comp_app</span><span class=\"o\">],</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"o\">},</span>\n  <span class=\"o\">{</span> <span class=\"n\">intros</span> <span class=\"n\">h</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n    <span class=\"n\">exact</span> <span class=\"n\">h</span> <span class=\"o\">(</span><span class=\"n\">ι</span> <span class=\"n\">R</span> <span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"o\">}</span>\n<span class=\"kd\">end</span>\n</code></pre></div>\n\n<p>This feels really quite clumsy - can anyone think of a tidier proof or theorem statement? Are we missing some obvious lemmas about <code>lift</code> and <code>ι</code> that would make this easier?</p>",
        "id": 212540998,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602067614
    },
    {
        "content": "<p>Two algebra maps out of the free algebra are equal (right hand side of iff) if and only if they agree on the generators <code>X</code> (left hand side of iff).</p>",
        "id": 212546247,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602071270
    },
    {
        "content": "<p>I think the non-trivial direction of that statement is exactly the statement of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/free_algebra.hom_ext\">docs#free_algebra.hom_ext</a> which my proof already uses</p>",
        "id": 212546857,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602071675
    },
    {
        "content": "<p>Although what you have there sounds like a nice docstring for <code>hom_ext</code></p>",
        "id": 212546995,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602071766
    },
    {
        "content": "<p>Well that's the general statement here. I don't see why we would have a lemma which is specialized to the case where one algebra map is the identity and the other one is <code>lift f</code> composed with some arbitrary other map. That's what passing arguments to lemmas is for.</p>",
        "id": 212550420,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602073692
    },
    {
        "content": "<p>It might be more convenient to have a version of <code>hom_ext</code> that yields an iff, and takes the algebra maps as explicit arguments, and maybe uses elementwise equality rather than equality of functions/algebra morphisms.</p>",
        "id": 212550767,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602073885
    },
    {
        "content": "<blockquote>\n<p>That's what passing arguments to lemmas is for.</p>\n</blockquote>\n<p>Agreed, that's why I felt uneasy with this proof. I'll have a go at your suggestion and see if it shortens my proof.</p>",
        "id": 212551196,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602074129
    },
    {
        "content": "<p>I don't really understand what is happening in this proof without running it, but I think it would be more straightforward to use <code>have</code> or something with a statement that involves things like <code>alg_hom.id</code> and <code>g.comp (lift R f)</code>, rather than trying to backwardsly massage the statement into making those expressions appear</p>",
        "id": 212551456,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074267
    },
    {
        "content": "<p>The key \"\"\"insight\"\"\" in this proof from Lean's perspective is that <code>z</code> is really the value of the identity algebra map applied to <code>z</code>, and so on. If you can get that information in as early as possible it should make the rest of the proof trivial.</p>",
        "id": 212551647,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074364
    },
    {
        "content": "<p>The reason you have to do any work at all is that Lean doesn't know how to solve problems like \"what's an algebra map <code>F</code> such that for every <code>z</code>, <code>F z = z</code>?\"</p>",
        "id": 212551781,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074443
    },
    {
        "content": "<p>Should that be an <code>ext</code> lemma for <code>alg_hom</code>?</p>",
        "id": 212551981,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602074553
    },
    {
        "content": "<p><code>(∀ z, ⇑F x = x) → F = alg_hom.id</code></p>",
        "id": 212552084,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602074619
    },
    {
        "content": "<p>I think you've nailed where the awkwardness is though - <code>alg_hom</code> is full of lemmas to simp to function applications, but I need to do the reverse and coalesce things into a single <code>alg_hom</code>.</p>",
        "id": 212552233,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602074677
    },
    {
        "content": "<p>I mean this already exists as a specialization of <code>ext</code></p>",
        "id": 212552240,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074682
    },
    {
        "content": "<p>But this is also the wrong direction, it says that the map has to be <code>alg_hom</code>, but what you need is something that makes you think to try <code>alg_hom</code> in the first place</p>",
        "id": 212552490,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074799
    },
    {
        "content": "<p>Right, hence your suggestion to use <code>have</code></p>",
        "id": 212552537,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602074829
    },
    {
        "content": "<p>Right, or I suppose you could pass the <code>alg_hom</code>s using <code>@</code> notation but there would probably be a lot of <code>_</code>s involved</p>",
        "id": 212552683,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074893
    },
    {
        "content": "<p>Actually there is a mechanism to do this already--unification hints</p>",
        "id": 212552780,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074944
    },
    {
        "content": "<p>but I don't know if they would work here anyways</p>",
        "id": 212552818,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602074967
    },
    {
        "content": "<p>Anywhere I can read about those?</p>",
        "id": 212552919,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602075003
    },
    {
        "content": "<p>Well they have about a 0% chance of getting used in mathlib anyways... not sure whether they are written up anywhere</p>",
        "id": 212552984,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602075038
    },
    {
        "content": "<p>In brief, you can register \"hints\" that tell Lean that if it is trying to solve for a metavariable <code>?m_1</code> by unification and there's not enough information, but there is a constraint like <code>?m_1.foo = bar</code>, then it should try to refine <code>?m_1</code> in some particular way. Johan and I experimented a bit with them and we have some notes at <a href=\"https://github.com/rwbarton/lean-omin/blob/master/old/unification_hints.lean\">https://github.com/rwbarton/lean-omin/blob/master/old/unification_hints.lean</a></p>",
        "id": 212553724,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602075407
    },
    {
        "content": "<p>I don't know if they would work with higher-order constraints--probably not because they're basically unsupported</p>",
        "id": 212553755,
        "sender_full_name": "Reid Barton",
        "timestamp": 1602075422
    },
    {
        "content": "<p>Oh, that looks interesting</p>",
        "id": 212554330,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602075686
    },
    {
        "content": "<p>I wonder if that can be used to fix the problem I had in <a href=\"#narrow/stream/113488-general/topic/Type.20inference.20on.20.60.E2.86.92.60.20vs.20.60.E2.89.83.60\">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type.20inference.20on.20.60.E2.86.92.60.20vs.20.60.E2.89.83.60</a></p>",
        "id": 212554441,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602075727
    },
    {
        "content": "<p>Thanks for the advice anyway, I ended up with a much tidier proof in the PR</p>",
        "id": 212555260,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1602076115
    },
    {
        "content": "<p>Note that they're being removed in lean 4 as far as I understand it</p>",
        "id": 212561268,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1602078821
    },
    {
        "content": "<p>Related to free stuff, but only tangentially to the conversation above - I found that we'd missed some quite useful bundling that makes it a little easier to work with <code>lift</code> - namely framing it as an equivalence, where <code>lift.symm F</code> is <code>F.comp ι</code> (<a href=\"https://github.com/leanprover-community/mathlib/issues/4908\">#4908</a>) - that way all of the other equiv lemmas can be used too, after converting things back to the <code>lift.symm</code> form</p>",
        "id": 215835274,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1604663376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310045\">Eric Wieser</span> <a href=\"#narrow/stream/116395-maths/topic/Free.20stuff/near/212413785\">said</a>:</p>\n<blockquote>\n<p>Vaguelly related to this thread: Is it true that <code>function.injective (free_algebra.ι R : X → free_algebra R X)</code>?</p>\n</blockquote>\n<p>I've circled back to wanting to prove this - it seems I need it to prove <code>nontrivial R → nontrivial X → nontrivial (free_algebra R X)</code></p>",
        "id": 217110413,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605690600
    },
    {
        "content": "<p>False alarm, I can prove that without it too, <a href=\"https://github.com/leanprover-community/mathlib/issues/5033\">#5033</a></p>",
        "id": 217111685,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1605691484
    }
]
[
    {
        "content": "<p>I was trying to prove that a home-rolled <code>nat</code> was an <code>add_comm_monoid</code>  in a way which was maximally mathematician-friendly, e.g. no leakage of <code>le</code> or <code>zero</code>: <a href=\"https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb\">see gist</a>.</p>\n<p>My understanding of how Lean works is that I am supposed to come up with a canonical representative for things like mynat.zero -- I choose <code>0</code>, and similarly I choose <code>1</code> for <code>one</code>. That's right, right?</p>\n<p>On line 56 I have a <code>zero</code> which is something I never really wanted to see again. Is there a more high-powered tactic which will preserve my choice for <code>0</code> as the \"canonical representative\" of <code>mynat.zero</code>? </p>\n<p>Is there a tactic that makes that instance on line 77 by just matching on names?</p>\n<p>Finally lines 142 and 146 -- what is the incantation which makes these? I am so bad at making structures. Let's say that you must make an instance of <code>add_semigroup mynat</code> before you make the instance of <code>add_comm_semigroup mynat</code>.</p>",
        "id": 169527348,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562109684
    },
    {
        "content": "<p>Kevin I think your <code>by common_sense</code> actually is a pretty easily makable tactic</p>",
        "id": 169539180,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562129376
    },
    {
        "content": "<p>I'll give it a go</p>",
        "id": 169539182,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562129388
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"bp\">...</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">mynat</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">replace_special_names</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">name</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">common_sense</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">env</span> <span class=\"err\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n   <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">sn</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n    <span class=\"k\">match</span> <span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">structure_fields</span> <span class=\"n\">sn</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n    <span class=\"n\">do</span> <span class=\"n\">n</span> <span class=\"bp\">::</span> <span class=\"bp\">_</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">open_namespaces</span><span class=\"o\">,</span>\n       <span class=\"k\">let</span> <span class=\"n\">lf</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">replace_special_names</span><span class=\"o\">,</span>\n       <span class=\"n\">v</span> <span class=\"err\">←</span> <span class=\"n\">lf</span><span class=\"bp\">.</span><span class=\"n\">mmap</span> <span class=\"n\">resolve_name</span><span class=\"o\">,</span>\n       <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">structure_instance_info</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n           <span class=\"n\">struct</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">sn</span><span class=\"o\">,</span>\n           <span class=\"n\">field_names</span> <span class=\"o\">:=</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n           <span class=\"n\">field_values</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n       <span class=\"o\">},</span>\n       <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"err\">$</span> <span class=\"n\">pexpr</span><span class=\"bp\">.</span><span class=\"n\">mk_structure_instance</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n       <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">e</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;goal not a structure&quot;</span>\n    <span class=\"kn\">end</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;unsupported goal&quot;</span>\n   <span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mynat</span>\n\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">add_monoid</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">common_sense</span>\n\n<span class=\"bp\">...</span>\n</pre></div>",
        "id": 169539788,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562130440
    },
    {
        "content": "<p>It works! Thanks! I hate making structures. I will use it forever.</p>",
        "id": 169544326,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562137256
    },
    {
        "content": "<p>Oh this is great. I have no clue how you're supposed to prove that <code>mynat</code> is a <code>comm_semiring</code>. You seem to have to perform the incantations all in exactly the right order in the official way to do it. This way I can just not even care. I went to the end of my multiplication file and typed <code>instance : comm_semiring mynat := by common_sense</code> and it just gave me a list of the fields for which it has failed and what the error messages were for each. I can then just make them at the end of my multiplication file as part of an api. This is <em>brilliant</em>. </p>\n<p>It's sort-of an idiot-proof structure maker.</p>",
        "id": 169544666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562137702
    },
    {
        "content": "<p>Can we have this in mathlib? Maybe called <code>structure_helper</code>?</p>",
        "id": 169554653,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1562149263
    },
    {
        "content": "<p>Kevin, could you post an updated gist using this tactic? It would make this conversation easier to understand</p>",
        "id": 169558300,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1562153657
    },
    {
        "content": "<p><a href=\"https://gist.github.com/kbuzzard/73237dbb64e70c482404d3780a4483c1\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/73237dbb64e70c482404d3780a4483c1\">Structure tactic</a></p>\n<p><a href=\"https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb\" target=\"_blank\" title=\"https://gist.github.com/kbuzzard/bec5f90d5e0a012696420f0f2430bedb\">add_comm_monoid nat</a></p>",
        "id": 169565725,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562160353
    },
    {
        "content": "<p>Nice! I hope mathlib's naming convention won't interfere with merging this useful tactic</p>",
        "id": 169567680,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1562161774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span> </p>\n<p>I can't make preorders because they have this weird <code>lt_iff_not_le</code> field.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">set_option</span> <span class=\"n\">auto_param</span><span class=\"bp\">.</span><span class=\"n\">check_exists</span> <span class=\"n\">false</span>\n<span class=\"n\">class</span> <span class=\"n\">preorder</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"kn\">extends</span> <span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">has_lt</span> <span class=\"n\">α</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">&lt;</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>I just want to not define <code>lt</code> or <code>lt_iff_le_not_le</code></p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">-- import the tactic</span>\n<span class=\"kn\">inductive</span> <span class=\"n\">mynat</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">mynat</span>\n\n<span class=\"n\">def</span> <span class=\"n\">le</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_le</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨</span><span class=\"n\">le</span><span class=\"bp\">⟩</span>\n<span class=\"n\">def</span> <span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"c1\">-- I think a,b,c should be implicit but Lean doesn&#39;t</span>\n<span class=\"n\">def</span> <span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"c1\">--instance : preorder mynat := by i_checked_all_teh_axioms -- fails</span>\n<span class=\"c1\">-- unknown identifier &#39;lt&#39;</span>\n\n<span class=\"n\">def</span> <span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"n\">mynat</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>  <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span>\n\n<span class=\"c1\">-- instance : preorder mynat := by i_checked_all_teh_axioms -- fails</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">type mismatch at field &#39;lt_iff_le_not_le&#39;</span>\n<span class=\"cm\">  lt_iff_le_not_le</span>\n<span class=\"cm\">has type</span>\n<span class=\"cm\">  ?m_3 &lt; ?m_4 ↔ ?m_3 ≤ ?m_4 ∧ ¬?m_4 ≤ ?m_3</span>\n<span class=\"cm\">but is expected to have type</span>\n<span class=\"cm\">  auto_param (∀ (a b : mynat), a &lt; b ↔ a ≤ b ∧ ¬b ≤ a) (name.mk_string &quot;order_laws_tac&quot; name.anonymous)</span>\n<span class=\"cm\">-/</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">mynat</span>\n<span class=\"c\">/-</span><span class=\"cm\"></span>\n<span class=\"cm\">class preorder (α : Type u) extends has_le α, has_lt α :=</span>\n<span class=\"cm\">(le_refl : ∀ a : α, a ≤ a)</span>\n<span class=\"cm\">(le_trans : ∀ a b c : α, a ≤ b → b ≤ c → a ≤ c)</span>\n<span class=\"cm\">(lt := λ a b, a ≤ b ∧ ¬ b ≤ a)</span>\n<span class=\"cm\">(lt_iff_le_not_le : ∀ a b : α, a &lt; b ↔ (a ≤ b ∧ ¬ b ≤ a) . order_laws_tac)</span>\n<span class=\"cm\">-/</span>\n</pre></div>",
        "id": 169570909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562163967
    },
    {
        "content": "<p>Ah, we'll have to add something that checks if a field is wrapped with <code>auto_param</code>, and then tries running the embedded tactic.</p>",
        "id": 169571250,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1562164220
    },
    {
        "content": "<p>or <code>opt_param</code> in the case of <code>lt</code></p>",
        "id": 169571347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562164307
    },
    {
        "content": "<p>hmm, wasn't there a hole tactic that did this as well that I saw posted awhile back? I may be misremembering</p>",
        "id": 169572735,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1562165227
    },
    {
        "content": "<p>Do you mean <a href=\"https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718\" target=\"_blank\" title=\"https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718\">https://github.com/leanprover-community/mathlib/blob/d001abfd48d64ac27310590458132009f47c852d/src/tactic/core.lean#L718</a>? It's slightly different</p>",
        "id": 169572917,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1562165333
    },
    {
        "content": "<p>ah, I think that is what I was thinking of</p>",
        "id": 169573027,
        "sender_full_name": "Andrew Ashworth",
        "timestamp": 1562165400
    },
    {
        "content": "<p>I just want to not even bother defining <code>lt</code> and <code>lt_iff_le_not_le</code> here</p>",
        "id": 169573853,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562165942
    },
    {
        "content": "<p>Yes, that's what we're proposing. Keeley's tactic should be able to identify <code>opt_param</code> or <code>auto_param</code> fields, and handle them automatically.</p>",
        "id": 169574950,
        "sender_full_name": "Scott Morrison",
        "timestamp": 1562166681
    },
    {
        "content": "<p>I'm glad it helped! Yes this should be easy to fix...</p>",
        "id": 169584033,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562173524
    },
    {
        "content": "<p>Oh hmm turns out it's a bit yuck...</p>",
        "id": 169584426,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562173842
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">canonically_ordered_comm_semiring</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">),</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">add_le_add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">lt_if_add_lt_add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">bot_le</span> <span class=\"o\">:=</span> <span class=\"n\">bot_le</span><span class=\"o\">,</span>\n  <span class=\"n\">le_iff_exists_add</span> <span class=\"o\">:=</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">),</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">left_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">right_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_eq_zero_iff</span> <span class=\"o\">:=</span> <span class=\"bp\">_</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>Also yuck.</p>",
        "id": 169584457,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562173897
    },
    {
        "content": "<p>ha! its literally 3am where I am at the moment so I'm going to throw in the towel until morning---but just one last sorried function needs filling in:</p>",
        "id": 169586591,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562175424
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">namespace</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n<span class=\"kn\">open</span> <span class=\"n\">tactic</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">replace_special_names</span> <span class=\"o\">:</span> <span class=\"n\">name</span> <span class=\"bp\">→</span> <span class=\"n\">name</span>\n<span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"bp\">`</span><span class=\"n\">has_add</span><span class=\"bp\">.</span><span class=\"n\">add</span>\n<span class=\"bp\">|</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">n</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">get_type_of_nth_arg_core</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span> <span class=\"bp\">→</span> <span class=\"n\">expr</span>\n<span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">get_type_of_nth_arg</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">expr</span> <span class=\"o\">:=</span>\n<span class=\"n\">get_type_of_nth_arg_core</span> <span class=\"n\">k</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"o\">(</span><span class=\"n\">resolve_name</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">to_expr</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">infer_type</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">run_tac</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">n</span> <span class=\"err\">←</span> <span class=\"n\">eval_expr</span> <span class=\"n\">name</span> <span class=\"n\">n</span><span class=\"o\">,</span>\n   <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">resolve_name</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">to_expr</span><span class=\"o\">,</span>\n   <span class=\"n\">tac</span> <span class=\"err\">←</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">)</span> <span class=\"n\">e</span><span class=\"o\">,</span>\n   <span class=\"n\">tac</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">resolve_name_or_use_autoparam</span> <span class=\"o\">(</span><span class=\"n\">sn</span> <span class=\"o\">:</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">×</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"bp\">×</span> <span class=\"n\">pexpr</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">pe</span> <span class=\"err\">←</span> <span class=\"n\">resolve_name</span> <span class=\"o\">(</span><span class=\"n\">replace_special_names</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">)</span> <span class=\"bp\">&lt;|&gt;</span>\n        <span class=\"n\">do</span> <span class=\"o\">{</span> <span class=\"n\">t</span> <span class=\"o\">:</span> <span class=\"n\">expr</span> <span class=\"err\">←</span> <span class=\"n\">get_type_of_nth_arg</span> <span class=\"o\">(</span><span class=\"n\">sn</span> <span class=\"bp\">++</span> <span class=\"bp\">`</span><span class=\"n\">mk</span><span class=\"o\">)</span> <span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"mi\">1</span><span class=\"o\">,</span>\n             <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n             <span class=\"bp\">|</span> <span class=\"bp\">`</span><span class=\"o\">(</span><span class=\"n\">auto_param</span> <span class=\"err\">%%</span><span class=\"n\">t</span> <span class=\"err\">%%</span><span class=\"n\">tac</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n               <span class=\"n\">lock_tactic_state</span> <span class=\"err\">$</span> <span class=\"n\">do</span>\n                 <span class=\"n\">m</span> <span class=\"err\">←</span> <span class=\"n\">mk_meta_var</span> <span class=\"n\">t</span><span class=\"o\">,</span>\n                 <span class=\"n\">set_goals</span> <span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">],</span>\n                 <span class=\"n\">run_tac</span> <span class=\"n\">tac</span><span class=\"o\">,</span>\n                 <span class=\"n\">to_pexpr</span> <span class=\"bp\">&lt;</span><span class=\"err\">$</span><span class=\"bp\">&gt;</span> <span class=\"n\">instantiate_mvars</span> <span class=\"n\">m</span>\n             <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">failed</span>\n             <span class=\"kn\">end</span>\n           <span class=\"o\">},</span>\n   <span class=\"n\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">.</span><span class=\"mi\">2</span><span class=\"o\">,</span> <span class=\"n\">pe</span><span class=\"o\">)</span>\n\n<span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">i_checked_all_teh_axioms</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">t</span> <span class=\"err\">←</span> <span class=\"n\">target</span><span class=\"o\">,</span>\n   <span class=\"n\">env</span> <span class=\"err\">←</span> <span class=\"n\">get_env</span><span class=\"o\">,</span>\n   <span class=\"k\">match</span> <span class=\"n\">t</span> <span class=\"k\">with</span>\n   <span class=\"bp\">|</span> <span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">app</span> <span class=\"o\">(</span><span class=\"n\">expr</span><span class=\"bp\">.</span><span class=\"n\">const</span> <span class=\"n\">sn</span> <span class=\"bp\">_</span><span class=\"o\">)</span> <span class=\"n\">e</span> <span class=\"o\">:=</span>\n    <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"o\">(</span><span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">structure_fields</span> <span class=\"n\">sn</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span>\n    <span class=\"k\">match</span> <span class=\"n\">env</span><span class=\"bp\">.</span><span class=\"n\">structure_fields</span> <span class=\"n\">sn</span> <span class=\"k\">with</span>\n    <span class=\"bp\">|</span> <span class=\"n\">some</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n    <span class=\"n\">do</span> <span class=\"n\">n</span> <span class=\"bp\">::</span> <span class=\"bp\">_</span> <span class=\"err\">←</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">open_namespaces</span><span class=\"o\">,</span>\n       <span class=\"k\">let</span> <span class=\"n\">l</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"bp\">.</span><span class=\"n\">range</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">length</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">zip</span> <span class=\"n\">l</span><span class=\"o\">,</span>\n       <span class=\"n\">v</span> <span class=\"err\">←</span> <span class=\"n\">l</span><span class=\"bp\">.</span><span class=\"n\">mfilter_map</span> <span class=\"err\">$</span> <span class=\"n\">resolve_name_or_use_autoparam</span> <span class=\"n\">sn</span><span class=\"o\">,</span>\n       <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n       <span class=\"k\">let</span> <span class=\"n\">s</span> <span class=\"o\">:</span> <span class=\"n\">structure_instance_info</span> <span class=\"o\">:=</span> <span class=\"o\">{</span>\n           <span class=\"n\">struct</span> <span class=\"o\">:=</span> <span class=\"n\">some</span> <span class=\"n\">sn</span><span class=\"o\">,</span>\n           <span class=\"n\">field_names</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">fst</span><span class=\"o\">,</span>\n           <span class=\"n\">field_values</span> <span class=\"o\">:=</span> <span class=\"n\">v</span><span class=\"bp\">.</span><span class=\"n\">map</span> <span class=\"n\">prod</span><span class=\"bp\">.</span><span class=\"n\">snd</span><span class=\"o\">,</span>\n       <span class=\"o\">},</span>\n       <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">trace</span> <span class=\"n\">v</span><span class=\"o\">,</span>\n       <span class=\"n\">e</span> <span class=\"err\">←</span> <span class=\"n\">to_expr</span> <span class=\"err\">$</span> <span class=\"n\">pexpr</span><span class=\"bp\">.</span><span class=\"n\">mk_structure_instance</span> <span class=\"n\">s</span><span class=\"o\">,</span>\n       <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">exact</span> <span class=\"n\">e</span>\n    <span class=\"bp\">|</span> <span class=\"n\">none</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;goal not a structure&quot;</span>\n    <span class=\"kn\">end</span>\n   <span class=\"bp\">|</span> <span class=\"bp\">_</span> <span class=\"o\">:=</span> <span class=\"n\">fail</span> <span class=\"s2\">&quot;unsupported goal&quot;</span>\n<span class=\"kn\">end</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">tactic</span><span class=\"bp\">.</span><span class=\"n\">interactive</span>\n</pre></div>",
        "id": 169586596,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562175426
    },
    {
        "content": "<p>haha funnily enough <code>run_tac</code> is equivalent to the ridiculous composite</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">meta</span> <span class=\"n\">def</span> <span class=\"n\">run_tac&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">expr</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">tactic</span> <span class=\"n\">unit</span> <span class=\"o\">:=</span>\n<span class=\"n\">do</span> <span class=\"n\">tac</span> <span class=\"err\">←</span> <span class=\"n\">eval_expr</span> <span class=\"n\">name</span> <span class=\"n\">n</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">resolve_name</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">to_expr</span> <span class=\"bp\">&gt;&gt;=</span> <span class=\"n\">eval_expr</span> <span class=\"o\">(</span><span class=\"n\">tactic</span> <span class=\"n\">unit</span><span class=\"o\">),</span>\n   <span class=\"n\">tac</span>\n</pre></div>",
        "id": 169586723,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562175523
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">canonically_ordered_comm_semiring</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span>\n<span class=\"o\">{</span> <span class=\"n\">add</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">+</span><span class=\"o\">),</span>\n  <span class=\"n\">add_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">add_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">zero</span> <span class=\"o\">:=</span> <span class=\"mi\">0</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_add</span> <span class=\"o\">:=</span> <span class=\"n\">zero_add</span><span class=\"o\">,</span>\n  <span class=\"n\">add_zero</span> <span class=\"o\">:=</span> <span class=\"n\">add_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">add_comm</span> <span class=\"o\">:=</span> <span class=\"n\">add_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">le</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">≤</span><span class=\"o\">),</span>\n  <span class=\"n\">le_refl</span> <span class=\"o\">:=</span> <span class=\"n\">le_refl</span><span class=\"o\">,</span>\n  <span class=\"n\">le_trans</span> <span class=\"o\">:=</span> <span class=\"n\">le_trans</span><span class=\"o\">,</span>\n  <span class=\"n\">le_antisymm</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">le_antisymm</span><span class=\"o\">,</span>\n  <span class=\"n\">add_le_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">add_le_add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">lt_of_add_lt_add_left</span> <span class=\"o\">:=</span> <span class=\"n\">lt_if_add_lt_add_left</span><span class=\"o\">,</span>\n  <span class=\"n\">bot</span> <span class=\"o\">:=</span> <span class=\"err\">⊥</span><span class=\"o\">,</span>\n  <span class=\"n\">bot_le</span> <span class=\"o\">:=</span> <span class=\"n\">bot_le</span><span class=\"o\">,</span>\n  <span class=\"n\">le_iff_exists_add</span> <span class=\"o\">:=</span> <span class=\"n\">le_iff_exists_add</span><span class=\"o\">,</span>\n  <span class=\"n\">mul</span> <span class=\"o\">:=</span> <span class=\"o\">(</span><span class=\"bp\">*</span><span class=\"o\">),</span>\n  <span class=\"n\">mul_assoc</span> <span class=\"o\">:=</span> <span class=\"n\">mul_assoc</span><span class=\"o\">,</span>\n  <span class=\"n\">one</span> <span class=\"o\">:=</span> <span class=\"mi\">1</span><span class=\"o\">,</span>\n  <span class=\"n\">one_mul</span> <span class=\"o\">:=</span> <span class=\"n\">one_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_one</span> <span class=\"o\">:=</span> <span class=\"n\">mul_one</span><span class=\"o\">,</span>\n  <span class=\"n\">left_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">left_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">right_distrib</span> <span class=\"o\">:=</span> <span class=\"n\">right_distrib</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_mul</span> <span class=\"o\">:=</span> <span class=\"n\">zero_mul</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_zero</span> <span class=\"o\">:=</span> <span class=\"n\">mul_zero</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_comm</span> <span class=\"o\">:=</span> <span class=\"n\">mul_comm</span><span class=\"o\">,</span>\n  <span class=\"n\">zero_ne_one</span> <span class=\"o\">:=</span> <span class=\"n\">zero_ne_one</span><span class=\"o\">,</span>\n  <span class=\"n\">mul_eq_zero_iff</span> <span class=\"o\">:=</span> <span class=\"n\">mul_eq_zero_iff</span> <span class=\"o\">}</span>\n</pre></div>\n\n\n<p>I finished my proof.</p>",
        "id": 169587709,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562176252
    },
    {
        "content": "<p>how about decidable le?</p>",
        "id": 169587982,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1562176492
    },
    {
        "content": "<p>Oh that's not maths, that's not in this game</p>",
        "id": 169588007,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562176513
    },
    {
        "content": "<p>That is generated without telling the user</p>",
        "id": 169588028,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562176529
    },
    {
        "content": "<blockquote>\n<p>how about decidable le?</p>\n</blockquote>\n<p><code>decidable le</code> uses recursion. I am trying to box off what is done by recursion, because mathematicians put it in a different box to induction.</p>\n<p>Example: one could present the natural numbers <code>mynat</code> as having two constants <code>mynat.zero</code> and <code>mynat.succ</code>, two axioms <code>mynat.zero_ne_succ</code> and <code>mynat.succ_inj</code>, and one key fact: you can use the <code>induction n</code> tactic if you have <code>n : mynat</code>. The two axioms are proved by Lean using recursion via <code>nat.rec</code>;  <code>succ_inj</code> can be proved easily using the completely artificial function <code>pred</code> which no mathematician has ever seen or uses (because it allows 0 as an input and gives the wrong answer), and <code>zero_ne_succ</code> can be proved by defining a function which sends 0 to <code>tt</code> and <code>succ n</code> to <code>ff</code>, again a function which can be defined by recursion but is of no use to us in practice.</p>\n<p>If you present nat this way and present addition similarly (<code>mynat.add</code> is a constant, we will always use the <code>+</code> notation, <code>add_zero</code> and <code>add_succ</code> are axioms, don't worry about how it was defined) then one can \"prove\" things like the \"theorem\" <code>add_monoid mynat</code> (because now it <em>is</em> a theorem -- all the data has been given to you and there's only a theorem left) purely within tactic mode, by supplying tactic proofs of each of the fields in whatever order you like.</p>\n<p>I am looking at what happens to <code>nat</code> if you try and isolate all the computational content and \"proofs and data constructed via recursion\" and just give the user an inductive principle which can only be used to construct proofs. One way of looking at it is you could say that I was trying to isolate \"the bit which mathematicians like best\".</p>",
        "id": 169627375,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562226326
    },
    {
        "content": "<p>Update: it almost works, but its hard to tell when a structure has optional parameters (the \"auto-param\" kind is fine). It turns out that the generated constructors don't have the <code>opt_param</code> part...</p>",
        "id": 169635851,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562235298
    },
    {
        "content": "<p>But otherwise it's a lot more robust than before now</p>",
        "id": 169635969,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562235413
    },
    {
        "content": "<p>Okay I found a tricksy way (not intended, but I don't think there is an API for this...)</p>",
        "id": 169636384,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562235781
    },
    {
        "content": "<p>Ok its even tricker than I thought, extra idea...</p>",
        "id": 169637998,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562237285
    },
    {
        "content": "<p>Yeah ok I'm really struggling. There is a lot of code now, and by some tricks I can find out which fields have optional/default values, but I can't find a way to determine what the values actually are. Secretly lean knows, but I think it might not be exposed. Does anyone know of a way to find the default value of a field declared <code>opt_param</code>?</p>",
        "id": 169639493,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562238832
    },
    {
        "content": "<p>(Sounds like this might be a job for lean 3.5.0, just need to add a function)</p>",
        "id": 169639547,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562238851
    },
    {
        "content": "<p>Here is the current state: <a href=\"https://gist.github.com/khoek/b820b0b242909a22bfd3b16a046eb9de\" target=\"_blank\" title=\"https://gist.github.com/khoek/b820b0b242909a22bfd3b16a046eb9de\">https://gist.github.com/khoek/b820b0b242909a22bfd3b16a046eb9de</a><br>\nIt does everything you want Kevin except for the <code>lt</code> problem.</p>",
        "id": 169639731,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562239044
    },
    {
        "content": "<p><code>try_apply_opt_auto_param_for_apply</code> might help as a template. It uses</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">when</span> <span class=\"n\">cfg</span><span class=\"bp\">.</span><span class=\"n\">opt_param</span> <span class=\"o\">(</span><span class=\"n\">try</span> <span class=\"n\">apply_opt_param</span><span class=\"o\">)</span> <span class=\"bp\">&gt;&gt;</span>\n<span class=\"n\">when</span> <span class=\"n\">cfg</span><span class=\"bp\">.</span><span class=\"n\">auto_param</span> <span class=\"o\">(</span><span class=\"n\">try</span> <span class=\"n\">apply_auto_param</span><span class=\"o\">)</span>\n</pre></div>",
        "id": 169640042,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562239438
    },
    {
        "content": "<p>which are themselves implemented in lean in the obvious way</p>",
        "id": 169640112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562239476
    },
    {
        "content": "<p>but they are expecting the opt/auto_param to be the main goal, not sure if that's true in your case</p>",
        "id": 169640141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562239506
    },
    {
        "content": "<p>I can do the handling of those cases just fine (and that code is in the gist), the problem is that there is no way at all I can find to programmically get the <code>opt_param blah</code> associated to an optional field of a structure.</p>",
        "id": 169650217,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248496
    },
    {
        "content": "<p>If you make an example structure which has an optional and auto param for comparison, the autogenerated <code>.mk</code> retains the autoparam but drops the optional</p>",
        "id": 169650282,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248546
    },
    {
        "content": "<p>An optional field has the type <code>opt_param type default_value</code></p>",
        "id": 169650291,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562248550
    },
    {
        "content": "<p>Sure, but this information is not exposed by lean</p>",
        "id": 169650317,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248563
    },
    {
        "content": "<p>it's literally in the expr</p>",
        "id": 169650345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562248570
    },
    {
        "content": "<p>The expr for what?</p>",
        "id": 169650358,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248579
    },
    {
        "content": "<p>the type of the projection</p>",
        "id": 169650364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562248585
    },
    {
        "content": "<p>oooooooh!</p>",
        "id": 169650378,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248595
    },
    {
        "content": "<p>Hang on</p>",
        "id": 169650454,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248669
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>run_cmd (do\n  tactic.mk_const `preorder.lt &gt;&gt;= tactic.infer_type &gt;&gt;= pp &gt;&gt;= tactic.trace\n)\n</pre></div>",
        "id": 169650466,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248677
    },
    {
        "content": "<p>I don't see any reference to the <code>opt_param</code></p>",
        "id": 169650474,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248680
    },
    {
        "content": "<p>The constructor <code>preorder.mk</code> is the same; <code>auto_param</code> fields are replicated, the optional ones are dropped</p>",
        "id": 169650546,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562248737
    },
    {
        "content": "<p>Oh, that's weird... I found a strange parsing issue while investigating this too</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">preorder1</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lt</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"bp\">_</span> <span class=\"bp\">_</span><span class=\"o\">,</span> <span class=\"n\">iff</span><span class=\"bp\">.</span><span class=\"n\">rfl</span><span class=\"o\">)</span>\n\n<span class=\"kn\">structure</span> <span class=\"n\">preorder2</span> <span class=\"o\">(</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">has_le</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">le_refl</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">le_trans</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">→</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span> <span class=\"bp\">→</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">c</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">lt_iff_le_not_le</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">,</span> <span class=\"n\">lt</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"bp\">↔</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">≤</span> <span class=\"n\">b</span> <span class=\"bp\">∧</span> <span class=\"bp\">¬</span> <span class=\"n\">b</span> <span class=\"bp\">≤</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"bp\">.</span> <span class=\"n\">order_laws_tac</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>The type of <code>lt_iff_le_not_le</code> is different in the two cases. <code>preorder2</code> is the right one. <code>preorder1.lt_iff_le_not_le</code> is trivial as evidenced by the <code>rfl</code> proof. <span class=\"user-mention\" data-user-id=\"110024\">@Sebastian Ullrich</span> Are you aware of this? It looks like that thing you pointed out a while back where structures could define lets and notation and other crazy things. Somehow <code>lt</code> is treated as a notation for the purposes of <code>lt_iff_le_not_le</code>, but it is also an actual field...?</p>",
        "id": 169651364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562249506
    },
    {
        "content": "<p>:0</p>",
        "id": 169651434,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562249543
    },
    {
        "content": "<p>The other weird thing about this is that <code>lt</code> is already defined in the case of <code>preorder</code>, in <code>has_lt</code>, and it's getting \"redefined\" with a new defeq type in <code>preorder</code></p>",
        "id": 169651451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562249570
    },
    {
        "content": "<p>I can already predict that the lean C++ code to make sense of all this is a rats nest</p>",
        "id": 169651495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562249610
    },
    {
        "content": "<p>Looks like a straight bug</p>",
        "id": 169651705,
        "sender_full_name": "Sebastian Ullrich",
        "timestamp": 1562249807
    },
    {
        "content": "<p>Now is the time were Sebastian will paste that url to the commit which fixed that bug in Lean 4 months ago</p>",
        "id": 169651739,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1562249864
    },
    {
        "content": "<p>I can make a preorder by just ignoring the <code>lt</code> and <code>lt_iff_whatever</code> fields completely. It's not possible to emulate that behaviour with a tactic?</p>",
        "id": 169653555,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562251435
    },
    {
        "content": "<p>It appears that lean does not provide a way for lean to access the pre-set optional values of structures, eg. <code>lt</code> in this case.<br>\nI think I make it work but it'll be a little bit less robust than I had hoped</p>",
        "id": 169654365,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562252139
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Here is a link to something that works, at least on the two <code>add_monoid</code> and <code>preorder</code> examples I've seen! <a href=\"https://gist.github.com/khoek/cfb72fe41b0725269a14bf9196bb9c73\" target=\"_blank\" title=\"https://gist.github.com/khoek/cfb72fe41b0725269a14bf9196bb9c73\">https://gist.github.com/khoek/cfb72fe41b0725269a14bf9196bb9c73</a></p>",
        "id": 169658797,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562257046
    },
    {
        "content": "<p>Are you able to make a <code>canonically_ordered_comm_semiring</code> using it?</p>",
        "id": 169659315,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562257771
    },
    {
        "content": "<p>I'm now seeing all sorts of errors like</p>\n<div class=\"codehilite\"><pre><span></span>type mismatch at field &#39;lt_of_add_lt_add_left&#39;\n  lt_of_add_lt_add_left\nhas type\n  ?m_3 + ?m_4 &lt; ?m_3 + ?m_5 → ?m_4 &lt; ?m_5\nbut is expected to have type\n  ∀ (a b c : mynat), a + b &lt; a + c → b &lt; c\n</pre></div>\n\n\n<p>but this is not your fault -- I have defined <code>lt_of_add_lt_add_left</code> with the inputs implicit but apparently Lean wants them explicit. Nearly there now, just fixing all of them.</p>",
        "id": 169659640,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562258099
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span> <span class=\"o\">:</span> <span class=\"n\">canonically_ordered_comm_semiring</span> <span class=\"n\">mynat</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">structure_helper</span> <span class=\"c1\">-- works!</span>\n</pre></div>",
        "id": 169659728,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562258210
    },
    {
        "content": "<p>How do I get a complete list of all the typeclasses <code>X</code> such that type class inference can find a term of type <code>X nat</code> ?</p>",
        "id": 169659758,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562258273
    },
    {
        "content": "<p>But it works :-) Many thanks Keeley!</p>",
        "id": 169659933,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562258420
    },
    {
        "content": "<p>Ultimately I would rather <code>lt_of_add_lt_add_left : ∀ {a b c : mynat}, a + b &lt; a + c → b &lt; c := ...</code> because I believe that this is the idiomatic way to define this function, with a, b, c implicit. It stops the tactic working through. We can put that down to \"further work if someone can be bothered\".</p>",
        "id": 169660220,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562258765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> you were talking about a bug in Lean. Can this  bug be easily fixed in 3.5.1? Would a consequence be that a whole bunch of <code>_</code>'s would need to be removed from mathlib? I feel like the definition of <code>canonically_ordered_comm_semiring.lt_of_add_lt_add_left</code> is \"wrong\".</p>\n<div class=\"codehilite\"><pre><span></span>canonically_ordered_comm_semiring.lt_of_add_lt_add_left : ∀ (a b c : ?M_1), a + b &lt; a + c → b &lt; c\n</pre></div>\n\n\n<p>I want to write some sort of front end for Lean where the user just has to type in simple proofs in tactic mode and that's all they can do. For this project, I don't care about mathlib and I don't care if I'm running a non-standard Lean. On the other hand if people change the behaviour of core tactics like <code>induction</code> then it will break everything I guess.</p>",
        "id": 169660436,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259038
    },
    {
        "content": "<p>You should just be using <code>lt_of_add_lt_add_left</code></p>",
        "id": 169660461,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259090
    },
    {
        "content": "<p>which has the right binders</p>",
        "id": 169660463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259100
    },
    {
        "content": "<p>ooh. <code>ordered_cancel_comm_monoid</code></p>",
        "id": 169660521,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259158
    },
    {
        "content": "<p>I love that there are just a gazillion really stupid-in-my-eyes classes which are just out there and I don't know the names of any of them.</p>",
        "id": 169660533,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259186
    },
    {
        "content": "<p>I don't want to use it, I want the user to prove it.</p>",
        "id": 169660548,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259224
    },
    {
        "content": "<p>There is a tactic that does the restating automatically</p>",
        "id": 169660601,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259278
    },
    {
        "content": "<p>Yeah but I don't want to restate it, I want the user to prove it.</p>",
        "id": 169660619,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259306
    },
    {
        "content": "<p>We're building nat from scratch.</p>",
        "id": 169660623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259315
    },
    {
        "content": "<p>The binders don't matter if you are proving it</p>",
        "id": 169660632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259326
    },
    {
        "content": "<p>it's lambda regardless</p>",
        "id": 169660634,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259335
    },
    {
        "content": "<p>I know, I just feel like I'm lying to the user.</p>",
        "id": 169660639,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259350
    },
    {
        "content": "<p>In fact, it's usually better for the axiom to have all explicit or semi implicit binders when proving it</p>",
        "id": 169660704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110111\">@Keeley Hoek</span> I would like an over-ride. I'd like to define <code>mynat.lt_of_add_lt_add_left</code>  with semi-implicit or implicit binders, and then define <code>mynat.lt_of_add_le_add_left'</code> to be the thing with the stupid binders and then tell your tactic to use the stupid version with the ' just for that field only.</p>",
        "id": 169660778,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259500
    },
    {
        "content": "<p>For instance, you might have an assumption that says <code>∀ (a b c : A), a + b &lt; a + c → b &lt; c</code> and you want to pass it in; if the assumption is implicit then the arguments will get auto applied and it won't fit</p>",
        "id": 169660780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259504
    },
    {
        "content": "<p>I would assume that for Keeley's tactic you can define the binders however you like</p>",
        "id": 169660796,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562259532
    },
    {
        "content": "<p>Unfortunately Mario it seems that the structure-builder notation refuses to accept specifying a field with different binders =/</p>",
        "id": 169660922,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562259661
    },
    {
        "content": "<p>Perhaps another bug?</p>",
        "id": 169660931,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562259670
    },
    {
        "content": "<p>MWE:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- works</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">func</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"n\">def</span> <span class=\"n\">concrete</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n<span class=\"c1\">-- doesn&#39;t</span>\n<span class=\"n\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">func</span> <span class=\"o\">:=</span> <span class=\"n\">concrete</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 169661038,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562259776
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>canonically_ordered_comm_semiring\n  canonically_ordered_monoid,\n    ordered_comm_monoid\n      add_comm_monoid\n      partial_order\n    lattice.order_bot\n      partial_order\n  comm_semiring\n  zero_ne_one_class\n</pre></div>\n\n\n<p>Generated by hand -- each thing extends the things one level of indentation below it.</p>",
        "id": 169661132,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259896
    },
    {
        "content": "<p>That's funny because you would imagine that <code>lam a, f</code> is syntactically equal to <code>lam {a}, f</code></p>",
        "id": 169661230,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562259978
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">structure</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">func</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">),</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span>\n\n<span class=\"c1\">-- works</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">func</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"o\">{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">},</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">}</span>\n\n<span class=\"c1\">-- also works!</span>\n<span class=\"n\">def</span> <span class=\"n\">concrete</span> <span class=\"o\">{{</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">}}</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">def</span> <span class=\"n\">bar</span> <span class=\"o\">:</span> <span class=\"n\">thingo</span> <span class=\"o\">:=</span> <span class=\"o\">{</span><span class=\"n\">func</span> <span class=\"o\">:=</span> <span class=\"n\">concrete</span><span class=\"o\">}</span>\n</pre></div>",
        "id": 169661271,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562260043
    },
    {
        "content": "<p>that's not a bug, that's by design</p>",
        "id": 169662170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562261238
    },
    {
        "content": "<p>and that's also why I said semi-implicit is a good choice here</p>",
        "id": 169662183,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562261259
    },
    {
        "content": "<p>Is there a \"correct\" decision for the variables in <code>lt_of_add_le_add_left</code> ? Or do you sometimes need one thing and sometimes another?</p>",
        "id": 169662260,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562261357
    },
    {
        "content": "<p>It might work to use apply to figure out the right number of arguments</p>",
        "id": 169662477,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562261729
    },
    {
        "content": "<p>ooh, well my tactic could count the number of expected explicit arguments and then instead of <code>fn := fn</code> not compiling <code>fn := \\lambda a b, @fn _ a b</code> would compile. Would that have defeq problems?</p>",
        "id": 169714756,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562338461
    },
    {
        "content": "<p>no</p>",
        "id": 169714809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562338518
    },
    {
        "content": "<p>In principle this is what <code>apply</code> is supposed to do, but it may not work for you</p>",
        "id": 169714901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562338570
    },
    {
        "content": "<p>Yes, due to the aforementioned <code>opt_param</code> problems the only way I can get those fields filled is using a <code>structure_instance_info</code>, which needs explicit <code>pexpr</code>s to be provided.</p>",
        "id": 169714995,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562338666
    },
    {
        "content": "<p>Also, is your \"no\" an answer to my question, or \"no that won't work\"?</p>",
        "id": 169715050,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562338684
    },
    {
        "content": "<p>no defeq problems</p>",
        "id": 169715060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562338693
    },
    {
        "content": "<p>You can elaborate an expr using <code>apply</code> and then quote it to turn it into a pexpr</p>",
        "id": 169715076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1562338719
    },
    {
        "content": "<p>Oh ok, I see what you are saying. I tried something like this for a bit but there were problems I think with the inter-dependence of the fields and things like <code>le</code> not being decided when <code>le_refl</code> was being decided using an <code>apply</code>. I guess you could build everything consistently so that all the fields of the structure had metavariables in their type in common when they correspond to the same thing? But this seems like some work</p>",
        "id": 169717116,
        "sender_full_name": "Keeley Hoek",
        "timestamp": 1562340392
    },
    {
        "content": "<p>I am using Mario's approach of <code>{{ }}</code> when necessary</p>",
        "id": 169717269,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1562340565
    }
]
[
    {
        "content": "<p>Hi all,</p>\n<p>At the suggestion/guidance of <span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>, <span class=\"user-mention\" data-user-id=\"459656\">@Hans Parshall</span>, <span class=\"user-mention\" data-user-id=\"450749\">@Dustin Mixon</span>, and I are thinking about introducing an <code>orthonormal_basis</code> structure,</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">orthonormal_basis</span> <span class=\"o\">:=</span> <span class=\"n\">of_repr</span> <span class=\"o\">::</span> <span class=\"o\">(</span><span class=\"n\">repr</span> <span class=\"o\">:</span> <span class=\"n\">E</span> <span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">Œπ</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>Which will be the finite dimensional version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis.has_coe_to_fun\">docs#hilbert_basis.has_coe_to_fun</a>. I think we have a basic sense of lemmas that we want to hit, but if you have any thoughts let us know!</p>",
        "id": 271836547,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644850441
    },
    {
        "content": "<p>So, there is already a noncomputable definition of orthonormal_basis at <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthonormal_basis\">docs#orthonormal_basis</a>. Ultimately it seems like this should get roped into the structure definition above. I'm not quite sure what the standard rules for how to combine these sorts of definitions for compatibility are.<br>\nThat is, it seems to me that the new output of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthonormal_basis\">docs#orthonormal_basis</a> should be:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">orthonormal_basis</span> <span class=\"o\">(</span><span class=\"bp\">ùïú</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_1</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u_2</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">is_R_or_C</span> <span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">inner_product_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n<span class=\"n\">orthonormal_basis</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span>\n</code></pre></div>\n<p>But I don't know if it's my role to refactor a thing like this (to be clear, I'm happy to, I just don't want to mess up some one else's code)</p>",
        "id": 271847463,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644854569
    },
    {
        "content": "<p>That definition is the definition of a particular \"standard\" orthonormal basis of a given inner product space.  Your definition is more important, so it should get the name.  And we'll rename that definition.</p>",
        "id": 271847704,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854643
    },
    {
        "content": "<p>Ah, I see. So the definition there should be like <code>std_orthonormal_basis</code>?</p>",
        "id": 271847799,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644854684
    },
    {
        "content": "<p>But your formulation of the type signature for the new output is correct!</p>",
        "id": 271847836,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854702
    },
    {
        "content": "<p>More generally, I've been thinking for a while that this would be a good change, and I'm very pleased that <span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span> and co will take it on.  There are several parts of the library that could probably be rewritten more elegantly once we have this new structure.  It would supersede <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.isometry_euclidean_of_orthonormal\">docs#basis.isometry_euclidean_of_orthonormal</a> , we'd probably rewrite <a href=\"https://leanprover-community.github.io/mathlib_docs/find/maximal_orthonormal_iff_basis_of_finite_dimensional\">docs#maximal_orthonormal_iff_basis_of_finite_dimensional</a> using it ...</p>",
        "id": 271847924,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854737
    },
    {
        "content": "<p>Probably <a href=\"https://leanprover-community.github.io/mathlib_docs/find/inner_product_space.is_self_adjoint.diagonalization_basis\">docs#inner_product_space.is_self_adjoint.diagonalization_basis</a> would pass through it</p>",
        "id": 271847967,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854761
    },
    {
        "content": "<p>And maybe <span class=\"user-mention\" data-user-id=\"266253\">@Joseph Myers</span> will have applications for Euclidean geometry.</p>",
        "id": 271848077,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854799
    },
    {
        "content": "<p>I'd be happy to help out switching all these parts of the library to the new structure ... Maybe the strategy should be: first make the new definition and the \"obvious\" new lemmas, then we can slowly switch these other parts of the library over, and discover what the other standard lemmas should be in the process of developing these applications.</p>",
        "id": 271848376,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644854930
    },
    {
        "content": "<p>One thought: When we have theories developed in parallel, it's good to have parallel naming.  Here, both <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis\">docs#hilbert_basis</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis\">docs#basis</a> are quite parallel, so when there is a lemma that is parallel to lemmas there, the names should also be the same.</p>",
        "id": 271849957,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644855577
    },
    {
        "content": "<p>By the way, if you are curious about this design choice to make the definition of \"basis\" the strongest possible thing one gets from a basis -- namely the identification with C^n -- you can read some of the history at the PR <a href=\"https://github.com/leanprover-community/mathlib/pull/7496\">#7496</a> and the Zulip discussions linked there.  It was <span class=\"user-mention\" data-user-id=\"238446\">@Anne Baanen</span>'s idea.</p>",
        "id": 271851782,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644856335
    },
    {
        "content": "<p>I'd expect the <code>orthonormal_basis</code> API to provide definitions converting to and from a <code>basis</code> that is propositionally <code>orthonormal</code> (with proofs that the basis vectors and coordinates are the same etc.) and analogues of <code>basis</code> APIs such as <code>basis.map</code>, <code>basis.reindex</code>, <code>basis.equiv</code> (<code>orthonormal_basis.map</code> and <code>orthonormal_basis.equiv</code> would of course work with <code>linear_isometry_equiv</code>), with lemmas showing those APIs are consistent with the corresponding APIs for <code>basis</code>. Some other APIs may be needed for particular purposes (e.g. <code>adjust_to_orientation</code>, in order to make <code>orientation.fin_orthonormal_basis</code> give a bundled <code>orthonormal_basis</code>; that may be a case where \"convert to <code>basis</code>, apply the <code>basis</code> API and then convert back to <code>orthonormal_basis</code>\" is an appropriate implementation strategy).</p>\n<p>My current work on oriented angles defines things in terms of a <code>basis</code> that's propositionally <code>orthonormal</code> (and then proves that the definition depends only on the orientation associated with the basis, so that the API can then be replicated with definitions and lemmas that only take an <code>orientation</code> and not a <code>basis</code> as an argument and hopefully most users don't need to refer to bases at all). (That work is <code>sorry</code>-free, but there are still more lemmas I'd like to add before PRing it.) It should be straightforward to adapt to take an <code>orthonormal_basis</code> once such a bundled type is available, with API corresponding to that of <code>basis</code> and existing lemmas about a <code>basis</code> that is <code>orthonormal</code> updated accordingly to use the new type.</p>",
        "id": 271918580,
        "sender_full_name": "Joseph Myers",
        "timestamp": 1644891994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266253\">Joseph Myers</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/271918580\">said</a>:</p>\n<blockquote>\n<p>I'd expect the <code>orthonormal_basis</code> API to provide definitions converting to and from a <code>basis</code> that is propositionally <code>orthonormal</code> (with proofs that the basis vectors and coordinates are the same etc.)</p>\n</blockquote>\n<p>Agreed; I think this should look very similar to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis.mk\">docs#hilbert_basis.mk</a> together with the associated lemma <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis.coe_mk\">docs#hilbert_basis.coe_mk</a> .</p>",
        "id": 271918913,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644892349
    },
    {
        "content": "<p>Or, perhaps we should have both <code>orthonormal_basis.mk</code>, from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">ùïú</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsp</span> <span class=\"o\">:</span> <span class=\"n\">submodule.span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)</span><span class=\"bp\">=</span> <span class=\"bp\">‚ä§</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>and also <code>basis.to_orthonormal_basis</code> from</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">ùïú</span> <span class=\"n\">b</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 271919025,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644892476
    },
    {
        "content": "<p>Okay, I've got a basic API set up  mirroring some of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis\">docs#hilbert_basis</a>. We have both</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mk</span> <span class=\"o\">(</span><span class=\"n\">hon</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">ùïú</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hsp</span><span class=\"o\">:</span> <span class=\"n\">submodule.span</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">set.range</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">‚ä§</span><span class=\"o\">):</span>\n<span class=\"n\">orthonormal_basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">_root_.basis.to_orthonormal_basis</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hb</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">ùïú</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">orthonormal_basis</span>  <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span>\n</code></pre></div>\n<p>There's still more to do, but I wanted to check in that it's generally going in the right direction. Some of the proofs are much longer than they need to be, but I don't think I know the right tricks to get them shorter. I also think I might need permission to the non-master branch--my github is Daniel-Packer.<br>\nCurrently, the repository is at Daniel-Packer/orthonormal_basis.</p>",
        "id": 271998420,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644942113
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span>  I think you can use <a href=\"https://leanprover-community.github.io/mathlib_docs/find/set.indicator\">docs#set.indicator</a> to define <code>euclidean_space.single</code>, and indeed there are probably some proofs that can be made shorter over the course of the PR process.  Also, can you make an analogue of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/hilbert_basis.has_sum_repr_symm\">docs#hilbert_basis.has_sum_repr_symm</a>, using the finite sum (<a href=\"https://leanprover-community.github.io/mathlib_docs/find/finset.sum\">docs#finset.sum</a>)? But otherwise this looks good to me!  Please go ahead and open a PR (I think the material can be put directly in the file <code>inner_product_space.pi_Lp</code>, and we may find that some of the lemmas there will naturally be deleted.)</p>",
        "id": 271999320,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1644942494
    },
    {
        "content": "<p>Okay! Both changes done! I think I might need permission for non-master branches on the mathlib repo, my user id is <code>Daniel-Packer</code></p>",
        "id": 272021447,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644951555
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span> Invite sent!</p>",
        "id": 272023569,
        "sender_full_name": "Kyle Miller",
        "timestamp": 1644952418
    },
    {
        "content": "<p>Okay, so we now have a branch at :<br>\n<a href=\"https://github.com/leanprover-community/mathlib/tree/orthonormal_basis\">https://github.com/leanprover-community/mathlib/tree/orthonormal_basis</a><br>\nI think there are some linting issues, and when building, it introduces some error in orientation world, so I haven't opened a pull request yet.<br>\nThat said, I've opened up a draft pull request here:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/pull/12060\">https://github.com/leanprover-community/mathlib/pull/12060</a></p>",
        "id": 272040154,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1644960203
    },
    {
        "content": "<p>I would love to hear more people talking about the various worlds we have in mathlib :-)</p>",
        "id": 272083553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644998441
    },
    {
        "content": "<p>Okeedokes! I think that the <code>orthonormal_basis</code> refactor is ready for review for merging. It has passed the checks, it seems.</p>",
        "id": 272169814,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645041358
    },
    {
        "content": "<p>Okay! Now that we have the updated <code>orthonormal_basis</code> structure, I'm going to go through <code>projection.lean</code> and <code>spectrum.lean</code> to refactor appropriately. I'm going to be starting with the section <code>orthonormal_basis</code> in <code>projection.lean</code> (which we might incidentally want to rename?). Let me know if you have strong opinions on how it refactors.<br>\nMy main goal is get <code>std_orthonormal_basis</code> to be of type <code>orthonormal_basis</code>, and to have <code>self_adjoint.eigenvector_basis</code> to be of type <code>orthonormal_basis</code> as well.</p>",
        "id": 272619675,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645394559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span>  Oh, snap!  I was doing this too.  I haven't made too much progress but I'll push what I have.</p>",
        "id": 272620024,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645394938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272619675\">said</a>:</p>\n<blockquote>\n<p>I'm going to be starting with the section <code>orthonormal_basis</code> in <code>projection.lean</code> (which we might incidentally want to rename?). <br>\nMy main goal is get <code>std_orthonormal_basis</code> to be of type <code>orthonormal_basis</code>, and to have <code>self_adjoint.eigenvector_basis</code> to be of type <code>orthonormal_basis</code> as well.</p>\n</blockquote>\n<p>Yes, I had the same idea.  And that stuff should, therefore, move from <code>projection</code> to <code>pi_L2</code>.</p>",
        "id": 272620060,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645394984
    },
    {
        "content": "<p><a href=\"https://github.com/leanprover-community/mathlib/tree/std_orthonormal_basis\">branch#std_orthonormal_basis</a> (about half-debugged)</p>",
        "id": 272620265,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645395236
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span>  No worries! Do you plan on working on it today? Because I'm happy to stay away from it for now if so--long term I just want <code>self_adjoint.eigenvector_basis</code> to be an <code>orthonormal_basis</code> for my own selfish purposes.<br>\nIf you aren't planning on working on it today, I can try to make some progress and you can take over from wherever I leave off.</p>",
        "id": 272620368,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645395338
    },
    {
        "content": "<p>Sounds great, I should really do some other things :). I'll leave the branch for you now, keep me posted!</p>",
        "id": 272620429,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645395384
    },
    {
        "content": "<p>Will do!</p>",
        "id": 272620440,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645395410
    },
    {
        "content": "<p>The first thing I've been trying to do is build a version of dos#basis.reindex for <code>orthonormal_basis</code>. It seems like the way to do that is to make a version of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.dom_lcongr\">docs#finsupp.dom_lcongr</a> with <code>linear_isometry_equiv</code> instead. Where should such a definition go?</p>",
        "id": 272621521,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645396696
    },
    {
        "content": "<p>I think in <code>pi_L2</code>, too.</p>",
        "id": 272621633,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645396872
    },
    {
        "content": "<p>Or, no, sorry, in <code>normed_space.pi_Lp</code>.</p>",
        "id": 272621706,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645396963
    },
    {
        "content": "<p>Ah, you're totally right! Thanks!</p>",
        "id": 272621781,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645397049
    },
    {
        "content": "<p>I think I might be misunderstanding things, but if I want to put <code>finsupp.dom_licongr</code> in <code>normed_space.pi_Lp</code>, then I think I will have to add an import in that file for <code>euclidean_space</code> to work (which feels wrong to me). Should <code>euclidean_space</code> be living in <code>normed_space.pi_Lp</code>?</p>",
        "id": 272711524,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645461815
    },
    {
        "content": "<p>Currently, I'm working with:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">Œπ'</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">_root_.finsupp.dom_licongr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">Œπ'</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 272711651,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645461862
    },
    {
        "content": "<p>Separately, this definition seems silly to have around now that we have the <code>orthonormal_basis</code> structure:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">linear_isometry_equiv.of_inner_product_space</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">E</span> <span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fin_std_orthonormal_basis</span> <span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span>\n</code></pre></div>",
        "id": 272712223,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645462178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span> I was thinking more like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">variables</span> <span class=\"o\">[</span><span class=\"n\">fintype</span> <span class=\"n\">Œπ'</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">E</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">normed_group</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">normed_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span>\n<span class=\"kd\">def</span> <span class=\"n\">pi_Lp.dom_licongr</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">pi_Lp</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"n\">pi_Lp</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span><span class=\"o\">,</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">p</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 272714778,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645463520
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272712223\">said</a>:</p>\n<blockquote>\n<p>Separately, this definition seems silly to have around now that we have the <code>orthonormal_basis</code> structure:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">linear_isometry_equiv.of_inner_product_space</span>\n  <span class=\"o\">[</span><span class=\"n\">finite_dimensional</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">]</span> <span class=\"o\">{</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">‚Ñï</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">hn</span> <span class=\"o\">:</span> <span class=\"n\">finrank</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"bp\">=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">E</span> <span class=\"bp\">‚âÉ‚Çó·µ¢</span><span class=\"o\">[</span><span class=\"bp\">ùïú</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">fin_std_orthonormal_basis</span> <span class=\"n\">hn</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Agreed!  Let's delete it.</p>",
        "id": 272715329,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645463822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> I've pushed where I'm at rn. I think my proof of <code>finsupp.dom_licongr</code> is far too long. <br>\nI'm also unsure how to mess  with</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">maximal_orthonormal_iff_basis_of_finite_dimensional</span>\n<span class=\"o\">(</span><span class=\"n\">hv</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal</span> <span class=\"bp\">ùïú</span> <span class=\"o\">(</span><span class=\"n\">coe</span> <span class=\"o\">:</span> <span class=\"n\">v</span> <span class=\"bp\">‚Üí</span> <span class=\"n\">E</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n</code></pre></div>\n<p>which you had commented out, as well as how the following discussion ought to go.</p>",
        "id": 272741340,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645483061
    },
    {
        "content": "<p>For instance, I had:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">direct_sum.submodule_is_internal.subordinate_orthonormal_basis</span> <span class=\"o\">:</span>\n  <span class=\"n\">orthonormal_basis</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 272741409,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645483110
    },
    {
        "content": "<p>Which I tried to combine with the later <code>subordinate_orthonormal_basis_orthonormal</code>, which added this hypothesis:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">@[irreducible]</span> <span class=\"kd\">def</span> <span class=\"n\">direct_sum.submodule_is_internal.subordinate_orthonormal_basis</span>\n  <span class=\"o\">(</span><span class=\"n\">hV'</span> <span class=\"o\">:</span> <span class=\"bp\">@</span><span class=\"n\">orthogonal_family</span> <span class=\"bp\">ùïú</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"n\">_</span> <span class=\"o\">(</span><span class=\"bp\">Œª</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">i</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">subtype‚Çó</span><span class=\"bp\">·µ¢</span><span class=\"o\">))</span> <span class=\"o\">:</span>\n  <span class=\"n\">orthonormal_basis</span> <span class=\"o\">(</span><span class=\"n\">fin</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 272741453,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645483152
    },
    {
        "content": "<p>But this created errors later on, and I suspect it will mess up stuff in other parts of mathlib, so I think I would like to get others' (i.e. your) opinions before I push any changes to this.</p>",
        "id": 272741620,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645483294
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span> Quick comment -- I think it would be faster to prove <code>finsupp.dom_licongr</code> without passing through finitely-supported functions -- that's a complication you don't need when the index set itself is finite.  I think <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.Pi_congr_right\">docs#linear_equiv.Pi_congr_right</a>  will be a better \"basic model\" for a linear-equiv-to-upgrade-to-linear-isometry-equiv than <a href=\"https://leanprover-community.github.io/mathlib_docs/find/finsupp.dom_lcongr\">docs#finsupp.dom_lcongr</a></p>",
        "id": 272741872,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645483526
    },
    {
        "content": "<p><code>maximal_orthonormal_iff_basis_of_finite_dimensional</code> can hopefully be deleted, I just commented it out in case we needed to raid its proof for some argument.</p>",
        "id": 272742037,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645483684
    },
    {
        "content": "<p>And to deal with the awkwardness about <code>subordinate_orthonormal_basis</code>, I think you should define an analogue of the construction <a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.submodule_is_internal.collected_basis\">docs#direct_sum.submodule_is_internal.collected_basis</a> called something like</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"n\">direct_sum.submodule_is_internal.collected_orthonormal_basis</span>\n</code></pre></div>",
        "id": 272742338,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645483977
    },
    {
        "content": "<p>(refer to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/direct_sum.submodule_is_internal.collected_basis_orthonormal\">docs#direct_sum.submodule_is_internal.collected_basis_orthonormal</a> for some of the work involved in that construction)</p>",
        "id": 272742426,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645484062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260507\">@Heather Macbeth</span> For the <code>finsupp.dom_licongr</code> did you mean <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.Pi_congr_left\">docs#linear_equiv.Pi_congr_left</a> ? I'm not sure I understand how <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_equiv.Pi_congr_right\">docs#linear_equiv.Pi_congr_right</a> will help. (Separately, what does the naming convention refer to?)</p>",
        "id": 272808724,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645539627
    },
    {
        "content": "<p>Yes, sorry!  I have no idea what the names refer to :)</p>",
        "id": 272808875,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645539699
    },
    {
        "content": "<p>Git blame says <span class=\"user-mention\" data-user-id=\"310045\">@Eric Wieser</span> baptised them.</p>",
        "id": 272809027,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645539753
    },
    {
        "content": "<p>I think I just copied <a href=\"https://leanprover-community.github.io/mathlib_docs/find/equiv.Pi_congr_left\">docs#equiv.Pi_congr_left</a></p>",
        "id": 272809495,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645539965
    },
    {
        "content": "<p>The left vs right naming corresponds to the domain vs codomain of the pi type</p>",
        "id": 272809559,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645539998
    },
    {
        "content": "<p><code>dom</code> and <code>cod</code> would probably be more sensible names</p>",
        "id": 272809628,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645540035
    },
    {
        "content": "<p>So should I be calling the lemma <code>linear_isometry_equiv.Pi_congr_dom</code> instead?</p>",
        "id": 272812842,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645541410
    },
    {
        "content": "<p>No, you should stick to <code>Pi_congr_left</code> and <code>Pi_congr_right</code>, unless you first want to make a PR to rename all the existing <code>_left</code> / <code>_right</code>s to <code>_dom</code> / <code>_cod</code>.</p>",
        "id": 272815337,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1645542452
    },
    {
        "content": "<p>I'm going to put this question here, but feel free to move it if it deserves its own thread.<br>\nI've been trying to port the lemmas about <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.reindex\">docs#basis.reindex</a> to <a href=\"https://leanprover-community.github.io/mathlib_docs/find/orthonormal_basis\">docs#orthonormal_basis</a>, and one of these is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.coe_reindex_repr\">docs#basis.coe_reindex_repr</a>, which looks like: <code>((b.reindex e).repr x : Œπ' ‚Üí R) = b.repr x ‚àò e.symm</code>.<br>\nI've tried to port this over as:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">coe_reindex_repr</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal_basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">((</span><span class=\"n\">b.reindex</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">(</span><span class=\"n\">b.repr</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"bp\">‚àò</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>\n<p>but this requires an <code>id</code> (or perhaps something else) to make it run through, which tells Lean that this can't be a simplification lemma.<br>\nI have a few associated questions:</p>\n<ul>\n<li>Should I even be bothering to formalize this lemma?</li>\n<li>Why does this <code>id</code> prevent this from being a simplification lemma?</li>\n<li>Why doesn't <code>euclidean_space Œπ ùïú</code> have an instance of <code>has_coe_to_fun : Œπ ‚Üí ùïú</code>?</li>\n</ul>",
        "id": 272877716,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645570127
    },
    {
        "content": "<p>All very interesting questions!  I'd go for avoiding the issue by temporarily answering no to</p>\n<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272877716\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Should I even be bothering to formalize this lemma?</li>\n</ul>\n</blockquote>\n<p>but maybe someone will come along with a more principled answer :)</p>",
        "id": 272879617,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571171
    },
    {
        "content": "<p>If you gave us a <a href=\"https://leanprover-community.github.io/mwe.html\">#mwe</a> I could investigate further but I don't see why</p>\n<ul>\n<li>you need the <code>id</code> (maybe you just need a coercion arrow <code>‚Üë</code>?)</li>\n<li>the <code>id</code> would matter for simp normal form as it's on the RHS</li>\n</ul>",
        "id": 272879694,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645571245
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"387244\">@Ya√´l Dillies</span> the <code>id</code> is because <code>euclidean_space</code> is a type synonym.</p>",
        "id": 272879716,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571272
    },
    {
        "content": "<p>Ahah, so you're saying you're missing the \"identity\" equivalence between <code>euclidean_space</code> and <code>Œπ ‚Üí ùïú</code>? Definitely add that, in the spirit of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_dual.to_dual\">docs#order_dual.to_dual</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/find/of_lex\">docs#of_lex</a>.</p>",
        "id": 272879830,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645571340
    },
    {
        "content": "<p>Well, I think that's somewhat of an orthogonal (ha!) project to Daniel's.</p>",
        "id": 272879874,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571389
    },
    {
        "content": "<p>And also might not be necessarily once we find the Platonic ideal of how to represent Euclidean space ... therefore fine to punt on.</p>",
        "id": 272879941,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571425
    },
    {
        "content": "<p>Sure, but it seems related to Daniel's current problem and is also very cheap to have.</p>",
        "id": 272879972,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645571457
    },
    {
        "content": "<p>I <a href=\"#narrow/stream/116395-maths/topic/SVD\">still advocate</a> for trying other approaches to the issue, so I'd rather not (yet) add a lot of boilerplate to double down on the type synonym method.</p>",
        "id": 272880245,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"467358\">@Daniel Packer</span> Do you need this lemma?</p>",
        "id": 272880302,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645571710
    },
    {
        "content": "<p>Heather, two definitions is not a lot of boilerplate <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 272880312,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645571721
    },
    {
        "content": "<p>That's all you need to make your translations from and to <code>euclidean_space</code> type-correct.</p>",
        "id": 272880349,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645571760
    },
    {
        "content": "<p>One thing I didn't add in the thread you just linked to is that you don't need to insert those identity equivalences when writing non public-facing API. See for example <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_iso.dual_dual\">docs#order_iso.dual_dual</a>, which I literally just defined as <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_iso.refl\">docs#order_iso.refl</a> but without the <code>@[simps]</code> so that I get to write <a href=\"https://leanprover-community.github.io/mathlib_docs/find/order_iso.coe_dual_dual\">docs#order_iso.coe_dual_dual</a> and friends myself in the correct form.</p>",
        "id": 272880891,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645572123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272880302\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> Do you need this lemma?</p>\n</blockquote>\n<p>I don't need this lemma at all. I just didn't want to build half of an API. I'm also happy to add this change in, but I'm not quite sure what it looks like. Specifically, what sort of equivalence do we think it should be?</p>",
        "id": 272880941,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645572173
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">to_euclidean_space</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">Œπ</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.refl</span> <span class=\"n\">_</span>\n<span class=\"kd\">def</span> <span class=\"n\">of_euclidean_space</span> <span class=\"o\">:</span> <span class=\"n\">euclidean_space</span> <span class=\"bp\">ùïú</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"o\">(</span><span class=\"n\">Œπ</span> <span class=\"bp\">‚Üí</span> <span class=\"bp\">ùïú</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">equiv.refl</span> <span class=\"n\">_</span>\n</code></pre></div>\n<p>Note the absence of the <code>simps</code> attribute.</p>",
        "id": 272881184,
        "sender_full_name": "Ya√´l Dillies",
        "timestamp": 1645572361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272880941\">said</a>:</p>\n<blockquote>\n<p>I don't need this lemma at all. I just didn't want to build half of an API. </p>\n</blockquote>\n<p>I'd suggest adding the following equivalent lemma, which feels more \"native\" to Euclidean space.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">reindex_repr_apply</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal_basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">b.reindex</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span> <span class=\"n\">x</span> <span class=\"n\">i'</span> <span class=\"bp\">=</span> <span class=\"n\">b.repr</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div>",
        "id": 272881405,
        "sender_full_name": "Heather Macbeth",
        "timestamp": 1645572504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260507\">Heather Macbeth</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272881405\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"467358\">Daniel Packer</span> <a href=\"#narrow/stream/116395-maths/topic/orthonormal.20basis.20structure/near/272880941\">said</a>:</p>\n<blockquote>\n<p>I don't need this lemma at all. I just didn't want to build half of an API. </p>\n</blockquote>\n<p>I'd suggest adding the following equivalent lemma, which feels more \"native\" to Euclidean space.</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">protected</span> <span class=\"kd\">lemma</span> <span class=\"n\">reindex_repr_apply</span>\n  <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">orthonormal_basis</span> <span class=\"n\">Œπ</span> <span class=\"bp\">ùïú</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">Œπ</span> <span class=\"bp\">‚âÉ</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i'</span> <span class=\"o\">:</span> <span class=\"n\">Œπ'</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"o\">(</span><span class=\"n\">b.reindex</span> <span class=\"n\">e</span><span class=\"o\">)</span><span class=\"bp\">.</span><span class=\"n\">repr</span> <span class=\"n\">x</span> <span class=\"n\">i'</span> <span class=\"bp\">=</span> <span class=\"n\">b.repr</span> <span class=\"n\">x</span> <span class=\"o\">(</span><span class=\"n\">e.symm</span> <span class=\"n\">i'</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ah nice! In fact, that is the lemma that I did add after coming across the struggles with the other form. (Although I titled it <code>reindex_repr</code> to follow the convention of <a href=\"https://leanprover-community.github.io/mathlib_docs/find/basis.reindex_repr\">docs#basis.reindex_repr</a>).</p>",
        "id": 272881681,
        "sender_full_name": "Daniel Packer",
        "timestamp": 1645572715
    }
]
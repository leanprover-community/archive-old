[
    {
        "content": "<p>We could be clever and define an injective object in C to be a projective object in C^op. Is this a sensible thing to do or should we just make the API from first principles and avoid op hell?</p>",
        "id": 271107082,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644315891
    },
    {
        "content": "<p>It's part of <a href=\"https://github.com/leanprover-community/mathlib/pull/11878\">#11878</a> and I'm thinking it should be split off but I'm wondering whether people will object to the definition.</p>",
        "id": 271107633,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644316168
    },
    {
        "content": "<p>So a projective object in  <code>C</code> is an injective object in <code>Cᵒᵖ</code>? How can you state that if you try to spare yourself the definition from first principles?</p>",
        "id": 271107786,
        "sender_full_name": "Yaël Dillies",
        "timestamp": 1644316234
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">injective</span> <span class=\"o\">(</span><span class=\"n\">J</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n <span class=\"o\">(</span><span class=\"n\">factors</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">g</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">J</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">mono</span> <span class=\"n\">f</span><span class=\"o\">],</span> <span class=\"bp\">∃</span> <span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">Y</span> <span class=\"bp\">⟶</span> <span class=\"n\">J</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"bp\">≫</span> <span class=\"n\">h</span> <span class=\"bp\">=</span> <span class=\"n\">g</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 271107985,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1644316334
    },
    {
        "content": "<p>We duplicate the entire limit API into a colimit API. I would do the same here.</p>",
        "id": 271108591,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644316717
    },
    {
        "content": "<p>OK great; Jujian is working on it!</p>",
        "id": 271110371,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644317768
    },
    {
        "content": "<p>In the process of translating projectiveness to injectiveness, there is <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact.lift\">docs#category_theory.exact.lift</a>, which says<br>\nif <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>Q</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">Q\\rightarrow R\\rightarrow S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is exact and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span></span></span></span> is projective with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">P\\rightarrow R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> such that <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi><mo>→</mo><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">P\\rightarrow R\\rightarrow S=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">0</span></span></span></span>, then we can lift <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">P\\rightarrow R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">P\\rightarrow Q</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span></span></span></span>. So we need an analogous statement for injective objects. In the setting of abelian category, this is easily done, reverse arrow then use <code>exact.lift</code>, but that would require abelian category because we used <code>exact g.op f.op</code> from <code>exact f g</code>. To do this without abelian setting, we need the following fact (if this is true): if <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Q</mi><mo>→</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">f : Q\\rightarrow R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8778em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">Q</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mo>:</mo><mi>R</mi><mo>→</mo><mi>S</mi></mrow><annotation encoding=\"application/x-tex\">g:R\\rightarrow S</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span> is exact then <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">c</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi></mrow><mi>f</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">m</mi></mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{coker} f\\rightarrow\\mathrm{im} g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">coker</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8623em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">im</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> is mono (dual to <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"normal\">i</mi><mi mathvariant=\"normal\">m</mi></mrow><mi>f</mi><mo>→</mo><mrow><mi mathvariant=\"normal\">k</mi><mi mathvariant=\"normal\">e</mi><mi mathvariant=\"normal\">r</mi></mrow><mi>g</mi></mrow><annotation encoding=\"application/x-tex\">\\mathrm{im} f\\rightarrow\\mathrm{ker} g</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">im</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8889em;vertical-align:-0.1944em;\"></span><span class=\"mord\"><span class=\"mord mathrm\">ker</span></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span></span> being epi).<br>\nSo is this true in a general category where all relevant notion makes sense?</p>\n<p>The reason that I don't want to assume abelianness is that the corresponding <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.exact.lift\">docs#category_theory.exact.lift</a> is proved with far weaker assumption (only zero_morphisms,  equalizers and images). So how much theory of injective objects and injective resolutions do we want to develop before introducing abelianness assumption?</p>",
        "id": 271962641,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1644925971
    },
    {
        "content": "<p>If we're trying to talk about projectives and injectives without exactness conditions on the category--I'm kind of surprised that the definition of projective object does not involve <em>regular</em> epimorphisms.</p>",
        "id": 271968280,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644929169
    },
    {
        "content": "<p>I think we have a pretty assymetrical notion of exactness in mathlib, and maybe that's not a good idea.</p>",
        "id": 271968287,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1644929174
    },
    {
        "content": "<p>I guess I would be inclined to say that you shouldn't bother worrying about the non-abelian category case until you have some use for it</p>",
        "id": 271968505,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644929286
    },
    {
        "content": "<p>I see both wikipedia and nLab say a projective object is an object that lifts against all epimorphisms but I think it's the kind of definition that someone would make if they only think about cases where every epi is regular (e.g. in a topos or an abelian category).</p>",
        "id": 271969077,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644929599
    },
    {
        "content": "<p>I don't know if this helps with your question, but my point is that if you want to get correct definitions without any exactness assumptions on the category then maybe you have to start earlier.</p>",
        "id": 271969255,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644929695
    },
    {
        "content": "<p>Are there general <code>has_lifting_property x C</code> for an object <code>x</code> and a class of morphisms <code>C</code>?</p>",
        "id": 271969499,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1644929836
    },
    {
        "content": "<p>We do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.has_lifting_property\">docs#category_theory.has_lifting_property</a> but it's not used much AFAIK</p>",
        "id": 271971371,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644930756
    },
    {
        "content": "<p>I would agree that lifting against all mono- (resp. epi-)morphisms is mostly relevant to the abelian setup. If one wants to generalise the notion of a projective object, one should probably look into an exact category and then restrict having the lifting property to admissible mono- (resp. epi-) morphisms, aka inflations and deflations.</p>",
        "id": 271975724,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1644933009
    },
    {
        "content": "<p>I found out an almost comical solution, instead of assuming <code>exact f g</code>, we can work with assumption <code>exact g.op f.op</code>, so that the corresponding statement only requires <code>[has_zero_morphisms C] [has_images Cᵒᵖ] [has_equalizers Cᵒᵖ]</code></p>",
        "id": 271980404,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1644934960
    },
    {
        "content": "<p>Please don't change the definition of <code>projective</code>. We use it in LTE to talk about projective profinite spaces, and it works just fine as is. <code>Profinite</code> is not an exact category.</p>",
        "id": 271980869,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935114
    },
    {
        "content": "<p>I think every epimorphism in <code>Profinite</code> is regular though, right?</p>",
        "id": 271981051,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644935175
    },
    {
        "content": "<p>Is it?</p>",
        "id": 271981074,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/271980869\">said</a>:</p>\n<blockquote>\n<p>Please don't change the definition of <code>projective</code>. We use it in LTE to talk about projective profinite spaces, and it works just fine as is. <code>Profinite</code> is not an exact category.</p>\n</blockquote>\n<p>I won't change it.</p>",
        "id": 271981137,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1644935214
    },
    {
        "content": "<p>What does regular mean again?</p>",
        "id": 271981140,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935215
    },
    {
        "content": "<p>Coequalizer of some pair (which can be taken to be the kernel pair if the category has pullbacks)</p>",
        "id": 271981242,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644935258
    },
    {
        "content": "<p>Oh, yeah that's fine.</p>",
        "id": 271981328,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935284
    },
    {
        "content": "<p>I think it's usually less work to show that this agreess with what you want (surjections) than general epis</p>",
        "id": 271981546,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644935376
    },
    {
        "content": "<p>Do we have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.regular_epi\">docs#category_theory.regular_epi</a></p>",
        "id": 271981905,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935513
    },
    {
        "content": "<p>Hmm... is that the right definition for <code>regular_epi</code>? It includes the coequalizer as data.</p>",
        "id": 271982120,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1644935592
    },
    {
        "content": "<p>maybe a forgotten <code>: Prop</code>? I also don't understand why it is a class</p>",
        "id": 271982306,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644935664
    },
    {
        "content": "<p>(why is anything a class <span aria-label=\"angry\" class=\"emoji emoji-1f620\" role=\"img\" title=\"angry\">:angry:</span>)</p>",
        "id": 271982327,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644935674
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/projective+object\">nlab</a> seems to suggest that we should have different notions of <code>projective</code>, the one of lifting with respect to all epimorphisms, then also something called <code>regular_projective</code> which I have to admit I had not heard of before. In my area of research, the more frequently appearing notion is that of <code>projective with respect to some (Quillen) exact structure</code>, which is yet another version of a lifting property, see e.g. <a href=\"https://www.sciencedirect.com/science/article/pii/S0723086909000395\">Exact categories</a> by Bühler.</p>",
        "id": 271999175,
        "sender_full_name": "Julian Külshammer",
        "timestamp": 1644942440
    },
    {
        "content": "<p>Regular epimorphisms are the right notion in categories of models of an algebraic theory. For example in rings, the inclusion <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo>→</mo><mi mathvariant=\"double-struck\">Q</mi></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z} \\to \\mathbb{Q}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6889em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8556em;vertical-align:-0.1667em;\"></span><span class=\"mord mathbb\">Q</span></span></span></span> is an epimorphism (but not surjective of course) and so the polynomial ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"double-struck\">Z</mi><mo stretchy=\"false\">[</mo><mi>X</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">\\mathbb{Z}[X]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathbb\">Z</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mclose\">]</span></span></span></span> isn't projective. Regular epimorphisms agree with the surjective maps.</p>",
        "id": 272013768,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644948193
    },
    {
        "content": "<p>And one of the characteristic features of algebraic categories is that they have enough compact [regular] projective objects.</p>",
        "id": 272013825,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644948219
    },
    {
        "content": "<p>But indeed in other situations you might want to take the \"right\" notion of \"epimorphism\" as a parameter.</p>",
        "id": 272017826,
        "sender_full_name": "Reid Barton",
        "timestamp": 1644949920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> how about you make the basic definitions of projective objects with as few assumptions as possible but the moment it's convenient to do so, assume abelian. In contrast to what we were worried about yesterday it looks unlikely that people will be using the notion any time soon in the nonabelian setting (indeed it may not even be the right one), and the sooner we're in a position to start talking about it in the abelian setting the better.</p>",
        "id": 272081297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1644996429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/271971371\">said</a>:</p>\n<blockquote>\n<p>We do have <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.has_lifting_property\">docs#category_theory.has_lifting_property</a> but it's not used much AFAIK</p>\n</blockquote>\n<p>I have started attempting at formalising Quillen's model categories, and for that <code>has_lifting_property</code> shall be used and extended... (I guess that the first reachable example of <code>model_category</code> would be that of complexes (C^+) in an abelian category with enough injectives, or the dual version with enough projectives. )</p>",
        "id": 273537890,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646075061
    },
    {
        "content": "<p>That sounds great <span class=\"user-mention\" data-user-id=\"459699\">@Joël Riou</span> ! Actually <span class=\"user-mention\" data-user-id=\"306577\">@Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>",
        "id": 273538279,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646075238
    },
    {
        "content": "<p>And IIRC <span class=\"user-mention\" data-user-id=\"247154\">@Jakob Scholbach</span> 's original motivation for defining <code>has_lifting_property</code> was indeed as a start toward model categories!</p>",
        "id": 273538476,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646075325
    },
    {
        "content": "<p>The only good things in categories come from <code>has_lifting_property</code></p>",
        "id": 273538827,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646075518
    },
    {
        "content": "<p>The work on simplicial objects might make that equally accessible</p>",
        "id": 273538928,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646075563
    },
    {
        "content": "<p>I am working towards the \"fundamental lemma of homotopical algebra\", which is that is X is cofibrant and Y fibrant, then the morphisms in the localized category (obtained by formally inverting the weak equivalences) identifies to homotopy classes of maps defined by cylinder. I have already a draft of the construction of localized categories <code>C[W^-1]</code> (based on the great works that are already in mathlib, like <code>path_category</code> of a quiver and quotient categories).</p>",
        "id": 273539021,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646075626
    },
    {
        "content": "<p>Nice! I wonder, how did you formalize the definition of <code>(co)filbration</code> and <code>weak_equivalence</code>?</p>",
        "id": 273539154,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646075681
    },
    {
        "content": "<p>I believe that the model structure on simpliical sets will take more time! (I think we first need to have it for the category of topological spaces, with Serre fibrations. It would be nice if the on-going work on homotopies in topological helps there.)</p>",
        "id": 273539190,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646075701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273539154\">said</a>:</p>\n<blockquote>\n<p>Nice! I wonder, how did you formalize the definition of <code>(co)filbration</code> and <code>weak_equivalence</code>?</p>\n</blockquote>\n<p><code>abbreviation arrow_class := set (arrow C)</code></p>",
        "id": 273539276,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646075749
    },
    {
        "content": "<p>Happy to see people working on this! you might be interested in:<br>\n<a href=\"https://github.com/rwbarton/lean-homotopy-theory\">https://github.com/rwbarton/lean-homotopy-theory</a><br>\n<a href=\"https://github.com/rwbarton/lean-model-categories/tree/top-dev\">https://github.com/rwbarton/lean-model-categories/tree/top-dev</a> (old WIP, but has some stuff)</p>",
        "id": 273539497,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646075844
    },
    {
        "content": "<p>Aha I see. Did you find working with <code>arrow</code> to be easy enough? I would have guessed that </p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">arrow_class</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span>\n</code></pre></div>\n<p>might be easier to work with in practice.</p>",
        "id": 273539500,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646075847
    },
    {
        "content": "<p>It looks like this is what <span class=\"user-mention\" data-user-id=\"110032\">@Reid Barton</span> chose to do in his repo:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">class</span> <span class=\"n\">has_weak_equivalences</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_weq</span> <span class=\"o\">:</span> <span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"bp\">⟶</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 273539755,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646075964
    },
    {
        "content": "<p>That was my first idea, but it turned out to be easier to work with <code>arrow C</code>. One of the reasons is that <code>has_lifting_property</code> is defined using <code>arrow</code>.</p>",
        "id": 273540027,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646076106
    },
    {
        "content": "<p>Is there a reason for it to be? you can just use implicits for the objects and talk about lifting conditions between two morphisms without mentioning <code>arrow</code></p>",
        "id": 273540157,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646076164
    },
    {
        "content": "<p>Yes, of course, but perhaps it would be worthwhile to change the definition of <code>has_lifting_property</code>? (I don't remember exactly why <span class=\"user-mention\" data-user-id=\"247154\">@Jakob Scholbach</span> decided to use <code>arrow</code> there.)</p>",
        "id": 273540160,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646076165
    },
    {
        "content": "<p>In order to work with commutative squares (and lifting properties, etc), it is very convenient to use morphisms between objects in the category <code>arrow C</code>... Also, when stating some lemmas, we need only one variable for each arrow, not three!</p>",
        "id": 273541292,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646076636
    },
    {
        "content": "<p>Progress in this direction is excellent. I've spent my time looking for appropriate emoji to express my feelings. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 273541874,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646076895
    },
    {
        "content": "<p>I first want to apologize for leaving this topic. I simply didn't find the time do work on lean anymore.<br>\nI thought it is a good idea to formalize lifting properties using the arrow category since for example the usual arguments involving transfinite compositions take place as colimits in the arrow category, I think. But of course, if you see any reason to undo this choice, go ahead!<br>\nOn the original question: what is an injective object, I would like to briefly point out a remark / definition in \"Cesnavicius, Scholze.  Purity for flat cohomology\" that a compact object is an object x such that Hom(x, -) commutes with sifted colimits. Does it make sense to define a projective object to be an object such that Hom(x, -) preserves reflexive coequalizers?</p>",
        "id": 273541902,
        "sender_full_name": "Jakob Scholbach",
        "timestamp": 1646076909
    },
    {
        "content": "<p>Perhaps something like the following would be a good compromise</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">category_theory.arrow</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">category_theory</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">category</span> <span class=\"n\">C</span><span class=\"o\">]</span>\n\n<span class=\"kd\">abbreviation</span> <span class=\"n\">arrow_class</span> <span class=\"o\">:=</span> <span class=\"n\">set</span> <span class=\"o\">(</span><span class=\"n\">arrow</span> <span class=\"n\">C</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_fun</span> <span class=\"o\">(</span><span class=\"n\">arrow_class</span> <span class=\"n\">C</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"bp\">Π</span> <span class=\"o\">⦃</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"n\">C</span><span class=\"o\">⦄,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">⟶</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"kt\">Prop</span><span class=\"o\">))</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">a</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">arrow.mk</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"bp\">∈</span> <span class=\"n\">a</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">category_theory</span>\n</code></pre></div>",
        "id": 273542193,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646077039
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273538279\">said</a>:</p>\n<blockquote>\n<p>That sounds great <span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> ! Actually <span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>\n</blockquote>\n<p>After a little thought, I might temper this though. The derived functor will depend on the model structure and that seems hard to unify in a simple way. Relating Tor sheaves over a scheme and sheaf cohomology might be annoying as an example</p>",
        "id": 273542946,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646077354
    },
    {
        "content": "<p>But bounded above chain complexes with the projective model structure is definitely a good target given the work <span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>, <span class=\"user-mention\" data-user-id=\"439483\">@Andrew Yang</span>, and others have done for LTE.</p>",
        "id": 273543299,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646077511
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273542946\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273538279\">said</a>:</p>\n<blockquote>\n<p>That sounds great <span class=\"user-mention silent\" data-user-id=\"459699\">Joël Riou</span> ! Actually <span class=\"user-mention silent\" data-user-id=\"306577\">Matthew Ballard</span> and I were discussing just a few days ago that it would be nice to have the model category of complexes, and perhaps (re?)define derived functors using this approach.</p>\n</blockquote>\n<p>After a little thought, I might temper this though. The derived functor will depend on the model structure and that seems hard to unify in a simple way. Relating Tor sheaves over a scheme and sheaf cohomology might be annoying as an example</p>\n</blockquote>\n<p>Yes, this is true. To get a formalism independent of choices of (co)fibrations, one can use the notion of a category with weak equivalences (as in this book <a href=\"https://ncatlab.org/nlab/show/Homotopy+Limit+Functors+on+Model+Categories+and+Homotopical+Categories\">https://ncatlab.org/nlab/show/Homotopy+Limit+Functors+on+Model+Categories+and+Homotopical+Categories</a> ).</p>",
        "id": 273543505,
        "sender_full_name": "Jakob Scholbach",
        "timestamp": 1646077604
    },
    {
        "content": "<p>The model category structures on complexes always have quasi isos as the weak equivalences right?</p>",
        "id": 273543734,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646077719
    },
    {
        "content": "<p>Not the pure versions if I remember correctly</p>",
        "id": 273543766,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646077741
    },
    {
        "content": "<p>Actually, I think that in this context, model categories can be considered as a tool in order to study derived categories and construct derived functors. The homotopy category does not depend on the choice of cofibrations/fibrations, only on the class of weak equivalences. Similarly, the (total) left/right derived functors is defined by a universal property which depends only on the class of weak equivalences.</p>",
        "id": 273544484,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646078075
    },
    {
        "content": "<p>If we want to define derived functors as Kan extensions, then we should try to resolve this issue as well:<br>\n<a href=\"https://github.com/leanprover-community/mathlib/issues/7051\">https://github.com/leanprover-community/mathlib/issues/7051</a></p>",
        "id": 273544894,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646078255
    },
    {
        "content": "<p>True. But using adapted objects to \"compute\" derived functors in the linear setting seems more complicated here to me.</p>",
        "id": 273545852,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646078612
    },
    {
        "content": "<p>I think in this case having a characteristic predicate for a Kan extension would help if, for example, you want to \"compute\" a derived functor using projectives, i.e. you get some functor (defined in terms of projectives) which should satisfy the characteristic predicate, hence would be isomorphic to \"the\" derived functor defined in terms of a Kan extension.</p>",
        "id": 273546264,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646078805
    },
    {
        "content": "<p>Or maybe I am misunderstanding the issue?</p>",
        "id": 273546283,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646078815
    },
    {
        "content": "<p>I want to compute sheaf cohomology using a cover.</p>",
        "id": 273547360,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646079332
    },
    {
        "content": "<p>As an example</p>",
        "id": 273547395,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646079356
    },
    {
        "content": "<p>Okay, so in that case you can show that some functor you define in terms of (hyper)cover(s) of your scheme/space satisfies the characteristic predicate. I'm not saying it would be easy to show, but I don't think it's much more difficult than the proof showing that sheaf cohomology (defined in terms of injective resolutions of the sheaf) agrees with the object defined in terms of hypercovers.</p>",
        "id": 273547758,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1646079573
    },
    {
        "content": "<p>Same for sheaf Tor and a resolution by locally frees?</p>",
        "id": 273548434,
        "sender_full_name": "Matthew Ballard",
        "timestamp": 1646079933
    },
    {
        "content": "<p>The problem with <code>arrow</code> is that you cannot really compose <code>arrow</code>s. More generally, you are forced to either introduce variables in a restricted format (which will sometimes be impossible, as in the case of composition) or just go ahead and use <code>{X Y Z : C} (f : X -&gt; Y) (g : Y -&gt; Z)</code> anyways. The latter form will be required at least some of the time. If you always use the latter form, then there is obviously no advantage to \"<code>arrow</code> classes\" since it forces you to write <code>&lt;f&gt;</code> for no reason. If you mix them, then you have to decide when to talk about <code>arrow</code>s versus morphisms, and you're likely to have annoyances due to a lack of eta <code>f = &lt;f.hom&gt;</code>.</p>",
        "id": 273550143,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646080687
    },
    {
        "content": "<p>I can't imagine there is any advantage of <code>arrow</code> that outweighs this problem.</p>",
        "id": 273550260,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646080711
    },
    {
        "content": "<p>(Another subjective advantage is that it's nicer to talk about maps <code>B -&gt; X</code> than maps <code>f.cod -&gt; g.dom</code> or whatever.)</p>",
        "id": 273550661,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646080818
    },
    {
        "content": "<p>It's true that at some point you'll want to say things like \"weak equivalences are closed under filtered colimits in the arrow category\", but this isn't made harder by working with morphism classes: use a cocone in <code>arrow C</code>, and then formulate the hypotheses and conclusions in terms of <code>is_weq (F.obj i).hom</code> or whatever.</p>",
        "id": 273550862,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646080925
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/what.20is.20an.20injective.20object/near/273550260\">said</a>:</p>\n<blockquote>\n<p>I can't imagine there is any advantage of <code>arrow</code> that outweighs this problem.</p>\n</blockquote>\n<p>Actually, when working with model categories, it is important to be able to talk about retracts of arrows, and this is a very good <em>mathematical</em> reason to work with the category <code>arrow C</code>. Anyway, I do not think this is a serious discussion, and I will refrain from fueling it more here.</p>",
        "id": 273552827,
        "sender_full_name": "Joël Riou",
        "timestamp": 1646081953
    },
    {
        "content": "<p>I'm not exactly sure what you mean by a serious discussion.</p>",
        "id": 273553177,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646082029
    },
    {
        "content": "<p>It's true that retracts of arrows come up but it's not clear to me that this notion is necessarily more conveniently phrased in terms of <code>arrow</code>--in order to work with it you have to unwind this definition anyways.</p>",
        "id": 273553571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646082196
    },
    {
        "content": "<p>I spent a lot of time thinking specifically about formalizing model categories in Lean (as you can see from the linked repos) and my heartfelt opinion is that you will save yourself a lot of annoyance by avoiding <code>arrow</code> when talking about classes of morphisms. Of course you can just ignore me, if you like.</p>",
        "id": 273553825,
        "sender_full_name": "Reid Barton",
        "timestamp": 1646082305
    },
    {
        "content": "<p>I think that Reid probably has the most experience of everyone, when it comes to formalizing model categories (and homotopy theory outside of HoTT). I would take his opinion very serious.</p>",
        "id": 273609653,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1646125925
    }
]
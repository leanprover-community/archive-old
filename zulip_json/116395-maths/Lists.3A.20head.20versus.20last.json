[
    {
        "content": "<p>Why, conceptually, are <code>list.head</code> and <code>list.last</code> different?</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.last</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Reasonable - given a list of some type and proof the list isn't empty, give its last element.</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.head</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span>\n  <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>Given a list of some inhabited type, give either the first element of the list, or if the list is empty, default α. This means we have <code>list.last_mem</code>, but there isn't (and cannot be?) any <code>list.head_mem</code>. I don't really understand why these work in two different ways.</p>",
        "id": 219222252,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607442448
    },
    {
        "content": "<p>It is a bit of a headache as the head is quite natural to work with, more so than the last element, and I'm in a context where I'm dealing with non-empty lists.</p>",
        "id": 219222487,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607442560
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">list.head_mem</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">l</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">inhabited</span> <span class=\"n\">α</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">l.head</span> <span class=\"bp\">∈</span> <span class=\"n\">l</span> <span class=\"o\">:=</span>\n<span class=\"n\">list.mem_of_mem_head'</span> <span class=\"bp\">$</span> <span class=\"n\">list.head_mem_head'</span> <span class=\"n\">h</span>\n</code></pre></div>",
        "id": 219223266,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607442895
    },
    {
        "content": "<p>Although that doesn't answer the question of why they're defined differently</p>",
        "id": 219223376,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607442941
    },
    {
        "content": "<p>Indeed, not so hard to whip up my own custom lemma, but seemed a bit odd that they were defined like this to me!</p>",
        "id": 219223522,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607442994
    },
    {
        "content": "<p><code>list.tail</code>  has the following type:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">list.tail</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">:</span>\n  <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"n\">list</span> <span class=\"n\">α</span>\n</code></pre></div>\n<p>(With<code>list.nil</code> sent to <code>list.nil</code>.)</p>\n<p>With <code>list.init</code> defined in a similar way. So there's sort of a symmetry here which isn't present for the \"other\" operations.</p>",
        "id": 219224248,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443264
    },
    {
        "content": "<p>There's also <code>head'</code> which gives an <code>option α</code>, with <code>none</code> is the list is empty.</p>",
        "id": 219224552,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443375
    },
    {
        "content": "<p>Aye, indeed: and a corresponding last'. Which is reasonable!</p>",
        "id": 219224648,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443427
    },
    {
        "content": "<p>And perhaps the <code>list.nil</code> case would already be taken care of by something upstream.</p>",
        "id": 219224754,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443451
    },
    {
        "content": "<p><code>list.ilast</code> is the symmetric version of <code>list.head</code></p>",
        "id": 219224822,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607443478
    },
    {
        "content": "<p>So you'd have a <code>l ≠ list.nil</code> hypothesis, and an <code>l = a :: l'</code> hypothesis.</p>",
        "id": 219224830,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443483
    },
    {
        "content": "<p>So you wouldn't even need <code>head</code>, you'd just use <code>a</code>.</p>",
        "id": 219224858,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443498
    },
    {
        "content": "<p><code>list.cons_head_tail</code> and <code>list.init_append_last</code> both require the <code>l ≠ list.nil</code> hypothesis.</p>",
        "id": 219224870,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443502
    },
    {
        "content": "<p>Proofs about lists often use <code>induction</code> so that the empty and <code>hd :: tl</code> cases are dealt with separately.</p>",
        "id": 219225074,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443580
    },
    {
        "content": "<p>Mmm.</p>",
        "id": 219225145,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443617
    },
    {
        "content": "<p>Since I missed this - worth noting that there are two doc pages for these basic list definitions: <a href=\"https://leanprover-community.github.io/mathlib_docs/init/data/list/basic.html#list.last\">core</a> and <a href=\"https://leanprover-community.github.io/mathlib_docs/data/list/defs.html\">mathlib</a></p>",
        "id": 219225336,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607443690
    },
    {
        "content": "<p>So whatever API you're building with lists, you could phrase it instead as</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">lemma</span> <span class=\"n\">something_about_lists</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"bp\">*</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"n\">α</span> <span class=\"bp\">-&gt;</span> <span class=\"kt\">Prop</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">p</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">...</span>\n</code></pre></div>",
        "id": 219225470,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607443757
    },
    {
        "content": "<p>Aye, I've been consulting them. Essentially I am defining something (the chains stuff I was talking about previously) - I am trying to decide \"which way round\" to put my chain. At some point in a proof I am going to want to add an element to the start/end of the chain and I'm trying to decide what the best way to orientate things is.</p>",
        "id": 219225521,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443784
    },
    {
        "content": "<p>So my type in question looks like:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n<span class=\"o\">(</span> <span class=\"n\">primes</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">ideal.is_prime</span> <span class=\"n\">I</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">is_chain</span> <span class=\"o\">:</span> <span class=\"n\">list.chain'</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">carrier</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">not_nil</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span> <span class=\"o\">)</span>\n</code></pre></div>",
        "id": 219225625,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607443819
    },
    {
        "content": "<p>I'm getting the biggest element of some C of this type (in this formulation, the head of C.carrier), using C.primes to show that's prime, and then constructing a bigger element and adjoining it to C.carrier and creating a new <code>prime_ideal_chain</code>.</p>",
        "id": 219226302,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607444036
    },
    {
        "content": "<p>Obviously I could flip everything (then I'd be using <code>last</code> instead) - but I thought this would be nicer; as <code>head</code> isn't symmetrical to <code>last</code>, however, I got to wondering the thought that started the OP.</p>",
        "id": 219226465,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607444104
    },
    {
        "content": "<p>You might like <code>list.sorted</code></p>",
        "id": 219226504,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607444122
    },
    {
        "content": "<p>Oh that's nice.</p>",
        "id": 219226536,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607444144
    },
    {
        "content": "<p>sorted (&gt;) l or something.</p>",
        "id": 219226567,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607444159
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">def</span> <span class=\"n\">prime_ideal_chain.cons</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">bigger</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">bigger</span> <span class=\"o\">::</span> <span class=\"n\">pic.carrier</span><span class=\"o\">,</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">bigger.is_prime</span><span class=\"o\">,</span> <span class=\"n\">pic.primes</span><span class=\"o\">]</span> <span class=\"o\">},</span> <span class=\"c1\">--uses list.mem_cons_iff</span>\n<span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"k\">show</span> <span class=\"o\">(</span><span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">),</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic.carrier</span><span class=\"o\">),</span> <span class=\"n\">bigger</span> <span class=\"bp\">&gt;</span> <span class=\"n\">I</span><span class=\"o\">),</span> <span class=\"k\">from</span> <span class=\"n\">bigger.is_bigger</span><span class=\"o\">,</span> <span class=\"n\">pic.is_sorted</span><span class=\"o\">]</span> <span class=\"o\">}</span> <span class=\"c1\">--uses list.sorted_cons,</span>\n<span class=\"kd\">by</span> <span class=\"n\">simp</span>\n<span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219227490,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607444571
    },
    {
        "content": "<p>Very rough sketch</p>",
        "id": 219227503,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607444577
    },
    {
        "content": "<p>Why do you think <code>sorted</code> is better than <code>chain'</code>, incidentally?</p>",
        "id": 219228471,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445028
    },
    {
        "content": "<p>(I only have that my bigger element is definitely bigger than the previously-biggest element, y'see.)</p>",
        "id": 219228591,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445098
    },
    {
        "content": "<p>I can get quite far using <code>chain'</code> although I'm not sure how to deal with a hypothesis of the form <code>hy: y ∈ C.carrier.head'</code></p>",
        "id": 219228690,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445134
    },
    {
        "content": "<p>Is there a lemma to convert <code>chain' r</code> to <code>pairwise r</code> given the fact that <code>r</code> is transitive?</p>",
        "id": 219228717,
        "sender_full_name": "Eric Wieser",
        "timestamp": 1607445150
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.prod</span>\n<span class=\"kn\">import</span> <span class=\"n\">data.list.sort</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span> <span class=\"n\">carrier</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n<span class=\"o\">(</span> <span class=\"n\">primes</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">carrier</span> <span class=\"bp\">→</span> <span class=\"n\">ideal.is_prime</span> <span class=\"n\">I</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">is_chain</span> <span class=\"o\">:</span> <span class=\"n\">list.sorted</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">carrier</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span> <span class=\"n\">not_nil</span> <span class=\"o\">:</span> <span class=\"n\">carrier</span> <span class=\"bp\">≠</span> <span class=\"n\">list.nil</span> <span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prime_ideal_chain.mem</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic.carrier</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">prime_ideal_chain.mem</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prime_ideal_chain.mem_def</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic</span> <span class=\"bp\">↔</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic.carrier</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prime_ideal_chain.cons</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bigger</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hprime</span> <span class=\"o\">:</span> <span class=\"n\">bigger.is_prime</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbig</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic</span><span class=\"o\">,</span> <span class=\"n\">I</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bigger</span><span class=\"o\">):</span>\n  <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">bigger</span> <span class=\"o\">::</span> <span class=\"n\">pic.carrier</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hprime</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">forall_eq_or_imp</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">pic.primes</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">pic.is_chain</span><span class=\"o\">,</span> <span class=\"n\">list.sorted_cons</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hbig</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">ne.def</span><span class=\"o\">,</span> <span class=\"n\">not_false_iff</span><span class=\"o\">]⟩</span>\n</code></pre></div>",
        "id": 219228803,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607445193
    },
    {
        "content": "<p>Yes, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.chain'_iff_pairwise\">docs#list.chain'_iff_pairwise</a></p>",
        "id": 219228895,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607445233
    },
    {
        "content": "<p>What are you using <code>ring_theory.ideal.prod</code> for?</p>",
        "id": 219229002,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445269
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/list.sorted_of_sorted_cons\">docs#list.sorted_of_sorted_cons</a> might also work here.</p>",
        "id": 219229037,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607445291
    },
    {
        "content": "<p>Just wanted an import that worked</p>",
        "id": 219229057,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607445301
    },
    {
        "content": "<p>Fair.</p>",
        "id": 219229084,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445308
    },
    {
        "content": "<p>Maybe I want to pre-write a way to get the head of a chain along with the fact it's prime also.</p>",
        "id": 219229344,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607445428
    },
    {
        "content": "<p>Then perhaps your structure can store what the <code>head</code> is and use <code>list.chain</code> instead?</p>",
        "id": 219232403,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607446933
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.prod</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">rest</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">primes</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">::</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ideal.is_prime</span> <span class=\"n\">I</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_chain</span> <span class=\"o\">:</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">largest</span> <span class=\"n\">rest</span><span class=\"o\">)</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prime_ideal_chain.mem</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">)</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">prime_ideal_chain.mem</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">prime_ideal_chain.mem_def</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic</span> <span class=\"bp\">↔</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">prime_ideal_chain.cons</span> <span class=\"o\">{</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">bigger</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n  <span class=\"o\">(</span><span class=\"n\">hprime</span> <span class=\"o\">:</span> <span class=\"n\">bigger.is_prime</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbig</span> <span class=\"o\">:</span> <span class=\"n\">pic.largest</span> <span class=\"bp\">&lt;</span> <span class=\"n\">bigger</span><span class=\"o\">):</span>\n  <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">bigger</span><span class=\"o\">,</span>\n  <span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hprime</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">forall_eq_or_imp</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">pic.primes</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">pic.is_chain</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">list.chain_cons</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hbig</span><span class=\"o\">⟩</span>\n</code></pre></div>",
        "id": 219232997,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607447202
    },
    {
        "content": "<p>mhm. That does work, though I suppose in a sense it would be nice if rest was itself a prime_ideal_chain (because of course it is).</p>",
        "id": 219233143,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607447277
    },
    {
        "content": "<p>But I like the way you did it.</p>",
        "id": 219233189,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607447285
    },
    {
        "content": "<p>Well under this definition, that wouldn't be possible because <code>[]</code> is not a valid chain.</p>",
        "id": 219233629,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607447486
    },
    {
        "content": "<p>RIght.</p>",
        "id": 219233650,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607447494
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">ring_theory.ideal.prod</span>\n\n<span class=\"kn\">section</span> <span class=\"n\">prime_ideal_chain</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">[</span><span class=\"n\">comm_ring</span> <span class=\"n\">R</span><span class=\"o\">]</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">rest</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">))</span>\n<span class=\"o\">(</span><span class=\"n\">primes</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">largest</span> <span class=\"o\">::</span> <span class=\"n\">rest</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">ideal.is_prime</span> <span class=\"n\">I</span> <span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">is_chain</span> <span class=\"o\">:</span> <span class=\"n\">list.chain</span> <span class=\"o\">(</span><span class=\"bp\">&gt;</span><span class=\"o\">)</span> <span class=\"n\">largest</span> <span class=\"n\">rest</span><span class=\"o\">)</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">prime_ideal_chain</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">prime_ideal_chain</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">R</span><span class=\"o\">}</span>\n<span class=\"kd\">variables</span> <span class=\"o\">(</span><span class=\"n\">I</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">pic</span> <span class=\"o\">:</span> <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kn\">protected</span> <span class=\"kd\">def</span> <span class=\"n\">mem</span> <span class=\"o\">:</span> <span class=\"kt\">Prop</span> <span class=\"o\">:=</span>\n<span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">)</span>\n\n<span class=\"kd\">variable</span> <span class=\"o\">{</span><span class=\"n\">I</span><span class=\"o\">}</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">:</span> <span class=\"n\">has_mem</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"o\">⟨</span><span class=\"n\">mem</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">mem_def</span> <span class=\"o\">:</span>\n  <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic</span> <span class=\"bp\">↔</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"o\">(</span><span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">iff.rfl</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">cons</span> <span class=\"o\">(</span><span class=\"n\">hprime</span> <span class=\"o\">:</span> <span class=\"n\">I.is_prime</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">hbig</span> <span class=\"o\">:</span> <span class=\"n\">pic.largest</span> <span class=\"bp\">&lt;</span> <span class=\"n\">I</span><span class=\"o\">):</span>\n  <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">I</span><span class=\"o\">,</span> <span class=\"n\">pic.largest</span> <span class=\"o\">::</span> <span class=\"n\">pic.rest</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">hprime</span><span class=\"o\">,</span> <span class=\"n\">true_and</span><span class=\"o\">,</span> <span class=\"n\">forall_eq_or_imp</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">pic.primes</span><span class=\"o\">,</span>\n  <span class=\"kd\">by</span> <span class=\"n\">simpa</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">pic.is_chain</span><span class=\"o\">,</span> <span class=\"n\">and_true</span><span class=\"o\">,</span> <span class=\"n\">list.chain_cons</span><span class=\"o\">]</span> <span class=\"n\">using</span> <span class=\"n\">hbig</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_prime_largest</span> <span class=\"o\">:</span> <span class=\"n\">pic.largest.is_prime</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pic.primes</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">true_or</span><span class=\"o\">,</span> <span class=\"n\">eq_self_iff_true</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">lemma</span> <span class=\"n\">is_prime_of_rest</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">I</span> <span class=\"bp\">∈</span> <span class=\"n\">pic.rest</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">I.is_prime</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">apply</span> <span class=\"n\">pic.primes</span><span class=\"o\">,</span>\n  <span class=\"n\">simp</span> <span class=\"n\">only</span> <span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">list.mem_cons_iff</span><span class=\"o\">,</span> <span class=\"n\">or_true</span><span class=\"o\">]</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">def</span> <span class=\"n\">of_rest</span> <span class=\"o\">{</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">}</span> <span class=\"o\">{</span><span class=\"n\">xs</span> <span class=\"o\">:</span> <span class=\"n\">list</span> <span class=\"o\">(</span><span class=\"n\">ideal</span> <span class=\"n\">R</span><span class=\"o\">)}</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">:</span> <span class=\"n\">pic.rest</span> <span class=\"bp\">=</span> <span class=\"n\">x</span> <span class=\"o\">::</span> <span class=\"n\">xs</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n  <span class=\"n\">prime_ideal_chain</span> <span class=\"n\">R</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">xs</span><span class=\"o\">,</span>\n  <span class=\"bp\">λ</span> <span class=\"n\">I</span> <span class=\"n\">hI</span><span class=\"o\">,</span> <span class=\"n\">pic.is_prime_of_rest</span> <span class=\"o\">(</span><span class=\"n\">h.symm</span> <span class=\"bp\">▸</span> <span class=\"n\">hI</span><span class=\"o\">),</span>\n  <span class=\"kd\">by</span> <span class=\"o\">{</span> <span class=\"n\">apply</span> <span class=\"n\">list.chain_of_chain_cons</span><span class=\"o\">,</span> <span class=\"n\">convert</span> <span class=\"n\">pic.is_chain</span><span class=\"o\">,</span> <span class=\"n\">exact</span> <span class=\"n\">h.symm</span> <span class=\"o\">}⟩</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">prime_ideal_chain</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">prime_ideal_chain</span>\n</code></pre></div>",
        "id": 219235869,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607448447
    },
    {
        "content": "<p>Thank you.</p>",
        "id": 219236093,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607448537
    },
    {
        "content": "<p>Think it is a little easier to have <code>(primes : largest.is_prime ∧ ∀ I ∈ rest, ideal.is_prime I )</code>.</p>",
        "id": 219236157,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607448569
    },
    {
        "content": "<p>However you write it (and your way is definitely easier to deconstruct), you might still have an API lemma like <code>is_prime_largest</code>, the proof of which will be just <code>_.1</code> in your case.</p>",
        "id": 219236353,
        "sender_full_name": "Yakov Pechersky",
        "timestamp": 1607448658
    },
    {
        "content": "<p>Aye.</p>",
        "id": 219236517,
        "sender_full_name": "Wrenna Robson",
        "timestamp": 1607448725
    }
]
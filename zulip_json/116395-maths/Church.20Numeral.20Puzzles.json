[
    {
        "content": "<p>I am trying to understand church numerals by writing a collection of basic theorems about them.</p>",
        "id": 126010843,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525290945
    },
    {
        "content": "<p>I just solved this one:</p>",
        "id": 126010845,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525290950
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">chnat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">ℕ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_nat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- f (f^n x)</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">of_nat&#39;</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"bp\">+</span> <span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">of_nat&#39;</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- f^n (f x)</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">of_nat_is_of_nat&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">of_nat&#39;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">chnat</span>\n</pre></div>",
        "id": 126010886,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525290975
    },
    {
        "content": "<p>it was harder than I expected though, so I probably missed a trick, which is why I mention it here.</p>",
        "id": 126010904,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525291032
    },
    {
        "content": "<p>Hmm, this was a pretty straightforward induction:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">of_nat_is_of_nat&#39;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"bp\">=</span> <span class=\"n\">of_nat&#39;</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span><span class=\"bp\">;</span> <span class=\"n\">funext</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"n\">clear</span> <span class=\"n\">n_ih</span><span class=\"o\">,</span> <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">generalizing</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"bp\">*</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 126011292,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1525291582
    },
    {
        "content": "<p>This is the key lemma I've been after:</p>",
        "id": 126012437,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293232
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">of_nat_functorial</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n<span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">x&#39;</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x&#39;</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"n\">x</span> <span class=\"o\">:=</span>\n</pre></div>",
        "id": 126012439,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293238
    },
    {
        "content": "<p>I have never used <code>generalizing</code> or <code>simp!</code> before.</p>",
        "id": 126012493,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293300
    },
    {
        "content": "<p>So thanks very much for these!</p>",
        "id": 126012503,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293307
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span></p>",
        "id": 126012504,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293314
    },
    {
        "content": "<p>I also have this:</p>",
        "id": 126012553,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293371
    },
    {
        "content": "<p><code>example (m n : ℕ) : of_nat (m + n) = of_nat m + of_nat n := sorry</code></p>",
        "id": 126012554,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525293376
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">of_nat_functorial</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">X</span><span class=\"o\">),</span>\n<span class=\"n\">a</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">@</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">Y</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span> <span class=\"n\">x&#39;</span><span class=\"o\">,</span> <span class=\"n\">g</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x&#39;</span><span class=\"o\">))</span> <span class=\"n\">a</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"mi\">0</span> <span class=\"o\">:=</span> <span class=\"k\">by</span> <span class=\"n\">intros</span><span class=\"bp\">;</span> <span class=\"n\">refl</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">n</span><span class=\"bp\">+</span><span class=\"mi\">1</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"k\">begin</span>\n  <span class=\"k\">assume</span> <span class=\"n\">X</span> <span class=\"n\">Y</span> <span class=\"n\">a</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"o\">[</span><span class=\"n\">of_nat</span><span class=\"o\">],</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n  <span class=\"n\">rw</span> <span class=\"err\">←</span> <span class=\"n\">of_nat_functorial</span><span class=\"o\">,</span>\n  <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n   <span class=\"n\">apply</span> <span class=\"n\">congr_arg</span><span class=\"o\">,</span>\n   <span class=\"n\">clear</span> <span class=\"n\">of_nat_functorial</span><span class=\"o\">,</span>\n   <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">ih</span> <span class=\"n\">generalizing</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n   <span class=\"n\">refl</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">of_nat</span><span class=\"o\">,</span>\n   <span class=\"n\">dsimp</span><span class=\"o\">,</span>\n   <span class=\"n\">rw</span> <span class=\"n\">ih</span><span class=\"o\">,</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 126012995,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1525294054
    },
    {
        "content": "<p>Not the cleanest, but done.</p>",
        "id": 126013010,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1525294074
    },
    {
        "content": "<p>These lemmas are all induction+simp, if you set them up correctly:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">instance</span><span class=\"o\">:</span> <span class=\"n\">has_add</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">⟨λ</span> <span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">b</span> <span class=\"bp\">_</span> <span class=\"n\">f</span><span class=\"bp\">⟩</span>\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">chℕ_add</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">a</span> <span class=\"bp\">+</span> <span class=\"n\">b</span> <span class=\"bp\">=</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"bp\">_</span> <span class=\"n\">f</span> <span class=\"err\">∘</span> <span class=\"n\">b</span> <span class=\"bp\">_</span> <span class=\"n\">f</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">rfl</span>\n\n<span class=\"bp\">@</span><span class=\"o\">[</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"kn\">lemma</span> <span class=\"n\">of_nat_f</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"n\">generalizing</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span><span class=\"bp\">!</span> <span class=\"bp\">*</span>\n\n<span class=\"n\">local</span> <span class=\"n\">attribute</span> <span class=\"o\">[</span><span class=\"bp\">-</span><span class=\"n\">simp</span><span class=\"o\">]</span> <span class=\"n\">add_comm</span>\n<span class=\"kn\">lemma</span> <span class=\"n\">of_nat_add</span>  <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of_nat</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">induction</span> <span class=\"n\">n</span> <span class=\"k\">with</span> <span class=\"n\">n</span> <span class=\"n\">generalizing</span> <span class=\"n\">m</span><span class=\"bp\">;</span> <span class=\"n\">funext</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"bp\">;</span> <span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">of_nat</span><span class=\"o\">,</span> <span class=\"bp\">*</span><span class=\"o\">]</span>\n</pre></div>",
        "id": 126013555,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1525294702
    },
    {
        "content": "<p>Unfortunately you can't orient <code>of_nat_f</code> the other way around because it won't work as a simp lemma then.</p>",
        "id": 126013667,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1525294831
    },
    {
        "content": "<p>Thanks so much Gabriel!</p>",
        "id": 126015189,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525296881
    },
    {
        "content": "<p>These proofs are really cool :-)</p>",
        "id": 126016767,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525299130
    },
    {
        "content": "<p>I understand better the way you think about the question now. I want to prove all the intermediate lemmas first, because historically I have been trained to go forwards. You just keep reducing the problem to simpler statements by induction because dependent type theory is somehow better at pushing backwards.</p>",
        "id": 126016801,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525299216
    },
    {
        "content": "<p>The one with <code>clear n_ih</code> is interesting!</p>",
        "id": 126016926,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525299369
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">pow</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">of_nat_pow</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">of_nat</span> <span class=\"n\">m</span> <span class=\"bp\">+</span> <span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n</pre></div>",
        "id": 126017263,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525299997
    },
    {
        "content": "<p>I think the proof is <code>of_nat_add _ _</code> :)</p>",
        "id": 126017321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525300088
    },
    {
        "content": "<p>wait a second</p>",
        "id": 126017327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300127
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">chnat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"kn\">definition</span> <span class=\"n\">to_nat</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"bp\">ℕ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_nat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- f (f^n x)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pow</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span>\n<span class=\"bp\">λ</span> <span class=\"n\">m</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"bp\">λ</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">,</span>\n  <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"bp\">λ</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">X</span> <span class=\"n\">g</span><span class=\"o\">))</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n<span class=\"kn\">theorem</span> <span class=\"n\">of_nat_pow</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n\n\n<span class=\"kn\">end</span> <span class=\"n\">chnat</span>\n</pre></div>",
        "id": 126017334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300143
    },
    {
        "content": "<p>I think that runs and asks the question I want to ask :-)</p>",
        "id": 126017344,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300154
    },
    {
        "content": "<p>I thought I already proved it</p>",
        "id": 126017350,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300165
    },
    {
        "content": "<p>Can you golf it though?</p>",
        "id": 126017353,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300178
    },
    {
        "content": "<p>...</p>",
        "id": 126017355,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300184
    },
    {
        "content": "<p>Did you see Gabriel's proofs?</p>",
        "id": 126017360,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300198
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">def</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span> <span class=\"bp\">Π</span> <span class=\"n\">X</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"bp\">→</span> <span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">chnat</span>\n\n<span class=\"kn\">open</span> <span class=\"n\">nat</span>\n\n<span class=\"n\">def</span> <span class=\"n\">to_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">m</span> <span class=\"bp\">ℕ</span> <span class=\"n\">nat</span><span class=\"bp\">.</span><span class=\"n\">succ</span> <span class=\"mi\">0</span>\n\n<span class=\"n\">def</span> <span class=\"n\">of_nat</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"n\">chℕ</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">zero</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">x</span>\n<span class=\"bp\">|</span> <span class=\"o\">(</span><span class=\"n\">succ</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">f</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"c1\">-- f (f^n x)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span>\n<span class=\"bp\">|</span> <span class=\"n\">X</span> <span class=\"n\">f</span> <span class=\"n\">x</span> <span class=\"o\">:=</span> <span class=\"n\">n</span> <span class=\"o\">(</span><span class=\"n\">X</span> <span class=\"bp\">→</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">X</span><span class=\"o\">)</span> <span class=\"n\">f</span> <span class=\"n\">x</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">of_nat_pow</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"err\">^</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">pow</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"n\">sorry</span>\n\n<span class=\"kn\">end</span> <span class=\"n\">chnat</span>\n</pre></div>\n\n\n<p>golfed</p>",
        "id": 126017446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525300313
    },
    {
        "content": "<p>...</p>",
        "id": 126017509,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300348
    },
    {
        "content": "<p>Mario I guess that in reality I am more interested in the style. Is yours both preferable and golfier? Ultimately I want to write good style Lean.</p>",
        "id": 126017581,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300504
    },
    {
        "content": "<p>I wouldn't prefer it</p>",
        "id": 126017660,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300650
    },
    {
        "content": "<p>ooh the <code>lam g</code> on my part was a rookie error</p>",
        "id": 126017666,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525300656
    },
    {
        "content": "<p>you see, it uses the equation compiler</p>",
        "id": 126017667,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300657
    },
    {
        "content": "<p>and uses \"external\" definitional equality</p>",
        "id": 126017674,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300679
    },
    {
        "content": "<p>like it isn't \"expressionally equal\" but somehow they made it definitionally equal (by all those ._equation_1) thing</p>",
        "id": 126017718,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300702
    },
    {
        "content": "<p>do <code>#print prefix chnat.pow</code> to see what I mean</p>",
        "id": 126017719,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300712
    },
    {
        "content": "<p>huh? There is no fancy business in any of the definitions except <code>of_nat</code>, but that was already defined by eqn compiler</p>",
        "id": 126017740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525300791
    },
    {
        "content": "<p>hmm...</p>",
        "id": 126017781,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300804
    },
    {
        "content": "<p>they don't do <code>._main</code> if you don't have two cases?</p>",
        "id": 126017791,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525300816
    },
    {
        "content": "<p>the eqn compiler always produces <code>._main</code> I guess</p>",
        "id": 126017800,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525300839
    },
    {
        "content": "<p>for uniformity I assume</p>",
        "id": 126017804,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525300845
    },
    {
        "content": "<p>I don't like main</p>",
        "id": 126017880,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301023
    },
    {
        "content": "<p>as a sidenote now I prefer <code>trans_rel_left</code> over <code>calc</code> lol</p>",
        "id": 126017922,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301047
    },
    {
        "content": "<p>because _ with the tactics</p>",
        "id": 126017924,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301062
    },
    {
        "content": "<p>Oh you're right Kenny. So Mario does this  mean that the lambda style is preferred in practice?</p>",
        "id": 126017938,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301135
    },
    {
        "content": "<p>I think Mario prefers the equation compiler because it looks nicer</p>",
        "id": 126017985,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301204
    },
    {
        "content": "<p>I always locally optimize <code>def T : A -&gt; B := \\lam x, t</code> =&gt;  <code>def T (x : A) : B := t</code></p>",
        "id": 126017988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301211
    },
    {
        "content": "<p>and <code>def T : B := \\lam x, t</code> =&gt; <code>def T : B | x := t</code></p>",
        "id": 126017995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301239
    },
    {
        "content": "<p>what next, <code>\\la x, A $ B x</code> =&gt; <code>A \\o B</code>?</p>",
        "id": 126018003,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301275
    },
    {
        "content": "<p>does your optimization have church rosser?</p>",
        "id": 126018043,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301297
    },
    {
        "content": "<p>that one depends on whether the \\o gets in the way later</p>",
        "id": 126018044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301303
    },
    {
        "content": "<p>but usually yes</p>",
        "id": 126018045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301314
    },
    {
        "content": "<p>even if <code>x</code> is a proposition?</p>",
        "id": 126018048,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301333
    },
    {
        "content": "<p>sure, why not?</p>",
        "id": 126018054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301340
    },
    {
        "content": "<p>wow</p>",
        "id": 126018057,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301344
    },
    {
        "content": "<p>It's the <code>|</code> that causes the trouble</p>",
        "id": 126018064,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301357
    },
    {
        "content": "<p>it often doesn't work as a straight replacement since it could be dependent</p>",
        "id": 126018065,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301364
    },
    {
        "content": "<p>suddenly I have <code>pow._main</code></p>",
        "id": 126018066,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301366
    },
    {
        "content": "<p>yay we're on the same side for this time</p>",
        "id": 126018073,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301375
    },
    {
        "content": "<p>Yes, the <code>|</code> triggers the equation compiler</p>",
        "id": 126018075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301380
    },
    {
        "content": "<p>It also gives you the correct (applied) equation lemma</p>",
        "id": 126018124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301405
    },
    {
        "content": "<p>rather than the lambda equation lemma</p>",
        "id": 126018133,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301414
    },
    {
        "content": "<p>I don't like that</p>",
        "id": 126018134,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301416
    },
    {
        "content": "<p>But Kenny is that just because you haven't learned how to use the more complex type properly?</p>",
        "id": 126018164,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301479
    },
    {
        "content": "<p>What is an example of where this causes you problems?</p>",
        "id": 126018169,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301492
    },
    {
        "content": "<p>heh... I use the equation compiler all the time</p>",
        "id": 126018171,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301500
    },
    {
        "content": "<p>I just don't like it</p>",
        "id": 126018172,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301505
    },
    {
        "content": "<p>and I am asking why exactly</p>",
        "id": 126018175,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301514
    },
    {
        "content": "<p>i don't know</p>",
        "id": 126018218,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301528
    },
    {
        "content": "<p>I understand wanting a simple underlying term, but that's an issue best aimed at the equation compiler</p>",
        "id": 126018232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301573
    },
    {
        "content": "<p>I am just learning all these tricks now. I have learned that when you write a substantial amount of code you end up picking stuff up as you need it; Kenny you wrote a lot of code a lot quicker than me.</p>",
        "id": 126018242,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301589
    },
    {
        "content": "<p>Mario, did you do my Ackermann church question? ;-)</p>",
        "id": 126018247,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301616
    },
    {
        "content": "<p>I'm convinced you can't do it</p>",
        "id": 126018250,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301627
    },
    {
        "content": "<p>you need a higher order functional</p>",
        "id": 126018252,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301631
    },
    {
        "content": "<p>since chNat lives in Type 1</p>",
        "id": 126018256,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301641
    },
    {
        "content": "<p>you need an empowered chNat that lives in Type 2</p>",
        "id": 126018295,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301649
    },
    {
        "content": "<p>Ackermann isn't primitive recursive</p>",
        "id": 126018296,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301653
    },
    {
        "content": "<p>its image is in Delta_1 not Delta_0</p>",
        "id": 126018297,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301661
    },
    {
        "content": "<p>in the arithmetic hierarchy</p>",
        "id": 126018299,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301666
    },
    {
        "content": "<p><code>def ack : chℕ → chℕ → chℕ := sorry -- KB didn't try this one</code></p>",
        "id": 126018300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301668
    },
    {
        "content": "<p>whatever that means</p>",
        "id": 126018302,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301668
    },
    {
        "content": "<p>(for good reason!)</p>",
        "id": 126018303,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301674
    },
    {
        "content": "<p>what ackermann church question</p>",
        "id": 126018306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301686
    },
    {
        "content": "<p>fill in the def above</p>",
        "id": 126018308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> make ackermann using church</p>",
        "id": 126018309,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301694
    },
    {
        "content": "<p>so that it commutes with usual ack on nat</p>",
        "id": 126018311,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301700
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> or do you already know that one can't do it</p>",
        "id": 126018324,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301720
    },
    {
        "content": "<p>I don't have a clue</p>",
        "id": 126018327,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301726
    },
    {
        "content": "<p>You can do it</p>",
        "id": 126018329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301729
    },
    {
        "content": "<p>I just think this is really cool :-)</p>",
        "id": 126018330,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301733
    },
    {
        "content": "<p>How do you know you can do it?</p>",
        "id": 126018334,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I tried to do it and found myself requiring a more complex term in each iteration</p>",
        "id": 126018375,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301766
    },
    {
        "content": "<p>you can't iterate on (chN -&gt; chN) either</p>",
        "id": 126018379,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301777
    },
    {
        "content": "<p>When a computer scientist says \"you can do it\" do they mean \"there exists some computer code which does that job\" or \"it's possible to construct, in polynomial time, some computer code which does that job\"</p>",
        "id": 126018387,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301826
    },
    {
        "content": "<p>the former</p>",
        "id": 126018390,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301840
    },
    {
        "content": "<p>I mean there is a solution in less than 50 chars</p>",
        "id": 126018391,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301843
    },
    {
        "content": "<p>:-)</p>",
        "id": 126018393,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301850
    },
    {
        "content": "<p>??????</p>",
        "id": 126018394,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301852
    },
    {
        "content": "<p>50 chars....</p>",
        "id": 126018395,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301860
    },
    {
        "content": "<p>so just go through all the lambda terms, you'll get it</p>",
        "id": 126018396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301867
    },
    {
        "content": "<p>that's not polynomial time though</p>",
        "id": 126018398,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301877
    },
    {
        "content": "<p>heck no</p>",
        "id": 126018438,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301886
    },
    {
        "content": "<p>Just to be clear, we're talking about the church numeral type without the axiom.</p>",
        "id": 126018448,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301934
    },
    {
        "content": "<p><code>def chℕ := Π X : Type, (X → X) → X → X</code></p>",
        "id": 126018459,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525301957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> so what is wrong with my analysis?</p>",
        "id": 126018461,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525301967
    },
    {
        "content": "<p>Ah, I see what you mean now</p>",
        "id": 126018467,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525301999
    },
    {
        "content": "<p>In lambda calculus it's untyped so there is no problems</p>",
        "id": 126018518,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302012
    },
    {
        "content": "<p>exactly</p>",
        "id": 126018519,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302020
    },
    {
        "content": "<p>but lean has universe issues</p>",
        "id": 126018522,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302024
    },
    {
        "content": "<p>we're in typed lamdba calculus</p>",
        "id": 126018523,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302025
    },
    {
        "content": "<p>as opposed to his rather more well-behaved friend <code>chℕfree := {m : Π X : Type, (X → X) → X → X // ∀ (X Y : Type) (a : X → Y) (f : X → X) (x : X),\n  m (X → Y) (λ g, g ∘ f) a x = a (m X f x)}</code></p>",
        "id": 126018525,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302028
    },
    {
        "content": "<p>which comes with a free theorem</p>",
        "id": 126018526,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302033
    },
    {
        "content": "<p>you can still do it but you need inductive types, I think</p>",
        "id": 126018530,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302041
    },
    {
        "content": "<p>oh wait I can do it by cheating!</p>",
        "id": 126018540,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302072
    },
    {
        "content": "<p>There's a projection from church nat to nat</p>",
        "id": 126018549,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302100
    },
    {
        "content": "<p>exactly</p>",
        "id": 126018550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302104
    },
    {
        "content": "<p>so you do an induction on <code>nat -&gt; nat</code></p>",
        "id": 126018551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302114
    },
    {
        "content": "<p>that's cheating</p>",
        "id": 126018553,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302121
    },
    {
        "content": "<p>so I can define an \"incorrect\" pow</p>",
        "id": 126018567,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302123
    },
    {
        "content": "<p>But this is cheating</p>",
        "id": 126018594,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302133
    },
    {
        "content": "<p>Is this what they do with pred?</p>",
        "id": 126018596,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302142
    },
    {
        "content": "<p>like I said, you need inductive types</p>",
        "id": 126018597,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302145
    },
    {
        "content": "<p>that's like asking can I define pow by of_nat and to_nat</p>",
        "id": 126018598,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302146
    },
    {
        "content": "<p>If you were to project to nat and then project back with any of add, mul or pow</p>",
        "id": 126018600,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302164
    },
    {
        "content": "<p>I think you are right that chN only allows primrec definitions directly</p>",
        "id": 126018602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302168
    },
    {
        "content": "<p>you would get a different answer to the \"pure\" answers which exist</p>",
        "id": 126018605,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302178
    },
    {
        "content": "<blockquote>\n<p>I mean there is a solution in less than 50 chars</p>\n</blockquote>\n<p>this wouldn't work. how are you going to check if a given lambda term produces ack?</p>",
        "id": 126018627,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302223
    },
    {
        "content": "<p>solve the halting problem of course</p>",
        "id": 126018668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302244
    },
    {
        "content": "<p>in the proof I'm envisaging</p>",
        "id": 126018669,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302245
    },
    {
        "content": "<p>you...</p>",
        "id": 126018675,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302252
    },
    {
        "content": "<p>:-)</p>",
        "id": 126018677,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302254
    },
    {
        "content": "<p>it's going to follow from some cunning unravelling isn't it?</p>",
        "id": 126018684,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525302280
    },
    {
        "content": "<p>wait, no I lied again, it is possible</p>",
        "id": 126018841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302574
    },
    {
        "content": "<p>hmm</p>",
        "id": 126018844,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302580
    },
    {
        "content": "<p>the motive is <code>X → X</code></p>",
        "id": 126018846,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525302591
    },
    {
        "content": "<p>you need to store a function each time</p>",
        "id": 126018890,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1525302605
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kn\">theorem</span> <span class=\"n\">nat_of_chnat_of_nat</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">to_nat</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">n</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span> <span class=\"c1\">-- exercise</span>\n\n<span class=\"c1\">-- breakthough! I implemented my exciting new foo function on church numerals</span>\n<span class=\"n\">def</span> <span class=\"n\">foo</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"bp\">→</span> <span class=\"bp\">ℕ</span> <span class=\"o\">:=</span> <span class=\"n\">sorry</span>\n<span class=\"n\">def</span> <span class=\"n\">choo</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">chℕ</span> <span class=\"o\">:=</span> <span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"o\">(</span><span class=\"n\">to_nat</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">to_nat</span> <span class=\"n\">n</span><span class=\"o\">))</span>\n\n<span class=\"kn\">theorem</span> <span class=\"n\">amazing_compatibility</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"bp\">ℕ</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n<span class=\"n\">of_nat</span> <span class=\"o\">(</span><span class=\"n\">foo</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"n\">choo</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">of_nat</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"k\">begin</span>\n<span class=\"n\">unfold</span> <span class=\"n\">choo</span><span class=\"o\">,</span>\n<span class=\"n\">simp</span> <span class=\"o\">[</span><span class=\"n\">nat_of_chnat_of_nat</span><span class=\"o\">]</span>\n<span class=\"kn\">end</span>\n</pre></div>",
        "id": 126019177,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303097
    },
    {
        "content": "<p>That makes me slightly sad</p>",
        "id": 126019267,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303232
    },
    {
        "content": "<p>I spent some time today thinking about the Church Numeral which given X and f and x, returns x unless X = nat and f = succ and x = 0, in which case it returns 1</p>",
        "id": 126019292,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303308
    },
    {
        "content": "<p>it's quite a good way of reminding yourself exactly how far you can expect to push things</p>",
        "id": 126019341,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303334
    },
    {
        "content": "<p>e.g. I believe that funny numeral doesn't commute with + 1 and this can be easily checked via  very concrete calculation on nat</p>",
        "id": 126019415,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303448
    },
    {
        "content": "<p>so you know you shouldn't be trying to prove that add commutes</p>",
        "id": 126019425,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303480
    },
    {
        "content": "<p>I'm not sure what Mr Ackermann would have thought about evaluating his function there</p>",
        "id": 126019428,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303503
    },
    {
        "content": "<p>By the way, you got the free statement a bit off:</p>\n<div class=\"codehilite\"><pre><span></span>def chℕfree := {m : Π X : Type, (X → X) → X → X //\n  ∀ (X Y : Type) (a : X → Y) (f : X → X) (g : Y → Y),\n  a ∘ f = g ∘ a → m Y g ∘ a = a ∘ m X f}\n</pre></div>",
        "id": 126019502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525303617
    },
    {
        "content": "<p>Do you think that's the same?</p>",
        "id": 126019642,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303827
    },
    {
        "content": "<p>You are quantifying over g too</p>",
        "id": 126019651,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303850
    },
    {
        "content": "<p>It might be the same</p>",
        "id": 126019661,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525303875
    },
    {
        "content": "<p>It might be the same, but my version fits a more regular pattern</p>",
        "id": 126019775,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304080
    },
    {
        "content": "<p>and it doesn't require evaluating <code>m</code> at a function type</p>",
        "id": 126019789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304098
    },
    {
        "content": "<p>It's basically saying that if <code>a : f -&gt; g</code> is a natural transformation, then so is <code>m</code></p>",
        "id": 126019821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304137
    },
    {
        "content": "<p>That's probably a poor reading, but something like that</p>",
        "id": 126019871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304172
    },
    {
        "content": "<p>What makes <code>chN</code> not quite as powerful as system T is that <code>chN</code> isn't a type in the internal sense</p>",
        "id": 126019886,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304280
    },
    {
        "content": "<p>with impredicative quantification (like in system F) this would work</p>",
        "id": 126019930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304307
    },
    {
        "content": "<p>Godel's system T is simply typed lambda calculus with arrows and products, and a type <code>N</code> with <code>0 : N</code> and <code>S : N -&gt; N</code> and <code>iter_A : (A -&gt; A) -&gt; A -&gt; N -&gt; A</code></p>",
        "id": 126020008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304481
    },
    {
        "content": "<p>Then <code>N</code> there is just like lean's <code>ℕ</code>, but <code>chℕ</code> is not a substitute because it lives in <code>Type 1</code> so it is not a type in STLC</p>",
        "id": 126020060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525304557
    },
    {
        "content": "<p>This is really interesting</p>",
        "id": 126020250,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525304952
    },
    {
        "content": "<p>I identified nat as the universal object</p>",
        "id": 126020253,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525304964
    },
    {
        "content": "<p>and just wrote down some kind of standard maths functory thing about evaluating the universal object at a map</p>",
        "id": 126020256,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525304987
    },
    {
        "content": "<p>but, like induction, you might think about universal objects in a different way to us</p>",
        "id": 126020304,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305010
    },
    {
        "content": "<p>I think I see what I'm missing</p>",
        "id": 126020312,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305038
    },
    {
        "content": "<p>In my world, a would be a map in the category</p>",
        "id": 126020322,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305074
    },
    {
        "content": "<p>and I would be assuming m was a functor</p>",
        "id": 126020323,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305079
    },
    {
        "content": "<p>and trying to represent it</p>",
        "id": 126020325,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305083
    },
    {
        "content": "<p>but m being a functor is an extra condition which I have forgotten about because in the examples I know it is always there</p>",
        "id": 126020332,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525305118
    },
    {
        "content": "<p><code>example : equiv ℕ chℕfree := ⟨to_chfr,of_chfr,inv₁,inv₂⟩ </code></p>",
        "id": 126022755,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525309937
    },
    {
        "content": "<p>Mario's definition definitely works. I wonder if mine (which is implied by Mario's) is too weak.</p>",
        "id": 126022901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310225
    },
    {
        "content": "<p>So I understand the category theory language much better than this DTT stuff.</p>",
        "id": 126023071,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310582
    },
    {
        "content": "<p>I want to say that Type is a category.</p>",
        "id": 126023076,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310592
    },
    {
        "content": "<p>It is</p>",
        "id": 126023077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310602
    },
    {
        "content": "<p>Then m wants to be a functor from Type to Type</p>",
        "id": 126023078,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310607
    },
    {
        "content": "<p>but Church's naive definition just demands a map on objects</p>",
        "id": 126023080,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310625
    },
    {
        "content": "<p>In languages where the naive definition works, that's because of parametric polymorphism</p>",
        "id": 126023123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310656
    },
    {
        "content": "<p>i.e. everything is functorial</p>",
        "id": 126023124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310666
    },
    {
        "content": "<p>I don't know what that means</p>",
        "id": 126023125,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310668
    },
    {
        "content": "<p>HoTT is a lot like this</p>",
        "id": 126023127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310679
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 126023128,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310680
    },
    {
        "content": "<p>the language is crafted such that you can't write badly behaved terms at all</p>",
        "id": 126023130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310699
    },
    {
        "content": "<p>everything is \"fibrant\"</p>",
        "id": 126023138,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310709
    },
    {
        "content": "<p>whatever that means</p>",
        "id": 126023139,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310712
    },
    {
        "content": "<p>Let me modify Type</p>",
        "id": 126023140,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310730
    },
    {
        "content": "<p>so that its objects are still terms whose type is Type</p>",
        "id": 126023142,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310742
    },
    {
        "content": "<p>but that's basically why univalence works</p>",
        "id": 126023143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310743
    },
    {
        "content": "<p>but the morphisms are equivs</p>",
        "id": 126023144,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310746
    },
    {
        "content": "<p>Now m is a map on objects</p>",
        "id": 126023146,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310759
    },
    {
        "content": "<p>and the data of the equiv is exactly what m needs to be extendible to a map on morphisms I suspect</p>",
        "id": 126023186,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310798
    },
    {
        "content": "<p>Check this out: <a href=\"http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf\" target=\"_blank\" title=\"http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf\">http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf</a></p>",
        "id": 126023187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310817
    },
    {
        "content": "<p>In fact I guess it's exactly when X and Y biject that I would even dream of identifying <code>(X-&gt;X) -&gt; X -&gt; X</code> and the analogous term for <code>Y</code></p>",
        "id": 126023193,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310837
    },
    {
        "content": "<p>It argues that naturality is the wrong idea and should be replaced by parametricity</p>",
        "id": 126023194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310841
    },
    {
        "content": "<p>I need to finish digesting it though, so don't quote me on that</p>",
        "id": 126023196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310864
    },
    {
        "content": "<p>Notice though that the condition I gave does not require that a is an equiv</p>",
        "id": 126023241,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310894
    },
    {
        "content": "<p>I think that's going to be true in general</p>",
        "id": 126023244,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310912
    },
    {
        "content": "<p>It really is a functoriality condition</p>",
        "id": 126023245,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310931
    },
    {
        "content": "<p>You have to be careful</p>",
        "id": 126023249,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310944
    },
    {
        "content": "<p>Given a map A to B</p>",
        "id": 126023254,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310957
    },
    {
        "content": "<p>it's just this weird higher order functoriality thing</p>",
        "id": 126023255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310963
    },
    {
        "content": "<p>It seems like logical relations generate the condition well</p>",
        "id": 126023256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525310983
    },
    {
        "content": "<p>You don't get a map (A to A) to (B to B)</p>",
        "id": 126023258,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525310986
    },
    {
        "content": "<p>So I don't know what you mean when you say functoriality is true \"in general\"</p>",
        "id": 126023300,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311043
    },
    {
        "content": "<p>I can only see a functor in the equiv category</p>",
        "id": 126023301,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311059
    },
    {
        "content": "<p>Maybe we mean different things by functorially</p>",
        "id": 126023308,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311080
    },
    {
        "content": "<p>I mean that if you write down some more complicated thing than chN I can write down a more complicated parametricity constraint for it</p>",
        "id": 126023309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311094
    },
    {
        "content": "<p>and I can always do this</p>",
        "id": 126023310,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311099
    },
    {
        "content": "<p>and it will involve a function a : X -&gt; Y</p>",
        "id": 126023311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311107
    },
    {
        "content": "<p>and that function will usually not be required to be an equiv</p>",
        "id": 126023313,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311121
    },
    {
        "content": "<p>I can't make that concept into a functor</p>",
        "id": 126023363,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311231
    },
    {
        "content": "<p>For me, F (X -&gt; Y) is a map F X -&gt; F Y</p>",
        "id": 126023404,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311274
    },
    {
        "content": "<p>Here's the setup: we define a collection of logical relations [R] : X -&gt; Y -&gt; Prop. The important one is for arrows: <code>[R -&gt; S] : (X -&gt; X') -&gt; (Y -&gt; Y') -&gt; Prop</code> is defined by</p>\n<div class=\"codehilite\"><pre><span></span>f [R -&gt; S] g &lt;-&gt; \\forall x y, x [R] y -&gt; f x [S] g y\n</pre></div>",
        "id": 126023412,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311309
    },
    {
        "content": "<p>At the base types we define <code>[R] : X -&gt; Y -&gt; Prop</code> by <code>x [R] y &lt;-&gt; a x = y</code></p>",
        "id": 126023452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311379
    },
    {
        "content": "<p>where <code>a : X -&gt; Y</code> is our fixed morphism to commute over</p>",
        "id": 126023454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311406
    },
    {
        "content": "<p>Applying this definition to <code>[(R -&gt; R) -&gt; R -&gt; R]</code> gives exactly the condition I wrote down</p>",
        "id": 126023460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311446
    },
    {
        "content": "<p>Oh so you're going to tell me that the function I'm looking for is actually a relation</p>",
        "id": 126023463,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525311455
    },
    {
        "content": "<p>And we can go further to even get the <code>a</code> part: we can define <code>[∀ X, R] : (∀ X:Type, P X) -&gt; (∀ X:Type, Q X) -&gt; Prop</code> by</p>\n<div class=\"codehilite\"><pre><span></span>F [∀ X, R] G &lt;-&gt; ∀ X Y : Type, ∀ (a : X -&gt; Y), F X [R] G Y\n</pre></div>\n\n\n<p>(here if <code>X</code> appears in <code>R</code> it's referring to the relation for the function <code>a</code>)</p>",
        "id": 126023623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311747
    },
    {
        "content": "<p>Finally, a term is parametrically polymorphic if it is related to itself at its type, i.e. <code>m [∀ X, (X -&gt; X) -&gt; X -&gt; X] m</code> for the case of <code>chN</code></p>",
        "id": 126023635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311826
    },
    {
        "content": "<p>This is how logical relations work, and how the theorems for free statements are derived</p>",
        "id": 126023674,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1525311854
    },
    {
        "content": "<blockquote>\n<p>Check this out: <a href=\"http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf\" target=\"_blank\" title=\"http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf\">http://www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf</a></p>\n</blockquote>\n<p>That paper</p>",
        "id": 126050623,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1525361651
    }
]
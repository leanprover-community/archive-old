[
    {
        "content": "<p>I believe univalence can consistently be added to lean, since classical logic is valid in the simplicial set model<br>\n(<a href=\"https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf\" target=\"_blank\" title=\"https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf\">https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf</a>).<br>\nMoreover, that model also interprets strict propositions.<br>\nOne would of course need to disable UIP for universes. Would that be possible?</p>",
        "id": 190027207,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583700026
    },
    {
        "content": "<p>Have you seen <a href=\"https://github.com/gebner/hott3\" target=\"_blank\" title=\"https://github.com/gebner/hott3\">https://github.com/gebner/hott3</a> ?</p>",
        "id": 190027361,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583700362
    },
    {
        "content": "<p>I thought that the issue was that <code>bool = bool</code> was a singleton in Lean but <code>bool \\equiv bool</code> was not.</p>",
        "id": 190027386,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583700376
    },
    {
        "content": "<p>That's why you have to disable <code>Prop</code>, or at least large elimination from <code>Prop</code>s</p>",
        "id": 190027394,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583700426
    },
    {
        "content": "<p>And redefine equality to be a <code>Type</code></p>",
        "id": 190027398,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583700441
    },
    {
        "content": "<p>and this breaks all of mathlib immediately, right?</p>",
        "id": 190027403,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583700454
    },
    {
        "content": "<p>Yes</p>",
        "id": 190027405,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583700467
    },
    {
        "content": "<p>and also it means that it would be much harder to make it all again, because the cool tricks we can get away with because any two terms of type P : Prop are equal won't work any more, so it might not even be possible to make parts of mathlib again if we have univalence.</p>",
        "id": 190027659,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583700962
    },
    {
        "content": "<p>I understand why equality can't be a Prop but once that is changed I don't understand why Prop itself causes any problems.</p>",
        "id": 190030722,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583706810
    },
    {
        "content": "<p>If <code>eq : A -&gt; A -&gt; Prop</code> exists then you can prove that <code>eq' : A -&gt; A -&gt; Type</code> is equivalent to it and hence also satisfies UIP</p>",
        "id": 190030917,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583707129
    },
    {
        "content": "<p>Because this is inconsistent right?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">inductive</span> <span class=\"n\">eq2</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">α</span> <span class=\"bp\">→</span> <span class=\"kt\">Type</span>\n<span class=\"bp\">|</span> <span class=\"n\">refl</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">a</span>\n\n<span class=\"kn\">example</span> <span class=\"o\">{</span><span class=\"n\">α</span> <span class=\"o\">:</span> <span class=\"kt\">Type</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"n\">b</span> <span class=\"o\">:</span> <span class=\"n\">α</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">a</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">eq2</span> <span class=\"n\">h₁</span> <span class=\"n\">h₂</span> <span class=\"o\">:=</span>\n<span class=\"k\">by</span> <span class=\"n\">cases</span> <span class=\"n\">h₁</span><span class=\"bp\">;</span> <span class=\"n\">cases</span> <span class=\"n\">h₂</span><span class=\"bp\">;</span> <span class=\"n\">exact</span> <span class=\"n\">eq2</span><span class=\"bp\">.</span><span class=\"n\">refl</span>  <span class=\"bp\">_</span>\n</pre></div>",
        "id": 190030918,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583707132
    },
    {
        "content": "<p>which is basically what Chris's proof does, because <code>cases</code> is implicitly using <code>eq</code></p>",
        "id": 190030928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583707177
    },
    {
        "content": "<p>I was going to say maybe this just means you need to adjust the rules for large elimination of Props to not allow smuggling in eq, but possibly that eliminates all interesting uses?</p>",
        "id": 190031311,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583707870
    },
    {
        "content": "<p>If prop looked like type there wouldn't be any issues</p>",
        "id": 190031324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583707908
    },
    {
        "content": "<p>Well then it might as well not exist, right?</p>",
        "id": 190031367,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583707948
    },
    {
        "content": "<p>I am not sure if the impredicativity is also bad but if you don't have UIP in prop then I think it would be bad</p>",
        "id": 190031376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708003
    },
    {
        "content": "<p>I guess the question is how much stuff can you put into a definitionally proof-irrelevant Prop while remaining consistent with univalence, and is that amount enough to be useful</p>",
        "id": 190031378,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708007
    },
    {
        "content": "<p>You could remove all large elimination. just have all inductive types act like <code>exists</code></p>",
        "id": 190031422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708051
    },
    {
        "content": "<p>then Prop becomes a one-way path so it can't cause problems... I hope</p>",
        "id": 190031426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708082
    },
    {
        "content": "<p>Right, I should go back to: how permissive can the large elimination rules be</p>",
        "id": 190031431,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708106
    },
    {
        "content": "<p>E.g. I imagine that large elimination for <code>true</code> is ok</p>",
        "id": 190031435,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708122
    },
    {
        "content": "<p>But it's also not that exciting</p>",
        "id": 190031438,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708136
    },
    {
        "content": "<p>Some large elimination principles are provable without assuming them, like <code>and</code></p>",
        "id": 190031441,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708157
    },
    {
        "content": "<p>There's surely going to be issues with propext next, I guess</p>",
        "id": 190031468,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708162
    },
    {
        "content": "<p>but those are basically the only okay ones</p>",
        "id": 190031483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708185
    },
    {
        "content": "<p>Oh maybe there is no issue with propext as long as its type itself doesn't have large elimination</p>",
        "id": 190031536,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708288
    },
    {
        "content": "<p>propext is actually univalence for propositions</p>",
        "id": 190031542,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583708316
    },
    {
        "content": "<p>Ok, I think what I was imagining is not a real issue</p>",
        "id": 190031735,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708613
    },
    {
        "content": "<p>I guess if you can track the h-levels of types syntactically then you can also allow large elimination when appropriate. Is this what Arend does?</p>",
        "id": 190031834,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708772
    },
    {
        "content": "<p>Hmm this isn't very obvious actually</p>",
        "id": 190031839,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583708818
    },
    {
        "content": "<p>This theorising is all well and good but you seem to be saying \"if lean's core logic is changed a bit then it would be interesting to see what still works\" and I'm merely pointing out that it might be much much harder to develop a proper maths library, which is my impression of what happens the moment you go univalent: you can compute homotopy types of synthetic spheres and then the only thing you can do is higher topos theory</p>",
        "id": 190032414,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583710076
    },
    {
        "content": "<p>Because you can't use <code>cases</code> any more</p>",
        "id": 190032456,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583710108
    },
    {
        "content": "<p>in principle, lean tactics could be modified to be less HoTT-unfriendly. In practice, the people who are capable of doing a good job of it are not interested</p>",
        "id": 190033516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583712391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> Thanks. Does one still have classical logic?<br>\nInstead of singleton elimination, I guess one wants this: <span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> is also involved in that.<br>\n<a href=\"https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf\" target=\"_blank\" title=\"https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf\">https://jesper.sikanda.be/files/definitional-proof-irrelevance-without-K.pdf</a></p>",
        "id": 190049505,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583743848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110038\">@Kevin Buzzard</span> Most of basic maths happens at the lowest type level, so things wouldn't change much. Only the first universe becomes a groupoid, the second a 2-groupoid, etc.<br>\nOne would notice it when formalizing presheaves, and there I would expect it to be the more natural thing to do. Unless one is \"evil\":<br>\n<a href=\"https://ncatlab.org/nlab/show/principle+of+equivalence\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/principle+of+equivalence\">https://ncatlab.org/nlab/show/principle+of+equivalence</a></p>",
        "id": 190049784,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583744199
    },
    {
        "content": "<p>Presheaves are just a fancy word for functors and I'm sure there will be no problems with functors in a HoTT theory. I want to go much further than this. I want to see the proof that the presheaf of rings on an affine scheme is a sheaf, ie not just a definition of presheaves but a proof that they can be used. This took a team of complete amateurs a few months in Lean -- we were all mathematicians who knew nothing about computer proof systems or type theory one year earlier. I genuinely don't know whether the reason this isn't done in any computer HoTT system is because the systems aren't capable or because there just isn't anyone interested in doing it. I believe that there are classical hypotheses everywhere in the argument.</p>",
        "id": 190051752,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583746131
    },
    {
        "content": "<p>The reason I am banging on about this is that if your original assertion is supposed to imply that adding univalence does not in theory break anything, then I am pointing at an explicit piece of MSc level mathematics whose proof will be completely broken by it and am trying to ask the question \"is there any evidence that it can actually be fixed in practice?\". I am arguing that it took a team of amateurs a few months to make this proof in Lean in their spare time, so it does not seem like an unreasonable practical challenge. In my mind, one of the main things lean has going for it is a whole bunch of examples of mathematics at MSc level and above being done with relative ease by the community -- a proof that the proof assistant is usable in practice to do \"fashionable mathematics\".</p>\n<p>However this might well be a long way from the point you were trying to make originally and so I'll now stop banging on about this on this thread. Sorry to derail. </p>\n<p>I think Chris' original comment on Gabriel's work on HoTT in Lean 3 is the place to start. Both he and Floris van Doorn are experts in doing HoTT in Lean, but currently I don't think either of them are doing any, and perhaps this is only because the community is not there yet.</p>",
        "id": 190052297,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583746678
    },
    {
        "content": "<p>I could envisage someone setting an undergraduate project on doing some HoTT formalisation in Lean using Gabriel's library and then a stream being set up here for HoTT In Lean and one could just see how easy it is to do mathematics in practice in this mode. It would definitely be an interesting and worthwhile project. One could imagine the UniMath library and the HoTT book as being useful resources and one could ask whether this Lean framework is easier to use than the corresponding Coq framework</p>",
        "id": 190052547,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583746915
    },
    {
        "content": "<p>Of course, I would start from the HoTT library, not UniMath. It is better engineered and doesn't have the imho arbitrary restriction on the use of e.g. record types.<br>\n<a href=\"https://github.com/HoTT/HoTT\" target=\"_blank\" title=\"https://github.com/HoTT/HoTT\">https://github.com/HoTT/HoTT</a></p>",
        "id": 190054327,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583748493
    },
    {
        "content": "<p>Thanks for reminding me of this library! I see that it is actively growing too :D People are currently thinking about groups, judging by recent commits. Can you state Sylow's theorems? Can you prove them?</p>\n<p>To give you some sort of data point for comparison, when I arrived at Lean they had in their maths library a theory of groups, rings and topological spaces, and a good theory of finite sets. They had the naturals, integers, rationals and reals, and perhaps not too much more of interest to a \"working mathematician\" (although my memory might be inaccurate). This was definitely enough to get me interested though. Within a year Chris Hughes had proved Sylow's theorems, and he was a 1st year undergraduate mathematician with training in computer proof systems; Kenny Lau had set up a theory of localisation of rings, and he was also a 1st year undergraduate mathematician with no prior training in computer proof systems, and the three of us had proved this result about schemes. The reason I'm mentioning it is that one could ask what the \"bare minimum\"is that one needs to get mathematicians involved. And in my experience it's undergraduate mathematicians you can start with, especially when you say to them \"hey there's this cool system and there's a whole bunch of undergraduate level maths in it which you can do and which we need\". </p>\n<p>Are you considering the possibility of porting this library to Lean? Is that the question you're really asking -- whether the logics of the systems are sufficiently compatible?</p>",
        "id": 190056901,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1583750738
    },
    {
        "content": "<p>Impredicativity isn't compatible with HoTT right? This is something that seems quite important to do normal maths.</p>",
        "id": 190057399,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1583751140
    },
    {
        "content": "<p>Actually, impredicativity can be done in HoTT but it doesn't look the same. There is a well known result that says that two impredicative universes is inconsistent, and one impredicative universe is System F which does not have the \"standard semantics\" we like to have for function types and such. In the standard HoTT foundations you can define what it means for a type to be a proposition, but you end up with a subset of the universe at each level that are propositions, and there may be \"more propositions\" at the higher levels; this is what we mean by predicativity.</p>\n<p>In order to reflect these propositions down to the lowest level to get something more impredicative, there is Voevodsky's \"universe resizing\" rule. IIRC it says that if <code>A : Type u</code> and <code>is_prop A</code> (which we would render as <code>subsingleton A</code>), then there exists <code>A' : Type 0</code> such that <code>equiv A A'</code> (and a forteriori <code>is_prop A'</code> as well).</p>",
        "id": 190058144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583751794
    },
    {
        "content": "<p>In classical logic, this is trivial, because every proposition is either true or false and both true and false can be found in the lowest universe.</p>",
        "id": 190058447,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583752049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span> <br>\nImpredicativity is called the resizing axiom in the HoTT book. It holds in most (classical) models of HoTT, e.g. simplicial sets.</p>",
        "id": 190058840,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583752345
    },
    {
        "content": "<p>But it is an axiom, yes? This by contrast to the way lean's impredicativity works, by a different typing rule for the Pi</p>",
        "id": 190059013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583752536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> In the simplicial set model, the hProps are not the booleans, so the issue is somewhat more subtle:<br>\nAny contractible type is equivalent to a point (e.g. the unit type in the lowest universe)</p>",
        "id": 190059015,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583752538
    },
    {
        "content": "<p>I suspect that Kevin et al really want the hProps to be equivalent to bool</p>",
        "id": 190059083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583752586
    },
    {
        "content": "<p>One could use strict propositions for that, as developed by <span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> in Coq</p>",
        "id": 190059192,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583752696
    },
    {
        "content": "<p>is there a motivating example for why hProp can't be bool, in a classical HoTT model?</p>",
        "id": 190059326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583752831
    },
    {
        "content": "<p>I would have thought equality would be an example but it's not even an hProp unless the type is a hSet</p>",
        "id": 190059371,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583752886
    },
    {
        "content": "<p>I'm not really sure how strict propositions (by which I assume you mean Coq's SProp) differs from lean's Prop, and in particular what they do to avoid the exact same constructions shown by Chris above that trivialize the equality relation</p>",
        "id": 190059487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583753017
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  Indeed, with classical logic, hProp ~ bool. Cor 4 of:<br>\n<a href=\"https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf\" target=\"_blank\" title=\"https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf\">https://www.math.uwo.ca/faculty/kapulkin/notes/LEM_in_sSet.pdf</a></p>",
        "id": 190060309,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583753887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Does this mean that we can assume all types (or at least all types <code>X</code> with <code>is_Set X</code>) are either empty or have a term?</p>",
        "id": 190060582,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583754251
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Yes, that should be provable. Assuming classical logic and choice, hSets form a model of Lawvere's structural set theory.</p>",
        "id": 190063579,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583757274
    },
    {
        "content": "<p>Maybe with the new tooling it becomes easier to switch back and forth between mathlib and the hott3 project...</p>",
        "id": 190063618,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583757330
    },
    {
        "content": "<p>I wouldn't mind playing with it.</p>",
        "id": 190063622,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583757345
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Consider a huge type what paths between all terms. This is contractible, so an hprop, but this is obviously not a boolean.</p>",
        "id": 190063720,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583757430
    },
    {
        "content": "<p>isn't it equivalent to true?</p>",
        "id": 190063746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583757463
    },
    {
        "content": "<p>what makes it \"huge\"?</p>",
        "id": 190063777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583757479
    },
    {
        "content": "<p>or are you saying it has higher structure like loops or something</p>",
        "id": 190063844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583757520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> We can also consider the universe of strict sets. Here is a constructive development, which will not be easy to read, but may give an idea of the type theory.<br>\n<a href=\"http://www.cse.chalmers.se/~coquand/bishop.pdf\" target=\"_blank\" title=\"http://www.cse.chalmers.se/~coquand/bishop.pdf\">http://www.cse.chalmers.se/~coquand/bishop.pdf</a></p>",
        "id": 190064048,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583757742
    },
    {
        "content": "<p>What is the difference between an hSet and a strict set?</p>",
        "id": 190064117,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583757824
    },
    {
        "content": "<p>two equalities of fixed values in a strict set are defeq</p>",
        "id": 190064223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583757900
    },
    {
        "content": "<p>in other words, lean types</p>",
        "id": 190064233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583757908
    },
    {
        "content": "<p>Aha... but can you have those in a HoTT system?</p>",
        "id": 190064355,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1583758001
    },
    {
        "content": "<p>that is based on skimming Bas's link</p>",
        "id": 190064390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583758046
    },
    {
        "content": "<p>I don't think that type theory is classical, although probably you can just throw that in</p>",
        "id": 190064420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583758076
    },
    {
        "content": "<p>but the upshot of all this is still not clear to me. It sounds like you are offering most of the features lean has already. What are we giving up? Clearly something has to give since univalence in lean is disprovable</p>",
        "id": 190064517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583758144
    },
    {
        "content": "<p>the stuff about simplicial sets or cubical set models is not relevant for the lean user, since we are working <em>in</em> the theory not <em>on</em> the theory. (Formalizing type theories would be a worthy project but quite independent of tweaks to lean foundations.)</p>",
        "id": 190064721,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583758338
    },
    {
        "content": "<p>One would have a type theory with two kinds of propositions, strict ones and hProps.<br>\nset level mathematics should go through at the bottom universe, but the other universes can be univalent.<br>\nSo one would need to give up UIP for the higher universes.</p>",
        "id": 190072108,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1583762925
    },
    {
        "content": "<p>Wait, so the lowest universe is not univalent in this scheme? Isn't that where all the interesting maths would go? For example, I guess one desideratum would be to have <code>real = real x {0}</code> be provable, as well as similar statements for the corresponding elements of a fully bundled type <code>Ring := Sigma (A : Type 0) (mul : A -&gt; A -&gt; A), ...</code>. As I understand it this is the main selling point of having univalence around, but these objects are h-sets, possibly strict sets if you prefer, and live in the bottom universe. (<code>Ring</code> lives in the next universe but equality of rings, which should mean ring isomorphism, depends on equality in <code>Type 0</code>, and so needs the bottom universe to be univalent.)</p>",
        "id": 190134462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583802776
    },
    {
        "content": "<p>While UIP is tremendously convenient, it doesn't actually enable any particular kind of maths, as long as you can obtain the (non-judgmental) equality by other means. It would still require a lot of engineering effort to recover the same level of ease of use that you get with UIP, but at least in principle I can see giving it up provided that things like the resizing axiom are around to allow us to do long well founded recursions and such.</p>",
        "id": 190134631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1583802979
    },
    {
        "content": "<p>I think <code>@eq A a b</code> is a Prop if <code>A : Type 0</code>. That doesn't prevent <code>Type</code> itself from satisfying univalence</p>",
        "id": 190134746,
        "sender_full_name": "Reid Barton",
        "timestamp": 1583803170
    },
    {
        "content": "<p>We could have a universe of strict sets, and a universe of hSets living side by side.<br>\n<span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> has been working on the type theory for this. Some things will simplify in the classical model of simplicial sets, but I'm not sure anyone has gone through the details. It will be a simplification of Thierry's note.</p>",
        "id": 190492274,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584098679
    },
    {
        "content": "<p>What would \"living side by side\" mean in practice? Would it be easy to transport data and properties from one side to the other? Or would the gap be about as big as the gap between two different libraries right now (e.g., mathcomp and mathlib)?</p>",
        "id": 190492409,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584098796
    },
    {
        "content": "<p>This paper discusses a decade long research program on implementing transfer in proof assistants (Coq, Isabelle,...)<br>\nThe Marriage of Univalence and Parametricity<br>\n<a href=\"https://arxiv.org/abs/1909.05027\" target=\"_blank\" title=\"https://arxiv.org/abs/1909.05027\">https://arxiv.org/abs/1909.05027</a><br>\nand claims that the approach using HoTT is most convenient. It would be interesting to know whether there are any initiatives to implement transfer in lean.</p>",
        "id": 190492425,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584098812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110193\">@Cyril Cohen</span> has been working on this about a year ago.</p>",
        "id": 190492489,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584098877
    },
    {
        "content": "<p>Reference?</p>",
        "id": 190492540,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584098894
    },
    {
        "content": "<p>But so far we don't have any usable tools.</p>",
        "id": 190492541,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584098894
    },
    {
        "content": "<p><a href=\"https://github.com/CohenCyril/mathlib/commits/param\" target=\"_blank\" title=\"https://github.com/CohenCyril/mathlib/commits/param\">https://github.com/CohenCyril/mathlib/commits/param</a></p>",
        "id": 190492576,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584098937
    },
    {
        "content": "<p>I guess that is the CoqEAL approach? Has it been proved to work with classical logic? I don't recall seeing that result explicitly.</p>",
        "id": 190492846,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584099132
    },
    {
        "content": "<p>I really don't know.</p>",
        "id": 190493069,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099316
    },
    {
        "content": "<p>This is stuff that I never thought about as a mathematician</p>",
        "id": 190493079,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099329
    },
    {
        "content": "<p>It's just an extremely annoying problem that you discover once you start using ITP's</p>",
        "id": 190493093,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I don't think the type theory has been worked out. It would be somewhat like the interaction of sProp and Prop in Coq and agda.<br>\nSemantically, we can check what is going on by looking at the classical groupoid model.</p>",
        "id": 190493172,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584099408
    },
    {
        "content": "<p>Strange, I would imagine you would know about Artin gluing<br>\n<a href=\"https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf\" target=\"_blank\" title=\"https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf\">https://drops.dagstuhl.de/opus/volltexte/2019/10532/pdf/LIPIcs-FSCD-2019-25.pdf</a></p>",
        "id": 190493309,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584099510
    },
    {
        "content": "<p>I think it would be very helpful if some HoTT library would demonstrate that it's useful for maths that doesn't look like homotopy theory. It doesn't have to be perfectoid spaces. But something like the Hilbert basis theorem, or even better fundamental theorem of calculus. Those are low-level from a maths point of view, but my impression is that they are currently challenging for HoTT libs.</p>",
        "id": 190493332,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099547
    },
    {
        "content": "<p>Hmmm... let me check that link</p>",
        "id": 190493335,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099554
    },
    {
        "content": "<p>Unary, binary and machine integers low level enough for you :-)<br>\nThat's the examples they look at in the univalent parametricity paper.</p>",
        "id": 190493446,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584099650
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> Ok, I've heard of things like gluing sheaves or topoi, or what not. But (for a simple mathematician) it's not clear how that helps us with <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> are isomorphic semirings, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span> is a noetherian integral domain, hence <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span> is as well.</p>",
        "id": 190493458,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099664
    },
    {
        "content": "<p>And mathematicians completely don't know what you need to do to prove such a statement. They only know a 1-word proof: \"Obvious\".</p>",
        "id": 190493486,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099706
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190493446\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190493446\">said</a>:</p>\n<blockquote>\n<p>Unary, binary and machine integers low level enough for you :-)<br>\nThat's the examples they look at in the univalent parametricity paper.</p>\n</blockquote>\n<p>No, that won't do. We need to know that the maths that appears in bachelor courses is at least as easy in HoTT as it is in DTT like Lean.</p>",
        "id": 190493566,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> There was a smiley missing in my last comment. I just wanted to point out that the \"annoying problem\" actually hides beautiful maths that you know well.</p>",
        "id": 190493580,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584099772
    },
    {
        "content": "<p>So it has to be some calculus or commutative algebra or something. Binary integers are too low level.</p>",
        "id": 190493597,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099788
    },
    {
        "content": "<p>Sure... but I'm talking about the public relations / advertisement side of things. To get things rolling you need an eye-catching result.</p>",
        "id": 190493642,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584099838
    },
    {
        "content": "<p>Here are some examples from algebra:<br>\n<a href=\"http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf\" target=\"_blank\" title=\"http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf\">http://www.cse.chalmers.se/~nad/publications/coquand-danielsson-isomorphism-is-equality.pdf</a><br>\nWe are currently working on a formalization of universal algebra in HoTT. The isomorphism theorems become \"identification theorems\".</p>",
        "id": 190493926,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584100070
    },
    {
        "content": "<p>This is not what is taught in 1st year undergraduate classes. What Johan and I are trying to say is this: if HoTT is supposed to be able to do mathematics, let's see some mathematics which are taught in standard undergraduate mathematics classes. Where is quadratic reciprocity in any HoTT theory? The proof of this is not straightforward. You need a robust theory of finite sets. You need to be able to count. Where is the proof of Lagrange's theorem? Where is \"normal mathematics\"? machine integers and universal algebra etc are exactly what we are <em>not</em> talking about.</p>",
        "id": 190495413,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584101339
    },
    {
        "content": "<p>Navel-gazing about equality is something else which is not done at all in a mathematics department, away from esoteric coursees.</p>",
        "id": 190495566,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584101452
    },
    {
        "content": "<p>We may be talking past eachother, but I am saying that in HoTT we can prove <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> s statement about integral domains by univalent transfer. Since, A and B are ismorphic algebraic structures, the record types are equal, and hence we can transport the property of being a noetherian integral domain.</p>",
        "id": 190497429,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584102992
    },
    {
        "content": "<p>Exactly! And that is why HoTT is so enticing!</p>",
        "id": 190497662,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103162
    },
    {
        "content": "<p>But if that is the \"only\" thing it can do... it's no good (of course I'm exagerating with \"only\").</p>",
        "id": 190497686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103188
    },
    {
        "content": "<p>We need a system that gives us a powerful transfer. But we also need a system that gives us quadratic reciprocity, fund.thm.calc., lagrange, hilbert basis, and all the rest.</p>",
        "id": 190497765,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103233
    },
    {
        "content": "<p>So far we have all the classical (not in the logic sense, but in temporal sense) systems that struggle with transfer, and we have HoTT which doesn't.<br>\nBut HoTT isn't proving that you can do the \"classical\" theorems of mathematics in it.</p>",
        "id": 190497820,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103306
    },
    {
        "content": "<p>Universal algebra is nice. But can it be applied?</p>",
        "id": 190497873,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103326
    },
    {
        "content": "<p>If you can give me a formalisation of quadratic reciprocity as a 10 line consequence of universal algebra. Sure, then I will be very excited about the universal algebra library.</p>",
        "id": 190497920,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103377
    },
    {
        "content": "<p>Especially if the fundamental theorem of calculus is another 30-line consequence</p>",
        "id": 190497934,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103394
    },
    {
        "content": "<p>But I doubt that that is true.</p>",
        "id": 190497942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103404
    },
    {
        "content": "<p>To use some categorical language: we want the pushout of HoTT and mathlib.</p>",
        "id": 190497952,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103427
    },
    {
        "content": "<p>We need another paper \"The marriage of univalence and material set theory\".</p>",
        "id": 190498165,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584103597
    },
    {
        "content": "<p>I am aware universal algebra is close to logic/CS. I.e. it's use in effectful computation.<br>\nMy PhD-student Andreas has been working on integrating math-comp and HoTT.<br>\nThis is currently stuck on universe polymorphism:<br>\n<a href=\"https://github.com/coq/coq/issues/10513\" target=\"_blank\" title=\"https://github.com/coq/coq/issues/10513\">https://github.com/coq/coq/issues/10513</a><br>\nPerhaps Coq is trying to be too clever, and the more conservative approach of lean would work better. Also, there is less legacy code in lean.</p>",
        "id": 190498186,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584103622
    },
    {
        "content": "<p>Theorem 10.1.15 of the HoTT book: <br>\n If the axiom of choice holds then the category Set is a well-pointed boolean elementary topos with choice.</p>\n<p>This is called Lawver set theory. What else do you want from set theory?</p>",
        "id": 190498546,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584103812
    },
    {
        "content": "<p>I think that's good. That's good enough for the theoretical foundations. What we need to see is that it's usable in practice.</p>",
        "id": 190498838,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104087
    },
    {
        "content": "<p>How many lines of code does mathlib use to prove quadratic reciprocity? (I dunno, but we can find out.)<br>\nCan we do a 1-1 translation to HoTT?</p>",
        "id": 190498894,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104127
    },
    {
        "content": "<p>If not 1-to-1, what is the factor that proofs scale by? Should we expect less lines of code, or more?</p>",
        "id": 190498919,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104152
    },
    {
        "content": "<p>That's the kind of question that Kevin and I are interested in.</p>",
        "id": 190498976,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104171
    },
    {
        "content": "<p>Of course we could try to figure this out ourselves. But we are also wondering why HoTT experts are not figuring this out.</p>",
        "id": 190499039,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104221
    },
    {
        "content": "<p>(Also, unfortunately I need to spend lots of time on paper maths projects, and diving into developing a theory of finite sets in HoTT would not make my boss happy.)</p>",
        "id": 190499090,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584104270
    },
    {
        "content": "<p>I have the following analogy. It is consistent with ZF to assume that every set of the real line is measurable. Then, one can add this axiom, and do all measure theory in an extremely nice way (much nicer than what is usually done because you won't need to check measurability any time). Except that then you can not integrate this measure theory library with other traditional parts of maths that require choice (for instance the existence of the algebraic closure), as assuming measurability of everything is contradictory with choice. In this situation, it seems to me that doing measure theory in this way would be cheating, and mostly useless to build a whole library of mathematics.</p>\n<p>As to whether this is a good analogy with HOTT, I won't say anything, because I don't understand anything to HOTT.</p>",
        "id": 190499556,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584104560
    },
    {
        "content": "<p>Unless, I am overlooking something, lean is already consistent with HoTT under this translation (which uses --indices-matter)( <span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> ?)<br>\n<a href=\"https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581\" target=\"_blank\" title=\"https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581\">https://coq.discourse.group/t/alpha-announcement-coq-is-a-lean-typechecker/581</a><br>\nOf course, that does not directly give univalence, but it embeds lean in the strict propositions that we discussed before.</p>",
        "id": 190499786,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584104723
    },
    {
        "content": "<p>Yes but Coq isn't HoTT, it's some poorly defined union of a bunch of type theory extensions</p>",
        "id": 190499904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584104797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Coq implements pcuic. What do you mean?</p>",
        "id": 190499997,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584104868
    },
    {
        "content": "<p>Coq doesn't \"just\" implement pcuic, it has extra stuff</p>",
        "id": 190500077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584104892
    },
    {
        "content": "<p>I have literally never seen a definition of Coq that didn't finish \"oh and there's also some other stuff we won't go into here\"</p>",
        "id": 190500109,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584104916
    },
    {
        "content": "<p>I'm not 100% positive I know what the exact theory you are calling PCUIC is (usually people call \"that thing Coq implements\" CIC instead) but I think that SProp is not mentioned in it</p>",
        "id": 190500444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584105118
    },
    {
        "content": "<blockquote>\n<p>Unless, I am overlooking something, lean is already consistent with HoTT under this translation (which uses --indices-matter)( @Gaëtan Gilbert ?)</p>\n</blockquote>\n<p>I'm pretty sure the translation breaks when using -indices-matter<br>\nLean can't be consistent with HoTT since Lean has UIP</p>",
        "id": 190500717,
        "sender_full_name": "Gaëtan Gilbert",
        "timestamp": 1584105262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> What is the status of strict sets?</p>",
        "id": 190500791,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584105310
    },
    {
        "content": "<p>Pcuic:<br>\n<a href=\"https://hal.inria.fr/hal-01615123v2/document\" target=\"_blank\" title=\"https://hal.inria.fr/hal-01615123v2/document\">https://hal.inria.fr/hal-01615123v2/document</a><br>\nSProp is a recent addition described in Gaetan's thesis.</p>",
        "id": 190501023,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584105436
    },
    {
        "content": "<p>I know</p>",
        "id": 190501149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584105509
    },
    {
        "content": "<p>hence my claim that it's the union of a bunch of type theory extensions that have not all been examined as a whole</p>",
        "id": 190501175,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584105529
    },
    {
        "content": "<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>",
        "id": 190501247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584105599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> First, besides your point, measure theory should be developed algebraically/categorically e.g. in line with the theory of von Neumann algebras. See the remarks by people like Rota and Tao.<br>\nBut to address your point, which axiom would you like to add that is inconsistent with lawvere set theory ?</p>",
        "id": 190501249,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584105600
    },
    {
        "content": "<p>All this talk about foundations is nice and well. My question remains: suppose that all of mathlib were translated by magic to HoTT. Would it be longer or shorter?</p>",
        "id": 190501498,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584105758
    },
    {
        "content": "<p>It should be shorter, as we have more axioms (UA) at our disposal. However, I cannot completely gauge the influence of strict equality at the moment.</p>",
        "id": 190501771,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584105955
    },
    {
        "content": "<p>The number of axioms is not the only factor. We lose definitional proof irrelevance. Will automation apply it for us instead? How often will I need to prove that my type is an hSet? Or is that automated? Is there type class inference? Is there a simplifier? Do they work?</p>",
        "id": 190501946,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584106036
    },
    {
        "content": "<p>for that argument to work, you have to be able to mimic/model/implement every single one of lean's axioms and defeqs. The \"coq is a lean typechecker\" suggests that this is very nearly possible, but it seems like you still have to give up some things, like lean's strong form of the axiom of choice</p>",
        "id": 190502058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106086
    },
    {
        "content": "<p>But \"coq is a lean typechecker\" was not a univalent coq, was it?</p>",
        "id": 190502111,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584106132
    },
    {
        "content": "<p>no</p>",
        "id": 190502134,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106146
    },
    {
        "content": "<p>I think Bas is claiming that there is a way to have both strict sets and univalence in the same system</p>",
        "id": 190502189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106172
    },
    {
        "content": "<p>but I'm pretty sure that <code>nonempty A -&gt; A</code> breaks everything</p>",
        "id": 190502229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106201
    },
    {
        "content": "<p>the hott version of the axiom of choice is much more guarded, something like <code>(Pi x, nonempty (A x)) -&gt; nonempty (Pi x, A x)</code></p>",
        "id": 190502395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190501249\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190501249\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> First, besides your point, measure theory should be developed algebraically/categorically e.g. in line with the theory of von Neumann algebras. See the remarks by people like Rota and Tao.</p>\n</blockquote>\n<p>It definitely shouldn't. The von Neumann algebra point of view is interesting, but there are many statements of down to earth measure theory that are just not true in this generality.</p>",
        "id": 190503253,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584106748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190501249\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190501249\">said</a>:</p>\n<blockquote>\n<p>But to address your point, which axiom would you like to add that is inconsistent with lawvere set theory ?</p>\n</blockquote>\n<p>As I was saying, I don't know anything about HOTT. But my impression as an outsider is that you have to sacrifice some versions of choice, which is not an option for me. I would be happy to be proven wrong!</p>",
        "id": 190503415,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584106833
    },
    {
        "content": "<p>By the way, lean's version of the axiom of choice isn't even ok in ZFC. It's known as \"global choice\", positing the existence of a proper class function that is a choice function on every set</p>",
        "id": 190503700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584106992
    },
    {
        "content": "<p>The actual axiom of choice only allows you to choose from set-many nonempty sets at once</p>",
        "id": 190503749,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107028
    },
    {
        "content": "<p>However, in set theory you do have definable definite description, so unlike lean you don't have to use choice to define things like <code>lim</code> when the limit is unique</p>",
        "id": 190503967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107152
    },
    {
        "content": "<p>I'm not sure this is true though since a Lean term can only talk about finitely many choice constants.  Lean has a <code>choice.{u}</code> constant for every universe <code>u</code>.  There is no relation between <code>choice.{u}</code> and <code>choice.{u+1}</code> (except for what you get out of the type).  And each <code>choice.{u}</code> is definable in ZFC + enough inaccessibles.</p>",
        "id": 190504047,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584107181
    },
    {
        "content": "<p>Oh, that's an interesting point</p>",
        "id": 190504068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107206
    },
    {
        "content": "<p>Still, <code>choice.{-}</code> has a bit of a peculiar status as a family then, since it will not be uniformly definable</p>",
        "id": 190504213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107283
    },
    {
        "content": "<p>Is <code>Type.{-}</code> uniformly definable?</p>",
        "id": 190504301,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584107337
    },
    {
        "content": "<p>In all the models that I've considered for lean in set theory, yes. It's usually an explicitly agreed upon sequence, or perhaps the sequence \"the n-th inaccessible\"</p>",
        "id": 190504382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107394
    },
    {
        "content": "<p>I guess it's not really that different from the choice constants though. At some point this sequence breaks down - it's well defined but no longer points at anything because you've run out of inaccessibles in the outer model, say - and you can do something similar with the choice sequence where you start with an assumption that gives you the first 42 choice constants and the rest of them are just nonsense</p>",
        "id": 190504668,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107565
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> lawvere set theory includes choice...</p>",
        "id": 190504720,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584107601
    },
    {
        "content": "<p>Great!</p>",
        "id": 190505151,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584107901
    },
    {
        "content": "<p>which choice?</p>",
        "id": 190505171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584107916
    },
    {
        "content": "<p><a href=\"https://ncatlab.org/nlab/show/ETCS\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/ETCS\">https://ncatlab.org/nlab/show/ETCS</a><br>\n<a href=\"https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs\" target=\"_blank\" title=\"https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs\">https://ncatlab.org/nlab/show/fully+formal+ETCS#the_theory_etcs</a></p>",
        "id": 190505410,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584108055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190501247\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190501247\">said</a>:</p>\n<blockquote>\n<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>\n</blockquote>\n<p>what about <a href=\"https://coq.inria.fr/distrib/current/refman/language/cic.html\" target=\"_blank\" title=\"https://coq.inria.fr/distrib/current/refman/language/cic.html\">https://coq.inria.fr/distrib/current/refman/language/cic.html</a> ?</p>",
        "id": 190506562,
        "sender_full_name": "Gaëtan Gilbert",
        "timestamp": 1584108786
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"259452\">Bas Spitters</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190500791\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190500791\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243878\">Gaëtan Gilbert</span> What is the status of strict sets?</p>\n</blockquote>\n<p>I'm not working on them</p>",
        "id": 190506594,
        "sender_full_name": "Gaëtan Gilbert",
        "timestamp": 1584108809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110049\">Mario Carneiro</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190501247\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190501247\">said</a>:</p>\n<blockquote>\n<p>I really sincerely don't understand why there isn't some reference linked from the coq manual or something that defines the whole axiomatic system and stays up to date with new versions</p>\n</blockquote>\n<p>I guess  is related to the fact that the first released version of Coq is more than 30 years old. Nit-picking:  other  parts of a proof assistant, for which a paper description is seldom available, have at least as much impact on users and on their act of faith in formal statements. E.g. the elaborator, the parser etc. Since I am more interested in maths than in immediate applications in, e.g., security, I am not too worried though :).</p>",
        "id": 190507184,
        "sender_full_name": "Assia Mahboubi",
        "timestamp": 1584109110
    },
    {
        "content": "<p>I am interested in specification for those aspects as well, but I think the logical foundation is the first stage, and in principle should be the easiest to obtain, being as well studied as it is</p>",
        "id": 190507524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584109290
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> That is a nice link. It is a bit tutorial-like though, and in particular the propensity to defer more complex aspects of the system until later makes it unclear when the description of the axioms is \"done\"</p>",
        "id": 190507762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584109408
    },
    {
        "content": "<p>I don't think you could write a Coq typechecker from that description</p>",
        "id": 190507871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584109457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> I'm interested in both math and security and that's why I think it's important that the logical foundations are well specified.<br>\nI believe the information is there for the Coq system, but they could be collected in a more central place.</p>",
        "id": 190507962,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584109518
    },
    {
        "content": "<p>I am willing to believe that every piece of Coq foundations has been described in some paper written over the past 30 years. But there are also probably some bits of black magic in the ML code that never got air-time in a paper, and also the lack of central description means a lack of (proof of) global coherence, which is of course critical for soundness</p>",
        "id": 190508347,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584109709
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> Do you happen to know more about the parametricity plugin for lean and how it relates to classical logic?</p>",
        "id": 190509170,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584110065
    },
    {
        "content": "<p>from <a href=\"https://coq.inria.fr/distrib/current/refman/language/cic.html\" target=\"_blank\" title=\"https://coq.inria.fr/distrib/current/refman/language/cic.html\">the coq CIC manual</a>:</p>\n<blockquote>\n<p>the terms structurally smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span> are:</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow><mi mathvariant=\"sans-serif\">c</mi><mi mathvariant=\"sans-serif\">a</mi><mi mathvariant=\"sans-serif\">s</mi><mi mathvariant=\"sans-serif\">e</mi></mrow><mo stretchy=\"false\">(</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>P</mi><mo separator=\"true\">,</mo><msub><mi>f</mi><mn>1</mn></msub><mo>…</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathsf{case}(c,P,f_1\\dots f_n)</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathsf\">c</span><span class=\"mord mathsf\">a</span><span class=\"mord mathsf\">s</span><span class=\"mord mathsf\">e</span></span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> when each <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">f_i</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> is structurally smaller than <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>y</mi></mrow><annotation encoding=\"application/x-tex\">y</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span></span>.</li>\n</ul>\n</blockquote>\n<p>Isn't this the rule that caused a Coq soundness bug a while back?</p>",
        "id": 190509198,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584110080
    },
    {
        "content": "<p><a href=\"https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html\" target=\"_blank\" title=\"https://sympa.inria.fr/sympa/arc/coq-club/2013-12/msg00119.html\">this one</a></p>",
        "id": 190509645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584110237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> The parametricity plugin written by Cyril will prove the parametricity theorem for \"any lean term\". It works by recursion over the term syntax of the language, but it can get stuck when it gets to certain things. For axioms, there is nowhere to recurse so you have to manually provide a proof of parametricity. And <code>choice</code> simply doesn't satisfy the parametricity theorem, so any terms built using <code>choice</code> (and there are a lot of them) are similarly blocked. There are also complications in some inductive types, but last I saw there were no real theoretical barriers.</p>",
        "id": 190510238,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584110560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> Strictly speaking, this was not a soundness bug. It made Coq inconsistent with the standard Set model, which is indeed pretty bad, but doesn't allow to derive False either.</p>",
        "id": 190510363,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584110630
    },
    {
        "content": "<p>I realize that another way to phrase this is \"Coq is anti-classical\", and that is what is done in the thread itself. But for all the lean users and mathematicians around here, that's basically just proving false things.</p>",
        "id": 190510526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584110712
    },
    {
        "content": "<p>Stated another way, it allows you to derive False in Coq + axioms that everyone wants to have and are unwilling to give up</p>",
        "id": 190510649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584110771
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> so, that approach to Transfer does not seem to be very suitable for lean...</p>",
        "id": 190510709,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584110819
    },
    {
        "content": "<p>Right, somehow the pure \"abstract nonsense\" proof of parametricity doesn't work in practice because <code>choice</code> is too deeply ingrained. But for more engineering minded folks like myself the news isn't all bad. Although we use <code>choice</code> a lot to do proofs, it's not like we have choicy functions all over the place. Mathematicians by and large tend to avoid constructions that are not \"canonical\" in some sense and this means that \"random functions\" are quite rare. So one might hope to blockade the region around <code>choice</code> by proving, by alternate means, the parametricity theorem for certain terms that use <code>choice</code> in their definition, and then being able to stop the recursion when you get there rather than peeking into the definition and getting stuck on <code>choice</code>.</p>\n<p>In particular, much of our usage of <code>choice</code> comes via <code>classical.em</code>, which I think satisfies the parametricity theorem because of proof irrelevance</p>",
        "id": 190511194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> I am not sure what you refer to, but <em>anti-classical</em> has a well-defined meaning and this doesn't apply to Coq. Coq is compatible with classical logic, but it doesn't imply it. So, parametricity breaks in presence of classical logic, but that's not preventing the extension of Coq with classical principles. Furthermore, adding effects to a language just weakens parametricity, there are still weaker presentations that can be salvaged.</p>",
        "id": 190511479,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111226
    },
    {
        "content": "<p>When I talk about proving soundness of Coq, it may not be obvious but I don't mean \"no axioms Coq\", I mean \"all common axioms Coq\"</p>",
        "id": 190511622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111267
    },
    {
        "content": "<p>I'm pretty sure there is a file in the coq standard library called <code>Axioms.v</code> or something like that containing a bunch of things commonly believed to be ok. I want those to all be consistent with Coq</p>",
        "id": 190511733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111323
    },
    {
        "content": "<p>This is ill-defined, people do use conflicting \"common\" axioms. Is UIP common? Is univalence common?</p>",
        "id": 190511869,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111365
    },
    {
        "content": "<p>If there are mutually incompatible supported subsets, they should be explicitly determined and the (probably quite distinct) proofs of consistency of each maximal consistent subset should be shown</p>",
        "id": 190512007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111422
    },
    {
        "content": "<p>And also there should be GIANT WARNING FLAGS on these axioms to prevent someone from accidentally using both in the same development</p>",
        "id": 190512064,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111451
    },
    {
        "content": "<p>This doesn't make sense, by Gödel's theorem there is no maximally consistent extension...</p>",
        "id": 190512099,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111470
    },
    {
        "content": "<p>The set of axioms in the coq standard library is finite</p>",
        "id": 190512176,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111492
    },
    {
        "content": "<p>There is a nice graph somewhere in the doc, for set-theoretic axioms. Let me find it.</p>",
        "id": 190512221,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111523
    },
    {
        "content": "<p>I would have hoped that all the axioms taken together are consistent. Univalence is not in the coq standard library, I think</p>",
        "id": 190512307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111573
    },
    {
        "content": "<p>You can have a look at <a href=\"https://github.com/coq/coq/wiki/The-Logic-of-Coq\" target=\"_blank\" title=\"https://github.com/coq/coq/wiki/The-Logic-of-Coq\">https://github.com/coq/coq/wiki/The-Logic-of-Coq</a> and <a href=\"https://github.com/coq/coq/wiki/CoqAndAxioms\" target=\"_blank\" title=\"https://github.com/coq/coq/wiki/CoqAndAxioms\">https://github.com/coq/coq/wiki/CoqAndAxioms</a>.</p>",
        "id": 190512309,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111575
    },
    {
        "content": "<p>All 7 axioms on that page are consistent with each other in lean, and I hope in Coq as well</p>",
        "id": 190512420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111615
    },
    {
        "content": "<p>There is no such thing as \"true mathematics\" so it doesn't make sense to ask our users to abide to a specific set of axioms.</p>",
        "id": 190512431,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111625
    },
    {
        "content": "<p>Compatibility is a strength. But if you like sets, you can throw in whatever set-theoretical axiom you fancy.</p>",
        "id": 190512573,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111674
    },
    {
        "content": "<p>And I am not a crazy intuitionist, I would actually like to have some extension of CIC to classical reasoning that preserves its good computational properties. But it's far from being an easy task. And no, I don't consider that what Lean does is the right way.</p>",
        "id": 190512837,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111766
    },
    {
        "content": "<p>As long as the union of all provided axioms is still consistent, it's not so bad to work with subsets. You can choose not to use any of them, or just one, or just a different one, and all the libraries are compatible. As soon as you throw in an axiom that is inconsistent with the others, you bifurcate the libraries and the community</p>",
        "id": 190512859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111781
    },
    {
        "content": "<p>So what? There are people writing thread-safe code in C++, that doesn't mean that you can't also write code that is thread-unsafe.</p>",
        "id": 190513015,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584111847
    },
    {
        "content": "<p>I actually don't particularly like lean's approach to axioms either. There are 3 axioms, and for almost all work you basically are forced to accept them all. There is very little room for playing with subsets</p>",
        "id": 190513023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111851
    },
    {
        "content": "<p>In metamath there are something like 20-25 axioms, and while many of the subsets are not interesting, you can still play with avoiding the axiom of choice, or the axiom of foundation, or replacement, or first order logic, or intuitionistic logic.</p>",
        "id": 190513282,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584111967
    },
    {
        "content": "<p>However, the union of all available axioms is TG set theory which is rather strong but still believed to be consistent</p>",
        "id": 190513452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112029
    },
    {
        "content": "<p>so you don't need to have two separate libraries</p>",
        "id": 190513492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112045
    },
    {
        "content": "<p>This may look like an alien statement to the mathematicians around here, but I do think this kind of belief of \"the one metatheory to rule them all\" is 19th century thinking. If you accept proof-as-programs, then it makes sense to have several programming languages enforcing contradictory invariants. And this has nothing to do with the old feud between intuitionistic crackpots and the rest of the mathematical community, this is just about accepting the world as it is.</p>",
        "id": 190513607,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112095
    },
    {
        "content": "<p>Who cares? If you want to get mathematicians on board, you'll have to accept that they don't care about foundations and just want to prove their theorems.</p>",
        "id": 190513686,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112140
    },
    {
        "content": "<p>I know many mathematicians who really don't care about foundations. (I can't even list the axioms of ZFC myself.)</p>",
        "id": 190513724,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112174
    },
    {
        "content": "<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>",
        "id": 190513729,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112175
    },
    {
        "content": "<p>I'm all for supporting multiple foundations, but I also want to avoid erecting walls between formal developments</p>",
        "id": 190513748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112191
    },
    {
        "content": "<p>They don't care about correctness either. As long as proofs converge within a reasonable amount of time, that's fine.</p>",
        "id": 190513752,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112196
    },
    {
        "content": "<p>so compatibility is key</p>",
        "id": 190513757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112200
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260981\">Pierre-Marie Pédrot</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190513729\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190513729\">said</a>:</p>\n<blockquote>\n<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>\n</blockquote>\n<p>They aren't interested in that either.</p>",
        "id": 190513810,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112208
    },
    {
        "content": "<p>I don't say you should change. But in that case, don't get your hopes up on having mathematicians among your users.</p>",
        "id": 190513833,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112231
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> the situation is not as dire as you think from the point of view of foundations in the Coq community, there are mainly the Set people and the HoTT people.</p>",
        "id": 190513850,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112245
    },
    {
        "content": "<p>What I am interested in is a proof assistant that helps me do research in arithmetic geometry.</p>",
        "id": 190513859,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112247
    },
    {
        "content": "<p>Currently no such a thing exists.</p>",
        "id": 190513913,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112278
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> technical issues regarding the design choices of libraries are a much bigger issue than foundations.</p>",
        "id": 190513917,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112281
    },
    {
        "content": "<p>And as long as I need to spend brain power on foundational issues, it won't happen either.</p>",
        "id": 190513942,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112294
    },
    {
        "content": "<p>Again, compatibility is key</p>",
        "id": 190513946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112297
    },
    {
        "content": "<p>This is why mathlib is a monorepo</p>",
        "id": 190513956,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112306
    },
    {
        "content": "<p>Once again, I think we should turn to programming engineering to draw inspiration. It is not uncommon to see various styles emerge. Then people tend to turn this state of affairs in the dreaded \"platform\" thingy so that you effectively get another programming language atop of the base one, enforcing more constraints like style and whatnot. If you need to make interact two libraries using different platforms, then you're toast.</p>",
        "id": 190514321,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112441
    },
    {
        "content": "<p>If it really is the Set people and the HoTT people, then asking mathematicians to use HoTT is like asking them to jump over the wall. And they very reasonably point out that they like the things on this side of the wall and don't want to give them up, even though there are some cool things on the other side too.</p>",
        "id": 190514387,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112459
    },
    {
        "content": "<p>At least there is the C ABI for interop when it comes to cross library compatibility in software</p>",
        "id": 190514449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112502
    },
    {
        "content": "<p>You can do Set theory in HoTT, but this is more like bondage than anything else.</p>",
        "id": 190514473,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112514
    },
    {
        "content": "<p>As for C ABI, this is not a magical entity that happened overnight, this is the result of history and social interaction.</p>",
        "id": 190514506,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112541
    },
    {
        "content": "<p>My personal belief is that MLTT plus or minus is a rather good minimal system.</p>",
        "id": 190514602,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112572
    },
    {
        "content": "<p>but you can't actually share results in a base theory, because the theorems need more than the base theory</p>",
        "id": 190514661,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112601
    },
    {
        "content": "<p>There are French people believing that you should do everything via λΠ-modulo.</p>",
        "id": 190514688,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112617
    },
    {
        "content": "<p>If everyone worked in MLTT then they could be \"universal donors\" but there is no industrial strength implementation of MLTT</p>",
        "id": 190514774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112663
    },
    {
        "content": "<p>Well, so what? So be it. If I have code that uses threads, then it will break libraries relying on the absence of threads. That's life.</p>",
        "id": 190514785,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112674
    },
    {
        "content": "<p>You don't consider Coq to implement MLTT, or that it's not industrial-strength?</p>",
        "id": 190514884,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260981\">@Pierre-Marie Pédrot</span> Here is a result that I find extremely interesting: <a href=\"https://en.wikipedia.org/wiki/Resolution_of_singularities\" target=\"_blank\" title=\"https://en.wikipedia.org/wiki/Resolution_of_singularities\">https://en.wikipedia.org/wiki/Resolution_of_singularities</a><br>\nI would like to know what you think is the shortest path to getting such a statement and proof in a computer proof assistent. I have all the reason to believe that Lean is currently the proof assistant that is moving in that direction the fastest.</p>",
        "id": 190514995,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584112743
    },
    {
        "content": "<p>Coq implements a too strong theory, hence it cannot export results elsewhere</p>",
        "id": 190515019,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112753
    },
    {
        "content": "<p>The reason \"Coq is a Lean typechecker\" and not the other way around is because Coq is stronger. Strength is not a strength</p>",
        "id": 190515122,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> foundation-wise, there is no real difference between Lean and Coq. Anything you can do with one, you can do with the other. <span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> well, but nobody prevents you to define subsystems.</p>",
        "id": 190515156,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112807
    },
    {
        "content": "<p>Coq is not stronger than Lean, <span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> had to specifically use unsafe features to implement Lean.</p>",
        "id": 190515215,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112836
    },
    {
        "content": "<p>It's very difficult to have subsystems of Coq where it matters. Can you turn off inductive types? Fancy pattern matches? Type n for n &gt; 3?</p>",
        "id": 190515275,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112864
    },
    {
        "content": "<p>If anything, modulo implemementation details, Lean is an extension of Coq.</p>",
        "id": 190515287,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112872
    },
    {
        "content": "<p>What system do you want to get? As far as I am concerned, if you remove stuff like SProp, modules and template polymorphic inductive types, and only use eliminators, I get a reasonable foundation.</p>",
        "id": 190515435,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584112925
    },
    {
        "content": "<p>The truth is that neither Coq or Lean is a subsystem of the other because DTT is too sensitive to minor differences</p>",
        "id": 190515446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112930
    },
    {
        "content": "<p>Can I do something with equivalent axiomatic strength to HOL in Coq?</p>",
        "id": 190515515,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584112964
    },
    {
        "content": "<p>Or at least not surpassing ZFC (without going intuitionistic / predicative)?</p>",
        "id": 190515587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113004
    },
    {
        "content": "<p>Coq is conjectured to be strictly weaker than ZFC + ω universes btw.</p>",
        "id": 190515639,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113037
    },
    {
        "content": "<p>you are talking no axioms coq though</p>",
        "id": 190515698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113056
    },
    {
        "content": "<p>At the risk of repeating myself, there is no such thing as \"Coq + Axioms\".</p>",
        "id": 190515735,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113074
    },
    {
        "content": "<p>I want all the axioms on that page</p>",
        "id": 190515744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113078
    },
    {
        "content": "<p>Coq + those axioms</p>",
        "id": 190515813,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113095
    },
    {
        "content": "<p>Yes, but then you get a crappy theory.</p>",
        "id": 190515814,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113095
    },
    {
        "content": "<p>Why? It's the theory mathematicians are used to</p>",
        "id": 190515871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113112
    },
    {
        "content": "<p>It's not a programming language anymore.</p>",
        "id": 190515892,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113121
    },
    {
        "content": "<p>or at least, the best approximation you can get to it within the constraints of dependent type theory</p>",
        "id": 190515911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113135
    },
    {
        "content": "<p>Having axioms in SProp does look like a promising way though.</p>",
        "id": 190515929,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113143
    },
    {
        "content": "<p>You know, I don't think saying \"it's not a programming language anymore\" will get you much sympathy around here. We don't want a programming language, we want a proof language</p>",
        "id": 190516047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113186
    },
    {
        "content": "<p>As for HOL, the Dedukti people wrote a few translators from various systems. You could try playing with it.</p>",
        "id": 190516063,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113197
    },
    {
        "content": "<p>You can always use computable things if you want to compute</p>",
        "id": 190516082,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113206
    },
    {
        "content": "<p>This is why Coq has the distinction Prop / Type. Add you proof axioms in Prop, compute in Type.</p>",
        "id": 190516152,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113247
    },
    {
        "content": "<p>Sure, and none of those axioms interferes with this AFAIK</p>",
        "id": 190516263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113290
    },
    {
        "content": "<p>And FTR I don't really care about the sympathy of mathematicians. I have enough \"real math\" friends of mine who make fun of type theory and computer assistants. It's a social issue, not a technical one.</p>",
        "id": 190516346,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113334
    },
    {
        "content": "<p>I just don't see why they have to be at odds</p>",
        "id": 190516422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113378
    },
    {
        "content": "<p>Lean Santa Claus version of choice \"inhabited A -&gt; A\" is very bad in the Prop / Type distinction though.</p>",
        "id": 190516430,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113385
    },
    {
        "content": "<p>Sure, it's <code>noncomputable</code></p>",
        "id": 190516499,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113404
    },
    {
        "content": "<p>The cool thing is that if you use it only in proofs it becomes computable again</p>",
        "id": 190516541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113423
    },
    {
        "content": "<p>that is, <code>classical.em</code> is <code>computable</code></p>",
        "id": 190516556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113438
    },
    {
        "content": "<p>Well, breaking SR, strong normalization and whatnot.</p>",
        "id": 190516611,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113445
    },
    {
        "content": "<p>I am afraid this is a dealbreaker.</p>",
        "id": 190516655,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113464
    },
    {
        "content": "<p>But anyways, if a development uses choice, then will you consider this as valid?</p>",
        "id": 190516698,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113485
    },
    {
        "content": "<p>Axioms don't break SR, proof irrelevance and large elimination does</p>",
        "id": 190516709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113492
    },
    {
        "content": "<p>In a noncomputable way, I mean?</p>",
        "id": 190516714,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113494
    },
    {
        "content": "<p>strong normalization doesn't matter</p>",
        "id": 190516731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113502
    },
    {
        "content": "<p>(You can't shift the blame one one axiom, it's the whole interaction of rules.)</p>",
        "id": 190516749,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113520
    },
    {
        "content": "<p>That concerns the behavior of <code>#reduce</code> which we literally never use because it's impractically slow on almost all examples</p>",
        "id": 190516807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113534
    },
    {
        "content": "<blockquote>\n<p>strong normalization doesn't matter</p>\n</blockquote>",
        "id": 190516823,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113544
    },
    {
        "content": "<p>for some people it does</p>",
        "id": 190516841,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113553
    },
    {
        "content": "<p>so, please answer the question: assuming some subcommunity wants to restrict to computable functions</p>",
        "id": 190516902,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113594
    },
    {
        "content": "<p>for some reason, doesn't matter</p>",
        "id": 190516919,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113601
    },
    {
        "content": "<p>what does mathlib tell them?</p>",
        "id": 190516934,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113613
    },
    {
        "content": "<p>What matters is evaluating computable functions that were written to be computable, not evaluating all terms anywhere in the proof assistant including proofs and stuff</p>",
        "id": 190516954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113623
    },
    {
        "content": "<p>OK, this foundation stuff is a red herring. Let me put it another way. Assume there are people deciding to go ssr-style in Lean.</p>",
        "id": 190517096,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113689
    },
    {
        "content": "<p>What happens? A fork?</p>",
        "id": 190517116,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113702
    },
    {
        "content": "<p>That's essentially what happened to Coq a long time ago.</p>",
        "id": 190517139,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113713
    },
    {
        "content": "<p>Lean has a marker, called <code>noncomputable</code>, that you are required to put on any definition that cannot be executed. There is a way to put this at the start of your file to say \"I don't care about computability\", and most mathematicians do this for their theories of category theory, commutative algebra and whatnot. If you care about computability, you write computable defs, which don't have this marking, and lean will generate bytecode on the spot. These functions can be called via <code>#eval</code> with concrete arguments and you get values out just like any programming language.</p>",
        "id": 190517321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113790
    },
    {
        "content": "<p>Right, right. But my point is about the existence of diverging design choices in library in software.</p>",
        "id": 190517480,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113865
    },
    {
        "content": "<p>Doesn't even have to be Lean.</p>",
        "id": 190517506,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113877
    },
    {
        "content": "<p>Moreover, there are ways to compute even with noncomputable terms, using tactics, and this is in fact the preferred method (by comparison to proofs by reflection). This is exemplified in tactics like <code>norm_num</code> that will prove things like <code>100 + 100 = 200</code> by cobbling proofs together, even though yes, you could prove it by <code>rfl</code>, the proof takes too long</p>",
        "id": 190517577,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113903
    },
    {
        "content": "<p>Invariably, there will be people disagreeing with whatever choice done in mathlib.</p>",
        "id": 190517588,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113911
    },
    {
        "content": "<blockquote>\n<p>the proof takes too long</p>\n</blockquote>\n<p>really? this sounds suspicious to me</p>",
        "id": 190517682,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113956
    },
    {
        "content": "<p>It unfolds into unary. It's bad</p>",
        "id": 190517710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584113971
    },
    {
        "content": "<p>yes, but tactics will have to generate similarly big proof terms</p>",
        "id": 190517750,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584113996
    },
    {
        "content": "<p>doesn't it mean that the reduction machine is not really optimized in Lean?</p>",
        "id": 190517822,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114017
    },
    {
        "content": "<p>The short story is that in Lean the tactics are fast and the kernel reduction (plus elaborator reduction) is comparatively slow. In Coq it is the other way around and the cost benefit analysis goes the other way</p>",
        "id": 190517859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114047
    },
    {
        "content": "<p>OK, this is surprising.</p>",
        "id": 190517895,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114072
    },
    {
        "content": "<p>Checking big proof terms is not that bad, as long as the types all line up</p>",
        "id": 190517914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114082
    },
    {
        "content": "<p>well, type-checking is at least linear in the size of the term</p>",
        "id": 190518045,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114138
    },
    {
        "content": "<p>yes, that's fast if the term is small</p>",
        "id": 190518075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114150
    },
    {
        "content": "<p>yeah but I fail to see how you can build a reasonable proof of \"100 + 100 = 200\" that is not generating a term requiring more work than mere evaluation, in unary that is</p>",
        "id": 190518180,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114197
    },
    {
        "content": "<p>Note also that if you provide a proof term you have a lot of flexibility in how to do the computation. For example when <code>norm_num</code> proves or disproves primality, the first thing it does is find out if the number is actually prime, and if not, it has a very short proof of the negation. A reduction based proof would have to do the whole primality thing even in the composite case</p>",
        "id": 190518294,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114254
    },
    {
        "content": "<p>depends how you write it</p>",
        "id": 190518346,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114290
    },
    {
        "content": "<p>You can produce a proof of <code>100 + 100 = 200</code> in size linear in the size of the expression, which is written in binary after the parser has had a go</p>",
        "id": 190518357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114296
    },
    {
        "content": "<p>the ssr people are very good at this kind of stuff</p>",
        "id": 190518372,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114306
    },
    {
        "content": "<p>The literal \"100\" itself is not in unary, as a term</p>",
        "id": 190518373,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584114306
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> <span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Is it possible that what mathematicians in lean are really using is Lawvere's version of choice as in ECTS, and not Hilbert epsilon which is non-structural.</p>",
        "id": 190518570,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584114418
    },
    {
        "content": "<p>Let's suppose you want to reduce <code>prime N</code> to true or false where <code>N</code> is some big number, say 50 digits. You have no choice but to push the kernel through a bunch of states to test the primality, while a tactic can just call GMP or mathematica to first factorize it and then prove the correctness of this untrusted guess</p>",
        "id": 190518702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110049\">@Mario Carneiro</span> that's assuming you go full reflection, but precisely the ssr people are argueing for interleaved computation with tactics.</p>",
        "id": 190518854,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114549
    },
    {
        "content": "<p>Is that so? I didn't realize that. I usually have a tough time being able to insert a proof term in the middle of a defeq computation</p>",
        "id": 190519001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114614
    },
    {
        "content": "<p>I am probably not qualified enough to talk about this but this is precisely the whole story of the \"small-scale\" nature of this approach. I'd recommend asking <span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> for instance.</p>",
        "id": 190519157,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584114700
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"259452\">@Bas Spitters</span> In a literal sense, of course they are not; lean provides one choice axiom and they are using it. But more likely you mean that they would be equally happy with a Lawvere style axiom of choice, and I'm not sure this is true. Among other things, we use <code>choice</code> to do definite descriptions. So things like <code>sum (f : nat -&gt; real) : real</code> will be defined using <code>choice</code>. (It would also be used here to do an outer if statement: if the sum is not defined then return 0 else return the unique sum of the sequence.)</p>",
        "id": 190519456,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584114838
    },
    {
        "content": "<p>I think this \"naked <code>choice</code>\" is potentially problematic even just in the context of Lean itself. For example (as noted earlier, I think) it blocks automatic syntax-directed proofs of parametricity.</p>",
        "id": 190519652,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584114908
    },
    {
        "content": "<p>It would be better to split off <code>axiom_of_choice</code> (the Prop version) and <code>unique_choice</code> into separate axioms</p>",
        "id": 190519766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584114946
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> I am not an expert on this topic, but the people in constructive/computer algebra have considered this topic. E.g.<br>\n<a href=\"https://arxiv.org/abs/1304.6770\" target=\"_blank\" title=\"https://arxiv.org/abs/1304.6770\">https://arxiv.org/abs/1304.6770</a><br>\nWhat is interesting is that the same abstractions are useful in topos theory (Coste, Roy, Lombardi, Wraith, ...) and in computer algebra (magma,GAP, ...)<br>\n<span class=\"user-mention\" data-user-id=\"110172\">@Assia Mahboubi</span> may know more. <br>\nI would imagine that a more algebraic development is more suitable for formalization. However, it is possible that we do not have all the right abstractions yet.</p>",
        "id": 190519957,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584115022
    },
    {
        "content": "<p>Then some definitions like (hypothetically, I don't think this is the actual mathlib definition) the dimension of a vector space as \"pick a basis, and take its cardinality\" can be formulated in terms of <code>unique_choice</code>, but it requires proving that the result is independent of the choice. Which is also the rule in ordinary math.</p>",
        "id": 190520052,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584115064
    },
    {
        "content": "<p>(I think the actual mathlib definition is \"the smallest cardinality of a basis\"? but surely there are other examples)</p>",
        "id": 190520216,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584115129
    },
    {
        "content": "<p><code>sum</code> mentioned above is an example. There are two uses of choice in that definition, and they are both definite descriptions</p>",
        "id": 190520437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115218
    },
    {
        "content": "<p>I'm not sure how the dimension of a (real) vector space could ever be computable.  What is the dimension of the span of a real number <code>x</code>?  This requires computing whether <code>x</code> is nonzero.  But alas, that's noncomutable.</p>",
        "id": 190520466,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584115232
    },
    {
        "content": "<p>It's not computable, <code>unique_choice</code> would still be an axiom</p>",
        "id": 190520501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115248
    },
    {
        "content": "<p>Ah, sorry didn't follow the discussion too much.  <code>unique_choice [subsingleton A] : nonempty A -&gt; A</code> then?</p>",
        "id": 190520660,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584115328
    },
    {
        "content": "<p>This also fits better with my mental model of the semantics--I want to say you get a model of Lean from a model of ZFC+omega inaccessibles, not from such a model together with some specific choice of choice functions.</p>",
        "id": 190520706,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584115354
    },
    {
        "content": "<p>Of course full <code>choice</code> would probably be needed/convenient for some purposes, but at least you could track it separately</p>",
        "id": 190520770,
        "sender_full_name": "Reid Barton",
        "timestamp": 1584115379
    },
    {
        "content": "<p>You can also do <code>unique_choice : unique A -&gt; A</code></p>",
        "id": 190520942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115452
    },
    {
        "content": "<p>This version of <code>unique_choice</code> doesn't require an axiom though, since <code>unique</code> extends <code>inhabited</code>.</p>",
        "id": 190521103,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584115531
    },
    {
        "content": "<p>oh</p>",
        "id": 190521255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115586
    },
    {
        "content": "<p><code>nonempty (unique A) -&gt; A</code>? Doesn't have the same ring</p>",
        "id": 190521285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115600
    },
    {
        "content": "<p>Corollary 3.9.2 (The principle of unique choice). Suppose a type family P : A → U such that<br>\n(i) For each x, the type P(x ) is a mere proposition, and<br>\n(ii) For each x we have || P( x)||.<br>\nThen we have ∏( x:A ) P( x).</p>",
        "id": 190521312,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584115613
    },
    {
        "content": "<p>The use of a type family there seems superfluous</p>",
        "id": 190521500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115697
    },
    {
        "content": "<p>Note that lean's <code>choice</code> used to be more complicated, and it was simplified to the current <code>nonempty A -&gt; A</code></p>",
        "id": 190521581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115743
    },
    {
        "content": "<p>I think the original axiom was <code>indefinite_description {α : Sort u} (p : α → Prop) : (∃ x, p x) → {x // p x}</code></p>",
        "id": 190521696,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584115802
    },
    {
        "content": "<p>If I ignore the thing about the type family (set A = unit), then it seems that the HoTT version reduces to what Gabriel posted</p>",
        "id": 190522702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584116224
    },
    {
        "content": "<p>The Lean version of unique choice is pretty strong since we have more subsingletons, e.g. it implies that all types have decidable equality.  Does the HoTT version allow you to write <code>λ x : ℝ, if x = 0 then tt else ff</code>?</p>",
        "id": 190523605,
        "sender_full_name": "Gabriel Ebner",
        "timestamp": 1584116610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110043\">@Gabriel Ebner</span> I believe so in the presence of PEM. Since the term is definable in ECTS using unique choice.</p>",
        "id": 190523827,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584116720
    },
    {
        "content": "<p>I think the proof of unique choice in HoTT is similar to the lean proof of <code>[subsingleton A] : trunc A -&gt; A</code></p>",
        "id": 190523906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1584116761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260981\">Pierre-Marie Pédrot</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190512431\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190512431\">said</a>:</p>\n<blockquote>\n<p>There is no such thing as \"true mathematics\" so it doesn't make sense to ask our users to abide to a specific set of axioms.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"260981\">@Pierre-Marie Pédrot</span> in my department the vast majority of us think ZFC is true mathematics, and I am certain that many other mathematics departments think the same way. The fact that logicians and computer scientists have invented a whole bunch more options and then decide to call them mathematics is problematic, because it means that discussions can degenerate into axiomatic issues which <em>as far as a mathematician is concerned</em> are completely solved. The axiom of choice is an axiom of maths as practiced in mathematics departments. Johan is absolutely right when he says that mathematicians are not interested in this stuff. You say</p>\n<blockquote>\n<p>... or maybe we can teach the mathematicians about computer science to make them understand it's not a sterile debate?</p>\n</blockquote>\n<p>but it is much <em>worse</em> than that -- it is not a sterile debate -- we finished debating 100 years ago and decided what mathematics was, and the fact that you guys are still arguing over it is of no interest to us. From your point of view this debate is very important, because if you want to design a new computer proof system than of course foundations are absolutely a major issue. But from a mathematician's point of view, ZFC works, constructivism doesn't work, ZF doesn't work, and these topics are not being studied in mathematics departments other than by a small niche group of people. We mathematicians are looking for a system where we can <em>reason the way we reason on paper</em> and having tried several systems I currently believe that Lean 3 is the closest we have to this; I can name explicit problems with every other system, either of the form \"not enough foundations yet\" or \"can't do some part of modern mathematics in a way which is practical\". For Coq it is \"quotients\", which are absolutely everywhere in modern mathematics.</p>\n<blockquote>\n<p>Once again, I think we should turn to programming engineering to draw inspiration. </p>\n</blockquote>\n<p>We mathematicians cannot turn to programming languages to draw inspiration because for you guys it's really important to have lots of different programming languages, because different languages are good at different things. We are attempting to make one coherent body of mathematics, and it's really important that everything is compatible with everything else. In particular every paper in number theory has to be accessible to me if I am a number theorist so it's really important that they all have the same foundations, and these foundations are decided -- they are ZFC -- and sure, add universes if you like, it doesn't matter, because it turns out that the kind of mathematics we do can sometimes be made easier with universes but we actually know tricks to get it back into ZFC. But we will not settle for anything less. LEM and AC are <em>embedded</em>. We are not going back.</p>\n<blockquote>\n<p>And FTR I don't really care about the sympathy of mathematicians. I have enough \"real math\" friends of mine who make fun of type theory and computer assistants. It's a social issue, not a technical one.</p>\n</blockquote>\n<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software. In particular I need to <em>hide</em> type theory if I want to get them to use computer assistants. It is a social issue and it is one which I think is extremely important, but we as proof assistant users need to tread carefully when attracting mathematicians into the area. I simply tell mathematicians that a type is a set where the elements aren't necessarily sets any more but could just be \"atoms\", and suggest that actually this is the way they think about stuff they call sets. </p>\n<p>I want to meet computer scientists \"half way\" and so I can have some dialogue with them about the future of these sytems -- but there are some ground rules, and AC and LEM and noncomputability are part of them. Any suggestion that a system which doesn't have them can be used to do modern mathematics is ridiculous to our ears, so the conversation cannot even start. This is why I use Lean and this is why I tell other mathematicians to use Lean.</p>",
        "id": 190528705,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584119076
    },
    {
        "content": "<blockquote>\n<p>LEM and AC are embedded. We are not going back.</p>\n</blockquote>\n<p>This is great, because that's what some people in the community are trying to provide in type theory in a way that <em>actually works</em>. Disclaimer: I am one of those, and I am not advocating against EM + AC. I am just constantly disappointed by the lack of consideration from mathematicians on the topic of foundations. And I am not saying that anybody should turn into a type theorist, but at least that they should be <em>listened</em> to, which is very different.</p>\n<p>So far, the logical choices of Lean are the dependent type theory equivalent of PHP. Yes, it <em>kind of works</em>, until you reach the size of Facebook and realize that you wrote your stuff on quicksand, and that disregard for foundational issues have a long term cost you'll only realize at that point. And now, they're switching parts of their code to ReasonML because the trade-off is long overdue.</p>\n<blockquote>\n<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software.</p>\n</blockquote>\n<p>I am not complaining about that. It is better to use whatever proof assistant than nothing, and the state of a few areas of mathematics is depressing. Needing a Fields medal to dismiss a broken proof is not a great situation, if you ask me.</p>\n<blockquote>\n<p>What I am trying to do in Lean is to bring mathematicians in and get them using this software. In particular I need to hide type theory if I want to get them to use computer assistants. [...] actually this is the way they think about stuff they call sets.</p>\n</blockquote>\n<p>There is wide evidence that no mathematician ever uses ZFC anyways, so I don't think it's very hard to make them forget about sets, except maybe for some weird hilbertian fetichism.</p>\n<blockquote>\n<p>For Coq it is \"quotients\", which are absolutely everywhere in modern mathematics.</p>\n</blockquote>\n<p>I will call your bluff, because you keep spreading this lie around, and I am starting to be slightly annoyed. As demonstrated by <span class=\"user-mention\" data-user-id=\"243878\">@Gaëtan Gilbert</span> , it is perfectly possible to get quotients in Coq with the very same rules, if you opt-in for a broken feature that is hardwired in Lean. Even Santa Claus choice can be obtained by similar tricks. I have actually heard rumours that you didn't even try Coq thoroughly, and I even believe there is a written account of that. You don't have indeed to try everything out there to settle for a tool, and it's nice to see math users playing around with any type-theoretic proof assistant.</p>\n<p>Yet, I am a type theorist and I would never not making random claims in some arbitrary area of mathematics.</p>\n<p>But once again, I claim the minimal divergence of foundations between Lean and Coq are of little relevance to formalization of mathematics. From what I gather, Lean has not reached Gonthier's famous <em>wall of complexity</em>. By that, he means that a lot of a priori ridiculous technical impediments are paving the way to mathematical formalization. I am genuinely willing to see an actual large mathematical development in Lean, to satisfy my own computer scientist fetichism, namely <em>scalability</em>. It might be changing, but Coq proofs are still a cottage industry. Can Lean do better?</p>",
        "id": 190536491,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584122771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260981\">Pierre-Marie Pédrot</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190536491\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190536491\">said</a>:</p>\n<blockquote>\n<p>As demonstrated by <span class=\"user-mention silent\" data-user-id=\"243878\">Gaëtan Gilbert</span> , it is perfectly possible to get quotients in Coq with the very same rules, if you opt-in for a broken feature that is hardwired in Lean. Even Santa Claus choice can be obtained by similar tricks.</p>\n</blockquote>\n<p>I don't think the question is whether they can be constructed in Coq. To an outsider to type theory like me, the systems are sufficiently similar that I have little doubt that something natural that can be made with one can be made with the other. The question is rather whether they are used in the libraries, i.e., if the main libraries with the software try to use a constructivist point of view, or don't care and go full classical right away. Here I can see a really different approach currently with the Coq and Lean communities. I think it is very healthy that different viewpoints are tried and put forward, but mathematicians will be more easily attracted to libraries that use choice and LEM from the very beginning, because it will sound more familiar to them.</p>",
        "id": 190537829,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584123519
    },
    {
        "content": "<p>You are right about my Coq experience. I heard about this \"setoid hell\" from various people but I am certainly not an experienced Coq user. I will try and get some more concrete facts.</p>\n<p>Mathematicians are <em>terrible</em> about foundations. It is not regarded as an interesting topic by most people, because \"all the interesting questions were solved when forcing was invented\" or something :-/ You are also right that we don't use ZFC in practice, however it is true that there is a general belief that whatever it is that we <em>are</em> doing, it is possible to translate it down to ZFC (and classical logic) in theory. My impression is that in the areas I am interested in (number theory, arithmetic geometry) it is possible to find people (they are rare, but they exist) who actually know how to do this, but it is not something which is deemed particularly important. Somehow the workers in each area know the API, and then a few people know how to get from the API to the foundations, but what is taught is the API.</p>\n<p>I am not necessarily saying that Lean is the solution to everything. But I think it is close enough to being able to simulate the kind of mathematics done by mathematicians that it might be enough to get people interested in the theory in general. My general line of thought is this. Which system is best for modern mathematics? We don't really know. So let's try and get mathematicians actually making mathematics in as many systems as possible, because my impression is that when we get stuck the computer scientists are able to understand what the problem is and try to solve it. You know we have some typeclass problems in Lean 3, which I think were basically discovered because of mathematicians trying to push the system? Hopefully these will be fixed in Lean 4.</p>\n<p>I guess it will take time before we have a large development. I guess we are working on mathlib as being this development?</p>",
        "id": 190537881,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584123543
    },
    {
        "content": "<blockquote>\n<p>mathematicians will be more easily attracted to libraries that use choice and LEM from the very beginning, because it will sound more familiar to them.</p>\n</blockquote>\n<p>I don't know why Coq has this aura of knife-between-their-teeth intuitionists in the mathematical community. Just as mathematicians, most computer scientists don't care at all about their foundations. Most serious computer science Coq developments I know of actually use classical axioms everywhere.</p>",
        "id": 190538570,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584123914
    },
    {
        "content": "<p>Is knife-between-their-teeth a French phrase?</p>",
        "id": 190538936,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584124134
    },
    {
        "content": "<p>It's clear what is meant :-)</p>",
        "id": 190538946,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124150
    },
    {
        "content": "<p>I actually wasn't able to infer it from context</p>",
        "id": 190539008,
        "sender_full_name": "Kenny Lau",
        "timestamp": 1584124201
    },
    {
        "content": "<p>I remember one of the first things I noticed when reading the Coq odd order paper was that they said that the result was proved constructively, and I thought \"what does that even _mean_?\" (this was a few years ago before I knew the definition). And then later on they started explaining about how they couldn't use the complex numbers and I was totally speechless. I think it is more the issue that constructivism is simply not taught in mathematics departments, so we find anyone who talks about it slightly scary.</p>",
        "id": 190539178,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124283
    },
    {
        "content": "<p>I literally had no idea 5 years ago that the complex numbers were somehow illegal for some people.</p>",
        "id": 190539317,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124343
    },
    {
        "content": "<p>It's strange, because I am fairly sure mathcomp uses classical logic locally. Dually to Lean, they mark classical statements by quantifying over a proof of EM. Anyway, AFAIR it does not even matter for the odd order theorem since it's a negative statement, which are essentially equivalent in intuitionistic and classical logic.</p>",
        "id": 190539739,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584124568
    },
    {
        "content": "<p>I guess the point is that all the constructions they used in the proof were also constructive.</p>",
        "id": 190539909,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124676
    },
    {
        "content": "<p>See Chapter 3.3 of <a href=\"https://math-comp.github.io/mcb/book.pdf\" target=\"_blank\" title=\"https://math-comp.github.io/mcb/book.pdf\">https://math-comp.github.io/mcb/book.pdf</a>.</p>",
        "id": 190539957,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584124685
    },
    {
        "content": "<p>When I started with proof assistants (I wanted to do some measure theory), I tried both Coq and Isabelle and I gave up very quickly with Coq, one of the reasons being that in the standard library many files talking about the reals start with the word \"Constructive\".</p>",
        "id": 190540204,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584124822
    },
    {
        "content": "<p>The link is just the sort of thing that mathematicians find intimidating. We do not teach decidability in any serious way; I think I met it once in the 2nd year logic course and then it was never mentioned again (and I am certain that my 3rd year lecturers did not know what it was). I learnt very quickly when talking to mathematicians about Lean that the moment you start mentioning these things they think you've become some kind of crank.</p>",
        "id": 190540272,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124862
    },
    {
        "content": "<p>I think this is the main reason I am so edgy about the univalence axiom. It starts with a discussion of univalence, and within minutes the conversation has either turned to elementary topoi (about which mathematicians know nothing), or constructivism (about which mathematicians know nothing), or some discussion about how things can be equal in more than one way (which just sounds like complete craziness). It is so far from what happens in practice in maths departments.</p>",
        "id": 190540494,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584124983
    },
    {
        "content": "<blockquote>\n<p>many files talking about the reals start with the word \"Constructive\"</p>\n</blockquote>\n<p>This is funny because precisely the Coq real library from stdlib is classical, to please the mathematicians. I guess merely uttering the word \"constructive\" is enough to deter mathematicians then...</p>",
        "id": 190540708,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584125122
    },
    {
        "content": "<p>Absolutely. Because it means, at some point, you will have to make some effort to stay constructive (otherwise, you wouldn't put the word constructive in the file name). So, the definition starts with some constructive stuff, and then goes classical. To me, if you can express a statement or a proof by remaining constructive but it requires 1% effort more, then it should be avoided (both for the library builder, and for the user who will have to skim the library), simply because there's no point. Maybe I am a little extreme there, but I think it is pretty reasonable in fact.</p>",
        "id": 190541078,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584125320
    },
    {
        "content": "<p>On this forum, I can say that I see value of constructive maths (for example, constructive maths holds in any topos). But when I'm having lunch with my colleagues, they don't want to hear anything about giving up the C in ZFC. So yes:</p>\n<blockquote>\n<p>I guess merely uttering the word \"constructive\" is enough to deter mathematicians then...</p>\n</blockquote>\n<p>My goal is to get them engaged with proof assistants. And for that, mentioning the word \"constructive\" is quite often an unfortunate obstacle.</p>",
        "id": 190541281,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584125439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> well, until very recently Coq reals were fully axiomatic, so there was not even a hint of constructivism in there. Now they're trying to have some subsystem that's constructive in order to plug into C-CoRN.</p>",
        "id": 190541439,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584125526
    },
    {
        "content": "<p>Georges seem to take it as a matter of pride to make a constructive proof. Georges has a deep appreciation for the use of computation to proof mathematical theorems.</p>",
        "id": 190541485,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584125563
    },
    {
        "content": "<p>I am wondering whether the mathlib people take pride in the fact that the development is 100% axiom-free. Sure we use Lean's inbuilt axioms (because this is just \"maths mode\") but there are no instances where we build a mathematical object by just adding axioms.</p>",
        "id": 190541631,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1584125650
    },
    {
        "content": "<p>Somewhat unrelated to the discussion, but <span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> we could try to have more discussions on the topic in person, we're just one building away IIUC... (when they reopen the uni, that is.)</p>",
        "id": 190541639,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584125654
    },
    {
        "content": "<p>There is now a substantial development of constructive measure theory in Coq. Following Bishop, who was a great functional analyst.<br>\n<a href=\"https://github.com/coq/coq/pull/9185\" target=\"_blank\" title=\"https://github.com/coq/coq/pull/9185\">https://github.com/coq/coq/pull/9185</a><br>\nThe classical theorems are then derived quickly from the constructive ones. One does not <em>need</em> to do it that way, but some people appreciate it.</p>",
        "id": 190541801,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584125769
    },
    {
        "content": "<blockquote>\n<p>they don't want to hear anything about giving up the C in ZFC.</p>\n</blockquote>\n<p>One of the advantages of type theory is that they are finer-grained than sets, and that it's easier to understand what is what. The usual joke on the understandability of choice vs. Zorn vs. well-ordering makes sense there. CIC validates choice phrased as \"you can pick elements of existentials\".</p>",
        "id": 190541924,
        "sender_full_name": "Pierre-Marie Pédrot",
        "timestamp": 1584125867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260981\">Pierre-Marie Pédrot</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190541639\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190541639\">said</a>:</p>\n<blockquote>\n<p>Somewhat unrelated to the discussion, but <span class=\"user-mention silent\" data-user-id=\"110050\">Sebastien Gouezel</span> we could try to have more discussions on the topic in person, we're just one building away IIUC... (when they reopen the uni, that is.)</p>\n</blockquote>\n<p>Definitely! In May or June, maybe :-)</p>",
        "id": 190542453,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584126157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260981\">Pierre-Marie Pédrot</span> <a href=\"#narrow/stream/116395-maths/topic/Univalence/near/190541924\" title=\"#narrow/stream/116395-maths/topic/Univalence/near/190541924\">said</a>:</p>\n<blockquote>\n<p>One of the advantages of type theory is that they are finer-grained than sets, and that it's easier to understand what is what. The usual joke on the understandability of choice vs. Zorn vs. well-ordering makes sense there. CIC validates choice phrased as \"you can pick elements of existentials\".</p>\n</blockquote>\n<p>That's a good point. Thanks for pointing it out! Still, it's only useful for mathematicians if you can also have transport (not only along equiv's, but also other isos) and have a sizable library of \"basic maths\".</p>",
        "id": 190542603,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584126247
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> Peter Johnstone once wrote an apology for locale theory, and the benefits of working classically, but without choice.<br>\nThe point of pointless topology<br>\n<a href=\"https://projecteuclid.org/euclid.bams/1183550014\" target=\"_blank\" title=\"https://projecteuclid.org/euclid.bams/1183550014\">https://projecteuclid.org/euclid.bams/1183550014</a><br>\nChoice is only used to construct the points of a locale. The locale it self can be constructed without choice. The use of the axiom of choice is a choice.<br>\nThis has applications in e.g. functional analysis.</p>",
        "id": 190542731,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584126357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> I had a quick look at your homepage. <br>\n<a href=\"https://www.math.sciences.univ-nantes.fr/~gouezel/\" target=\"_blank\" title=\"https://www.math.sciences.univ-nantes.fr/~gouezel/\">https://www.math.sciences.univ-nantes.fr/~gouezel/</a><br>\nYou seem to be working in a beautiful part of analysis that is not very structural, i.e. somewhat distanced from say functional analysis.<br>\nMoreover, does not seem to be very computational/numerical.<br>\nSo, constructive methods may be less natural to you.</p>",
        "id": 190543323,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584126721
    },
    {
        "content": "<p><span aria-label=\"open mouth\" class=\"emoji emoji-1f62e\" role=\"img\" title=\"open mouth\">:open_mouth:</span>  I think this is the first I see anyone claiming to know which part of mathematics Sébastien works in.</p>",
        "id": 190543609,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584126889
    },
    {
        "content": "<p>About the Hausdorff metric. My PhD-student once used it to make a 1980-style graphical calculator which was provably correct. The printing of graphs of functions was done using the Coq notation system.<br>\n<a href=\"https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf\" target=\"_blank\" title=\"https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf\">https://www3.risc.jku.at/publications/download/risc_3448/SCSS2008_Proceedings.pdf</a><br>\nRussell O’Connor. A Computer Verified Theory of Compact Sets. SCSS 2008, RISC-Linz Report Series 08–08: 148–162, Jul 2008, Proceedings</p>",
        "id": 190543694,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584126953
    },
    {
        "content": "<p>I use a lot of functional analysis (in the sense of operator theory on spaces of functions, so with concrete applications to other problems in mind), but not on the abstract side of things (I know what a trace on a C^* algebra is, but I don't use them in my research). So, I am away from the finite world (where decidable methods are appealing because they can let you compute for free on examples), and away from the more abstract sides (higher homotopy theory for instance) where foundational discussions become relevant. So yes, I am definitely biased away from these questions. But I guess that this is also the case of maybe 90% working mathematicians.</p>",
        "id": 190543823,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584127011
    },
    {
        "content": "<p>While I'm at it. One can use constructive analysis to do certified computation with classical real numbers:<br>\nCezary Kaliszyk and Russell O’Connor. Computing with Classical Real Numbers. Journal of Formalized Reasoning, Vol. 2, No. 1, 2009, Pages 27–29<br>\n<a href=\"http://jfr.cib.unibo.it/article/view/1411/932\" target=\"_blank\" title=\"http://jfr.cib.unibo.it/article/view/1411/932\">http://jfr.cib.unibo.it/article/view/1411/932</a></p>\n<p>How does one prove in lean that:<br>\npi ~ 3.14159265359  ?</p>",
        "id": 190543885,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584127060
    },
    {
        "content": "<p>We can only do the first 4 digits (-;</p>",
        "id": 190543958,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584127090
    },
    {
        "content": "<p>Maybe we pushed till 7 digits, on last years Pi-day</p>",
        "id": 190544021,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584127133
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112680\">@Johan Commelin</span> So, that's one reason you should have used constructive reals :-)</p>",
        "id": 190544039,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584127146
    },
    {
        "content": "<p>Or we just need some tactic that can spit out proofs.</p>",
        "id": 190544183,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1584127221
    },
    {
        "content": "<p>Arguably, one can also connect with interval computation \"by hand\", as in the impressive work by Fabian Immler in Isabelle to prove that the Lorentz attractor is chaotic</p>",
        "id": 190544206,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584127236
    },
    {
        "content": "<p>I really don't understand that bit. Say I prove some series <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum a_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> of rational numbers converges to pi. I can do this 100% classically. And then I prove an estimate on the remainder <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mo>∑</mo><mrow><mi>n</mi><mo>≥</mo><mi>N</mi></mrow></msub><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum_{n\\geq N} a_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.144889em;vertical-align:-0.39488900000000005em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.17862099999999992em;\"><span style=\"top:-2.40029em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span><span class=\"mrel mtight\">≥</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.39488900000000005em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>. Then I can prove the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span> digits are correct. Where do I need anything constructive as long as I can prove all this and compute with rational numbers?</p>",
        "id": 190544266,
        "sender_full_name": "Patrick Massot",
        "timestamp": 1584127272
    },
    {
        "content": "<p>For most of basic analysis such proofs would be naturally constructive, and one would combine the proof of convergence with the estimate on the remainder.<br>\nYou are right, it is not needed to do so.</p>",
        "id": 190545052,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584127709
    },
    {
        "content": "<p>In Isabelle, which is completely non-constructive but more mature, you would prove it with</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kn\">lemma</span> <span class=\"n\">ineq3</span><span class=\"o\">:</span>\n  <span class=\"s2\">&quot;(pi :: real) ≤ 3.141592658&quot;</span>\n<span class=\"k\">by</span> <span class=\"o\">(</span><span class=\"n\">approximation</span> <span class=\"mi\">40</span><span class=\"o\">)</span>\n</pre></div>\n\n\n<p>where <code>approximation</code> is a tactic that will do all the dirty interval arithmetic for you.</p>",
        "id": 190545122,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584127751
    },
    {
        "content": "<p>So my understanding is that if I had a constructive proof of convergence of <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∑</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding=\"application/x-tex\">\\sum a_n</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, then given some <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">ϵ</span></span></span></span> I could compute <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, such that the sum of the first <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> terms was within <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding=\"application/x-tex\">\\epsilon</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">ϵ</span></span></span></span>. But the problem with this is that it means whenever I do a continuity proof or a convergence proof I will have to think about providing a minimal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>δ</mi></mrow><annotation encoding=\"application/x-tex\">\\delta</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03785em;\">δ</span></span></span></span> or a minimal <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>, in order to make sure the computation time was reasonable, but often with the standard proofs, you'll end up computing an <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span aria-hidden=\"true\" class=\"katex-html\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span> way bigger than it really needs to be and not really practical to compute with.</p>\n<p>Does an unfolded proof of convergence actually provide a practical way of approximating the limit most of the time?</p>",
        "id": 190546148,
        "sender_full_name": "Chris Hughes",
        "timestamp": 1584128302
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110050\">@Sebastien Gouezel</span> Coq has a similar package:<br>\n<a href=\"http://coq-interval.gforge.inria.fr/\" target=\"_blank\" title=\"http://coq-interval.gforge.inria.fr/\">http://coq-interval.gforge.inria.fr/</a></p>",
        "id": 190546360,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584128432
    },
    {
        "content": "<p>Yes I am not surprised: Coq and Isabelle are much more mature than Lean, so most things that should be there are already there.</p>",
        "id": 190546551,
        "sender_full_name": "Sebastien Gouezel",
        "timestamp": 1584128548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"110044\">@Chris Hughes</span>  With a bit of engineering this can be made practical. However, with epsilon-delta proofs one is computing backwards from the precision of the result to the precision of the input.<br>\nFor optimal speed, one wants to compute forwards: start with a small interval see whether the result is precise enough. If not, start over with double precision. This is what IRRAM does:<br>\n<a href=\"https://github.com/norbert-mueller/iRRAM\" target=\"_blank\" title=\"https://github.com/norbert-mueller/iRRAM\">https://github.com/norbert-mueller/iRRAM</a><br>\nI believe mathematica does something similar.</p>",
        "id": 190546873,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584128738
    },
    {
        "content": "<p>Hoping I wasn't too zealous, I just wanted to point out that constructive mathematics has its uses in the formalization of mathematics, even if one is not a diehard constructivist.</p>",
        "id": 190555005,
        "sender_full_name": "Bas Spitters",
        "timestamp": 1584133698
    }
]
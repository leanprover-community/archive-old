[
    {
        "content": "<p>I was experimenting with definition of presheaves of modules following stack project 6.6. I came up with two formalizations</p>\n<ol>\n<li>\n<p>presheaves of modules are a functor with values in <code>BundledModule</code>, see <a href=\"https://github.com/leanprover-community/mathlib/pull/10724\">#10724</a>, i.e. then if <code>𝓕</code> is a presheaf of modules, aka, <code>(opens X)ᵒᵖ ⥤ BunledModule</code>, then <code>𝓕 ⋙ BundledModule.forget_to_Ring</code> is a presheaf of ring and <code>𝓕 ⋙ BundledModule.forget_to_Ab</code> is a presheaf of abelian groups. The nice thing about this approach is that, for any opens <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\"> U </annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span>, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">F</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal F(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.09931em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> is automatically <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal O(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span>-module and restriction map is automatically compatible with scalar multiplication. But this definition will make category of presheaves of module over a presheaf of ring <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal O</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> difficult, because then the category needs to be defined as<br>\n<code>{𝓕 | 𝓕 ⋙ BundledModule.forget_to_Ring = 𝓞}</code> with equalities of functor flowing around. And I think the sheaf condition would be presumably \"wrong\", because that would actually imply <code>𝓕 ⋙ BundledModule.forget_to_Ring</code> is a sheaf as well.</p>\n</li>\n<li>\n<p>given a presheaf of rings <code>𝓞</code>,  define presheaf of modules over <code>𝓞</code> as</p>\n</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">presheaf_of_module</span>\n<span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">Ab</span> <span class=\"n\">X</span><span class=\"o\">)</span>\n<span class=\"o\">[</span><span class=\"n\">module</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">(</span><span class=\"n\">U</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">),</span> <span class=\"n\">module</span> <span class=\"o\">(</span><span class=\"bp\">𝓞.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">self.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))]</span>\n<span class=\"o\">(</span><span class=\"n\">compatible</span> <span class=\"o\">:</span> <span class=\"bp\">∀</span> <span class=\"o\">{</span><span class=\"n\">U</span> <span class=\"n\">V</span> <span class=\"o\">:</span> <span class=\"n\">opens</span> <span class=\"n\">X</span><span class=\"o\">}</span> <span class=\"o\">(</span><span class=\"n\">inc</span> <span class=\"o\">:</span> <span class=\"n\">op</span> <span class=\"n\">U</span> <span class=\"bp\">⟶</span> <span class=\"n\">op</span> <span class=\"n\">V</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">:</span> <span class=\"bp\">𝓞.</span><span class=\"n\">obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">))</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">:</span> <span class=\"n\">self.obj</span> <span class=\"o\">(</span><span class=\"n\">op</span> <span class=\"n\">U</span><span class=\"o\">)),</span>\n   <span class=\"n\">self.map</span> <span class=\"n\">inc</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"bp\">=</span> <span class=\"bp\">𝓞.</span><span class=\"n\">map</span> <span class=\"n\">inc</span> <span class=\"n\">r</span> <span class=\"bp\">•</span> <span class=\"n\">self.map</span> <span class=\"n\">inc</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">sheaf_of_module</span> <span class=\"kd\">extends</span> <span class=\"n\">presheaf_of_module</span> <span class=\"bp\">𝓞</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">is_sheaf</span> <span class=\"o\">:</span> <span class=\"n\">presheaf.is_sheaf</span> <span class=\"n\">self</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>see <a href=\"https://github.com/leanprover-community/mathlib/pull/12186\">#12186</a> <a href=\"https://github.com/leanprover-community/mathlib/blob/6e7aa6302bf658bb037513ad65be80366befc4e1/src/scratch.lean#L61\">this link</a>.</p>\n<p>Now the problem with this approach is that</p>\n<ul>\n<li>then presheaf of module is not literally a presheaf in mathlib's sense</li>\n<li>(common to both approaches, I think) given a morphism <code>f : 𝓞1 ⟶ 𝓞2</code> between presheaves of ring, defining restriction and extension of presheaf of modules by <code>f</code> is cumbersome, because lean's class inference cannot \"see through <code>f</code>\".</li>\n</ul>",
        "id": 272790956,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645529939
    },
    {
        "content": "<p>I think Adam was a big fan of (1).</p>",
        "id": 272791240,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645530129
    },
    {
        "content": "<p>The equality in (1) seems quite awkward. I think in order to work with it directly, you would basically need to create an API for it that looked like (2) anyways.</p>",
        "id": 272792993,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645531235
    },
    {
        "content": "<p>The DTT-natural way to say this would probably be using <a href=\"https://ncatlab.org/nlab/show/displayed+category\">https://ncatlab.org/nlab/show/displayed+category</a>, which is basically an abstraction of (2), I think</p>",
        "id": 272793186,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645531354
    },
    {
        "content": "<p>I would suggest first thinking about all the operations you will want to support--I guess there are a lot: sheafification of presheaves of O-modules, (co)limits, restriction and extension of scalars, closed monoidal structure, pullback/pushforward between ringed sites</p>",
        "id": 272794341,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645532104
    },
    {
        "content": "<p>I was thinking of this <a href=\"#narrow/stream/267928-condensed-mathematics/topic/tensor.20product.20of.20sheaves/near/263012430\">https://leanprover.zulipchat.com/#narrow/stream/267928-condensed-mathematics/topic/tensor.20product.20of.20sheaves/near/263012430</a> and the discussion following it</p>",
        "id": 272798135,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645534446
    },
    {
        "content": "<p>OK so \"essential fiber\" means we have a ring+module and an isomorphism of its ring to <code>O</code>. That's better in some respects (and maybe not worse in any respects since <code>=</code> is so awkward anyways). But it still leaves a lot to be desired, for example, even to define the direct sum of two objects of this category you will need to make use of those isomorphisms already to define <code>+</code></p>",
        "id": 272798644,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645534770
    },
    {
        "content": "<p>Ah not to define <code>+</code>, but to define the action of the \"wrong\" copy of <code>O</code> on one (or both) of the summands</p>",
        "id": 272798766,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645534819
    },
    {
        "content": "<p>Johan you asked me once why HoTT people think definitional equality is so important--here is an example. I don't think it will be pleasant to work in the category of \"modules over a ring equipped with an isomorphism to <code>R</code>\".</p>",
        "id": 272799114,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645535025
    },
    {
        "content": "<p>Using the second approach, I have defined the restriction and extension functor and close of finishing their adjunction.</p>",
        "id": 272800366,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645535735
    },
    {
        "content": "<p>With approach 2, you would have to replicate literally everything we have  about sheafification.</p>",
        "id": 272813781,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645541779
    },
    {
        "content": "<p>Here is a non-(pre)sheafy way I see to make approach 1 work in practice:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.restrict_scalars</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">BundledModule</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Module'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">BundledModule.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">M.R</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Module'</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">Module'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M.M.M</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module'</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"o\">:=</span> <span class=\"n\">M.e.inv.to_algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Module'</span>\n</code></pre></div>",
        "id": 272815916,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645542718
    },
    {
        "content": "<p>Essentially, set up the correct instances for your object so you can work with them as we usually work with modules from mathlib.</p>",
        "id": 272816117,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645542815
    },
    {
        "content": "<p>Now you can't use the original restriction maps of the presheaf directly so you also need an API for those... and you end up at (2)</p>",
        "id": 272816529,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645542976
    },
    {
        "content": "<p>So maybe the answer is \"both\", and you use (1) abstractly to prove that existence of sheafififcation</p>",
        "id": 272816571,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645542998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272816529\">said</a>:</p>\n<blockquote>\n<p>Now you can't use the original restriction maps of the presheaf directly so you also need an API for those... and you end up at (2)</p>\n</blockquote>\n<p>There may be a way to convince the <code>scalar_tower</code> stuff to make this fairly quick?\"</p>",
        "id": 272816673,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645543057
    },
    {
        "content": "<p>Just to be clear -- Jujian has made extensive experiments with both approaches in the links he posts above.</p>",
        "id": 272818229,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645543622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916\">said</a>:</p>\n<blockquote>\n<p>Here is a non-(pre)sheafy way I see to make approach 1 work in practice:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"n\">algebra.category.Module.basic</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.category.CommRing</span>\n<span class=\"kn\">import</span> <span class=\"n\">algebra.algebra.restrict_scalars</span>\n\n<span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">BundledModule</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">R</span><span class=\"o\">)</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">Module'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">BundledModule.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">M.R</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n\n<span class=\"kn\">namespace</span> <span class=\"n\">Module'</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">Module'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M.M.M</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module'</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"o\">:=</span> <span class=\"n\">M.e.inv.to_algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n\n<span class=\"kd\">end</span> <span class=\"n\">Module'</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I haven't thought about this <code>Module'</code> approach.</p>\n<p>If to use this approach, do we see a possibility in which we use approach 1, but avoid equality of functor when defining sheaf of modules over some given sheaf of rings?</p>",
        "id": 272818678,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645543791
    },
    {
        "content": "<p>Use isomorphism instead of equality.</p>",
        "id": 272818764,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645543811
    },
    {
        "content": "<p>I.e. \"sheafify\" this definition:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Module'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">BundledModule.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">M.R</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div>",
        "id": 272818821,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645543839
    },
    {
        "content": "<p>My concern with approach (2) is that whenever there is some categorical thing you want to do, you would have to make some bespoke construction that only really applies to your structure, and doesn't really fit in with the rest of the <code>Sheaf</code>/<code>functor</code> library. I think that would get old REALLY fast.</p>",
        "id": 272819093,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645543938
    },
    {
        "content": "<p>I don't really understand how that doesn't also apply to (1), though</p>",
        "id": 272819225,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645543996
    },
    {
        "content": "<p>What constructions do you get on (1) for free?</p>",
        "id": 272819242,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645544004
    },
    {
        "content": "<p>For example, one obvious milestone would be to prove that the category of <code>O</code>-modules is abelian</p>",
        "id": 272819565,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645544122
    },
    {
        "content": "<p><code>BundledModule</code> is a sufficiently nice concrete category, so you get sheafification for free. <code>BundledModule</code> has (co)limits, so you get (co)limits of sheaves of <code>BundledModules</code> for free. The forgetful functors to <code>Ab</code> and <code>CommRing</code> preserve limits, so you get the forgetful functors from sheaves of <code>BundledModules</code> to Sheaves of <code>Ab</code> and/or <code>CommRing</code> for free (this allows you define (1) in the first place in the case of sheaves).</p>",
        "id": 272819577,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645544128
    },
    {
        "content": "<p>But the colimits of bundled modules aren't the colimits you want--they will have some kind of colimit in the ring part too.</p>",
        "id": 272819896,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645544251
    },
    {
        "content": "<p>You need some kind of fiberwise colimit and now it is another custom construction</p>",
        "id": 272819953,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645544276
    },
    {
        "content": "<p>Hmm... I thought there may be a way to use the isomorphism to make this work without a custom construction. Let me think.</p>",
        "id": 272820879,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645544634
    },
    {
        "content": "<p>For sheafification specifically, I think it does work, but you need some argument to verify it (something like forgetting to rings preserves limits and colimits)</p>",
        "id": 272821807,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645545000
    },
    {
        "content": "<p>I mean that tells you that sheafifying a presheaf of <code>O</code>-modules gives you another <code>O</code>-module, but I guess you still have to check that it has the right universal property</p>",
        "id": 272821939,
        "sender_full_name": "Reid Barton",
        "timestamp": 1645545036
    },
    {
        "content": "<p>I verified that for any <code>L : J  ⥤  BundledModule</code>,  denote <code>R</code> to be <code>L forget to ring</code> and <code>M</code> to be <code>L forget to abelian group</code>, then <code>lim M</code> is a <code>lim R</code>-module, but couldn't prove <code>(lim R, lim M)</code> has the universal property. (because I can only get a group homomorphism instead of linear map)</p>",
        "id": 272822401,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645545192
    },
    {
        "content": "<p>Bah... I'm ready to throw my hands up and say that we should work internally in the Sheaf topos.</p>",
        "id": 272822768,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645545333
    },
    {
        "content": "<p>Can you explain what that means?</p>",
        "id": 272824108,
        "sender_full_name": "Kevin Buzzard",
        "timestamp": 1645545798
    },
    {
        "content": "<p>Roughly what I mean is one of the following two approaches:</p>\n<p>Approach (3): Work with sheaves of sets, and define <code>Ring</code>-objects and <code>Module</code>-objects over such <code>Ring</code>-objects, inside of the category of sheaves of sets.</p>\n<p>Approach (3'): Work with sheaves of abelian groups, define the monoidal structure, and use that to define <code>Ring</code>-objects (as monoid objects) and modules over them.</p>",
        "id": 272824397,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645545911
    },
    {
        "content": "<p>Of course these approaches come with their own problems.</p>",
        "id": 272825005,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645546133
    },
    {
        "content": "<p>Okay, now I really don't know what the best approach would be! It's an interesting problem to think about!</p>",
        "id": 272825287,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645546237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"110032\">Reid Barton</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272819896\">said</a>:</p>\n<blockquote>\n<p>But the colimits of bundled modules aren't the colimits you want--they will have some kind of colimit in the ring part too.</p>\n</blockquote>\n<p>Considering this: Let me just think about modules for a moment (the case of (pre)sheaves should be similar): Suppose I have a diagram <code>J : I ⥤ Module' A</code> where <code>Module'</code> is the category of <code>BunledModule</code>s with an isomorphism to <code>A</code> on the ring level (as in the code above).<br>\nLet <code>F : Module' A ⥤ BundledModule</code> be the forgetful functor, and consider the colimit of <code>J ⋙ F</code>, say <code>M</code>. <br>\nI suppose this is a module over the colimit of <code>J ⋙ F ⋙ R</code> where <code>R : BundledModule ⥤ CommRing</code> is the forgetful functor. Now, the isomorphisms used in the definition of <code>Module' A</code> give us a morphism from the colimit of <code>J ⋙ F ⋙ R</code> to <code>A</code> in the category of commutative rings. If I then base-change along this morphism, I suppose that should be the colimit of the original <code>J</code>.</p>\n<p>(NB. I don't have a complete proof of this, but I think I convinced myself that this is true in the case of coproducts)</p>",
        "id": 272830289,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645548104
    },
    {
        "content": "<p>At some point, anyway, it shall make sense to develop notions of group-objects, etc, in <em>general</em> monoidal categories, whether the monoidal structure is given by the categorical product (e.g. group schemes are group-objects in a category of S-schemes), or any other monoidal structure...</p>",
        "id": 272859073,
        "sender_full_name": "Joël Riou",
        "timestamp": 1645560204
    },
    {
        "content": "<p>It's probably a good idea to keep sheaves of modules and group schemes in mind at the same time, when thinking about this problem. As you say, they could benefit from similar approaches.</p>",
        "id": 272859939,
        "sender_full_name": "Johan Commelin",
        "timestamp": 1645560619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272818821\">said</a>:</p>\n<blockquote>\n<p>I.e. \"sheafify\" this definition:</p>\n<p><div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">structure</span> <span class=\"n\">Module'</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">BundledModule.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">M.R</span> <span class=\"bp\">≅</span> <span class=\"n\">A</span><span class=\"o\">)</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"243562\">@Adam Topaz</span>  Were you thinking about something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">universe</span> <span class=\"n\">u</span>\n\n<span class=\"kd\">variables</span> <span class=\"o\">{</span><span class=\"n\">T</span> <span class=\"o\">:</span> <span class=\"n\">Top.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}}</span>\n\n<span class=\"kd\">structure</span> <span class=\"n\">presheaf_of_module</span> <span class=\"o\">(</span><span class=\"bp\">𝓞</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">CommRing</span> <span class=\"n\">T</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">(</span><span class=\"n\">self</span> <span class=\"o\">:</span> <span class=\"n\">presheaf</span> <span class=\"n\">BundledModule</span> <span class=\"n\">T</span><span class=\"o\">)</span>\n<span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">:</span> <span class=\"n\">self</span> <span class=\"bp\">⋙</span> <span class=\"n\">BundledModule.forget_to_Ring</span> <span class=\"bp\">≅</span> <span class=\"bp\">𝓞</span><span class=\"o\">)</span>\n</code></pre></div>\n<p>If so, I think this approach is weird because, for <code>𝓕 : presheaf_of_module 𝓞</code>, <code>(𝓕 .obj U).M</code> is not an <code>𝓞.obj U</code> module, rather a <code>(𝓕 .obj U).R</code> module.  I don't think class inference can pick up <code>e</code> and use it to synthesize what we want.</p>",
        "id": 272864984,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645563254
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span> see <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916\">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272815916</a></p>",
        "id": 272866162,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645563657
    },
    {
        "content": "<p>specifically this part:</p>\n<div class=\"codehilite\" data-code-language=\"Lean\"><pre><span></span><code><span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">:</span> <span class=\"n\">has_coe_to_sort</span> <span class=\"o\">(</span><span class=\"n\">Module'.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">}</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"kt\">Type</span> <span class=\"n\">u</span><span class=\"o\">)</span> <span class=\"o\">:=</span>\n<span class=\"o\">⟨</span><span class=\"bp\">λ</span> <span class=\"n\">M</span><span class=\"o\">,</span> <span class=\"n\">M.M.M</span><span class=\"o\">⟩</span>\n\n<span class=\"kd\">instance</span> <span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"o\">:</span> <span class=\"n\">CommRing.</span><span class=\"o\">{</span><span class=\"n\">u</span><span class=\"o\">})</span> <span class=\"o\">(</span><span class=\"n\">M</span> <span class=\"o\">:</span> <span class=\"n\">Module'</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"n\">M</span> <span class=\"o\">:=</span>\n<span class=\"kd\">begin</span>\n  <span class=\"n\">haveI</span> <span class=\"o\">:</span> <span class=\"n\">algebra</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"o\">:=</span> <span class=\"n\">M.e.inv.to_algebra</span><span class=\"o\">,</span>\n  <span class=\"n\">change</span> <span class=\"n\">module</span> <span class=\"n\">A</span> <span class=\"o\">(</span><span class=\"n\">restrict_scalars</span> <span class=\"n\">A</span> <span class=\"n\">M.M.R</span> <span class=\"n\">M</span><span class=\"o\">),</span>\n  <span class=\"n\">apply_instance</span><span class=\"o\">,</span>\n<span class=\"kd\">end</span>\n</code></pre></div>",
        "id": 272866298,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1645563685
    },
    {
        "content": "<p>The essential fiber could alternatively be defined as <code>{ f : structured_arrow 𝓞 forget // is_iso f }</code> but I'm not in favor of the approach. What <span class=\"user-mention\" data-user-id=\"252627\">@Jujian Zhang</span>  has done is essentially defining the restriction/extension (lax) functors from <code>presheaf CommRing X</code> to <code>Cat</code> (short of showing they're adjoint), and after that we could show that the Grothendieck constructions applied to these functors are isomorphic to the <code>presheaf BundledModule</code> category, and transition freely between them. (Working with the presheaf of abelian groups and its sheafification should be nice enough, but if we can somehow use the bundled presheaf category to automatically put module structures on abelian groups and verify compatibilit in constructions, that would even be better.)</p>\n<p>Here are some mathlib API that <a href=\"https://github.com/leanprover-community/mathlib/pull/12186\">#12186</a> failed to use, which seems to make it longer than necessary:<br>\n<a href=\"https://leanprover-community.github.io/mathlib_docs/find/module.comp_hom\">docs#module.comp_hom</a> (or <a href=\"https://leanprover-community.github.io/mathlib_docs/find/restrict_scalars.module\">docs#restrict_scalars.module</a>), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.restrict_scalars\">docs#linear_map.restrict_scalars</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.left_module\">docs#tensor_product.left_module</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.base_change\">docs#linear_map.base_change</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/linear_map.compatible_smul\">docs#linear_map.compatible_smul</a>, <a href=\"https://leanprover-community.github.io/mathlib_docs/find/tensor_product.algebra_tensor_module.lift.equiv\">docs#tensor_product.algebra_tensor_module.lift.equiv</a> (more general than the hom_equiv of the restriction-extension adjunction but I can't find a simpler version), <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.adjunction.mk_of_hom_equiv\">docs#category_theory.adjunction.mk_of_hom_equiv</a></p>",
        "id": 272910048,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1645597965
    },
    {
        "content": "<p>Various constructions involving O-modules (e.g. tensor product, and those in abelian category axioms) could be abstracted into the following: module categories with restriction of scalars can be seen as a (strict) functor <code>module : CommRing ⥤ Cat</code>; whenever we have a (oplax) natural transformation from \"<code>module^n</code>\" to <code>module</code>, i.e. a functor <code>(module R)^n ⥤ module R</code> for each comm ring <code>R</code> that \"commutes\" with restriction of scalars, we get a functor from <code>O-modules^n</code> to <code>O-modules</code> (the natural transformation could be made strict for direct sum, kernel, image etc. but not for tensor products!).</p>",
        "id": 272912537,
        "sender_full_name": "Junyan Xu",
        "timestamp": 1645600805
    },
    {
        "content": "<p>Thanks for pointing out the useful lemmas and apis. Though I don’t fully understand all the terminologies, am I correct to assume that you are suggesting to build two versions of (pre)sheaf of modules in parallel and prove the two versions are isomorphic and choose whichever version that is more convenient to do some specific construction, for example shefification using functor into bundled module etc.</p>",
        "id": 272927417,
        "sender_full_name": "Jujian Zhang",
        "timestamp": 1645610846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272824397\">said</a>:</p>\n<blockquote>\n<p>Roughly what I mean is one of the following two approaches:</p>\n<p>Approach (3): Work with sheaves of sets, and define <code>Ring</code>-objects and <code>Module</code>-objects over such <code>Ring</code>-objects, inside of the category of sheaves of sets.</p>\n<p>Approach (3'): Work with sheaves of abelian groups, define the monoidal structure, and use that to define <code>Ring</code>-objects (as monoid objects) and modules over them.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/272825005\">said</a>:</p>\n<blockquote>\n<p>Of course these approaches come with their own problems.</p>\n</blockquote>\n<p>Can someone explain what the drawbacks to such an approach would be?</p>\n<p>Surely it gets rid of the \"category-is-hard\" and \"sheafification-is-hard\" problems from before. I assume approaching it this way would make it much harder (at least, at first) to prove basic results. However, this seems like the most natural approach for a Bourbaki-style exposition in my (admittedly biased) opinion. </p>\n<p>One a less subjective note, developing a theory of group/ring/module/monoid objects in an arbitrary category (not to mention groupoids in a category) will be quite useful as this is a suuuuuuper common perspective in cutting-edge research. I.e. buzzwords like group schemes, etale equivalence relations, ring spectra, etc. Might we end up having to go to this module-object approach eventually anyway?</p>",
        "id": 290149319,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1658259064
    },
    {
        "content": "<p>The difficulty is that if you have a sheaf of modules <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span> over a sheaf of rings <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span></span></span></span> and <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>U</mi></mrow><annotation encoding=\"application/x-tex\">U</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span></span></span></span> is open, then you want <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">M(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> to be a module over <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">O</mi><mo stretchy=\"false\">(</mo><mi>U</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\mathcal{O}(U)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mclose\">)</span></span></span></span> <em>in the usual sense</em>!</p>",
        "id": 290149615,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658259215
    },
    {
        "content": "<p>of course if you go with the internal objects approach, you could introduce the appropriate instances on such things, but that requires additional work and additional API.</p>",
        "id": 290149737,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658259272
    },
    {
        "content": "<p>In the ideal world, we would have <em>all</em> the definitions, and a robust API that would let us go back-and-forth between any two definitions you chose.</p>",
        "id": 290149807,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658259310
    },
    {
        "content": "<p>Ok, maybe I'll try this definition out and see what happens</p>",
        "id": 290151802,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1658260288
    },
    {
        "content": "<p>If you want to try to define monoid objects in sheaves on a site, and identify those with sheaves of monoids, that would be a very good test case!</p>",
        "id": 290151949,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260356
    },
    {
        "content": "<p>We already have monoid objects in a monoidal category, but we don't have the monoidal structure on sheaves</p>",
        "id": 290151986,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260376
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151986\">said</a>:</p>\n<blockquote>\n<p>...but we don't have the monoidal structure on sheaves</p>\n</blockquote>\n<p>well, we do, it's just the cartesian structure in this case, so you should be good to go</p>",
        "id": 290152059,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260417
    },
    {
        "content": "<p><a href=\"https://leanprover-community.github.io/mathlib_docs/find/Mon_\">docs#Mon_</a></p>",
        "id": 290152150,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260450
    },
    {
        "content": "<p>There we go!</p>",
        "id": 290152210,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260493
    },
    {
        "content": "<p>That will give you sheaves of monoids</p>",
        "id": 290152519,
        "sender_full_name": "Reid Barton",
        "timestamp": 1658260656
    },
    {
        "content": "<p>Oh this is as a test case, carry on!</p>",
        "id": 290152541,
        "sender_full_name": "Reid Barton",
        "timestamp": 1658260675
    },
    {
        "content": "<p>Well, anyway we should choose a single-sorted thing as our first test case before jumping into modules</p>",
        "id": 290152651,
        "sender_full_name": "Adam Topaz",
        "timestamp": 1658260726
    },
    {
        "content": "<p>Right, I was thinking of rings</p>",
        "id": 290158138,
        "sender_full_name": "Reid Barton",
        "timestamp": 1658263573
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290152059\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151986\">said</a>:</p>\n<blockquote>\n<p>...but we don't have the monoidal structure on sheaves</p>\n</blockquote>\n<p>well, we do, it's just the cartesian structure in this case, so you should be good to go</p>\n</blockquote>\n<p>So, I'm having trouble finding an instance of <code>has_finite_products</code> or <code>has_products</code> on any of the sheaf categories. Do you know if Lean has this somewhere? (also is there is a standard way to see if something has an instance somewhere? my method so far is searching on github)</p>",
        "id": 290193573,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1658292991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243562\">Adam Topaz</span> <a href=\"#narrow/stream/116395-maths/topic/Definition.20of.20presheaf.20of.20modules/near/290151949\">said</a>:</p>\n<blockquote>\n<p>If you want to try to define monoid objects in sheaves on a site, and identify those with sheaves of monoids, that would be a very good test case!</p>\n</blockquote>\n<p>Is there a standard thing that we want to mean by \"identify\" here? I.e. some possibilities show an equivalence of categories between monoid objects in the category of sheaves and sheaves of monoids, or give some sort of function that takes a monoid object in the category of sheaves and gives a sheaf of monoids and then give an inverse, or is there some more mathlibby way?</p>",
        "id": 290193754,
        "sender_full_name": "Jack J Garzella",
        "timestamp": 1658293223
    },
    {
        "content": "<blockquote>\n<p>is there is a standard way to see if something has an instance somewhere?</p>\n</blockquote>\n<p>do you mean starting from a specific structure and trying to figure out if it instantiates a specific class somehow? or do you mean starting from a class and finding a list of structures that instantiate it?</p>\n<p>re: the latter, each class has an \"Instances of this typeclass\" list below it in the mathlib docs</p>",
        "id": 290194079,
        "sender_full_name": "Matt Diamond",
        "timestamp": 1658293575
    },
    {
        "content": "<p>Searching in <a href=\"https://leanprover-community.github.io/mathlib_docs\">the documentation</a> for \"sheaf has_limits_of_shape\" gives <a href=\"https://leanprover-community.github.io/mathlib_docs/find/category_theory.Sheaf.category_theory.limits.has_limits_of_shape\">docs#category_theory.Sheaf.category_theory.limits.has_limits_of_shape</a></p>",
        "id": 290194286,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658293816
    },
    {
        "content": "<p>I think showing the equivalence of the two categories is the right way to go?</p>",
        "id": 290194385,
        "sender_full_name": "Andrew Yang",
        "timestamp": 1658293990
    }
]